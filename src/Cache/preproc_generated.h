// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PREPROC_SURELOG_MACROCACHE_H_
#define FLATBUFFERS_GENERATED_PREPROC_SURELOG_MACROCACHE_H_

#include "flatbuffers/flatbuffers.h"

#include "header_generated.h"

namespace SURELOG {
namespace MACROCACHE {

struct Macro;
struct MacroBuilder;

struct IncludeFileInfo;
struct IncludeFileInfoBuilder;

struct LineTranslationInfo;
struct LineTranslationInfoBuilder;

struct PPCache;
struct PPCacheBuilder;

enum MacroType : int8_t {
  MacroType_NO_ARGS = 0,
  MacroType_WITH_ARGS = 1,
  MacroType_MIN = MacroType_NO_ARGS,
  MacroType_MAX = MacroType_WITH_ARGS
};

inline const MacroType (&EnumValuesMacroType())[2] {
  static const MacroType values[] = {
    MacroType_NO_ARGS,
    MacroType_WITH_ARGS
  };
  return values;
}

inline const char * const *EnumNamesMacroType() {
  static const char * const names[3] = {
    "NO_ARGS",
    "WITH_ARGS",
    nullptr
  };
  return names;
}

inline const char *EnumNameMacroType(MacroType e) {
  if (flatbuffers::IsOutRange(e, MacroType_NO_ARGS, MacroType_WITH_ARGS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMacroType()[index];
}

struct Macro FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MacroBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_NAME = 4,
    VT_M_TYPE = 6,
    VT_M_LINE = 8,
    VT_M_COLUMN = 10,
    VT_M_ARGUMENTS = 12,
    VT_M_TOKENS = 14
  };
  const flatbuffers::String *m_name() const {
    return GetPointer<const flatbuffers::String *>(VT_M_NAME);
  }
  SURELOG::MACROCACHE::MacroType m_type() const {
    return static_cast<SURELOG::MACROCACHE::MacroType>(GetField<int8_t>(VT_M_TYPE, 0));
  }
  uint32_t m_line() const {
    return GetField<uint32_t>(VT_M_LINE, 0);
  }
  uint16_t m_column() const {
    return GetField<uint16_t>(VT_M_COLUMN, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *m_arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_M_ARGUMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *m_tokens() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_M_TOKENS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M_NAME) &&
           verifier.VerifyString(m_name()) &&
           VerifyField<int8_t>(verifier, VT_M_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_M_LINE) &&
           VerifyField<uint16_t>(verifier, VT_M_COLUMN) &&
           VerifyOffset(verifier, VT_M_ARGUMENTS) &&
           verifier.VerifyVector(m_arguments()) &&
           verifier.VerifyVectorOfStrings(m_arguments()) &&
           VerifyOffset(verifier, VT_M_TOKENS) &&
           verifier.VerifyVector(m_tokens()) &&
           verifier.VerifyVectorOfStrings(m_tokens()) &&
           verifier.EndTable();
  }
};

struct MacroBuilder {
  typedef Macro Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_name(flatbuffers::Offset<flatbuffers::String> m_name) {
    fbb_.AddOffset(Macro::VT_M_NAME, m_name);
  }
  void add_m_type(SURELOG::MACROCACHE::MacroType m_type) {
    fbb_.AddElement<int8_t>(Macro::VT_M_TYPE, static_cast<int8_t>(m_type), 0);
  }
  void add_m_line(uint32_t m_line) {
    fbb_.AddElement<uint32_t>(Macro::VT_M_LINE, m_line, 0);
  }
  void add_m_column(uint16_t m_column) {
    fbb_.AddElement<uint16_t>(Macro::VT_M_COLUMN, m_column, 0);
  }
  void add_m_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_arguments) {
    fbb_.AddOffset(Macro::VT_M_ARGUMENTS, m_arguments);
  }
  void add_m_tokens(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_tokens) {
    fbb_.AddOffset(Macro::VT_M_TOKENS, m_tokens);
  }
  explicit MacroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Macro> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Macro>(end);
    return o;
  }
};

inline flatbuffers::Offset<Macro> CreateMacro(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> m_name = 0,
    SURELOG::MACROCACHE::MacroType m_type = SURELOG::MACROCACHE::MacroType_NO_ARGS,
    uint32_t m_line = 0,
    uint16_t m_column = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_arguments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_tokens = 0) {
  MacroBuilder builder_(_fbb);
  builder_.add_m_tokens(m_tokens);
  builder_.add_m_arguments(m_arguments);
  builder_.add_m_line(m_line);
  builder_.add_m_name(m_name);
  builder_.add_m_column(m_column);
  builder_.add_m_type(m_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Macro> CreateMacroDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *m_name = nullptr,
    SURELOG::MACROCACHE::MacroType m_type = SURELOG::MACROCACHE::MacroType_NO_ARGS,
    uint32_t m_line = 0,
    uint16_t m_column = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *m_arguments = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *m_tokens = nullptr) {
  auto m_name__ = m_name ? _fbb.CreateString(m_name) : 0;
  auto m_arguments__ = m_arguments ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*m_arguments) : 0;
  auto m_tokens__ = m_tokens ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*m_tokens) : 0;
  return SURELOG::MACROCACHE::CreateMacro(
      _fbb,
      m_name__,
      m_type,
      m_line,
      m_column,
      m_arguments__,
      m_tokens__);
}

struct IncludeFileInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IncludeFileInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_SECTIONSTARTLINE = 4,
    VT_M_SECTIONFILE = 6,
    VT_M_ORIGINALLINE = 8,
    VT_M_TYPE = 10,
    VT_M_INDEXOPENING = 12,
    VT_M_INDEXCLOSING = 14
  };
  uint32_t m_sectionStartLine() const {
    return GetField<uint32_t>(VT_M_SECTIONSTARTLINE, 0);
  }
  const flatbuffers::String *m_sectionFile() const {
    return GetPointer<const flatbuffers::String *>(VT_M_SECTIONFILE);
  }
  uint32_t m_originalLine() const {
    return GetField<uint32_t>(VT_M_ORIGINALLINE, 0);
  }
  uint32_t m_type() const {
    return GetField<uint32_t>(VT_M_TYPE, 0);
  }
  int32_t m_indexOpening() const {
    return GetField<int32_t>(VT_M_INDEXOPENING, 0);
  }
  int32_t m_indexClosing() const {
    return GetField<int32_t>(VT_M_INDEXCLOSING, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_M_SECTIONSTARTLINE) &&
           VerifyOffset(verifier, VT_M_SECTIONFILE) &&
           verifier.VerifyString(m_sectionFile()) &&
           VerifyField<uint32_t>(verifier, VT_M_ORIGINALLINE) &&
           VerifyField<uint32_t>(verifier, VT_M_TYPE) &&
           VerifyField<int32_t>(verifier, VT_M_INDEXOPENING) &&
           VerifyField<int32_t>(verifier, VT_M_INDEXCLOSING) &&
           verifier.EndTable();
  }
};

struct IncludeFileInfoBuilder {
  typedef IncludeFileInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_sectionStartLine(uint32_t m_sectionStartLine) {
    fbb_.AddElement<uint32_t>(IncludeFileInfo::VT_M_SECTIONSTARTLINE, m_sectionStartLine, 0);
  }
  void add_m_sectionFile(flatbuffers::Offset<flatbuffers::String> m_sectionFile) {
    fbb_.AddOffset(IncludeFileInfo::VT_M_SECTIONFILE, m_sectionFile);
  }
  void add_m_originalLine(uint32_t m_originalLine) {
    fbb_.AddElement<uint32_t>(IncludeFileInfo::VT_M_ORIGINALLINE, m_originalLine, 0);
  }
  void add_m_type(uint32_t m_type) {
    fbb_.AddElement<uint32_t>(IncludeFileInfo::VT_M_TYPE, m_type, 0);
  }
  void add_m_indexOpening(int32_t m_indexOpening) {
    fbb_.AddElement<int32_t>(IncludeFileInfo::VT_M_INDEXOPENING, m_indexOpening, 0);
  }
  void add_m_indexClosing(int32_t m_indexClosing) {
    fbb_.AddElement<int32_t>(IncludeFileInfo::VT_M_INDEXCLOSING, m_indexClosing, 0);
  }
  explicit IncludeFileInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IncludeFileInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IncludeFileInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<IncludeFileInfo> CreateIncludeFileInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t m_sectionStartLine = 0,
    flatbuffers::Offset<flatbuffers::String> m_sectionFile = 0,
    uint32_t m_originalLine = 0,
    uint32_t m_type = 0,
    int32_t m_indexOpening = 0,
    int32_t m_indexClosing = 0) {
  IncludeFileInfoBuilder builder_(_fbb);
  builder_.add_m_indexClosing(m_indexClosing);
  builder_.add_m_indexOpening(m_indexOpening);
  builder_.add_m_type(m_type);
  builder_.add_m_originalLine(m_originalLine);
  builder_.add_m_sectionFile(m_sectionFile);
  builder_.add_m_sectionStartLine(m_sectionStartLine);
  return builder_.Finish();
}

inline flatbuffers::Offset<IncludeFileInfo> CreateIncludeFileInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t m_sectionStartLine = 0,
    const char *m_sectionFile = nullptr,
    uint32_t m_originalLine = 0,
    uint32_t m_type = 0,
    int32_t m_indexOpening = 0,
    int32_t m_indexClosing = 0) {
  auto m_sectionFile__ = m_sectionFile ? _fbb.CreateString(m_sectionFile) : 0;
  return SURELOG::MACROCACHE::CreateIncludeFileInfo(
      _fbb,
      m_sectionStartLine,
      m_sectionFile__,
      m_originalLine,
      m_type,
      m_indexOpening,
      m_indexClosing);
}

struct LineTranslationInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LineTranslationInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_PRETENDFILE = 4,
    VT_M_ORIGINALLINE = 6,
    VT_M_PRETENDLINE = 8
  };
  const flatbuffers::String *m_pretendFile() const {
    return GetPointer<const flatbuffers::String *>(VT_M_PRETENDFILE);
  }
  uint32_t m_originalLine() const {
    return GetField<uint32_t>(VT_M_ORIGINALLINE, 0);
  }
  uint32_t m_pretendLine() const {
    return GetField<uint32_t>(VT_M_PRETENDLINE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M_PRETENDFILE) &&
           verifier.VerifyString(m_pretendFile()) &&
           VerifyField<uint32_t>(verifier, VT_M_ORIGINALLINE) &&
           VerifyField<uint32_t>(verifier, VT_M_PRETENDLINE) &&
           verifier.EndTable();
  }
};

struct LineTranslationInfoBuilder {
  typedef LineTranslationInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_pretendFile(flatbuffers::Offset<flatbuffers::String> m_pretendFile) {
    fbb_.AddOffset(LineTranslationInfo::VT_M_PRETENDFILE, m_pretendFile);
  }
  void add_m_originalLine(uint32_t m_originalLine) {
    fbb_.AddElement<uint32_t>(LineTranslationInfo::VT_M_ORIGINALLINE, m_originalLine, 0);
  }
  void add_m_pretendLine(uint32_t m_pretendLine) {
    fbb_.AddElement<uint32_t>(LineTranslationInfo::VT_M_PRETENDLINE, m_pretendLine, 0);
  }
  explicit LineTranslationInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LineTranslationInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LineTranslationInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<LineTranslationInfo> CreateLineTranslationInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> m_pretendFile = 0,
    uint32_t m_originalLine = 0,
    uint32_t m_pretendLine = 0) {
  LineTranslationInfoBuilder builder_(_fbb);
  builder_.add_m_pretendLine(m_pretendLine);
  builder_.add_m_originalLine(m_originalLine);
  builder_.add_m_pretendFile(m_pretendFile);
  return builder_.Finish();
}

inline flatbuffers::Offset<LineTranslationInfo> CreateLineTranslationInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *m_pretendFile = nullptr,
    uint32_t m_originalLine = 0,
    uint32_t m_pretendLine = 0) {
  auto m_pretendFile__ = m_pretendFile ? _fbb.CreateString(m_pretendFile) : 0;
  return SURELOG::MACROCACHE::CreateLineTranslationInfo(
      _fbb,
      m_pretendFile__,
      m_originalLine,
      m_pretendLine);
}

struct PPCache FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PPCacheBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_HEADER = 4,
    VT_M_MACROS = 6,
    VT_M_INCLUDES = 8,
    VT_M_BODY = 10,
    VT_M_ERRORS = 12,
    VT_M_SYMBOLS = 14,
    VT_M_CMD_INCLUDE_PATHS = 16,
    VT_M_CMD_DEFINE_OPTIONS = 18,
    VT_M_TIMEINFO = 20,
    VT_M_LINETRANSLATIONVEC = 22,
    VT_M_INCLUDEFILEINFO = 24,
    VT_M_OBJECTS = 26
  };
  const SURELOG::CACHE::Header *m_header() const {
    return GetPointer<const SURELOG::CACHE::Header *>(VT_M_HEADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::Macro>> *m_macros() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::Macro>> *>(VT_M_MACROS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *m_includes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_M_INCLUDES);
  }
  const flatbuffers::String *m_body() const {
    return GetPointer<const flatbuffers::String *>(VT_M_BODY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SURELOG::CACHE::Error>> *m_errors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SURELOG::CACHE::Error>> *>(VT_M_ERRORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *m_symbols() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_M_SYMBOLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *m_cmd_include_paths() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_M_CMD_INCLUDE_PATHS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *m_cmd_define_options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_M_CMD_DEFINE_OPTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SURELOG::CACHE::TimeInfo>> *m_timeInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SURELOG::CACHE::TimeInfo>> *>(VT_M_TIMEINFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::LineTranslationInfo>> *m_lineTranslationVec() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::LineTranslationInfo>> *>(VT_M_LINETRANSLATIONVEC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::IncludeFileInfo>> *m_includeFileInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::IncludeFileInfo>> *>(VT_M_INCLUDEFILEINFO);
  }
  const flatbuffers::Vector<const SURELOG::CACHE::VObject *> *m_objects() const {
    return GetPointer<const flatbuffers::Vector<const SURELOG::CACHE::VObject *> *>(VT_M_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M_HEADER) &&
           verifier.VerifyTable(m_header()) &&
           VerifyOffset(verifier, VT_M_MACROS) &&
           verifier.VerifyVector(m_macros()) &&
           verifier.VerifyVectorOfTables(m_macros()) &&
           VerifyOffset(verifier, VT_M_INCLUDES) &&
           verifier.VerifyVector(m_includes()) &&
           verifier.VerifyVectorOfStrings(m_includes()) &&
           VerifyOffset(verifier, VT_M_BODY) &&
           verifier.VerifyString(m_body()) &&
           VerifyOffset(verifier, VT_M_ERRORS) &&
           verifier.VerifyVector(m_errors()) &&
           verifier.VerifyVectorOfTables(m_errors()) &&
           VerifyOffset(verifier, VT_M_SYMBOLS) &&
           verifier.VerifyVector(m_symbols()) &&
           verifier.VerifyVectorOfStrings(m_symbols()) &&
           VerifyOffset(verifier, VT_M_CMD_INCLUDE_PATHS) &&
           verifier.VerifyVector(m_cmd_include_paths()) &&
           verifier.VerifyVectorOfStrings(m_cmd_include_paths()) &&
           VerifyOffset(verifier, VT_M_CMD_DEFINE_OPTIONS) &&
           verifier.VerifyVector(m_cmd_define_options()) &&
           verifier.VerifyVectorOfStrings(m_cmd_define_options()) &&
           VerifyOffset(verifier, VT_M_TIMEINFO) &&
           verifier.VerifyVector(m_timeInfo()) &&
           verifier.VerifyVectorOfTables(m_timeInfo()) &&
           VerifyOffset(verifier, VT_M_LINETRANSLATIONVEC) &&
           verifier.VerifyVector(m_lineTranslationVec()) &&
           verifier.VerifyVectorOfTables(m_lineTranslationVec()) &&
           VerifyOffset(verifier, VT_M_INCLUDEFILEINFO) &&
           verifier.VerifyVector(m_includeFileInfo()) &&
           verifier.VerifyVectorOfTables(m_includeFileInfo()) &&
           VerifyOffset(verifier, VT_M_OBJECTS) &&
           verifier.VerifyVector(m_objects()) &&
           verifier.EndTable();
  }
};

struct PPCacheBuilder {
  typedef PPCache Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_header(flatbuffers::Offset<SURELOG::CACHE::Header> m_header) {
    fbb_.AddOffset(PPCache::VT_M_HEADER, m_header);
  }
  void add_m_macros(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::Macro>>> m_macros) {
    fbb_.AddOffset(PPCache::VT_M_MACROS, m_macros);
  }
  void add_m_includes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_includes) {
    fbb_.AddOffset(PPCache::VT_M_INCLUDES, m_includes);
  }
  void add_m_body(flatbuffers::Offset<flatbuffers::String> m_body) {
    fbb_.AddOffset(PPCache::VT_M_BODY, m_body);
  }
  void add_m_errors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SURELOG::CACHE::Error>>> m_errors) {
    fbb_.AddOffset(PPCache::VT_M_ERRORS, m_errors);
  }
  void add_m_symbols(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_symbols) {
    fbb_.AddOffset(PPCache::VT_M_SYMBOLS, m_symbols);
  }
  void add_m_cmd_include_paths(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_cmd_include_paths) {
    fbb_.AddOffset(PPCache::VT_M_CMD_INCLUDE_PATHS, m_cmd_include_paths);
  }
  void add_m_cmd_define_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_cmd_define_options) {
    fbb_.AddOffset(PPCache::VT_M_CMD_DEFINE_OPTIONS, m_cmd_define_options);
  }
  void add_m_timeInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SURELOG::CACHE::TimeInfo>>> m_timeInfo) {
    fbb_.AddOffset(PPCache::VT_M_TIMEINFO, m_timeInfo);
  }
  void add_m_lineTranslationVec(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::LineTranslationInfo>>> m_lineTranslationVec) {
    fbb_.AddOffset(PPCache::VT_M_LINETRANSLATIONVEC, m_lineTranslationVec);
  }
  void add_m_includeFileInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::IncludeFileInfo>>> m_includeFileInfo) {
    fbb_.AddOffset(PPCache::VT_M_INCLUDEFILEINFO, m_includeFileInfo);
  }
  void add_m_objects(flatbuffers::Offset<flatbuffers::Vector<const SURELOG::CACHE::VObject *>> m_objects) {
    fbb_.AddOffset(PPCache::VT_M_OBJECTS, m_objects);
  }
  explicit PPCacheBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PPCache> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PPCache>(end);
    return o;
  }
};

inline flatbuffers::Offset<PPCache> CreatePPCache(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SURELOG::CACHE::Header> m_header = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::Macro>>> m_macros = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_includes = 0,
    flatbuffers::Offset<flatbuffers::String> m_body = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SURELOG::CACHE::Error>>> m_errors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_symbols = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_cmd_include_paths = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> m_cmd_define_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SURELOG::CACHE::TimeInfo>>> m_timeInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::LineTranslationInfo>>> m_lineTranslationVec = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SURELOG::MACROCACHE::IncludeFileInfo>>> m_includeFileInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SURELOG::CACHE::VObject *>> m_objects = 0) {
  PPCacheBuilder builder_(_fbb);
  builder_.add_m_objects(m_objects);
  builder_.add_m_includeFileInfo(m_includeFileInfo);
  builder_.add_m_lineTranslationVec(m_lineTranslationVec);
  builder_.add_m_timeInfo(m_timeInfo);
  builder_.add_m_cmd_define_options(m_cmd_define_options);
  builder_.add_m_cmd_include_paths(m_cmd_include_paths);
  builder_.add_m_symbols(m_symbols);
  builder_.add_m_errors(m_errors);
  builder_.add_m_body(m_body);
  builder_.add_m_includes(m_includes);
  builder_.add_m_macros(m_macros);
  builder_.add_m_header(m_header);
  return builder_.Finish();
}

inline flatbuffers::Offset<PPCache> CreatePPCacheDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SURELOG::CACHE::Header> m_header = 0,
    const std::vector<flatbuffers::Offset<SURELOG::MACROCACHE::Macro>> *m_macros = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *m_includes = nullptr,
    const char *m_body = nullptr,
    const std::vector<flatbuffers::Offset<SURELOG::CACHE::Error>> *m_errors = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *m_symbols = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *m_cmd_include_paths = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *m_cmd_define_options = nullptr,
    const std::vector<flatbuffers::Offset<SURELOG::CACHE::TimeInfo>> *m_timeInfo = nullptr,
    const std::vector<flatbuffers::Offset<SURELOG::MACROCACHE::LineTranslationInfo>> *m_lineTranslationVec = nullptr,
    const std::vector<flatbuffers::Offset<SURELOG::MACROCACHE::IncludeFileInfo>> *m_includeFileInfo = nullptr,
    const std::vector<SURELOG::CACHE::VObject> *m_objects = nullptr) {
  auto m_macros__ = m_macros ? _fbb.CreateVector<flatbuffers::Offset<SURELOG::MACROCACHE::Macro>>(*m_macros) : 0;
  auto m_includes__ = m_includes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*m_includes) : 0;
  auto m_body__ = m_body ? _fbb.CreateString(m_body) : 0;
  auto m_errors__ = m_errors ? _fbb.CreateVector<flatbuffers::Offset<SURELOG::CACHE::Error>>(*m_errors) : 0;
  auto m_symbols__ = m_symbols ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*m_symbols) : 0;
  auto m_cmd_include_paths__ = m_cmd_include_paths ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*m_cmd_include_paths) : 0;
  auto m_cmd_define_options__ = m_cmd_define_options ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*m_cmd_define_options) : 0;
  auto m_timeInfo__ = m_timeInfo ? _fbb.CreateVector<flatbuffers::Offset<SURELOG::CACHE::TimeInfo>>(*m_timeInfo) : 0;
  auto m_lineTranslationVec__ = m_lineTranslationVec ? _fbb.CreateVector<flatbuffers::Offset<SURELOG::MACROCACHE::LineTranslationInfo>>(*m_lineTranslationVec) : 0;
  auto m_includeFileInfo__ = m_includeFileInfo ? _fbb.CreateVector<flatbuffers::Offset<SURELOG::MACROCACHE::IncludeFileInfo>>(*m_includeFileInfo) : 0;
  auto m_objects__ = m_objects ? _fbb.CreateVectorOfStructs<SURELOG::CACHE::VObject>(*m_objects) : 0;
  return SURELOG::MACROCACHE::CreatePPCache(
      _fbb,
      m_header,
      m_macros__,
      m_includes__,
      m_body__,
      m_errors__,
      m_symbols__,
      m_cmd_include_paths__,
      m_cmd_define_options__,
      m_timeInfo__,
      m_lineTranslationVec__,
      m_includeFileInfo__,
      m_objects__);
}

inline const SURELOG::MACROCACHE::PPCache *GetPPCache(const void *buf) {
  return flatbuffers::GetRoot<SURELOG::MACROCACHE::PPCache>(buf);
}

inline const SURELOG::MACROCACHE::PPCache *GetSizePrefixedPPCache(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SURELOG::MACROCACHE::PPCache>(buf);
}

inline const char *PPCacheIdentifier() {
  return "SLPP";
}

inline bool PPCacheBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, PPCacheIdentifier());
}

inline bool VerifyPPCacheBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SURELOG::MACROCACHE::PPCache>(PPCacheIdentifier());
}

inline bool VerifySizePrefixedPPCacheBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SURELOG::MACROCACHE::PPCache>(PPCacheIdentifier());
}

inline const char *PPCacheExtension() {
  return "slpp";
}

inline void FinishPPCacheBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SURELOG::MACROCACHE::PPCache> root) {
  fbb.Finish(root, PPCacheIdentifier());
}

inline void FinishSizePrefixedPPCacheBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SURELOG::MACROCACHE::PPCache> root) {
  fbb.FinishSizePrefixed(root, PPCacheIdentifier());
}

}  // namespace MACROCACHE
}  // namespace SURELOG

#endif  // FLATBUFFERS_GENERATED_PREPROC_SURELOG_MACROCACHE_H_

// This file is auto-generated by generate_ast_listener.py
// DO NOT EDIT

/*
 Copyright 2019 Alain Dargelas
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 *
 * File:   ParseTreeListener.h
 * Author: hs
 *
 */

#ifndef SURELOG_PARSETREELISTENER_H
#define SURELOG_PARSETREELISTENER_H
#pragma once

#include <Surelog/Common/NodeId.h>
#include <Surelog/Common/PathId.h>
#include <Surelog/SourceCompile/VObjectTypes.h>

#include <cstdint>
#include <type_traits>
#include <unordered_set>
#include <vector>

namespace SURELOG {

class ParseTreeListener;
class SymbolTable;
class VObject;
struct ParseTreeNodeEqualityComparer;
struct ParseTreeNodeHash;
struct ParseTreeNodeLessComparer;

class ParseTreeNode final {
 public:
  ParseTreeNode() : m_index(), m_object(nullptr) {}
  ParseTreeNode(const ParseTreeNode& node)
      : m_index(node.m_index), m_object(node.m_object) {}
  ParseTreeNode(const NodeId& index, const VObject* const object)
      : m_index(index), m_object(object) {}

  ParseTreeNode& operator=(const ParseTreeNode& rhs) {
    if (this != &rhs) {
      m_index = rhs.m_index;
      m_object = rhs.m_object;
    }
    return *this;
  }

 public:
  operator bool() const { return m_index && (m_object != nullptr); }

 private:
  NodeId m_index;
  const VObject* m_object = nullptr;

  friend class ParseTreeListener;
  friend struct ParseTreeNodeHash;
  friend struct ParseTreeNodeEqualityComparer;
  friend struct ParseTreeNodeLessComparer;
};

struct ParseTreeNodeEqualityComparer final {
  bool operator()(const ParseTreeNode& lhs, const ParseTreeNode& rhs) const {
    return (lhs.m_index == rhs.m_index) && (lhs.m_object == rhs.m_object);
  }
};

struct ParseTreeNodeHash final {
  size_t operator()(const ParseTreeNode& node) const {
    return std::hash<RawNodeId>()(node.m_index);
  }
};

class ParseTreeListener {
 protected:
  typedef std::unordered_set<ParseTreeNode, ParseTreeNodeHash,
                             ParseTreeNodeEqualityComparer>
      parsetreenode_set_t;
  typedef std::vector<ParseTreeNode> parsetreenode_stack_t;
  typedef std::vector<ParseTreeNode> parsetreenode_vector_t;

 public:
  ParseTreeListener() = default;
  virtual ~ParseTreeListener() = default;

  virtual void enterSourceFile(PathId fileId) {}
  virtual void leaveSourceFile(PathId fileId) {}

  virtual void enter(const ParseTreeNode& node) {}
  virtual void leave(const ParseTreeNode& node) {}

  // clang-format off
<PUBLIC_ENTER_LEAVE_DECLARATIONS>
  // clang-format on

  // clang-format off
<PUBLIC_VISIT_DECLARATIONS>
  // clang-format on

  void listen(const ParseTreeNode& node);
  void listenChildren(const ParseTreeNode& node, bool ordered);
  void listenSiblings(const ParseTreeNode& node, bool ordered);

  void listen(PathId fileId, const VObject* objects, size_t count,
              const SymbolTable* symbolTable);

  VObjectType getNodeType(const ParseTreeNode& node) const;
  ParseTreeNode getRootNode() const;
  bool getNodeText(const ParseTreeNode& node, std::string& text) const;
  bool getNodeFileId(const ParseTreeNode& node, PathId& fileId) const;
  bool getNodeStartLocation(const ParseTreeNode& node, int32_t& line,
                            int32_t& column) const;
  bool getNodeEndLocation(const ParseTreeNode& node, int32_t& line,
                          int32_t& column) const;
  bool getNodeLocation(const ParseTreeNode& node, int32_t& startLine,
                       int32_t& startColumn, int32_t& endLine,
                       int32_t& endColumn) const;
  ParseTreeNode getNodeParent(const ParseTreeNode& node) const;
  ParseTreeNode getNodePrevSibling(const ParseTreeNode& node) const;
  ParseTreeNode getNodeNextSibling(const ParseTreeNode& node) const;
  bool getNodeChildren(const ParseTreeNode& node, bool ordered,
                       parsetreenode_vector_t& children) const;
  bool getNodeSiblings(const ParseTreeNode& node, bool ordered,
                       parsetreenode_vector_t& siblings) const;

 private:
  // clang-format off
<PRIVATE_LISTEN_DECLARATIONS>
  // clang-format on

 protected:
  parsetreenode_set_t m_visited;
  parsetreenode_stack_t m_callstack;

 private:
  const VObject* m_objects = nullptr;
  size_t m_count = 0;
  const SymbolTable* m_symbolTable = nullptr;
};
}  // namespace SURELOG

#endif  // SURELOG_PARSETREELISTENER_H

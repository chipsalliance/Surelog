
<!DOCTYPE html>
<html>
<head>
<style>
body {
background-color: #93B874;
}
</style>
<h3>hw/ip/alert_handler/rtl/alert_handler.sv</h3>
<pre>  input                           clk_i,</pre>
<pre>  input                           rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t       tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t       tl_o,</pre>
<pre>  output logic                    intr_classa_o,</pre>
<pre>  output logic                    intr_classb_o,</pre>
<pre>  output logic                    intr_classc_o,</pre>
<pre>  output logic                    intr_classd_o,</pre>
<pre>  output alert_crashdump_t        crashdump_o,</pre>
<pre>  input                           entropy_i,</pre>
<pre>  input  alert_tx_t [NAlerts-1:0] alert_tx_i,</pre>
<pre>  output alert_rx_t [NAlerts-1:0] alert_rx_o,</pre>
<pre>  input  esc_rx_t [N_ESC_SEV-1:0] esc_rx_i,</pre>
<pre>  output esc_tx_t [N_ESC_SEV-1:0] esc_tx_o</pre>
<pre>  logic [N_CLASSES-1:0] irq;</pre>
<pre>  hw2reg_wrap_t hw2reg_wrap;</pre>
<pre>  reg2hw_wrap_t reg2hw_wrap;</pre>
<pre>  assign {intr_classd_o,</pre>
<pre>          intr_classc_o,</pre>
<pre>          intr_classb_o,</pre>
<pre>          intr_classa_o} = irq;</pre>
<pre>  alert_handler_reg_wrap i_reg_wrap (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .tl_o,</pre>
<pre>    .irq_o ( irq ),</pre>
<pre>    .crashdump_o,</pre>
<pre>    .hw2reg_wrap,</pre>
<pre>    .reg2hw_wrap</pre>
<pre>  logic [N_LOC_ALERT-1:0] loc_alert_trig;</pre>
<pre>  logic [NAlerts-1:0]   alert_ping_en;</pre>
<pre>  logic [NAlerts-1:0]   alert_ping_ok;</pre>
<pre>  logic [N_ESC_SEV-1:0] esc_ping_en;</pre>
<pre>  logic [N_ESC_SEV-1:0] esc_ping_ok;</pre>
<pre>  alert_handler_ping_timer i_ping_timer (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .entropy_i,</pre>
<pre>    .en_i               ( reg2hw_wrap.config_locked    ),</pre>
<pre>    .alert_en_i         ( reg2hw_wrap.alert_en         ),</pre>
<pre>    .ping_timeout_cyc_i ( reg2hw_wrap.ping_timeout_cyc ),</pre>
<pre>    .wait_cyc_mask_i    ( PING_CNT_DW'(24'hFFFFFF)     ),</pre>
<pre>    .alert_ping_en_o    ( alert_ping_en                ),</pre>
<pre>    .esc_ping_en_o      ( esc_ping_en                  ),</pre>
<pre>    .alert_ping_ok_i    ( alert_ping_ok                ),</pre>
<pre>    .esc_ping_ok_i      ( esc_ping_ok                  ),</pre>
<pre>    .alert_ping_fail_o  ( loc_alert_trig[0]            ),</pre>
<pre>    .esc_ping_fail_o    ( loc_alert_trig[1]            )</pre>
<pre>  logic [NAlerts-1:0] alert_integfail;</pre>
<pre>  logic [NAlerts-1:0] alert_trig;</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0 ; k < NAlerts ; k++) begin : gen_alerts</pre>
<pre style="background-color: #FF0000;">    prim_alert_receiver #(</pre>
<pre style="background-color: #FF0000;">      .AsyncOn(AsyncOn[k])</pre>
<pre style="background-color: #FF0000;">    ) i_alert_receiver (</pre>
<pre style="background-color: #FF0000;">      .clk_i                              ,</pre>
<pre style="background-color: #FF0000;">      .rst_ni                             ,</pre>
<pre style="background-color: #FF0000;">      .ping_en_i    ( alert_ping_en[k]   ),</pre>
<pre style="background-color: #FF0000;">      .ping_ok_o    ( alert_ping_ok[k]   ),</pre>
<pre style="background-color: #FF0000;">      .integ_fail_o ( alert_integfail[k] ),</pre>
<pre style="background-color: #FF0000;">      .alert_o      ( alert_trig[k]      ),</pre>
<pre style="background-color: #FF0000;">      .alert_rx_o   ( alert_rx_o[k]      ),</pre>
<pre style="background-color: #FF0000;">      .alert_tx_i   ( alert_tx_i[k]      )</pre>
<pre>  assign loc_alert_trig[2] = |(reg2hw_wrap.alert_en & alert_integfail);</pre>
<pre>  alert_handler_class i_class (</pre>
<pre>    .alert_trig_i      ( alert_trig                  ),</pre>
<pre>    .loc_alert_trig_i  ( loc_alert_trig              ),</pre>
<pre>    .alert_en_i        ( reg2hw_wrap.alert_en        ),</pre>
<pre>    .loc_alert_en_i    ( reg2hw_wrap.loc_alert_en    ),</pre>
<pre>    .alert_class_i     ( reg2hw_wrap.alert_class     ),</pre>
<pre>    .loc_alert_class_i ( reg2hw_wrap.loc_alert_class ),</pre>
<pre>    .alert_cause_o     ( hw2reg_wrap.alert_cause     ),</pre>
<pre>    .loc_alert_cause_o ( hw2reg_wrap.loc_alert_cause ),</pre>
<pre>    .class_trig_o      ( hw2reg_wrap.class_trig      )</pre>
<pre>  logic [N_CLASSES-1:0] class_accum_trig;</pre>
<pre>  logic [N_CLASSES-1:0][N_ESC_SEV-1:0] class_esc_sig_en;</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0; k < N_CLASSES; k++) begin : gen_classes</pre>
<pre style="background-color: #FF0000;">    alert_handler_accu i_accu (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre style="background-color: #FF0000;">      .rst_ni,</pre>
<pre style="background-color: #FF0000;">      .class_en_i   ( reg2hw_wrap.class_en[k]           ),</pre>
<pre style="background-color: #FF0000;">      .clr_i        ( reg2hw_wrap.class_clr[k]          ),</pre>
<pre style="background-color: #FF0000;">      .class_trig_i ( hw2reg_wrap.class_trig[k]         ),</pre>
<pre style="background-color: #FF0000;">      .thresh_i     ( reg2hw_wrap.class_accum_thresh[k] ),</pre>
<pre style="background-color: #FF0000;">      .accu_cnt_o   ( hw2reg_wrap.class_accum_cnt[k]    ),</pre>
<pre style="background-color: #FF0000;">      .accu_trig_o  ( class_accum_trig[k]               )</pre>
<pre style="background-color: #FF0000;">    alert_handler_esc_timer i_esc_timer (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre style="background-color: #FF0000;">      .rst_ni,</pre>
<pre style="background-color: #FF0000;">      .en_i             ( reg2hw_wrap.class_en[k]          ),</pre>
<pre style="background-color: #FF0000;">      .clr_i            ( reg2hw_wrap.class_clr[k]         ),</pre>
<pre style="background-color: #FF0000;">      .timeout_en_i     ( irq[k]                           ),</pre>
<pre style="background-color: #FF0000;">      .accum_trig_i     ( class_accum_trig[k]              ),</pre>
<pre style="background-color: #FF0000;">      .timeout_cyc_i    ( reg2hw_wrap.class_timeout_cyc[k] ),</pre>
<pre style="background-color: #FF0000;">      .esc_en_i         ( reg2hw_wrap.class_esc_en[k]      ),</pre>
<pre style="background-color: #FF0000;">      .esc_map_i        ( reg2hw_wrap.class_esc_map[k]     ),</pre>
<pre style="background-color: #FF0000;">      .phase_cyc_i      ( reg2hw_wrap.class_phase_cyc[k]   ),</pre>
<pre style="background-color: #FF0000;">      .esc_trig_o       ( hw2reg_wrap.class_esc_trig[k]    ),</pre>
<pre style="background-color: #FF0000;">      .esc_cnt_o        ( hw2reg_wrap.class_esc_cnt[k]     ),</pre>
<pre style="background-color: #FF0000;">      .esc_state_o      ( hw2reg_wrap.class_esc_state[k]   ),</pre>
<pre style="background-color: #FF0000;">      .esc_sig_en_o     ( class_esc_sig_en[k]              )</pre>
<pre>  logic [N_ESC_SEV-1:0] esc_sig_en;</pre>
<pre>  logic [N_ESC_SEV-1:0] esc_integfail;</pre>
<pre>  logic [N_ESC_SEV-1:0][N_CLASSES-1:0] esc_sig_en_trsp;</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0; k < N_ESC_SEV; k++) begin : gen_esc_sev</pre>
<pre style="background-color: #FF0000;">    for (genvar j = 0; j < N_CLASSES; j++) begin : gen_transp</pre>
<pre style="background-color: #FF0000;">      assign esc_sig_en_trsp[k][j] = class_esc_sig_en[j][k];</pre>
<pre style="background-color: #FF0000;">    assign esc_sig_en[k] = |esc_sig_en_trsp[k];</pre>
<pre style="background-color: #FF0000;">    prim_esc_sender i_esc_sender (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre style="background-color: #FF0000;">      .rst_ni,</pre>
<pre style="background-color: #FF0000;">      .ping_en_i    ( esc_ping_en[k]   ),</pre>
<pre style="background-color: #FF0000;">      .ping_ok_o    ( esc_ping_ok[k]   ),</pre>
<pre style="background-color: #FF0000;">      .integ_fail_o ( esc_integfail[k] ),</pre>
<pre style="background-color: #FF0000;">      .esc_en_i     ( esc_sig_en[k]    ),</pre>
<pre style="background-color: #FF0000;">      .esc_rx_i     ( esc_rx_i[k]      ),</pre>
<pre style="background-color: #FF0000;">      .esc_tx_o     ( esc_tx_o[k]      )</pre>
<pre>  assign loc_alert_trig[3] = |esc_integfail;</pre>
<h3>hw/ip/alert_handler/rtl/alert_handler_class.sv</h3>
<pre>  input [NAlerts-1:0]                   alert_trig_i,      // alert trigger</pre>
<pre>  input [N_LOC_ALERT-1:0]               loc_alert_trig_i,  // alert trigger</pre>
<pre>  input [NAlerts-1:0]                   alert_en_i,        // alert enable</pre>
<pre>  input [N_LOC_ALERT-1:0]               loc_alert_en_i,    // alert enable</pre>
<pre>  input [NAlerts-1:0]    [CLASS_DW-1:0] alert_class_i,     // class assignment</pre>
<pre>  input [N_LOC_ALERT-1:0][CLASS_DW-1:0] loc_alert_class_i, // class assignment</pre>
<pre>  output logic [NAlerts-1:0]            alert_cause_o,     // alert cause</pre>
<pre>  output logic [N_LOC_ALERT-1:0]        loc_alert_cause_o, // alert cause</pre>
<pre>  output logic [N_CLASSES-1:0]          class_trig_o       // class triggered</pre>
<pre>  assign alert_cause_o     = alert_en_i     & alert_trig_i;</pre>
<pre>  assign loc_alert_cause_o = loc_alert_en_i & loc_alert_trig_i;</pre>
<pre>  logic [N_CLASSES-1:0][NAlerts-1:0]     class_masks;</pre>
<pre>  logic [N_CLASSES-1:0][N_LOC_ALERT-1:0] loc_class_masks;</pre>
<pre>  always_comb begin : p_class_mask</pre>
<pre>    class_masks = '0;</pre>
<pre>    loc_class_masks = '0;</pre>
<pre>    for (int unsigned kk = 0; kk < NAlerts; kk++) begin</pre>
<pre>      class_masks[alert_class_i[kk]][kk] = 1'b1;</pre>
<pre>    for (int unsigned kk = 0; kk < N_LOC_ALERT; kk++) begin</pre>
<pre>      loc_class_masks[loc_alert_class_i[kk]][kk] = 1'b1;</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0; k < N_CLASSES; k++) begin : gen_classifier</pre>
<pre style="background-color: #FF0000;">    assign class_trig_o[k] = (|{ alert_cause_o     & class_masks[k],</pre>
<pre style="background-color: #FF0000;">                                 loc_alert_cause_o & loc_class_masks[k] });</pre>
<pre style="background-color: #FF0000;">endmodule : alert_handler_class</pre>
<h3>hw/ip/alert_handler/rtl/alert_handler_ping_timer.sv</h3>
<pre>module alert_handler_ping_timer import alert_pkg::*; #(</pre>
<pre>  parameter bit                MaxLenSVA  = 1'b1,</pre>
<pre>  parameter bit                LockupSVA  = 1'b1</pre>
<pre>  input                          clk_i,</pre>
<pre>  input                          rst_ni,</pre>
<pre>  input                          entropy_i,          // from TRNG</pre>
<pre>  input                          en_i,               // enable ping testing</pre>
<pre>  input        [NAlerts-1:0]     alert_en_i,         // determines which alerts to ping</pre>
<pre>  input        [PING_CNT_DW-1:0] ping_timeout_cyc_i, // timeout in cycles</pre>
<pre>  input        [PING_CNT_DW-1:0] wait_cyc_mask_i,    // wait cycles mask</pre>
<pre>  output logic [NAlerts-1:0]     alert_ping_en_o,    // enable to alert receivers</pre>
<pre>  output logic [N_ESC_SEV-1:0]   esc_ping_en_o,      // enable to esc senders</pre>
<pre>  input        [NAlerts-1:0]     alert_ping_ok_i,    // response from alert receivers</pre>
<pre>  input        [N_ESC_SEV-1:0]   esc_ping_ok_i,      // response from esc senders</pre>
<pre>  output logic                   alert_ping_fail_o,  // any of the alert receivers failed</pre>
<pre>  output logic                   esc_ping_fail_o     // any of the esc senders failed</pre>
<pre>  localparam int unsigned NModsToPing = NAlerts + N_ESC_SEV;</pre>
<pre>  localparam int unsigned IdDw        = $clog2(NModsToPing);</pre>
<pre>  localparam int unsigned perm [32] = '{</pre>
<pre>    4, 11, 25,  3,   //</pre>
<pre>    15, 16,  1, 10,  //</pre>
<pre>    2, 22,  7,  0,   //</pre>
<pre>    23, 28, 30, 19,  //</pre>
<pre>    27, 12, 24, 26,  //</pre>
<pre>    14, 21, 18,  5,  //</pre>
<pre>    13,  8, 29, 31,  //</pre>
<pre>    20,  6,  9, 17   //</pre>
<pre>  logic lfsr_en;</pre>
<pre>  logic [31:0] lfsr_state, perm_state;</pre>
<pre>  logic [16-IdDw-1:0] unused_perm_state;</pre>
<pre>  prim_lfsr #(</pre>
<pre>    .LfsrDw      ( 32         ),</pre>
<pre>    .EntropyDw   ( 1          ),</pre>
<pre>    .StateOutDw  ( 32         ),</pre>
<pre>    .DefaultSeed ( LfsrSeed   ),</pre>
<pre>    .MaxLenSVA   ( MaxLenSVA  ),</pre>
<pre>    .LockupSVA   ( LockupSVA  ),</pre>
<pre>    .ExtSeedSVA  ( 1'b0       ) // ext seed is unused</pre>
<pre style="background-color: #FF0000;">  ) i_prim_lfsr (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .seed_en_i  ( 1'b0       ),</pre>
<pre>    .seed_i     ( '0         ),</pre>
<pre>    .lfsr_en_i  ( lfsr_en    ),</pre>
<pre>    .entropy_i,</pre>
<pre>    .state_o    ( lfsr_state )</pre>
<pre>  for (genvar k = 0; k < 32; k++) begin : gen_perm</pre>
<pre>    assign perm_state[k] = lfsr_state[perm[k]];</pre>
<pre>  logic [IdDw-1:0] id_to_ping;</pre>
<pre>  logic [PING_CNT_DW-1:0] wait_cyc;</pre>
<pre>  assign id_to_ping = perm_state[16 +: IdDw];</pre>
<pre>  assign unused_perm_state = perm_state[31:16+IdDw];</pre>
<pre>  assign wait_cyc   = PING_CNT_DW'({perm_state[15:2], 8'h01, perm_state[1:0]}) & wait_cyc_mask_i;</pre>
<pre>  logic [2**IdDw-1:0] enable_mask;</pre>
<pre>  always_comb begin : p_enable_mask</pre>
<pre>    enable_mask                        = '0;         // tie off unused</pre>
<pre>    enable_mask[NAlerts-1:0]           = alert_en_i; // alerts</pre>
<pre>    enable_mask[NModsToPing-1:NAlerts] = '1;         // escalation senders</pre>
<pre>  logic id_vld;</pre>
<pre>  assign id_vld  = enable_mask[id_to_ping];</pre>
<pre>  logic [PING_CNT_DW-1:0] cnt_d, cnt_q;</pre>
<pre>  logic cnt_en, cnt_clr;</pre>
<pre>  logic wait_ge, timeout_ge;</pre>
<pre>  assign cnt_d      = cnt_q + 1'b1;</pre>
<pre>  assign wait_ge    = (cnt_q >= wait_cyc);</pre>
<pre>  assign timeout_ge = (cnt_q >= ping_timeout_cyc_i);</pre>
<pre>  typedef enum logic [1:0] {Init, RespWait, DoPing} state_e;</pre>
<pre>  state_e state_d, state_q;</pre>
<pre>  logic ping_en, ping_ok;</pre>
<pre>  logic [NModsToPing-1:0] ping_sel;</pre>
<pre>  logic [NModsToPing-1:0] spurious_ping;</pre>
<pre>  logic spurious_alert_ping, spurious_esc_ping;</pre>
<pre>  assign ping_sel        = NModsToPing'(ping_en) << id_to_ping;</pre>
<pre>  assign alert_ping_en_o = ping_sel[NAlerts-1:0];</pre>
<pre>  assign esc_ping_en_o   = ping_sel[NModsToPing-1:NAlerts];</pre>
<pre>  assign ping_ok             = |({esc_ping_ok_i, alert_ping_ok_i} & ping_sel);</pre>
<pre>  assign spurious_ping       = ({esc_ping_ok_i, alert_ping_ok_i} & ~ping_sel);</pre>
<pre>  assign spurious_alert_ping = |spurious_ping[NAlerts-1:0];</pre>
<pre>  assign spurious_esc_ping   = |spurious_ping[NModsToPing-1:NAlerts];</pre>
<pre>  always_comb begin : p_fsm</pre>
<pre>    state_d = state_q;</pre>
<pre>    cnt_en  = 1'b0;</pre>
<pre>    cnt_clr = 1'b0;</pre>
<pre>    lfsr_en = 1'b0;</pre>
<pre>    ping_en = 1'b0;</pre>
<pre>    alert_ping_fail_o = spurious_alert_ping;</pre>
<pre>    esc_ping_fail_o   = spurious_esc_ping;</pre>
<pre>    unique case (state_q)</pre>
<pre>      Init: begin</pre>
<pre>        cnt_clr = 1'b1;</pre>
<pre>        if (en_i) begin</pre>
<pre>          state_d = RespWait;</pre>
<pre>      RespWait: begin</pre>
<pre>        if (!id_vld) begin</pre>
<pre>          lfsr_en = 1'b1;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>        end else if (wait_ge) begin</pre>
<pre>          state_d = DoPing;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          cnt_en = 1'b1;</pre>
<pre>      DoPing: begin</pre>
<pre>        cnt_en  = 1'b1;</pre>
<pre>        ping_en = 1'b1;</pre>
<pre>        if (timeout_ge || ping_ok) begin</pre>
<pre>          state_d = RespWait;</pre>
<pre>          lfsr_en = 1'b1;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>          if (timeout_ge) begin</pre>
<pre>            if (id_to_ping < NAlerts) begin</pre>
<pre>              alert_ping_fail_o = 1'b1;</pre>
<pre>            end else begin</pre>
<pre>              esc_ping_fail_o   = 1'b1;</pre>
<pre>      default: begin</pre>
<pre>        alert_ping_fail_o = 1'b1;</pre>
<pre>        esc_ping_fail_o   = 1'b1;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      state_q <= Init;</pre>
<pre>      cnt_q   <= '0;</pre>
<pre>    end else begin</pre>
<pre>      state_q <= state_d;</pre>
<pre>      if (cnt_clr) begin</pre>
<pre>        cnt_q <= '0;</pre>
<pre>      end else if (cnt_en) begin</pre>
<pre>        cnt_q <= cnt_d;</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>hw/ip/pinmux/rtl/pinmux.sv</h3>
<pre>  input                                         clk_i,</pre>
<pre>  input                                         rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t                     tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t                     tl_o,</pre>
<pre>  input        [pinmux_reg_pkg::NPeriphOut-1:0] periph_to_mio_i,</pre>
<pre>  input        [pinmux_reg_pkg::NPeriphOut-1:0] periph_to_mio_oe_i,</pre>
<pre>  output logic [pinmux_reg_pkg::NPeriphIn-1:0]  mio_to_periph_o,</pre>
<pre>  output logic [pinmux_reg_pkg::NMioPads-1:0]   mio_out_o,</pre>
<pre>  output logic [pinmux_reg_pkg::NMioPads-1:0]   mio_oe_o,</pre>
<pre>  input        [pinmux_reg_pkg::NMioPads-1:0]   mio_in_i</pre>
<pre>  pinmux_reg_pkg::pinmux_reg2hw_t reg2hw;</pre>
<pre>  pinmux_reg_top i_reg_top (</pre>
<pre>    .clk_i  ,</pre>
<pre>    .rst_ni ,</pre>
<pre>    .tl_i   ,</pre>
<pre>    .tl_o   ,</pre>
<pre>    .reg2hw ,</pre>
<pre>    .devmode_i(1'b1)</pre>
<pre>  for (genvar k = 0; k < pinmux_reg_pkg::NPeriphIn; k++) begin : gen_periph_in</pre>
<pre>    logic [pinmux_reg_pkg::NMioPads+2-1:0] data_mux;</pre>
<pre>    assign data_mux = $bits(data_mux)'({mio_in_i, 1'b1, 1'b0});</pre>
<pre>    assign mio_to_periph_o[k] = data_mux[reg2hw.periph_insel[k].q];</pre>
<pre>    logic [pinmux_reg_pkg::NPeriphOut+3-1:0] data_mux, oe_mux;</pre>
<pre>    // stack output data/enable and default signals for convenient indexing below</pre>
<pre>    assign oe_mux   = $bits(oe_mux)'({periph_to_mio_oe_i,  1'b0, 1'b1, 1'b1});</pre>
<pre>    // index using configured outsel</pre>
<pre>    assign mio_oe_o[k]  = oe_mux[reg2hw.mio_outsel[k].q];</pre>
<pre>    // disallow undefined entries</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>hw/ip/alert_handler/rtl/alert_handler_esc_timer.sv</h3>
<pre>  input                        clk_i,</pre>
<pre>  input                        rst_ni,</pre>
<pre>  input                        en_i,           // enables timeout/escalation</pre>
<pre>  input                        clr_i,          // aborts escalation</pre>
<pre>  input                        accum_trig_i,   // this will trigger escalation</pre>
<pre>  input                        timeout_en_i,   // enables timeout</pre>
<pre>  input        [EscCntDw-1:0]  timeout_cyc_i,  // interrupt timeout. 0 = disabled</pre>
<pre>  input        [N_ESC_SEV-1:0] esc_en_i,       // escalation signal enables</pre>
<pre style="background-color: #FF0000;">  input        [N_ESC_SEV-1:0]</pre>
<pre>               [PHASE_DW-1:0]  esc_map_i,      // escalation signal / phase map</pre>
<pre style="background-color: #FF0000;">  input        [N_PHASES-1:0]</pre>
<pre>               [EscCntDw-1:0]  phase_cyc_i,    // cycle counts of individual phases</pre>
<pre>  output logic                 esc_trig_o,     // asserted if escalation triggers</pre>
<pre>  output logic [EscCntDw-1:0]  esc_cnt_o,      // current timeout / escalation count</pre>
<pre>  output logic [N_ESC_SEV-1:0] esc_sig_en_o,   // escalation signal outputs</pre>
<pre>  output cstate_e              esc_state_o</pre>
<pre>  cstate_e state_d, state_q;</pre>
<pre>  logic cnt_en, cnt_clr, cnt_ge;</pre>
<pre>  logic [EscCntDw-1:0] cnt_d, cnt_q;</pre>
<pre>  assign cnt_d = cnt_q + 1'b1;</pre>
<pre>  assign esc_state_o = state_q;</pre>
<pre>  assign esc_cnt_o   = cnt_q;</pre>
<pre>  logic [EscCntDw-1:0] thresh;</pre>
<pre>  assign cnt_ge    = (cnt_q >= thresh);</pre>
<pre>  logic [N_PHASES-1:0] phase_oh;</pre>
<pre>  always_comb begin : p_fsm</pre>
<pre>    state_d    = state_q;</pre>
<pre>    cnt_en     = 1'b0;</pre>
<pre>    cnt_clr    = 1'b0;</pre>
<pre>    esc_trig_o = 1'b0;</pre>
<pre>    phase_oh   = '0;</pre>
<pre>    thresh     = timeout_cyc_i;</pre>
<pre>    unique case (state_q)</pre>
<pre>      Idle: begin</pre>
<pre>        cnt_clr = 1'b1;</pre>
<pre>        if (accum_trig_i && en_i) begin</pre>
<pre>          state_d    = Phase0;</pre>
<pre>          cnt_en     = 1'b1;</pre>
<pre>          esc_trig_o = 1'b1;</pre>
<pre>        end else if (timeout_en_i && !cnt_ge && en_i) begin</pre>
<pre>          cnt_en  = 1'b1;</pre>
<pre>          state_d = Timeout;</pre>
<pre>      Timeout: begin</pre>
<pre>        if (accum_trig_i || (cnt_ge && timeout_en_i)) begin</pre>
<pre>          state_d    = Phase0;</pre>
<pre>          cnt_en     = 1'b1;</pre>
<pre>          cnt_clr    = 1'b1;</pre>
<pre>          esc_trig_o = 1'b1;</pre>
<pre>        end else if (timeout_en_i) begin</pre>
<pre>          cnt_en  = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>      Phase0: begin</pre>
<pre>        cnt_en      = 1'b1;</pre>
<pre>        phase_oh[0] = 1'b1;</pre>
<pre>        thresh      = phase_cyc_i[0];</pre>
<pre>        if (clr_i) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>          cnt_en  = 1'b0;</pre>
<pre>        end else if (cnt_ge) begin</pre>
<pre>          state_d = Phase1;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>          cnt_en  = 1'b1;</pre>
<pre>      Phase1: begin</pre>
<pre>        cnt_en      = 1'b1;</pre>
<pre>        phase_oh[1] = 1'b1;</pre>
<pre>        thresh      = phase_cyc_i[1];</pre>
<pre>        if (clr_i) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>          cnt_en  = 1'b0;</pre>
<pre>        end else if (cnt_ge) begin</pre>
<pre>          state_d = Phase2;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>          cnt_en  = 1'b1;</pre>
<pre>      Phase2: begin</pre>
<pre>        cnt_en      = 1'b1;</pre>
<pre>        phase_oh[2] = 1'b1;</pre>
<pre>        thresh      = phase_cyc_i[2];</pre>
<pre>        if (clr_i) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>          cnt_en  = 1'b0;</pre>
<pre>        end else if (cnt_ge) begin</pre>
<pre>          state_d = Phase3;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>      Phase3: begin</pre>
<pre>        cnt_en      = 1'b1;</pre>
<pre>        phase_oh[3] = 1'b1;</pre>
<pre>        thresh      = phase_cyc_i[3];</pre>
<pre>        if (clr_i) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>          cnt_en  = 1'b0;</pre>
<pre>        end else if (cnt_ge) begin</pre>
<pre>          state_d = Terminal;</pre>
<pre>          cnt_clr = 1'b1;</pre>
<pre>      Terminal: begin</pre>
<pre>        cnt_clr = 1'b1;</pre>
<pre>        if (clr_i) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>      default: state_d = Idle;</pre>
<pre>  logic [N_ESC_SEV-1:0][N_PHASES-1:0] esc_map_oh;</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0; k < N_ESC_SEV; k++) begin : gen_phase_map</pre>
<pre style="background-color: #FF0000;">    assign esc_map_oh[k] = N_ESC_SEV'(esc_en_i[k]) << esc_map_i[k];</pre>
<pre style="background-color: #FF0000;">    assign esc_sig_en_o[k] = |(esc_map_oh[k] & phase_oh);</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      state_q <= Idle;</pre>
<pre>      cnt_q   <= '0;</pre>
<pre>    end else begin</pre>
<pre>      state_q <= state_d;</pre>
<pre>      if (cnt_en && cnt_clr) begin</pre>
<pre>        cnt_q <= EscCntDw'(1'b1);</pre>
<pre>      end else if (cnt_clr) begin</pre>
<pre>        cnt_q <= '0;</pre>
<pre>      end else if (cnt_en) begin</pre>
<pre>        cnt_q <= cnt_d;</pre>
<pre style="background-color: #FF0000;">endmodule : alert_handler_esc_timer</pre>
<h3>hw/ip/alert_handler/rtl/alert_handler_reg_wrap.sv</h3>
<pre>  input                                   clk_i,</pre>
<pre>  input                                   rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t               tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t               tl_o,</pre>
<pre>  output logic [N_CLASSES-1:0] irq_o,</pre>
<pre>  output alert_crashdump_t     crashdump_o,</pre>
<pre>  input  hw2reg_wrap_t         hw2reg_wrap,</pre>
<pre>  output reg2hw_wrap_t         reg2hw_wrap</pre>
<pre>  logic [N_CLASSES-1:0] class_autolock_en;</pre>
<pre>  alert_handler_reg_pkg::alert_handler_reg2hw_t reg2hw;</pre>
<pre>  alert_handler_reg_pkg::alert_handler_hw2reg_t hw2reg;</pre>
<pre>  alert_handler_reg_top i_reg (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .tl_o,</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .devmode_i(1'b1)</pre>
<pre>    prim_intr_hw #(</pre>
<pre>      .Width(1)</pre>
<pre style="background-color: #FF0000;">    ) i_irq_classa (</pre>
<pre>      .event_intr_i           ( hw2reg_wrap.class_trig[0]    ),</pre>
<pre>      .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.classa.q  ),</pre>
<pre>      .reg2hw_intr_test_q_i   ( reg2hw.intr_test.classa.q    ),</pre>
<pre>      .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.classa.qe   ),</pre>
<pre>      .reg2hw_intr_state_q_i  ( reg2hw.intr_state.classa.q   ),</pre>
<pre>      .hw2reg_intr_state_de_o ( hw2reg.intr_state.classa.de  ),</pre>
<pre>      .hw2reg_intr_state_d_o  ( hw2reg.intr_state.classa.d   ),</pre>
<pre>      .intr_o                 ( irq_o[0]                     )</pre>
<pre>    prim_intr_hw #(</pre>
<pre>      .Width(1)</pre>
<pre style="background-color: #FF0000;">    ) i_irq_classb (</pre>
<pre>      .event_intr_i           ( hw2reg_wrap.class_trig[1]    ),</pre>
<pre>      .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.classb.q  ),</pre>
<pre>      .reg2hw_intr_test_q_i   ( reg2hw.intr_test.classb.q    ),</pre>
<pre>      .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.classb.qe   ),</pre>
<pre>      .reg2hw_intr_state_q_i  ( reg2hw.intr_state.classb.q   ),</pre>
<pre>      .hw2reg_intr_state_de_o ( hw2reg.intr_state.classb.de  ),</pre>
<pre>      .hw2reg_intr_state_d_o  ( hw2reg.intr_state.classb.d   ),</pre>
<pre>      .intr_o                 ( irq_o[1]                     )</pre>
<pre>    prim_intr_hw #(</pre>
<pre>      .Width(1)</pre>
<pre style="background-color: #FF0000;">    ) i_irq_classc (</pre>
<pre>      .event_intr_i           ( hw2reg_wrap.class_trig[2]    ),</pre>
<pre>      .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.classc.q  ),</pre>
<pre>      .reg2hw_intr_test_q_i   ( reg2hw.intr_test.classc.q    ),</pre>
<pre>      .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.classc.qe   ),</pre>
<pre>      .reg2hw_intr_state_q_i  ( reg2hw.intr_state.classc.q   ),</pre>
<pre>      .hw2reg_intr_state_de_o ( hw2reg.intr_state.classc.de  ),</pre>
<pre>      .hw2reg_intr_state_d_o  ( hw2reg.intr_state.classc.d   ),</pre>
<pre>      .intr_o                 ( irq_o[2]                     )</pre>
<pre>    prim_intr_hw #(</pre>
<pre>      .Width(1)</pre>
<pre style="background-color: #FF0000;">    ) i_irq_classd (</pre>
<pre>      .event_intr_i           ( hw2reg_wrap.class_trig[3]    ),</pre>
<pre>      .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.classd.q  ),</pre>
<pre>      .reg2hw_intr_test_q_i   ( reg2hw.intr_test.classd.q    ),</pre>
<pre>      .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.classd.qe   ),</pre>
<pre>      .reg2hw_intr_state_q_i  ( reg2hw.intr_state.classd.q   ),</pre>
<pre>      .hw2reg_intr_state_de_o ( hw2reg.intr_state.classd.de  ),</pre>
<pre>      .hw2reg_intr_state_d_o  ( hw2reg.intr_state.classd.d   ),</pre>
<pre>      .intr_o                 ( irq_o[3]                     )</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0; k < NAlerts; k++) begin : gen_alert_cause</pre>
<pre style="background-color: #FF0000;">    assign hw2reg.alert_cause[k].d  = 1'b1;</pre>
<pre style="background-color: #FF0000;">    assign hw2reg.alert_cause[k].de = reg2hw.alert_cause[k].q |</pre>
<pre style="background-color: #FF0000;">                                      hw2reg_wrap.alert_cause[k];</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0; k < N_LOC_ALERT; k++) begin : gen_loc_alert_cause</pre>
<pre style="background-color: #FF0000;">    assign hw2reg.loc_alert_cause[k].d  = 1'b1;</pre>
<pre style="background-color: #FF0000;">    assign hw2reg.loc_alert_cause[k].de = reg2hw.loc_alert_cause[k].q |</pre>
<pre style="background-color: #FF0000;">                                          hw2reg_wrap.loc_alert_cause[k];</pre>
<pre>  assign { hw2reg.classd_clren.d,</pre>
<pre>           hw2reg.classc_clren.d,</pre>
<pre>           hw2reg.classb_clren.d,</pre>
<pre>           hw2reg.classa_clren.d } = '0;</pre>
<pre>  assign { hw2reg.classd_clren.de,</pre>
<pre>           hw2reg.classc_clren.de,</pre>
<pre>           hw2reg.classb_clren.de,</pre>
<pre>           hw2reg.classa_clren.de } = hw2reg_wrap.class_esc_trig    &</pre>
<pre>                                      class_autolock_en             &</pre>
<pre>                                      reg2hw_wrap.class_en;</pre>
<pre>  assign { hw2reg.classd_accum_cnt.d,</pre>
<pre>           hw2reg.classc_accum_cnt.d,</pre>
<pre>           hw2reg.classb_accum_cnt.d,</pre>
<pre>           hw2reg.classa_accum_cnt.d } = hw2reg_wrap.class_accum_cnt;</pre>
<pre>  assign { hw2reg.classd_esc_cnt.d,</pre>
<pre>           hw2reg.classc_esc_cnt.d,</pre>
<pre>           hw2reg.classb_esc_cnt.d,</pre>
<pre>           hw2reg.classa_esc_cnt.d } = hw2reg_wrap.class_esc_cnt;</pre>
<pre>  assign { hw2reg.classd_state.d,</pre>
<pre>           hw2reg.classc_state.d,</pre>
<pre>           hw2reg.classb_state.d,</pre>
<pre>           hw2reg.classa_state.d } = hw2reg_wrap.class_esc_state;</pre>
<pre>  assign reg2hw_wrap.config_locked = ~reg2hw.regen.q;</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0; k < NAlerts; k++) begin : gen_alert_en_class</pre>
<pre style="background-color: #FF0000;">    assign reg2hw_wrap.alert_en[k]    = reg2hw.alert_en[k].q;</pre>
<pre style="background-color: #FF0000;">    assign reg2hw_wrap.alert_class[k] = reg2hw.alert_class[k].q;</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0; k < N_LOC_ALERT; k++) begin : gen_loc_alert_en_class</pre>
<pre style="background-color: #FF0000;">    assign reg2hw_wrap.loc_alert_en[k]    = reg2hw.loc_alert_en[k].q;</pre>
<pre style="background-color: #FF0000;">    assign reg2hw_wrap.loc_alert_class[k] = reg2hw.loc_alert_class[k].q;</pre>
<pre>  assign reg2hw_wrap.ping_timeout_cyc = reg2hw.ping_timeout_cyc.q;</pre>
<pre>  assign reg2hw_wrap.class_en = { reg2hw.classd_ctrl.en,</pre>
<pre>                                  reg2hw.classc_ctrl.en,</pre>
<pre>                                  reg2hw.classb_ctrl.en,</pre>
<pre>                                  reg2hw.classa_ctrl.en };</pre>
<pre>  assign class_autolock_en = { reg2hw.classd_ctrl.lock,</pre>
<pre>                               reg2hw.classc_ctrl.lock,</pre>
<pre>                               reg2hw.classb_ctrl.lock,</pre>
<pre>                               reg2hw.classa_ctrl.lock };</pre>
<pre>  assign reg2hw_wrap.class_esc_en = { reg2hw.classd_ctrl.en_e3,</pre>
<pre>                                      reg2hw.classd_ctrl.en_e2,</pre>
<pre>                                      reg2hw.classd_ctrl.en_e1,</pre>
<pre>                                      reg2hw.classd_ctrl.en_e0,</pre>
<pre>                                      reg2hw.classc_ctrl.en_e3,</pre>
<pre>                                      reg2hw.classc_ctrl.en_e2,</pre>
<pre>                                      reg2hw.classc_ctrl.en_e1,</pre>
<pre>                                      reg2hw.classc_ctrl.en_e0,</pre>
<pre>                                      reg2hw.classb_ctrl.en_e3,</pre>
<pre>                                      reg2hw.classb_ctrl.en_e2,</pre>
<pre>                                      reg2hw.classb_ctrl.en_e1,</pre>
<pre>                                      reg2hw.classb_ctrl.en_e0,</pre>
<pre>                                      reg2hw.classa_ctrl.en_e3,</pre>
<pre>                                      reg2hw.classa_ctrl.en_e2,</pre>
<pre>                                      reg2hw.classa_ctrl.en_e1,</pre>
<pre>                                      reg2hw.classa_ctrl.en_e0 };</pre>
<pre>  assign reg2hw_wrap.class_esc_map = { reg2hw.classd_ctrl.map_e3,</pre>
<pre>                                       reg2hw.classd_ctrl.map_e2,</pre>
<pre>                                       reg2hw.classd_ctrl.map_e1,</pre>
<pre>                                       reg2hw.classd_ctrl.map_e0,</pre>
<pre>                                       reg2hw.classc_ctrl.map_e3,</pre>
<pre>                                       reg2hw.classc_ctrl.map_e2,</pre>
<pre>                                       reg2hw.classc_ctrl.map_e1,</pre>
<pre>                                       reg2hw.classc_ctrl.map_e0,</pre>
<pre>                                       reg2hw.classb_ctrl.map_e3,</pre>
<pre>                                       reg2hw.classb_ctrl.map_e2,</pre>
<pre>                                       reg2hw.classb_ctrl.map_e1,</pre>
<pre>                                       reg2hw.classb_ctrl.map_e0,</pre>
<pre>                                       reg2hw.classa_ctrl.map_e3,</pre>
<pre>                                       reg2hw.classa_ctrl.map_e2,</pre>
<pre>                                       reg2hw.classa_ctrl.map_e1,</pre>
<pre>                                       reg2hw.classa_ctrl.map_e0 };</pre>
<pre>  assign reg2hw_wrap.class_clr = { reg2hw.classd_clr.q & reg2hw.classd_clr.qe,</pre>
<pre>                                   reg2hw.classc_clr.q & reg2hw.classc_clr.qe,</pre>
<pre>                                   reg2hw.classb_clr.q & reg2hw.classb_clr.qe,</pre>
<pre>                                   reg2hw.classa_clr.q & reg2hw.classa_clr.qe };</pre>
<pre>  assign reg2hw_wrap.class_accum_thresh = { reg2hw.classd_accum_thresh.q,</pre>
<pre>                                            reg2hw.classc_accum_thresh.q,</pre>
<pre>                                            reg2hw.classb_accum_thresh.q,</pre>
<pre>                                            reg2hw.classa_accum_thresh.q };</pre>
<pre>  assign reg2hw_wrap.class_timeout_cyc = { reg2hw.classd_timeout_cyc.q,</pre>
<pre>                                           reg2hw.classc_timeout_cyc.q,</pre>
<pre>                                           reg2hw.classb_timeout_cyc.q,</pre>
<pre>                                           reg2hw.classa_timeout_cyc.q };</pre>
<pre>  assign reg2hw_wrap.class_phase_cyc = { reg2hw.classd_phase3_cyc.q,</pre>
<pre>                                         reg2hw.classd_phase2_cyc.q,</pre>
<pre>                                         reg2hw.classd_phase1_cyc.q,</pre>
<pre>                                         reg2hw.classd_phase0_cyc.q,</pre>
<pre>                                         reg2hw.classc_phase3_cyc.q,</pre>
<pre>                                         reg2hw.classc_phase2_cyc.q,</pre>
<pre>                                         reg2hw.classc_phase1_cyc.q,</pre>
<pre>                                         reg2hw.classc_phase0_cyc.q,</pre>
<pre>                                         reg2hw.classb_phase3_cyc.q,</pre>
<pre>                                         reg2hw.classb_phase2_cyc.q,</pre>
<pre>                                         reg2hw.classb_phase1_cyc.q,</pre>
<pre>                                         reg2hw.classb_phase0_cyc.q,</pre>
<pre>                                         reg2hw.classa_phase3_cyc.q,</pre>
<pre>                                         reg2hw.classa_phase2_cyc.q,</pre>
<pre>                                         reg2hw.classa_phase1_cyc.q,</pre>
<pre>                                         reg2hw.classa_phase0_cyc.q};</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0; k < NAlerts; k++) begin : gen_alert_cause_dump</pre>
<pre style="background-color: #FF0000;">    assign crashdump_o.alert_cause[k]  = reg2hw.alert_cause[k].q;</pre>
<pre style="background-color: #FF0000;">  for (genvar k = 0; k < N_LOC_ALERT; k++) begin : gen_loc_alert_cause_dump</pre>
<pre style="background-color: #FF0000;">    assign crashdump_o.loc_alert_cause[k]  = reg2hw.loc_alert_cause[k].q;</pre>
<pre>  assign crashdump_o.class_accum_cnt = hw2reg_wrap.class_accum_cnt;</pre>
<pre>  assign crashdump_o.class_esc_cnt   = hw2reg_wrap.class_esc_cnt;</pre>
<pre>  assign crashdump_o.class_esc_state = hw2reg_wrap.class_esc_state;</pre>
<pre style="background-color: #FF0000;">endmodule : alert_handler_reg_wrap</pre>
<h3>hw/ip/alert_handler/rtl/alert_handler_accu.sv</h3>
<pre>  input                        clk_i,</pre>
<pre>  input                        rst_ni,</pre>
<pre>  input                        class_en_i,   // class enable</pre>
<pre>  input                        clr_i,        // clear the accumulator</pre>
<pre>  input                        class_trig_i, // increments the accu</pre>
<pre>  input        [AccuCntDw-1:0] thresh_i,     // escalation trigger threshold</pre>
<pre>  output logic [AccuCntDw-1:0] accu_cnt_o,   // output of current accu value</pre>
<pre>  output logic                 accu_trig_o   // escalation trigger output</pre>
<pre>  logic trig_gated;</pre>
<pre>  logic [AccuCntDw-1:0] accu_d, accu_q;</pre>
<pre>  assign trig_gated = class_trig_i & class_en_i;</pre>
<pre>  assign accu_d = (clr_i)                    ? '0            : // clear</pre>
<pre>                  (trig_gated && !(&accu_q)) ? accu_q + 1'b1 : // saturate counter at maximum</pre>
<pre>                                               accu_q;</pre>
<pre>  assign accu_trig_o = (accu_q >= thresh_i) & trig_gated;</pre>
<pre>  assign accu_cnt_o = accu_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      accu_q <= '0;</pre>
<pre>    end else begin</pre>
<pre>      accu_q <= accu_d;</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>hw/ip/alert_handler/rtl/alert_pkg.sv</h3>
<pre>package alert_pkg;</pre>
<pre>  localparam int unsigned      NAlerts   = alert_handler_reg_pkg::NAlerts;   // maximum 252</pre>
<pre>  localparam int unsigned      EscCntDw  = alert_handler_reg_pkg::EscCntDw;  // maximum 32</pre>
<pre>  localparam int unsigned      AccuCntDw = alert_handler_reg_pkg::AccuCntDw; // maximum 32</pre>
<pre>  localparam logic [31:0]      LfsrSeed  = alert_handler_reg_pkg::LfsrSeed;</pre>
<pre>  localparam bit [NAlerts-1:0] AsyncOn   = alert_handler_reg_pkg::AsyncOn;</pre>
<pre>  localparam int unsigned N_CLASSES   = alert_handler_reg_pkg::N_CLASSES;</pre>
<pre>  localparam int unsigned N_ESC_SEV   = alert_handler_reg_pkg::N_ESC_SEV;</pre>
<pre>  localparam int unsigned N_PHASES    = alert_handler_reg_pkg::N_PHASES;</pre>
<pre>  localparam int unsigned N_LOC_ALERT = alert_handler_reg_pkg::N_LOC_ALERT;</pre>
<pre>  localparam int unsigned PING_CNT_DW = alert_handler_reg_pkg::PING_CNT_DW;</pre>
<pre>  localparam int unsigned PHASE_DW    = alert_handler_reg_pkg::PHASE_DW;</pre>
<pre>  localparam int unsigned CLASS_DW    = alert_handler_reg_pkg::CLASS_DW;</pre>
<pre>  typedef enum logic [2:0] {Idle = 3'b000, Timeout = 3'b001, Terminal = 3'b011,</pre>
<pre>                            Phase0 = 3'b100, Phase1 = 3'b101, Phase2 = 3'b110,</pre>
<pre>                            Phase3 = 3'b111} cstate_e;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic    [NAlerts-1:0]                  alert_cause;     // alert cause bits</pre>
<pre>    logic    [N_LOC_ALERT-1:0]              loc_alert_cause; // local alert cause bits</pre>
<pre>    logic    [N_CLASSES-1:0][AccuCntDw-1:0] class_accum_cnt; // current accumulator value</pre>
<pre>    logic    [N_CLASSES-1:0][EscCntDw-1:0]  class_esc_cnt;   // current escalation counter value</pre>
<pre>    cstate_e [N_CLASSES-1:0]                class_esc_state; // current escalation protocol state</pre>
<pre style="background-color: #FF0000;">  } alert_crashdump_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic    [NAlerts-1:0]                  alert_cause;     // alert cause bits</pre>
<pre>    logic    [N_LOC_ALERT-1:0]              loc_alert_cause; // local alert cause bits</pre>
<pre>    logic    [N_CLASSES-1:0]                class_trig;      // class trigger</pre>
<pre>    logic    [N_CLASSES-1:0]                class_esc_trig;  // escalation trigger</pre>
<pre>    logic    [N_CLASSES-1:0][AccuCntDw-1:0] class_accum_cnt; // current accumulator value</pre>
<pre>    logic    [N_CLASSES-1:0][EscCntDw-1:0]  class_esc_cnt;   // current escalation counter value</pre>
<pre>    cstate_e [N_CLASSES-1:0]                class_esc_state; // current escalation protocol state</pre>
<pre style="background-color: #FF0000;">  } hw2reg_wrap_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic                                              config_locked;      // locked -> ping enabled</pre>
<pre>    logic [PING_CNT_DW-1:0]                            ping_timeout_cyc;   // ping timeout config</pre>
<pre>    logic [N_LOC_ALERT-1:0]                            loc_alert_en;       // alert enable</pre>
<pre>    logic [N_LOC_ALERT-1:0][CLASS_DW-1:0]              loc_alert_class;    // alert class config</pre>
<pre>    logic [NAlerts-1:0]                                alert_en;           // alert enable</pre>
<pre>    logic [NAlerts-1:0][CLASS_DW-1:0]                  alert_class;        // alert class config</pre>
<pre>    logic [N_CLASSES-1:0]                              class_en;           // enables esc mechanisms</pre>
<pre>    logic [N_CLASSES-1:0]                              class_clr;          // clears esc/accu</pre>
<pre>    logic [N_CLASSES-1:0][AccuCntDw-1:0]               class_accum_thresh; // accum esc threshold</pre>
<pre>    logic [N_CLASSES-1:0][EscCntDw-1:0]                class_timeout_cyc;  // interrupt timeout</pre>
<pre>    logic [N_CLASSES-1:0][N_PHASES-1:0][EscCntDw-1:0]  class_phase_cyc;    // length of phases 0..3</pre>
<pre>    logic [N_CLASSES-1:0][N_ESC_SEV-1:0]               class_esc_en;       // esc signal enables</pre>
<pre>    logic [N_CLASSES-1:0][N_ESC_SEV-1:0][PHASE_DW-1:0] class_esc_map;      // esc signal/phase map</pre>
<pre style="background-color: #FF0000;">  } reg2hw_wrap_t;</pre>
<pre style="background-color: #FF0000;">endpackage : alert_pkg</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv</h3>
<pre>module ibex_ex_block #(</pre>
<pre>    parameter bit    RV32M                    = 1,</pre>
<pre>    parameter        MultiplierImplementation = "fast"</pre>
<pre>    input  logic              clk_i,</pre>
<pre>    input  logic              rst_ni,</pre>
<pre>    input  ibex_pkg::alu_op_e alu_operator_i,</pre>
<pre>    input  logic [31:0]       alu_operand_a_i,</pre>
<pre>    input  logic [31:0]       alu_operand_b_i,</pre>
<pre>    input  ibex_pkg::md_op_e  multdiv_operator_i,</pre>
<pre>    input  logic              mult_en_i,</pre>
<pre>    input  logic              div_en_i,</pre>
<pre>    input  logic  [1:0]       multdiv_signed_mode_i,</pre>
<pre>    input  logic [31:0]       multdiv_operand_a_i,</pre>
<pre>    input  logic [31:0]       multdiv_operand_b_i,</pre>
<pre>    output logic [31:0]       alu_adder_result_ex_o, // to LSU</pre>
<pre>    output logic [31:0]       regfile_wdata_ex_o,</pre>
<pre>    output logic [31:0]       jump_target_o,         // to IF</pre>
<pre>    output logic              branch_decision_o,     // to ID</pre>
<pre>    output logic              ex_valid_o             // EX has valid output</pre>
<pre>  logic [31:0] alu_result, multdiv_result;</pre>
<pre>  logic [32:0] multdiv_alu_operand_b, multdiv_alu_operand_a;</pre>
<pre>  logic [33:0] alu_adder_result_ext;</pre>
<pre>  logic        alu_cmp_result, alu_is_equal_result;</pre>
<pre>  logic        multdiv_valid, multdiv_en_sel;</pre>
<pre>  logic        multdiv_en;</pre>
<pre>  if (RV32M) begin : gen_multdiv_m</pre>
<pre>    assign multdiv_en_sel = MultiplierImplementation == "fast" ? div_en_i : mult_en_i | div_en_i;</pre>
<pre>    assign multdiv_en     = mult_en_i | div_en_i;</pre>
<pre style="background-color: #FF0000;">  end else begin : gen_multdiv_no_m</pre>
<pre style="background-color: #FF0000;">    assign multdiv_en_sel = 1'b0;</pre>
<pre style="background-color: #FF0000;">    assign multdiv_en     = 1'b0;</pre>
<pre>  assign regfile_wdata_ex_o = multdiv_en ? multdiv_result : alu_result;</pre>
<pre>  assign branch_decision_o  = alu_cmp_result;</pre>
<pre>  assign jump_target_o      = alu_adder_result_ex_o;</pre>
<pre>  ibex_alu alu_i (</pre>
<pre>      .operator_i          ( alu_operator_i            ),</pre>
<pre>      .operand_a_i         ( alu_operand_a_i           ),</pre>
<pre>      .operand_b_i         ( alu_operand_b_i           ),</pre>
<pre>      .multdiv_operand_a_i ( multdiv_alu_operand_a     ),</pre>
<pre>      .multdiv_operand_b_i ( multdiv_alu_operand_b     ),</pre>
<pre>      .multdiv_en_i        ( multdiv_en_sel            ),</pre>
<pre>      .adder_result_o      ( alu_adder_result_ex_o     ),</pre>
<pre>      .adder_result_ext_o  ( alu_adder_result_ext      ),</pre>
<pre>      .result_o            ( alu_result                ),</pre>
<pre>      .comparison_result_o ( alu_cmp_result            ),</pre>
<pre>      .is_equal_result_o   ( alu_is_equal_result       )</pre>
<pre style="background-color: #FF0000;">  if (MultiplierImplementation == "slow") begin : gen_multdiv_slow</pre>
<pre style="background-color: #FF0000;">    ibex_multdiv_slow multdiv_i (</pre>
<pre style="background-color: #FF0000;">        .clk_i              ( clk_i                 ),</pre>
<pre style="background-color: #FF0000;">        .rst_ni             ( rst_ni                ),</pre>
<pre style="background-color: #FF0000;">        .mult_en_i          ( mult_en_i             ),</pre>
<pre style="background-color: #FF0000;">        .div_en_i           ( div_en_i              ),</pre>
<pre style="background-color: #FF0000;">        .operator_i         ( multdiv_operator_i    ),</pre>
<pre style="background-color: #FF0000;">        .signed_mode_i      ( multdiv_signed_mode_i ),</pre>
<pre style="background-color: #FF0000;">        .op_a_i             ( multdiv_operand_a_i   ),</pre>
<pre style="background-color: #FF0000;">        .op_b_i             ( multdiv_operand_b_i   ),</pre>
<pre style="background-color: #FF0000;">        .alu_adder_ext_i    ( alu_adder_result_ext  ),</pre>
<pre style="background-color: #FF0000;">        .alu_adder_i        ( alu_adder_result_ex_o ),</pre>
<pre style="background-color: #FF0000;">        .equal_to_zero      ( alu_is_equal_result   ),</pre>
<pre style="background-color: #FF0000;">        .valid_o            ( multdiv_valid         ),</pre>
<pre style="background-color: #FF0000;">        .alu_operand_a_o    ( multdiv_alu_operand_a ),</pre>
<pre style="background-color: #FF0000;">        .alu_operand_b_o    ( multdiv_alu_operand_b ),</pre>
<pre style="background-color: #FF0000;">        .multdiv_result_o   ( multdiv_result        )</pre>
<pre style="background-color: #FF0000;">  end else if (MultiplierImplementation == "fast") begin : gen_multdiv_fast</pre>
<pre>    ibex_multdiv_fast multdiv_i (</pre>
<pre>        .clk_i              ( clk_i                 ),</pre>
<pre>        .rst_ni             ( rst_ni                ),</pre>
<pre>        .mult_en_i          ( mult_en_i             ),</pre>
<pre>        .div_en_i           ( div_en_i              ),</pre>
<pre>        .operator_i         ( multdiv_operator_i    ),</pre>
<pre>        .signed_mode_i      ( multdiv_signed_mode_i ),</pre>
<pre>        .op_a_i             ( multdiv_operand_a_i   ),</pre>
<pre>        .op_b_i             ( multdiv_operand_b_i   ),</pre>
<pre>        .alu_operand_a_o    ( multdiv_alu_operand_a ),</pre>
<pre>        .alu_operand_b_o    ( multdiv_alu_operand_b ),</pre>
<pre>        .alu_adder_ext_i    ( alu_adder_result_ext  ),</pre>
<pre>        .alu_adder_i        ( alu_adder_result_ex_o ),</pre>
<pre>        .equal_to_zero      ( alu_is_equal_result   ),</pre>
<pre>        .valid_o            ( multdiv_valid         ),</pre>
<pre>        .multdiv_result_o   ( multdiv_result        )</pre>
<pre>  assign ex_valid_o = multdiv_en ? multdiv_valid : 1'b1;</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_compressed_decoder.sv</h3>
<pre>    input  logic        clk_i,</pre>
<pre>    input  logic        rst_ni,</pre>
<pre>    input  logic        valid_i,</pre>
<pre>    input  logic [31:0] instr_i,</pre>
<pre>    output logic [31:0] instr_o,</pre>
<pre>    output logic        is_compressed_o,</pre>
<pre>    output logic        illegal_instr_o</pre>
<pre>  logic unused_valid;</pre>
<pre>  assign unused_valid = valid_i;</pre>
<pre>  always_comb begin</pre>
<pre>    instr_o         = instr_i;</pre>
<pre>    illegal_instr_o = 1'b0;</pre>
<pre>    unique case (instr_i[1:0])</pre>
<pre>      2'b00: begin</pre>
<pre>        unique case (instr_i[15:13])</pre>
<pre>          3'b000: begin</pre>
<pre>            instr_o = {2'b0, instr_i[10:7], instr_i[12:11], instr_i[5],</pre>
<pre>                       instr_i[6], 2'b00, 5'h02, 3'b000, 2'b01, instr_i[4:2], {OPCODE_OP_IMM}};</pre>
<pre>            if (instr_i[12:5] == 8'b0)  illegal_instr_o = 1'b1;</pre>
<pre>          3'b010: begin</pre>
<pre>            instr_o = {5'b0, instr_i[5], instr_i[12:10], instr_i[6],</pre>
<pre>                       2'b00, 2'b01, instr_i[9:7], 3'b010, 2'b01, instr_i[4:2], {OPCODE_LOAD}};</pre>
<pre>          3'b110: begin</pre>
<pre>            instr_o = {5'b0, instr_i[5], instr_i[12], 2'b01, instr_i[4:2],</pre>
<pre>                       2'b01, instr_i[9:7], 3'b010, instr_i[11:10], instr_i[6],</pre>
<pre>                       2'b00, {OPCODE_STORE}};</pre>
<pre>          3'b001,</pre>
<pre>          3'b011,</pre>
<pre>          3'b100,</pre>
<pre>          3'b101,</pre>
<pre>          3'b111: begin</pre>
<pre>            illegal_instr_o = 1'b1;</pre>
<pre>          default: begin</pre>
<pre>            illegal_instr_o = 1'b1;</pre>
<pre>      2'b01: begin</pre>
<pre>        unique case (instr_i[15:13])</pre>
<pre>          3'b000: begin</pre>
<pre>            instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2],</pre>
<pre>                       instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP_IMM}};</pre>
<pre>          3'b001, 3'b101: begin</pre>
<pre>            instr_o = {instr_i[12], instr_i[8], instr_i[10:9], instr_i[6],</pre>
<pre>                       instr_i[7], instr_i[2], instr_i[11], instr_i[5:3],</pre>
<pre>                       {9 {instr_i[12]}}, 4'b0, ~instr_i[15], {OPCODE_JAL}};</pre>
<pre>          3'b010: begin</pre>
<pre>            instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0,</pre>
<pre>                       3'b0, instr_i[11:7], {OPCODE_OP_IMM}};</pre>
<pre>          3'b011: begin</pre>
<pre>            instr_o = {{15 {instr_i[12]}}, instr_i[6:2], instr_i[11:7], {OPCODE_LUI}};</pre>
<pre>            if (instr_i[11:7] == 5'h02) begin</pre>
<pre>              instr_o = {{3 {instr_i[12]}}, instr_i[4:3], instr_i[5], instr_i[2],</pre>
<pre>                         instr_i[6], 4'b0, 5'h02, 3'b000, 5'h02, {OPCODE_OP_IMM}};</pre>
<pre>            if ({instr_i[12], instr_i[6:2]} == 6'b0) illegal_instr_o = 1'b1;</pre>
<pre>          3'b100: begin</pre>
<pre>            unique case (instr_i[11:10])</pre>
<pre>              2'b00,</pre>
<pre>              2'b01: begin</pre>
<pre>                instr_o = {1'b0, instr_i[10], 5'b0, instr_i[6:2], 2'b01, instr_i[9:7],</pre>
<pre>                           3'b101, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};</pre>
<pre>                if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1;</pre>
<pre>              2'b10: begin</pre>
<pre>                instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 2'b01, instr_i[9:7],</pre>
<pre>                           3'b111, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};</pre>
<pre>              2'b11: begin</pre>
<pre>                unique case ({instr_i[12], instr_i[6:5]})</pre>
<pre>                  3'b000: begin</pre>
<pre>                    instr_o = {2'b01, 5'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7],</pre>
<pre>                               3'b000, 2'b01, instr_i[9:7], {OPCODE_OP}};</pre>
<pre>                  3'b001: begin</pre>
<pre>                    instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b100,</pre>
<pre>                               2'b01, instr_i[9:7], {OPCODE_OP}};</pre>
<pre>                  3'b010: begin</pre>
<pre>                    instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b110,</pre>
<pre>                               2'b01, instr_i[9:7], {OPCODE_OP}};</pre>
<pre>                  3'b011: begin</pre>
<pre>                    instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b111,</pre>
<pre>                               2'b01, instr_i[9:7], {OPCODE_OP}};</pre>
<pre>                  3'b100,</pre>
<pre>                  3'b101,</pre>
<pre>                  3'b110,</pre>
<pre>                  3'b111: begin</pre>
<pre>                    illegal_instr_o = 1'b1;</pre>
<pre>                  default: begin</pre>
<pre>                    illegal_instr_o = 1'b1;</pre>
<pre>              default: begin</pre>
<pre>                illegal_instr_o = 1'b1;</pre>
<pre>          3'b110, 3'b111: begin</pre>
<pre>            instr_o = {{4 {instr_i[12]}}, instr_i[6:5], instr_i[2], 5'b0, 2'b01,</pre>
<pre>                       instr_i[9:7], 2'b00, instr_i[13], instr_i[11:10], instr_i[4:3],</pre>
<pre>                       instr_i[12], {OPCODE_BRANCH}};</pre>
<pre>          default: begin</pre>
<pre>            illegal_instr_o = 1'b1;</pre>
<pre>      2'b10: begin</pre>
<pre>        unique case (instr_i[15:13])</pre>
<pre>          3'b000: begin</pre>
<pre>            instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], {OPCODE_OP_IMM}};</pre>
<pre>            if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1; // reserved for custom extensions</pre>
<pre>          3'b010: begin</pre>
<pre>            instr_o = {4'b0, instr_i[3:2], instr_i[12], instr_i[6:4], 2'b00, 5'h02,</pre>
<pre>                       3'b010, instr_i[11:7], OPCODE_LOAD};</pre>
<pre>            if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;</pre>
<pre>          3'b100: begin</pre>
<pre>            if (instr_i[12] == 1'b0) begin</pre>
<pre>              if (instr_i[6:2] != 5'b0) begin</pre>
<pre>                instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], {OPCODE_OP}};</pre>
<pre>              end else begin</pre>
<pre>                instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, {OPCODE_JALR}};</pre>
<pre>                if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;</pre>
<pre>            end else begin</pre>
<pre>              if (instr_i[6:2] != 5'b0) begin</pre>
<pre>                instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP}};</pre>
<pre>              end else begin</pre>
<pre>                if (instr_i[11:7] == 5'b0) begin</pre>
<pre>                  instr_o = {32'h00_10_00_73};</pre>
<pre>                end else begin</pre>
<pre>                  instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, {OPCODE_JALR}};</pre>
<pre>          3'b110: begin</pre>
<pre>            instr_o = {4'b0, instr_i[8:7], instr_i[12], instr_i[6:2], 5'h02, 3'b010,</pre>
<pre>                       instr_i[11:9], 2'b00, {OPCODE_STORE}};</pre>
<pre>          3'b001,</pre>
<pre>          3'b011,</pre>
<pre>          3'b101,</pre>
<pre>          3'b111: begin</pre>
<pre>            illegal_instr_o = 1'b1;</pre>
<pre>          default: begin</pre>
<pre>            illegal_instr_o = 1'b1;</pre>
<pre>      2'b11:;</pre>
<pre>      default: begin</pre>
<pre>        illegal_instr_o = 1'b1;</pre>
<pre>  assign is_compressed_o = (instr_i[1:0] != 2'b11);</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv</h3>
<pre> */</pre>
<pre>module ibex_multdiv_fast (</pre>
<pre>    input  logic             clk_i,</pre>
<pre>    input  logic             rst_ni,</pre>
<pre>    input  logic             mult_en_i,</pre>
<pre>    input  logic             div_en_i,</pre>
<pre>    input  ibex_pkg::md_op_e operator_i,</pre>
<pre>    input  logic  [1:0]      signed_mode_i,</pre>
<pre>    input  logic [31:0]      op_a_i,</pre>
<pre>    input  logic [31:0]      op_b_i,</pre>
<pre>    input  logic [33:0]      alu_adder_ext_i,</pre>
<pre>    input  logic             equal_to_zero,</pre>
<pre></pre>
<pre>    output logic [32:0]      alu_operand_b_o,</pre>
<pre></pre>
<pre>  import ibex_pkg::*;</pre>
<pre></pre>
<pre>  logic [ 4:0] div_counter_q, div_counter_n;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    ALBL, ALBH, AHBL, AHBH</pre>
<pre>  mult_fsm_e mult_state_q, mult_state_n;</pre>
<pre></pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    MD_IDLE, MD_ABS_A, MD_ABS_B, MD_COMP, MD_LAST, MD_CHANGE_SIGN, MD_FINISH</pre>
<pre>  md_fsm_e md_state_q, md_state_n;</pre>
<pre></pre>
<pre>  logic        [34:0] mac_res_ext;</pre>
<pre></pre>
<pre>  logic [33:0] mac_res_q, mac_res_n, mac_res, op_remainder_n;</pre>
<pre>  logic [15:0] mult_op_a;</pre>
<pre>  logic [15:0] mult_op_b;</pre>
<pre>  logic [33:0] accum;</pre>
<pre>  logic        sign_a, sign_b;</pre>
<pre>  logic        div_sign_a, div_sign_b;</pre>
<pre>  logic        signed_mult;</pre>
<pre>  logic        is_greater_equal;</pre>
<pre>  logic        div_change_sign, rem_change_sign;</pre>
<pre>  logic [31:0] one_shift;</pre>
<pre>  logic [31:0] op_denominator_q;</pre>
<pre>  logic [31:0] op_numerator_q;</pre>
<pre>  logic [31:0] op_quotient_q;</pre>
<pre>  logic [31:0] op_denominator_n;</pre>
<pre>  logic [31:0] op_numerator_n;</pre>
<pre>  logic [31:0] op_quotient_n;</pre>
<pre>  logic [31:0] next_remainder;</pre>
<pre>  logic [32:0] next_quotient;</pre>
<pre>  logic [32:0] res_adder_h;</pre>
<pre>  logic        div_valid;</pre>
<pre></pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_mult_state_q</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      mult_state_q     <= ALBL;</pre>
<pre>      mac_res_q        <= '0;</pre>
<pre>      div_counter_q    <= '0;</pre>
<pre>      md_state_q       <= MD_IDLE;</pre>
<pre>      op_denominator_q <= '0;</pre>
<pre>      op_numerator_q   <= '0;</pre>
<pre>    end else begin</pre>
<pre></pre>
<pre>      end</pre>
<pre></pre>
<pre>      if (div_en_i) begin</pre>
<pre>        div_counter_q    <= div_counter_n;</pre>
<pre>        op_denominator_q <= op_denominator_n;</pre>
<pre>        op_numerator_q   <= op_numerator_n;</pre>
<pre>      end</pre>
<pre></pre>
<pre>      unique case(1'b1)</pre>
<pre>        mult_en_i:</pre>
<pre>          mac_res_q <= mac_res_n;</pre>
<pre>        div_en_i:</pre>
<pre>          mac_res_q <= op_remainder_n;</pre>
<pre>  end</pre>
<pre>  assign signed_mult      = (signed_mode_i != 2'b00);</pre>
<pre>  // 2. The 16 MSBs of the addend (accum[33:18]) are always equal.</pre>
<pre>  // Thus, it is safe to ignore mac_res_ext[34].</pre>
<pre>  assign mac_res_signed =</pre>
<pre>      $signed({sign_a, mult_op_a}) * $signed({sign_b, mult_op_b}) + $signed(accum);</pre>
<pre>  assign mac_res        = mac_res_ext[33:0];</pre>
<pre>  assign res_adder_h    = alu_adder_ext_i[33:1];</pre>
<pre></pre>
<pre>  assign next_remainder = is_greater_equal ? res_adder_h[31:0] : mac_res_q[31:0];</pre>
<pre>                                             {1'b0,op_quotient_q};</pre>
<pre>  // Remainder - Divisor. If Remainder - Divisor >= 0, is_greater_equal is equal to 1,</pre>
<pre>  // the next Remainder is Remainder - Divisor contained in res_adder_h and the</pre>
<pre>  always_comb begin</pre>
<pre>    if ((mac_res_q[31] ^ op_denominator_q[31]) == 1'b0) begin</pre>
<pre>      is_greater_equal = (res_adder_h[31] == 1'b0);</pre>
<pre>  end</pre>
<pre></pre>
<pre>  assign div_sign_a      = op_a_i[31] & signed_mode_i[0];</pre>
<pre>  assign div_sign_b      = op_b_i[31] & signed_mode_i[1];</pre>
<pre></pre>
<pre></pre>
<pre>  always_comb begin : md_fsm</pre>
<pre>    div_counter_n    = div_counter_q - 5'h1;</pre>
<pre>    op_remainder_n   = mac_res_q;</pre>
<pre>    op_quotient_n    = op_quotient_q;</pre>
<pre>    md_state_n       = md_state_q;</pre>
<pre>    op_numerator_n   = op_numerator_q;</pre>
<pre>    op_denominator_n = op_denominator_q;</pre>
<pre>    alu_operand_a_o  = {32'h0  , 1'b1};</pre>
<pre>    div_valid        = 1'b0;</pre>
<pre></pre>
<pre>    unique case(md_state_q)</pre>
<pre>          // Check if the Denominator is 0</pre>
<pre>          // quotient for division by 0</pre>
<pre>          op_remainder_n = '1;</pre>
<pre>          // Check if the Denominator is 0</pre>
<pre>          // remainder for division by 0</pre>
<pre>        end</pre>
<pre>        // 0 - B = 0 iff B == 0</pre>
<pre>        alu_operand_a_o  = {32'h0  , 1'b1};</pre>
<pre>      end</pre>
<pre>      MD_ABS_A: begin</pre>
<pre>        op_quotient_n   = '0;</pre>
<pre>        // A abs value</pre>
<pre>        op_numerator_n  = div_sign_a ? alu_adder_i : op_a_i;</pre>
<pre>        div_counter_n   = 5'd31;</pre>
<pre>        // ABS(A) = 0 - A</pre>
<pre>      end</pre>
<pre>      MD_ABS_B: begin</pre>
<pre>        op_remainder_n   = { 33'h0, op_numerator_q[31]};</pre>
<pre>        // B abs value</pre>
<pre>        op_denominator_n = div_sign_b ? alu_adder_i : op_b_i;</pre>
<pre>        div_counter_n    = 5'd31;</pre>
<pre>        // ABS(B) = 0 - B</pre>
<pre>      end</pre>
<pre></pre>
<pre>      MD_COMP: begin</pre>
<pre>        op_remainder_n  = {1'b0, next_remainder[31:0], op_numerator_q[div_counter_n]};</pre>
<pre>        md_state_n      = (div_counter_q == 5'd1) ? MD_LAST : MD_COMP;</pre>
<pre>        // Division</pre>
<pre>      end</pre>
<pre></pre>
<pre>          // this time we save the quotient in op_remainder_n (i.e. mac_res_q) since</pre>
<pre>          // we do not need anymore the remainder</pre>
<pre>        end else begin</pre>
<pre>        end</pre>
<pre>        // Division</pre>
<pre>        alu_operand_b_o  = {~op_denominator_q[31:0], 1'b1}; // -denominator two's compliment</pre>
<pre>      end</pre>
<pre></pre>
<pre>      MD_CHANGE_SIGN: begin</pre>
<pre>        md_state_n  = MD_FINISH;</pre>
<pre>        if (operator_i == MD_OP_DIV) begin</pre>
<pre>          op_remainder_n = (div_change_sign) ? {2'h0,alu_adder_i} : mac_res_q;</pre>
<pre>        end</pre>
<pre>        // ABS(Quotient) = 0 - Quotient (or Remainder)</pre>
<pre>      end</pre>
<pre></pre>
<pre>      MD_FINISH: begin</pre>
<pre>      end</pre>
<pre></pre>
<pre>  end</pre>
<pre>    mult_op_a    = op_a_i[`OP_L];</pre>
<pre>    mult_op_b    = op_b_i[`OP_L];</pre>
<pre>    sign_a       = 1'b0;</pre>
<pre>    sign_b       = 1'b0;</pre>
<pre>    accum        = mac_res_q;</pre>
<pre>    mac_res_n    = mac_res;</pre>
<pre>    mult_state_n = mult_state_q;</pre>
<pre>    mult_valid   = 1'b0;</pre>
<pre></pre>
<pre></pre>
<pre>        // al*bl</pre>
<pre>        mult_op_b = op_b_i[`OP_L];</pre>
<pre>        sign_a    = 1'b0;</pre>
<pre>        sign_b    = 1'b0;</pre>
<pre>        accum     = '0;</pre>
<pre>        mac_res_n = mac_res;</pre>
<pre>        mult_state_n = ALBH;</pre>
<pre>      end</pre>
<pre>        // al*bh<<16</pre>
<pre>        mult_op_b = op_b_i[`OP_H];</pre>
<pre>        sign_a    = 1'b0;</pre>
<pre>        sign_b    = signed_mode_i[1] & op_b_i[31];</pre>
<pre>        // result of AL*BL (in mac_res_q) always unsigned with no carry, so carries_q always 00</pre>
<pre>        if (operator_i == MD_OP_MULL) begin</pre>
<pre>          mac_res_n = {2'b0,mac_res[`OP_L],mac_res_q[`OP_L]};</pre>
<pre>        end else begin</pre>
<pre>          // MD_OP_MULH</pre>
<pre>        end</pre>
<pre>      end</pre>
<pre>        // ah*bl<<16</pre>
<pre>        mult_op_b = op_b_i[`OP_L];</pre>
<pre>        sign_a    = signed_mode_i[0] & op_a_i[31];</pre>
<pre>        sign_b    = 1'b0;</pre>
<pre>        if (operator_i == MD_OP_MULL) begin</pre>
<pre>          accum        = {18'b0,mac_res_q[31:16]};</pre>
<pre>          mac_res_n    = {2'b0,mac_res[15:0],mac_res_q[15:0]};</pre>
<pre>          mult_valid   = 1'b1;</pre>
<pre>          mult_state_n = ALBL;</pre>
<pre>        end else begin</pre>
<pre>          accum        = mac_res_q;</pre>
<pre>          mac_res_n    = mac_res;</pre>
<pre>          mult_state_n = AHBH;</pre>
<pre>        end</pre>
<pre>        // only MD_OP_MULH here</pre>
<pre>        mult_op_b = op_b_i[`OP_H];</pre>
<pre>        sign_a    = signed_mode_i[0] & op_a_i[31];</pre>
<pre>        sign_b    = signed_mode_i[1] & op_b_i[31];</pre>
<pre>        accum[17: 0]  = mac_res_q[33:16];</pre>
<pre>        accum[33:18]  = {16{signed_mult & mac_res_q[33]}};</pre>
<pre>        // result of AH*BL is not signed only if signed_mode_i == 2'b00</pre>
<pre>        mult_state_n = ALBL;</pre>
<pre>        mult_valid   = 1'b1;</pre>
<pre>      end</pre>
<pre>        mult_state_n = ALBL;</pre>
<pre>      end</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_decoder.sv</h3>
<pre> * This module is fully combinatorial, clock and reset are used for</pre>
<pre> * assertions only.</pre>
<pre> */</pre>
<pre>    parameter bit RV32E = 0,</pre>
<pre>    parameter bit RV32M = 1</pre>
<pre>    input  logic                 rst_ni,</pre>
<pre></pre>
<pre>    // to/from controller</pre>
<pre>    output logic                 ebrk_insn_o,           // trap instr encountered</pre>
<pre>    output logic                 mret_insn_o,           // return from exception instr</pre>
<pre>                                                        // encountered</pre>
<pre>    output logic                 dret_insn_o,           // return from debug instr encountered</pre>
<pre>    output logic                 jump_set_o,            // jump taken set signal</pre>
<pre></pre>
<pre>    // from IF-ID pipeline register</pre>
<pre>    input  logic                 illegal_c_insn_i,      // compressed instruction decode failed</pre>
<pre></pre>
<pre>    // immediates</pre>
<pre>    output ibex_pkg::imm_a_sel_e imm_a_mux_sel_o,       // immediate selection for operand a</pre>
<pre>    output ibex_pkg::imm_b_sel_e imm_b_mux_sel_o,       // immediate selection for operand b</pre>
<pre>    output logic [31:0]          imm_i_type_o,</pre>
<pre>    output logic [31:0]          imm_s_type_o,</pre>
<pre>    output logic [31:0]          imm_b_type_o,</pre>
<pre>    output logic [31:0]          zimm_rs1_type_o,</pre>
<pre></pre>
<pre>    // register file</pre>
<pre>    output ibex_pkg::rf_wd_sel_e regfile_wdata_sel_o,   // RF write data selection</pre>
<pre>    output logic                 regfile_we_o,          // write enable for regfile</pre>
<pre>    output logic [4:0]           regfile_waddr_o,</pre>
<pre></pre>
<pre>    output ibex_pkg::alu_op_e    alu_operator_o,        // ALU operation selection</pre>
<pre>                                                        // immediate</pre>
<pre></pre>
<pre>    output logic                 mult_en_o,             // perform integer multiplication</pre>
<pre>    output logic                 div_en_o,              // perform integer division or</pre>
<pre>    output logic [1:0]           multdiv_signed_mode_o,</pre>
<pre></pre>
<pre>    // CSRs</pre>
<pre>    output logic                 csr_pipe_flush_o,      // CSR-related pipeline flush</pre>
<pre></pre>
<pre>    // LSU</pre>
<pre>    output logic                 data_we_o,             // write enable</pre>
<pre>                                                        // memory</pre>
<pre></pre>
<pre></pre>
<pre>  import ibex_pkg::*;</pre>
<pre></pre>
<pre>  logic        illegal_insn;</pre>
<pre>  logic        csr_illegal;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>  //////////////////////////////////////</pre>
<pre></pre>
<pre>  // immediate extraction and sign extension</pre>
<pre>  assign imm_i_type_o = { {20{instr[31]}}, instr[31:20] };</pre>
<pre>  assign imm_s_type_o = { {20{instr[31]}}, instr[31:25], instr[11:7] };</pre>
<pre></pre>
<pre>  assign regfile_raddr_b_o = instr[`REG_S2]; // rs2</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;">    assign illegal_reg_rv32e = ((regfile_raddr_a_o[4] & (alu_op_a_mux_sel_o == OP_A_REG_A)) |</pre>
<pre style="background-color: #FF0000;">                                (regfile_raddr_b_o[4] & (alu_op_b_mux_sel_o == OP_B_REG_B)) |</pre>
<pre style="background-color: #FF0000;">                                (regfile_waddr_o[4]   & regfile_we));</pre>
<pre style="background-color: #FF0000;">  end else begin : gen_rv32e_reg_check_inactive</pre>
<pre>    assign illegal_reg_rv32e = 1'b0;</pre>
<pre>  end</pre>
<pre>    csr_op_o = csr_op;</pre>
<pre></pre>
<pre>        instr[`REG_S1] == '0) begin</pre>
<pre>      csr_op_o = CSR_OP_READ;</pre>
<pre>    end</pre>
<pre>    csr_pipe_flush_o = 1'b0;</pre>
<pre></pre>
<pre>      if (csr_num_e'(instr[31:20]) == CSR_MSTATUS   ||</pre>
<pre>          csr_num_e'(instr[31:20]) == CSR_MIE) begin</pre>
<pre>        csr_pipe_flush_o = 1'b1;</pre>
<pre>      end</pre>
<pre>      if (csr_num_e'(instr[31:20]) == CSR_DCSR      ||</pre>
<pre>          csr_num_e'(instr[31:20]) == CSR_DPC       ||</pre>
<pre>          csr_num_e'(instr[31:20]) == CSR_DSCRATCH0 ||</pre>
<pre>          csr_num_e'(instr[31:20]) == CSR_DSCRATCH1) begin</pre>
<pre>        csr_pipe_flush_o = 1'b1;</pre>
<pre>      end</pre>
<pre>    jump_in_dec_o               = 1'b0;</pre>
<pre>    jump_set_o                  = 1'b0;</pre>
<pre>    branch_in_dec_o             = 1'b0;</pre>
<pre>    alu_operator_o              = ALU_SLTU;</pre>
<pre>    alu_op_a_mux_sel_o          = OP_A_IMM;</pre>
<pre>    alu_op_b_mux_sel_o          = OP_B_IMM;</pre>
<pre></pre>
<pre>    imm_b_mux_sel_o             = IMM_B_I;</pre>
<pre></pre>
<pre>    div_en_o                    = 1'b0;</pre>
<pre>    multdiv_operator_o          = MD_OP_MULL;</pre>
<pre>    multdiv_signed_mode_o       = 2'b00;</pre>
<pre></pre>
<pre>    regfile_we                  = 1'b0;</pre>
<pre></pre>
<pre>    csr_illegal                 = 1'b0;</pre>
<pre>    csr_op                      = CSR_OP_READ;</pre>
<pre></pre>
<pre>    data_type_o                 = 2'b00;</pre>
<pre>    data_sign_extension_o       = 1'b0;</pre>
<pre>    data_req_o                  = 1'b0;</pre>
<pre></pre>
<pre>    ebrk_insn_o                 = 1'b0;</pre>
<pre>    mret_insn_o                 = 1'b0;</pre>
<pre>    dret_insn_o                 = 1'b0;</pre>
<pre>    ecall_insn_o                = 1'b0;</pre>
<pre>    wfi_insn_o                  = 1'b0;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>        jump_in_dec_o         = 1'b1;</pre>
<pre>        if (instr_new_i) begin</pre>
<pre>          // Calculate jump target</pre>
<pre>          alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>          imm_b_mux_sel_o     = IMM_B_J;</pre>
<pre>          alu_operator_o      = ALU_ADD;</pre>
<pre>          regfile_we          = 1'b0;</pre>
<pre>          jump_set_o          = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          // Calculate and store PC+4</pre>
<pre>          alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>          imm_b_mux_sel_o     = IMM_B_INCR_PC;</pre>
<pre>          alu_operator_o      = ALU_ADD;</pre>
<pre>          regfile_we          = 1'b1;</pre>
<pre>        end</pre>
<pre>        jump_in_dec_o         = 1'b1;</pre>
<pre>        if (instr_new_i) begin</pre>
<pre>          // Calculate jump target</pre>
<pre>          alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>          imm_b_mux_sel_o     = IMM_B_I;</pre>
<pre>          alu_operator_o      = ALU_ADD;</pre>
<pre>          regfile_we          = 1'b0;</pre>
<pre>          jump_set_o          = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          // Calculate and store PC+4</pre>
<pre>          alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>          imm_b_mux_sel_o     = IMM_B_INCR_PC;</pre>
<pre>          alu_operator_o      = ALU_ADD;</pre>
<pre>          regfile_we          = 1'b1;</pre>
<pre>        end</pre>
<pre>          illegal_insn = 1'b1;</pre>
<pre>        end</pre>
<pre>        branch_in_dec_o       = 1'b1;</pre>
<pre>        // Check branch condition selection</pre>
<pre>          3'b000:  alu_operator_o = ALU_EQ;</pre>
<pre>          3'b001:  alu_operator_o = ALU_NE;</pre>
<pre>          3'b100:  alu_operator_o = ALU_LT;</pre>
<pre>          3'b101:  alu_operator_o = ALU_GE;</pre>
<pre>          3'b110:  alu_operator_o = ALU_LTU;</pre>
<pre>          3'b111:  alu_operator_o = ALU_GEU;</pre>
<pre>          default: illegal_insn   = 1'b1;</pre>
<pre>        endcase</pre>
<pre>          // Evaluate branch condition</pre>
<pre>          alu_op_b_mux_sel_o  = OP_B_REG_B;</pre>
<pre>        end else begin</pre>
<pre>          // Calculate jump target in EX</pre>
<pre>          alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>          imm_b_mux_sel_o     = IMM_B_B;</pre>
<pre>          alu_operator_o      = ALU_ADD;</pre>
<pre>          regfile_we          = 1'b0;</pre>
<pre>        end</pre>
<pre>        alu_op_a_mux_sel_o = OP_A_REG_A;</pre>
<pre>        alu_op_b_mux_sel_o = OP_B_REG_B;</pre>
<pre>        data_req_o         = 1'b1;</pre>
<pre>        data_we_o          = 1'b1;</pre>
<pre>        alu_operator_o     = ALU_ADD;</pre>
<pre></pre>
<pre>          // offset from immediate</pre>
<pre>          alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>        end else begin</pre>
<pre>          // Register offset is illegal since no register c available</pre>
<pre>        end</pre>
<pre>          2'b00:   data_type_o  = 2'b10; // SB</pre>
<pre>          2'b01:   data_type_o  = 2'b01; // SH</pre>
<pre>          2'b10:   data_type_o  = 2'b00; // SW</pre>
<pre>          default: illegal_insn = 1'b1;</pre>
<pre>        endcase</pre>
<pre>        alu_op_a_mux_sel_o  = OP_A_REG_A;</pre>
<pre>        data_req_o          = 1'b1;</pre>
<pre>        regfile_wdata_sel_o = RF_WD_LSU;</pre>
<pre>        regfile_we          = 1'b1;</pre>
<pre>        data_type_o         = 2'b00;</pre>
<pre></pre>
<pre>        alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>        imm_b_mux_sel_o     = IMM_B_I;</pre>
<pre></pre>
<pre></pre>
<pre>          2'b00: data_type_o = 2'b10; // LB(U)</pre>
<pre>          2'b01: data_type_o = 2'b01; // LH(U)</pre>
<pre>          2'b10: begin</pre>
<pre>            data_type_o = 2'b00;      // LW</pre>
<pre>            if (instr[14]) begin</pre>
<pre>              illegal_insn = 1'b1;    // LWU does not exist</pre>
<pre>            end</pre>
<pre>            illegal_insn = 1'b1;</pre>
<pre>          end</pre>
<pre>        alu_op_a_mux_sel_o  = OP_A_IMM;</pre>
<pre>        alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>        imm_a_mux_sel_o     = IMM_A_ZERO;</pre>
<pre>        imm_b_mux_sel_o     = IMM_B_U;</pre>
<pre>        alu_operator_o      = ALU_ADD;</pre>
<pre>        regfile_we          = 1'b1;</pre>
<pre>      end</pre>
<pre>        alu_op_a_mux_sel_o  = OP_A_CURRPC;</pre>
<pre>        alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>        imm_b_mux_sel_o     = IMM_B_U;</pre>
<pre>        alu_operator_o      = ALU_ADD;</pre>
<pre>        regfile_we          = 1'b1;</pre>
<pre>      end</pre>
<pre>        alu_op_a_mux_sel_o  = OP_A_REG_A;</pre>
<pre>        alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>        imm_b_mux_sel_o     = IMM_B_I;</pre>
<pre>        regfile_we          = 1'b1;</pre>
<pre></pre>
<pre>          3'b000: alu_operator_o = ALU_ADD;  // Add Immediate</pre>
<pre>          3'b010: alu_operator_o = ALU_SLT;  // Set to one if Lower Than Immediate</pre>
<pre>          3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned</pre>
<pre>          3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate</pre>
<pre>          3'b110: alu_operator_o = ALU_OR;   // Or with Immediate</pre>
<pre>          3'b111: alu_operator_o = ALU_AND;  // And with Immediate</pre>
<pre></pre>
<pre>            alu_operator_o = ALU_SLL;  // Shift Left Logical by Immediate</pre>
<pre>            if (instr[31:25] != 7'b0) begin</pre>
<pre>              illegal_insn = 1'b1;</pre>
<pre>            end</pre>
<pre>            if (instr[31:25] == 7'b0) begin</pre>
<pre>              alu_operator_o = ALU_SRL;  // Shift Right Logical by Immediate</pre>
<pre>            end else if (instr[31:25] == 7'b010_0000) begin</pre>
<pre>              alu_operator_o = ALU_SRA;  // Shift Right Arithmetically by Immediate</pre>
<pre>            end else begin</pre>
<pre>              illegal_insn   = 1'b1;</pre>
<pre>            end</pre>
<pre>            alu_operator_o = ALU_SLTU;</pre>
<pre>          end</pre>
<pre>        alu_op_a_mux_sel_o = OP_A_REG_A;</pre>
<pre>        alu_op_b_mux_sel_o = OP_B_REG_B;</pre>
<pre>        regfile_we         = 1'b1;</pre>
<pre></pre>
<pre>          illegal_insn = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          unique case ({instr[30:25], instr[14:12]})</pre>
<pre>            // RV32I ALU operations</pre>
<pre>            {6'b10_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub</pre>
<pre>            {6'b00_0000, 3'b010}: alu_operator_o = ALU_SLT;   // Set Lower Than</pre>
<pre>            {6'b00_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned</pre>
<pre>            {6'b00_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor</pre>
<pre>            {6'b00_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or</pre>
<pre>            {6'b00_0000, 3'b111}: alu_operator_o = ALU_AND;   // And</pre>
<pre>            {6'b00_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical</pre>
<pre>            {6'b00_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical</pre>
<pre>            {6'b10_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic</pre>
<pre></pre>
<pre>              alu_operator_o        = ALU_ADD;</pre>
<pre>              multdiv_operator_o    = MD_OP_MULL;</pre>
<pre>              mult_en_o             = RV32M ? 1'b1 : 1'b0;</pre>
<pre>              multdiv_signed_mode_o = 2'b00;</pre>
<pre>              illegal_insn          = RV32M ? 1'b0 : 1'b1;</pre>
<pre>            end</pre>
<pre>              alu_operator_o        = ALU_ADD;</pre>
<pre>              multdiv_operator_o    = MD_OP_MULH;</pre>
<pre>              mult_en_o             = RV32M ? 1'b1 : 1'b0;</pre>
<pre>              multdiv_signed_mode_o = 2'b11;</pre>
<pre>              illegal_insn          = RV32M ? 1'b0 : 1'b1;</pre>
<pre>            end</pre>
<pre>              alu_operator_o        = ALU_ADD;</pre>
<pre>              multdiv_operator_o    = MD_OP_MULH;</pre>
<pre>              mult_en_o             = RV32M ? 1'b1 : 1'b0;</pre>
<pre>              multdiv_signed_mode_o = 2'b01;</pre>
<pre>              illegal_insn          = RV32M ? 1'b0 : 1'b1;</pre>
<pre>            end</pre>
<pre>              alu_operator_o        = ALU_ADD;</pre>
<pre>              multdiv_operator_o    = MD_OP_MULH;</pre>
<pre>              mult_en_o             = RV32M ? 1'b1 : 1'b0;</pre>
<pre>              multdiv_signed_mode_o = 2'b00;</pre>
<pre>              illegal_insn          = RV32M ? 1'b0 : 1'b1;</pre>
<pre>            end</pre>
<pre>              alu_operator_o        = ALU_ADD;</pre>
<pre>              multdiv_operator_o    = MD_OP_DIV;</pre>
<pre>              div_en_o              = RV32M ? 1'b1 : 1'b0;</pre>
<pre>              multdiv_signed_mode_o = 2'b11;</pre>
<pre>              illegal_insn          = RV32M ? 1'b0 : 1'b1;</pre>
<pre>            end</pre>
<pre>              alu_operator_o        = ALU_ADD;</pre>
<pre>              multdiv_operator_o    = MD_OP_DIV;</pre>
<pre>              div_en_o              = RV32M ? 1'b1 : 1'b0;</pre>
<pre>              multdiv_signed_mode_o = 2'b00;</pre>
<pre>              illegal_insn          = RV32M ? 1'b0 : 1'b1;</pre>
<pre>            end</pre>
<pre>              alu_operator_o        = ALU_ADD;</pre>
<pre>              multdiv_operator_o    = MD_OP_REM;</pre>
<pre>              div_en_o              = RV32M ? 1'b1 : 1'b0;</pre>
<pre>              multdiv_signed_mode_o = 2'b11;</pre>
<pre>              illegal_insn          = RV32M ? 1'b0 : 1'b1;</pre>
<pre>            end</pre>
<pre>              alu_operator_o        = ALU_ADD;</pre>
<pre>              multdiv_operator_o    = MD_OP_REM;</pre>
<pre>              div_en_o              = RV32M ? 1'b1 : 1'b0;</pre>
<pre>              multdiv_signed_mode_o = 2'b00;</pre>
<pre>              illegal_insn          = RV32M ? 1'b0 : 1'b1;</pre>
<pre>            end</pre>
<pre>              illegal_insn = 1'b1;</pre>
<pre>            end</pre>
<pre>        // For now, treat the FENCE (funct3 == 000) instruction as a NOP.  This may not be correct</pre>
<pre>          3'b000: begin</pre>
<pre>            alu_operator_o     = ALU_ADD; // nop</pre>
<pre>            alu_op_a_mux_sel_o = OP_A_REG_A;</pre>
<pre>            alu_op_b_mux_sel_o = OP_B_IMM;</pre>
<pre>            regfile_we         = 1'b0;</pre>
<pre>          end</pre>
<pre>            // FENCE.I is implemented as a jump to the next PC, this gives the required flushing</pre>
<pre></pre>
<pre>            alu_op_b_mux_sel_o = OP_B_IMM;</pre>
<pre>            imm_b_mux_sel_o    = IMM_B_INCR_PC;</pre>
<pre>            alu_operator_o     = ALU_ADD;</pre>
<pre>            regfile_we         = 1'b0;</pre>
<pre></pre>
<pre>              jump_set_o       = 1'b1;</pre>
<pre>            end</pre>
<pre>            illegal_insn       = 1'b1;</pre>
<pre>          end</pre>
<pre>        if (instr[14:12] == 3'b000) begin</pre>
<pre>          // non CSR related SYSTEM instructions</pre>
<pre>          alu_op_b_mux_sel_o = OP_B_IMM;</pre>
<pre>          unique case (instr[31:20])</pre>
<pre>            12'h000:  // ECALL</pre>
<pre>              // environment (system) call</pre>
<pre></pre>
<pre>              // debugger trap</pre>
<pre></pre>
<pre>              mret_insn_o = 1'b1;</pre>
<pre></pre>
<pre>              dret_insn_o = 1'b1;</pre>
<pre></pre>
<pre>              wfi_insn_o = 1'b1;</pre>
<pre></pre>
<pre>              illegal_insn = 1'b1;</pre>
<pre>          endcase</pre>
<pre>            illegal_insn = 1'b1;</pre>
<pre>          end</pre>
<pre>          // instruction to read/modify CSR</pre>
<pre>          regfile_wdata_sel_o = RF_WD_CSR;</pre>
<pre>          regfile_we          = 1'b1;</pre>
<pre>          alu_op_b_mux_sel_o  = OP_B_IMM;</pre>
<pre>          imm_a_mux_sel_o     = IMM_A_Z;</pre>
<pre>          imm_b_mux_sel_o     = IMM_B_I;  // CSR address is encoded in I imm</pre>
<pre></pre>
<pre>            // rs1 field is used as immediate</pre>
<pre>          end else begin</pre>
<pre>            alu_op_a_mux_sel_o = OP_A_REG_A;</pre>
<pre>          end</pre>
<pre>            2'b01:   csr_op = CSR_OP_WRITE;</pre>
<pre>            2'b10:   csr_op = CSR_OP_SET;</pre>
<pre>            2'b11:   csr_op = CSR_OP_CLEAR;</pre>
<pre>            default: csr_illegal = 1'b1;</pre>
<pre>          endcase</pre>
<pre>        end</pre>
<pre>        illegal_insn = 1'b1;</pre>
<pre>      end</pre>
<pre>      illegal_insn = 1'b1;</pre>
<pre>    end</pre>
<pre>      regfile_we      = 1'b0;</pre>
<pre>      data_req_o      = 1'b0;</pre>
<pre>      data_we_o       = 1'b0;</pre>
<pre>      mult_en_o       = 1'b0;</pre>
<pre>      div_en_o        = 1'b0;</pre>
<pre>      jump_in_dec_o   = 1'b0;</pre>
<pre>      jump_set_o      = 1'b0;</pre>
<pre>      branch_in_dec_o = 1'b0;</pre>
<pre>      csr_access_o    = 1'b0;</pre>
<pre>    end</pre>
<pre></pre>
<pre></pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv</h3>
<pre>module ibex_register_file #(</pre>
<pre>    parameter bit RV32E              = 0,</pre>
<pre>    parameter int unsigned DataWidth = 32</pre>
<pre>    input  logic                 clk_i,</pre>
<pre>    input  logic                 rst_ni,</pre>
<pre>    input  logic                 test_en_i,</pre>
<pre>    input  logic [4:0]           raddr_a_i,</pre>
<pre>    output logic [DataWidth-1:0] rdata_a_o,</pre>
<pre>    input  logic [4:0]           raddr_b_i,</pre>
<pre>    output logic [DataWidth-1:0] rdata_b_o,</pre>
<pre>    input  logic [4:0]           waddr_a_i,</pre>
<pre>    input  logic [DataWidth-1:0] wdata_a_i,</pre>
<pre>    input  logic                 we_a_i</pre>
<pre>  localparam int unsigned ADDR_WIDTH = RV32E ? 4 : 5;</pre>
<pre>  localparam int unsigned NUM_WORDS  = 2**ADDR_WIDTH;</pre>
<pre>  logic [NUM_WORDS-1:0][DataWidth-1:0] rf_reg;</pre>
<pre>  logic [NUM_WORDS-1:1][DataWidth-1:0] rf_reg_tmp;</pre>
<pre>  logic [NUM_WORDS-1:1]                we_a_dec;</pre>
<pre>  always_comb begin : we_a_decoder</pre>
<pre>    for (int unsigned i = 1; i < NUM_WORDS; i++) begin</pre>
<pre>      we_a_dec[i] = (waddr_a_i == 5'(i)) ?  we_a_i : 1'b0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rf_reg_tmp <= '{default:'0};</pre>
<pre>    end else begin</pre>
<pre>      for (int r = 1; r < NUM_WORDS; r++) begin</pre>
<pre>        if (we_a_dec[r]) rf_reg_tmp[r] <= wdata_a_i;</pre>
<pre>  assign rf_reg[0] = '0;</pre>
<pre>  assign rf_reg[NUM_WORDS-1:1] = rf_reg_tmp[NUM_WORDS-1:1];</pre>
<pre>  assign rdata_a_o = rf_reg[raddr_a_i];</pre>
<pre>  assign rdata_b_o = rf_reg[raddr_b_i];</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_core.sv</h3>
<pre>module ibex_core #(</pre>
<pre>    parameter bit          PMPEnable                = 1'b0,</pre>
<pre>    parameter int unsigned PMPGranularity           = 0,</pre>
<pre>    parameter int unsigned PMPNumRegions            = 4,</pre>
<pre>    parameter int unsigned MHPMCounterNum           = 0,</pre>
<pre>    parameter int unsigned MHPMCounterWidth         = 40,</pre>
<pre>    parameter bit          RV32E                    = 1'b0,</pre>
<pre>    parameter bit          RV32M                    = 1'b1,</pre>
<pre>    parameter              MultiplierImplementation = "fast",</pre>
<pre>    parameter bit          DbgTriggerEn             = 1'b0,</pre>
<pre>    parameter int unsigned DmHaltAddr               = 32'h1A110800,</pre>
<pre>    parameter int unsigned DmExceptionAddr          = 32'h1A110808</pre>
<pre>    input  logic        clk_i,</pre>
<pre>    input  logic        rst_ni,</pre>
<pre>    input  logic        test_en_i,     // enable all clock gates for testing</pre>
<pre>    input  logic [31:0] hart_id_i,</pre>
<pre>    input  logic [31:0] boot_addr_i,</pre>
<pre>    output logic        instr_req_o,</pre>
<pre>    input  logic        instr_gnt_i,</pre>
<pre>    input  logic        instr_rvalid_i,</pre>
<pre>    output logic [31:0] instr_addr_o,</pre>
<pre>    input  logic [31:0] instr_rdata_i,</pre>
<pre>    input  logic        instr_err_i,</pre>
<pre>    output logic        data_req_o,</pre>
<pre>    input  logic        data_gnt_i,</pre>
<pre>    input  logic        data_rvalid_i,</pre>
<pre>    output logic        data_we_o,</pre>
<pre>    output logic [3:0]  data_be_o,</pre>
<pre>    output logic [31:0] data_addr_o,</pre>
<pre>    output logic [31:0] data_wdata_o,</pre>
<pre>    input  logic [31:0] data_rdata_i,</pre>
<pre>    input  logic        data_err_i,</pre>
<pre>    input  logic        irq_software_i,</pre>
<pre>    input  logic        irq_timer_i,</pre>
<pre>    input  logic        irq_external_i,</pre>
<pre>    input  logic [14:0] irq_fast_i,</pre>
<pre>    input  logic        irq_nm_i,       // non-maskeable interrupt</pre>
<pre>    input  logic        debug_req_i,</pre>
<pre>    input  logic        fetch_enable_i,</pre>
<pre>    output logic        core_sleep_o</pre>
<pre>  localparam int unsigned PMP_NUM_CHAN = 2;</pre>
<pre>  logic        instr_valid_id;</pre>
<pre>  logic        instr_new_id;</pre>
<pre>  logic [31:0] instr_rdata_id;         // Instruction sampled inside IF stage</pre>
<pre>  logic [15:0] instr_rdata_c_id;       // Compressed instruction sampled inside IF stage</pre>
<pre>  logic        instr_is_compressed_id;</pre>
<pre>  logic        instr_fetch_err;        // Bus error on instr fetch</pre>
<pre>  logic        illegal_c_insn_id;      // Illegal compressed instruction sent to ID stage</pre>
<pre>  logic [31:0] pc_if;                  // Program counter in IF stage</pre>
<pre>  logic [31:0] pc_id;                  // Program counter in ID stage</pre>
<pre>  logic        instr_valid_clear;</pre>
<pre>  logic        pc_set;</pre>
<pre>  pc_sel_e     pc_mux_id;              // Mux selector for next PC</pre>
<pre>  exc_pc_sel_e exc_pc_mux_id;          // Mux selector for exception PC</pre>
<pre>  exc_cause_e  exc_cause;              // Exception cause</pre>
<pre>  logic        lsu_load_err;</pre>
<pre>  logic        lsu_store_err;</pre>
<pre>  logic        lsu_addr_incr_req;</pre>
<pre>  logic [31:0] lsu_addr_last;</pre>
<pre>  logic [31:0] jump_target_ex;</pre>
<pre>  logic        branch_decision;</pre>
<pre>  logic        ctrl_busy;</pre>
<pre>  logic        if_busy;</pre>
<pre>  logic        lsu_busy;</pre>
<pre>  logic        core_busy_d, core_busy_q;</pre>
<pre>  alu_op_e     alu_operator_ex;</pre>
<pre>  logic [31:0] alu_operand_a_ex;</pre>
<pre>  logic [31:0] alu_operand_b_ex;</pre>
<pre>  logic [31:0] alu_adder_result_ex;    // Used to forward computed address to LSU</pre>
<pre>  logic [31:0] regfile_wdata_ex;</pre>
<pre>  logic        mult_en_ex;</pre>
<pre>  logic        div_en_ex;</pre>
<pre>  md_op_e      multdiv_operator_ex;</pre>
<pre>  logic [1:0]  multdiv_signed_mode_ex;</pre>
<pre>  logic [31:0] multdiv_operand_a_ex;</pre>
<pre>  logic [31:0] multdiv_operand_b_ex;</pre>
<pre>  logic        csr_access;</pre>
<pre>  logic        valid_csr_id;</pre>
<pre>  csr_op_e     csr_op;</pre>
<pre>  csr_num_e    csr_addr;</pre>
<pre>  logic [31:0] csr_rdata;</pre>
<pre>  logic [31:0] csr_wdata;</pre>
<pre>  logic        illegal_csr_insn_id;    // CSR access to non-existent register,</pre>
<pre>  logic        data_we_ex;</pre>
<pre>  logic [1:0]  data_type_ex;</pre>
<pre>  logic        data_sign_ext_ex;</pre>
<pre>  logic        data_req_ex;</pre>
<pre>  logic [31:0] data_wdata_ex;</pre>
<pre>  logic [31:0] regfile_wdata_lsu;</pre>
<pre>  logic        id_in_ready;</pre>
<pre>  logic        ex_valid;</pre>
<pre>  logic        lsu_data_valid;</pre>
<pre>  logic        instr_req_int;          // Id stage asserts a req to instruction core interface</pre>
<pre>  logic        irq_pending;</pre>
<pre>  logic        nmi_mode;</pre>
<pre>  logic        csr_msip;</pre>
<pre>  logic        csr_mtip;</pre>
<pre>  logic        csr_meip;</pre>
<pre>  logic [14:0] csr_mfip;</pre>
<pre>  logic        csr_mstatus_mie;</pre>
<pre>  logic [31:0] csr_mepc, csr_depc;</pre>
<pre>  logic [33:0] csr_pmp_addr [PMPNumRegions];</pre>
<pre>  pmp_cfg_t    csr_pmp_cfg  [PMPNumRegions];</pre>
<pre>  logic        pmp_req_err  [PMP_NUM_CHAN];</pre>
<pre>  logic        instr_req_out;</pre>
<pre>  logic        data_req_out;</pre>
<pre>  logic        csr_save_if;</pre>
<pre>  logic        csr_save_id;</pre>
<pre>  logic        csr_restore_mret_id;</pre>
<pre>  logic        csr_restore_dret_id;</pre>
<pre>  logic        csr_save_cause;</pre>
<pre>  logic        csr_mtvec_init;</pre>
<pre>  logic [31:0] csr_mtvec;</pre>
<pre>  logic [31:0] csr_mtval;</pre>
<pre>  logic        csr_mstatus_tw;</pre>
<pre>  priv_lvl_e   priv_mode_id;</pre>
<pre>  priv_lvl_e   priv_mode_if;</pre>
<pre>  priv_lvl_e   priv_mode_lsu;</pre>
<pre>  logic        debug_mode;</pre>
<pre>  dbg_cause_e  debug_cause;</pre>
<pre>  logic        debug_csr_save;</pre>
<pre>  logic        debug_single_step;</pre>
<pre>  logic        debug_ebreakm;</pre>
<pre>  logic        debug_ebreaku;</pre>
<pre>  logic        trigger_match;</pre>
<pre>  logic        instr_ret;</pre>
<pre>  logic        instr_ret_compressed;</pre>
<pre>  logic        perf_imiss;</pre>
<pre>  logic        perf_jump;</pre>
<pre>  logic        perf_branch;</pre>
<pre>  logic        perf_tbranch;</pre>
<pre>  logic        perf_load;</pre>
<pre>  logic        perf_store;</pre>
<pre>  logic        illegal_insn_id, unused_illegal_insn_id; // ID stage sees an illegal instruction</pre>
<pre>  logic        clk;</pre>
<pre>  logic        clock_en;</pre>
<pre>  assign core_busy_d = ctrl_busy | if_busy | lsu_busy;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      core_busy_q <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      core_busy_q <= core_busy_d;</pre>
<pre>  assign clock_en     = core_busy_q | debug_req_i | irq_pending | irq_nm_i;</pre>
<pre>  assign core_sleep_o = ~clock_en;</pre>
<pre>  prim_clock_gating core_clock_gate_i (</pre>
<pre>      .clk_i     ( clk_i           ),</pre>
<pre>      .en_i      ( clock_en        ),</pre>
<pre>      .test_en_i ( test_en_i       ),</pre>
<pre>      .clk_o     ( clk             )</pre>
<pre>  ibex_if_stage #(</pre>
<pre>      .DmHaltAddr       ( DmHaltAddr      ),</pre>
<pre>      .DmExceptionAddr  ( DmExceptionAddr )</pre>
<pre style="background-color: #FF0000;">  ) if_stage_i (</pre>
<pre>      .clk_i                    ( clk                    ),</pre>
<pre>      .rst_ni                   ( rst_ni                 ),</pre>
<pre>      .boot_addr_i              ( boot_addr_i            ),</pre>
<pre>      .req_i                    ( instr_req_int          ), // instruction request control</pre>
<pre>      .instr_req_o              ( instr_req_out          ),</pre>
<pre>      .instr_addr_o             ( instr_addr_o           ),</pre>
<pre>      .instr_gnt_i              ( instr_gnt_i            ),</pre>
<pre>      .instr_rvalid_i           ( instr_rvalid_i         ),</pre>
<pre>      .instr_rdata_i            ( instr_rdata_i          ),</pre>
<pre>      .instr_err_i              ( instr_err_i            ),</pre>
<pre>      .instr_pmp_err_i          ( pmp_req_err[PMP_I]     ),</pre>
<pre>      .instr_valid_id_o         ( instr_valid_id         ),</pre>
<pre>      .instr_new_id_o           ( instr_new_id           ),</pre>
<pre>      .instr_rdata_id_o         ( instr_rdata_id         ),</pre>
<pre>      .instr_rdata_c_id_o       ( instr_rdata_c_id       ),</pre>
<pre>      .instr_is_compressed_id_o ( instr_is_compressed_id ),</pre>
<pre>      .instr_fetch_err_o        ( instr_fetch_err        ),</pre>
<pre>      .illegal_c_insn_id_o      ( illegal_c_insn_id      ),</pre>
<pre>      .pc_if_o                  ( pc_if                  ),</pre>
<pre>      .pc_id_o                  ( pc_id                  ),</pre>
<pre>      .instr_valid_clear_i      ( instr_valid_clear      ),</pre>
<pre>      .pc_set_i                 ( pc_set                 ),</pre>
<pre>      .pc_mux_i                 ( pc_mux_id              ),</pre>
<pre>      .exc_pc_mux_i             ( exc_pc_mux_id          ),</pre>
<pre>      .exc_cause                ( exc_cause              ),</pre>
<pre>      .jump_target_ex_i         ( jump_target_ex         ),</pre>
<pre>      .csr_mepc_i               ( csr_mepc               ), // exception return address</pre>
<pre>      .csr_depc_i               ( csr_depc               ), // debug return address</pre>
<pre>      .csr_mtvec_i              ( csr_mtvec              ), // trap-vector base address</pre>
<pre>      .csr_mtvec_init_o         ( csr_mtvec_init         ),</pre>
<pre>      .id_in_ready_i            ( id_in_ready            ),</pre>
<pre>      .if_busy_o                ( if_busy                ),</pre>
<pre>      .perf_imiss_o             ( perf_imiss             )</pre>
<pre>  assign instr_req_o = instr_req_out & ~pmp_req_err[PMP_I];</pre>
<pre>  ibex_id_stage #(</pre>
<pre>      .RV32E ( RV32E ),</pre>
<pre>      .RV32M ( RV32M )</pre>
<pre style="background-color: #FF0000;">  ) id_stage_i (</pre>
<pre>      .clk_i                        ( clk                    ),</pre>
<pre>      .rst_ni                       ( rst_ni                 ),</pre>
<pre>      .test_en_i                    ( test_en_i              ),</pre>
<pre>      .fetch_enable_i               ( fetch_enable_i         ),</pre>
<pre>      .ctrl_busy_o                  ( ctrl_busy              ),</pre>
<pre>      .illegal_insn_o               ( illegal_insn_id        ),</pre>
<pre>      .instr_valid_i                ( instr_valid_id         ),</pre>
<pre>      .instr_new_i                  ( instr_new_id           ),</pre>
<pre>      .instr_rdata_i                ( instr_rdata_id         ),</pre>
<pre>      .instr_rdata_c_i              ( instr_rdata_c_id       ),</pre>
<pre>      .instr_is_compressed_i        ( instr_is_compressed_id ),</pre>
<pre>      .branch_decision_i            ( branch_decision        ),</pre>
<pre>      .id_in_ready_o                ( id_in_ready            ),</pre>
<pre>      .instr_valid_clear_o          ( instr_valid_clear      ),</pre>
<pre>      .instr_req_o                  ( instr_req_int          ),</pre>
<pre>      .pc_set_o                     ( pc_set                 ),</pre>
<pre>      .pc_mux_o                     ( pc_mux_id              ),</pre>
<pre>      .exc_pc_mux_o                 ( exc_pc_mux_id          ),</pre>
<pre>      .exc_cause_o                  ( exc_cause              ),</pre>
<pre>      .instr_fetch_err_i            ( instr_fetch_err        ),</pre>
<pre>      .illegal_c_insn_i             ( illegal_c_insn_id      ),</pre>
<pre>      .pc_id_i                      ( pc_id                  ),</pre>
<pre>      .ex_valid_i                   ( ex_valid               ),</pre>
<pre>      .lsu_valid_i                  ( lsu_data_valid         ),</pre>
<pre>      .alu_operator_ex_o            ( alu_operator_ex        ),</pre>
<pre>      .alu_operand_a_ex_o           ( alu_operand_a_ex       ),</pre>
<pre>      .alu_operand_b_ex_o           ( alu_operand_b_ex       ),</pre>
<pre>      .mult_en_ex_o                 ( mult_en_ex             ),</pre>
<pre>      .div_en_ex_o                  ( div_en_ex              ),</pre>
<pre>      .multdiv_operator_ex_o        ( multdiv_operator_ex    ),</pre>
<pre>      .multdiv_signed_mode_ex_o     ( multdiv_signed_mode_ex ),</pre>
<pre>      .multdiv_operand_a_ex_o       ( multdiv_operand_a_ex   ),</pre>
<pre>      .multdiv_operand_b_ex_o       ( multdiv_operand_b_ex   ),</pre>
<pre>      .csr_access_o                 ( csr_access             ),</pre>
<pre>      .csr_op_o                     ( csr_op                 ),</pre>
<pre>      .csr_save_if_o                ( csr_save_if            ), // control signal to save PC</pre>
<pre>      .csr_save_id_o                ( csr_save_id            ), // control signal to save PC</pre>
<pre>      .csr_restore_mret_id_o        ( csr_restore_mret_id    ), // restore mstatus upon DRET</pre>
<pre>      .csr_restore_dret_id_o        ( csr_restore_dret_id    ), // restore mstatus upon MRET</pre>
<pre>      .csr_save_cause_o             ( csr_save_cause         ),</pre>
<pre>      .csr_mtval_o                  ( csr_mtval              ),</pre>
<pre>      .priv_mode_i                  ( priv_mode_id           ),</pre>
<pre>      .csr_mstatus_tw_i             ( csr_mstatus_tw         ),</pre>
<pre>      .illegal_csr_insn_i           ( illegal_csr_insn_id    ),</pre>
<pre>      .data_req_ex_o                ( data_req_ex            ), // to load store unit</pre>
<pre>      .data_we_ex_o                 ( data_we_ex             ), // to load store unit</pre>
<pre>      .data_type_ex_o               ( data_type_ex           ), // to load store unit</pre>
<pre>      .data_sign_ext_ex_o           ( data_sign_ext_ex       ), // to load store unit</pre>
<pre>      .data_wdata_ex_o              ( data_wdata_ex          ), // to load store unit</pre>
<pre>      .lsu_addr_incr_req_i          ( lsu_addr_incr_req      ),</pre>
<pre>      .lsu_addr_last_i              ( lsu_addr_last          ),</pre>
<pre>      .lsu_load_err_i               ( lsu_load_err           ),</pre>
<pre>      .lsu_store_err_i              ( lsu_store_err          ),</pre>
<pre>      .csr_mstatus_mie_i            ( csr_mstatus_mie        ),</pre>
<pre>      .csr_msip_i                   ( csr_msip               ),</pre>
<pre>      .csr_mtip_i                   ( csr_mtip               ),</pre>
<pre>      .csr_meip_i                   ( csr_meip               ),</pre>
<pre>      .csr_mfip_i                   ( csr_mfip               ),</pre>
<pre>      .irq_pending_i                ( irq_pending            ),</pre>
<pre>      .irq_nm_i                     ( irq_nm_i               ),</pre>
<pre>      .nmi_mode_o                   ( nmi_mode               ),</pre>
<pre>      .debug_mode_o                 ( debug_mode             ),</pre>
<pre>      .debug_cause_o                ( debug_cause            ),</pre>
<pre>      .debug_csr_save_o             ( debug_csr_save         ),</pre>
<pre>      .debug_req_i                  ( debug_req_i            ),</pre>
<pre>      .debug_single_step_i          ( debug_single_step      ),</pre>
<pre>      .debug_ebreakm_i              ( debug_ebreakm          ),</pre>
<pre>      .debug_ebreaku_i              ( debug_ebreaku          ),</pre>
<pre>      .trigger_match_i              ( trigger_match          ),</pre>
<pre>      .regfile_wdata_lsu_i          ( regfile_wdata_lsu      ),</pre>
<pre>      .regfile_wdata_ex_i           ( regfile_wdata_ex       ),</pre>
<pre>      .csr_rdata_i                  ( csr_rdata              ),</pre>
<pre>      .perf_jump_o                  ( perf_jump              ),</pre>
<pre>      .perf_branch_o                ( perf_branch            ),</pre>
<pre>      .perf_tbranch_o               ( perf_tbranch           ),</pre>
<pre>      .instr_ret_o                  ( instr_ret              ),</pre>
<pre>      .instr_ret_compressed_o       ( instr_ret_compressed   )</pre>
<pre>  assign unused_illegal_insn_id = illegal_insn_id;</pre>
<pre>  ibex_ex_block #(</pre>
<pre>      .RV32M                      ( RV32M                    ),</pre>
<pre>      .MultiplierImplementation   ( MultiplierImplementation )</pre>
<pre style="background-color: #FF0000;">  ) ex_block_i (</pre>
<pre>      .clk_i                      ( clk                      ),</pre>
<pre>      .rst_ni                     ( rst_ni                   ),</pre>
<pre>      .alu_operator_i             ( alu_operator_ex          ),</pre>
<pre>      .alu_operand_a_i            ( alu_operand_a_ex         ),</pre>
<pre>      .alu_operand_b_i            ( alu_operand_b_ex         ),</pre>
<pre>      .multdiv_operator_i         ( multdiv_operator_ex      ),</pre>
<pre>      .mult_en_i                  ( mult_en_ex               ),</pre>
<pre>      .div_en_i                   ( div_en_ex                ),</pre>
<pre>      .multdiv_signed_mode_i      ( multdiv_signed_mode_ex   ),</pre>
<pre>      .multdiv_operand_a_i        ( multdiv_operand_a_ex     ),</pre>
<pre>      .multdiv_operand_b_i        ( multdiv_operand_b_ex     ),</pre>
<pre>      .alu_adder_result_ex_o      ( alu_adder_result_ex      ), // to LSU</pre>
<pre>      .regfile_wdata_ex_o         ( regfile_wdata_ex         ), // to ID</pre>
<pre>      .jump_target_o              ( jump_target_ex           ), // to IF</pre>
<pre>      .branch_decision_o          ( branch_decision          ), // to ID</pre>
<pre>      .ex_valid_o                 ( ex_valid                 )</pre>
<pre>  assign data_req_o = data_req_out & ~pmp_req_err[PMP_D];</pre>
<pre>  ibex_load_store_unit  load_store_unit_i (</pre>
<pre>      .clk_i                 ( clk                 ),</pre>
<pre>      .rst_ni                ( rst_ni              ),</pre>
<pre>      .data_req_o            ( data_req_out        ),</pre>
<pre>      .data_gnt_i            ( data_gnt_i          ),</pre>
<pre>      .data_rvalid_i         ( data_rvalid_i       ),</pre>
<pre>      .data_err_i            ( data_err_i          ),</pre>
<pre>      .data_pmp_err_i        ( pmp_req_err[PMP_D]  ),</pre>
<pre>      .data_addr_o           ( data_addr_o         ),</pre>
<pre>      .data_we_o             ( data_we_o           ),</pre>
<pre>      .data_be_o             ( data_be_o           ),</pre>
<pre>      .data_wdata_o          ( data_wdata_o        ),</pre>
<pre>      .data_rdata_i          ( data_rdata_i        ),</pre>
<pre>      .data_we_ex_i          ( data_we_ex          ),</pre>
<pre>      .data_type_ex_i        ( data_type_ex        ),</pre>
<pre>      .data_wdata_ex_i       ( data_wdata_ex       ),</pre>
<pre>      .data_sign_ext_ex_i    ( data_sign_ext_ex    ),</pre>
<pre>      .data_rdata_ex_o       ( regfile_wdata_lsu   ),</pre>
<pre>      .data_req_ex_i         ( data_req_ex         ),</pre>
<pre>      .adder_result_ex_i     ( alu_adder_result_ex ),</pre>
<pre>      .addr_incr_req_o       ( lsu_addr_incr_req   ),</pre>
<pre>      .addr_last_o           ( lsu_addr_last       ),</pre>
<pre>      .data_valid_o          ( lsu_data_valid      ),</pre>
<pre>      .load_err_o            ( lsu_load_err        ),</pre>
<pre>      .store_err_o           ( lsu_store_err       ),</pre>
<pre>      .busy_o                ( lsu_busy            )</pre>
<pre>  assign csr_wdata  = alu_operand_a_ex;</pre>
<pre>  assign csr_addr   = csr_num_e'(csr_access ? alu_operand_b_ex[11:0] : 12'b0);</pre>
<pre>  assign perf_load  = data_req_o & data_gnt_i & (~data_we_o);</pre>
<pre>  assign perf_store = data_req_o & data_gnt_i & data_we_o;</pre>
<pre>  assign valid_csr_id = instr_new_id & ~instr_fetch_err;</pre>
<pre>  ibex_cs_registers #(</pre>
<pre>      .DbgTriggerEn     ( DbgTriggerEn     ),</pre>
<pre>      .MHPMCounterNum   ( MHPMCounterNum   ),</pre>
<pre>      .MHPMCounterWidth ( MHPMCounterWidth ),</pre>
<pre>      .PMPEnable        ( PMPEnable        ),</pre>
<pre>      .PMPGranularity   ( PMPGranularity   ),</pre>
<pre>      .PMPNumRegions    ( PMPNumRegions    ),</pre>
<pre>      .RV32E            ( RV32E            ),</pre>
<pre>      .RV32M            ( RV32M            )</pre>
<pre style="background-color: #FF0000;">  ) cs_registers_i (</pre>
<pre>      .clk_i                   ( clk                    ),</pre>
<pre>      .rst_ni                  ( rst_ni                 ),</pre>
<pre>      .hart_id_i               ( hart_id_i              ),</pre>
<pre>      .priv_mode_id_o          ( priv_mode_id           ),</pre>
<pre>      .priv_mode_if_o          ( priv_mode_if           ),</pre>
<pre>      .priv_mode_lsu_o         ( priv_mode_lsu          ),</pre>
<pre>      .csr_mtvec_o             ( csr_mtvec              ),</pre>
<pre>      .csr_mtvec_init_i        ( csr_mtvec_init         ),</pre>
<pre>      .boot_addr_i             ( boot_addr_i            ),</pre>
<pre>      .csr_access_i            ( csr_access             ),</pre>
<pre>      .csr_addr_i              ( csr_addr               ),</pre>
<pre>      .csr_wdata_i             ( csr_wdata              ),</pre>
<pre>      .csr_op_i                ( csr_op                 ),</pre>
<pre>      .csr_rdata_o             ( csr_rdata              ),</pre>
<pre>      .irq_software_i          ( irq_software_i         ),</pre>
<pre>      .irq_timer_i             ( irq_timer_i            ),</pre>
<pre>      .irq_external_i          ( irq_external_i         ),</pre>
<pre>      .irq_fast_i              ( irq_fast_i             ),</pre>
<pre>      .irq_pending_o           ( irq_pending            ),</pre>
<pre>      .nmi_mode_i              ( nmi_mode               ),</pre>
<pre>      .csr_msip_o              ( csr_msip               ),</pre>
<pre>      .csr_mtip_o              ( csr_mtip               ),</pre>
<pre>      .csr_meip_o              ( csr_meip               ),</pre>
<pre>      .csr_mfip_o              ( csr_mfip               ),</pre>
<pre>      .csr_mstatus_mie_o       ( csr_mstatus_mie        ),</pre>
<pre>      .csr_mstatus_tw_o        ( csr_mstatus_tw         ),</pre>
<pre>      .csr_mepc_o              ( csr_mepc               ),</pre>
<pre>      .csr_pmp_cfg_o           ( csr_pmp_cfg            ),</pre>
<pre>      .csr_pmp_addr_o          ( csr_pmp_addr           ),</pre>
<pre>      .csr_depc_o              ( csr_depc               ),</pre>
<pre>      .debug_mode_i            ( debug_mode             ),</pre>
<pre>      .debug_cause_i           ( debug_cause            ),</pre>
<pre>      .debug_csr_save_i        ( debug_csr_save         ),</pre>
<pre>      .debug_single_step_o     ( debug_single_step      ),</pre>
<pre>      .debug_ebreakm_o         ( debug_ebreakm          ),</pre>
<pre>      .debug_ebreaku_o         ( debug_ebreaku          ),</pre>
<pre>      .trigger_match_o         ( trigger_match          ),</pre>
<pre>      .pc_if_i                 ( pc_if                  ),</pre>
<pre>      .pc_id_i                 ( pc_id                  ),</pre>
<pre>      .csr_save_if_i           ( csr_save_if            ),</pre>
<pre>      .csr_save_id_i           ( csr_save_id            ),</pre>
<pre>      .csr_restore_mret_i      ( csr_restore_mret_id    ),</pre>
<pre>      .csr_restore_dret_i      ( csr_restore_dret_id    ),</pre>
<pre>      .csr_save_cause_i        ( csr_save_cause         ),</pre>
<pre>      .csr_mcause_i            ( exc_cause              ),</pre>
<pre>      .csr_mtval_i             ( csr_mtval              ),</pre>
<pre>      .illegal_csr_insn_o      ( illegal_csr_insn_id    ),</pre>
<pre>      .instr_new_id_i          ( valid_csr_id           ),</pre>
<pre>      .instr_ret_i             ( instr_ret              ),</pre>
<pre>      .instr_ret_compressed_i  ( instr_ret_compressed   ),</pre>
<pre>      .imiss_i                 ( perf_imiss             ),</pre>
<pre>      .pc_set_i                ( pc_set                 ),</pre>
<pre>      .jump_i                  ( perf_jump              ),</pre>
<pre>      .branch_i                ( perf_branch            ),</pre>
<pre>      .branch_taken_i          ( perf_tbranch           ),</pre>
<pre>      .mem_load_i              ( perf_load              ),</pre>
<pre>      .mem_store_i             ( perf_store             ),</pre>
<pre>      .lsu_busy_i              ( lsu_busy               )</pre>
<pre style="background-color: #FF0000;">  if (PMPEnable) begin : g_pmp</pre>
<pre style="background-color: #FF0000;">    logic [33:0] pmp_req_addr [PMP_NUM_CHAN];</pre>
<pre style="background-color: #FF0000;">    pmp_req_e    pmp_req_type [PMP_NUM_CHAN];</pre>
<pre style="background-color: #FF0000;">    priv_lvl_e   pmp_priv_lvl [PMP_NUM_CHAN];</pre>
<pre style="background-color: #FF0000;">    assign pmp_req_addr[PMP_I] = {2'b00,instr_addr_o[31:0]};</pre>
<pre style="background-color: #FF0000;">    assign pmp_req_type[PMP_I] = PMP_ACC_EXEC;</pre>
<pre style="background-color: #FF0000;">    assign pmp_priv_lvl[PMP_I] = priv_mode_if;</pre>
<pre style="background-color: #FF0000;">    assign pmp_req_addr[PMP_D] = {2'b00,data_addr_o[31:0]};</pre>
<pre style="background-color: #FF0000;">    assign pmp_req_type[PMP_D] = data_we_o ? PMP_ACC_WRITE : PMP_ACC_READ;</pre>
<pre style="background-color: #FF0000;">    assign pmp_priv_lvl[PMP_D] = priv_mode_lsu;</pre>
<pre style="background-color: #FF0000;">    ibex_pmp #(</pre>
<pre style="background-color: #FF0000;">        .PMPGranularity        ( PMPGranularity ),</pre>
<pre style="background-color: #FF0000;">        .PMPNumChan            ( PMP_NUM_CHAN   ),</pre>
<pre style="background-color: #FF0000;">        .PMPNumRegions         ( PMPNumRegions  )</pre>
<pre style="background-color: #FF0000;">    ) pmp_i (</pre>
<pre style="background-color: #FF0000;">        .clk_i                 ( clk            ),</pre>
<pre style="background-color: #FF0000;">        .rst_ni                ( rst_ni         ),</pre>
<pre style="background-color: #FF0000;">        .csr_pmp_cfg_i         ( csr_pmp_cfg    ),</pre>
<pre style="background-color: #FF0000;">        .csr_pmp_addr_i        ( csr_pmp_addr   ),</pre>
<pre style="background-color: #FF0000;">        .priv_mode_i           ( pmp_priv_lvl   ),</pre>
<pre style="background-color: #FF0000;">        .pmp_req_addr_i        ( pmp_req_addr   ),</pre>
<pre style="background-color: #FF0000;">        .pmp_req_type_i        ( pmp_req_type   ),</pre>
<pre style="background-color: #FF0000;">        .pmp_req_err_o         ( pmp_req_err    )</pre>
<pre>  end else begin : g_no_pmp</pre>
<pre style="background-color: #FF0000;">    priv_lvl_e unused_priv_lvl_if, unused_priv_lvl_ls;</pre>
<pre style="background-color: #FF0000;">    logic [33:0] unused_csr_pmp_addr [PMPNumRegions];</pre>
<pre style="background-color: #FF0000;">    pmp_cfg_t    unused_csr_pmp_cfg  [PMPNumRegions];</pre>
<pre>    assign unused_priv_lvl_if = priv_mode_if;</pre>
<pre>    assign unused_priv_lvl_ls = priv_mode_lsu;</pre>
<pre>    assign unused_csr_pmp_addr = csr_pmp_addr;</pre>
<pre>    assign unused_csr_pmp_cfg = csr_pmp_cfg;</pre>
<pre>    assign pmp_req_err[PMP_I] = 1'b0;</pre>
<pre>    assign pmp_req_err[PMP_D] = 1'b0;</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_load_store_unit.sv</h3>
<pre>    input  logic         clk_i,</pre>
<pre>    input  logic         rst_ni,</pre>
<pre>    output logic         data_req_o,</pre>
<pre>    input  logic         data_gnt_i,</pre>
<pre>    input  logic         data_rvalid_i,</pre>
<pre>    input  logic         data_err_i,</pre>
<pre>    input  logic         data_pmp_err_i,</pre>
<pre>    output logic [31:0]  data_addr_o,</pre>
<pre>    output logic         data_we_o,</pre>
<pre>    output logic [3:0]   data_be_o,</pre>
<pre>    output logic [31:0]  data_wdata_o,</pre>
<pre>    input  logic [31:0]  data_rdata_i,</pre>
<pre>    input  logic         data_we_ex_i,         // write enable                     -> from ID/EX</pre>
<pre>    input  logic [1:0]   data_type_ex_i,       // data type: word, half word, byte -> from ID/EX</pre>
<pre>    input  logic [31:0]  data_wdata_ex_i,      // data to write to memory          -> from ID/EX</pre>
<pre>    input  logic         data_sign_ext_ex_i,   // sign extension                   -> from ID/EX</pre>
<pre>    output logic [31:0]  data_rdata_ex_o,      // requested data                   -> to ID/EX</pre>
<pre>    input  logic         data_req_ex_i,        // data request                     -> from ID/EX</pre>
<pre>    input  logic [31:0]  adder_result_ex_i,    // address computed in ALU          -> from ID/EX</pre>
<pre>    output logic         addr_incr_req_o,      // request address increment for</pre>
<pre>    output logic [31:0]  addr_last_o,          // address of last transaction      -> to controller</pre>
<pre>    output logic         data_valid_o,         // LSU has completed transaction    -> to ID/EX</pre>
<pre>    output logic         load_err_o,</pre>
<pre>    output logic         store_err_o,</pre>
<pre>    output logic         busy_o</pre>
<pre>  logic [31:0]  data_addr;</pre>
<pre>  logic [31:0]  data_addr_w_aligned;</pre>
<pre>  logic [31:0]  addr_last_q;</pre>
<pre>  logic         addr_update;</pre>
<pre>  logic         ctrl_update;</pre>
<pre>  logic         rdata_update;</pre>
<pre>  logic [31:8]  rdata_q;</pre>
<pre>  logic [1:0]   rdata_offset_q;</pre>
<pre>  logic [1:0]   data_type_q;</pre>
<pre>  logic         data_sign_ext_q;</pre>
<pre>  logic         data_we_q;</pre>
<pre>  logic [1:0]   data_offset;   // mux control for data to be written to memory</pre>
<pre>  logic [3:0]   data_be;</pre>
<pre>  logic [31:0]  data_wdata;</pre>
<pre>  logic [31:0]  data_rdata_ext;</pre>
<pre>  logic [31:0]  rdata_w_ext; // word realignment for misaligned loads</pre>
<pre>  logic [31:0]  rdata_h_ext; // sign extension for half words</pre>
<pre>  logic [31:0]  rdata_b_ext; // sign extension for bytes</pre>
<pre>  logic         split_misaligned_access;</pre>
<pre>  logic         handle_misaligned_q, handle_misaligned_d; // high after receiving grant for first</pre>
<pre>  logic         pmp_err_q, pmp_err_d;</pre>
<pre>  logic         lsu_err_q, lsu_err_d;</pre>
<pre>  logic         data_or_pmp_err;</pre>
<pre>  typedef enum logic [2:0]  {</pre>
<pre>    IDLE, WAIT_GNT_MIS, WAIT_RVALID_MIS, WAIT_GNT, WAIT_RVALID,</pre>
<pre>    WAIT_RVALID_DONE</pre>
<pre>  } ls_fsm_e;</pre>
<pre>  ls_fsm_e ls_fsm_cs, ls_fsm_ns;</pre>
<pre>  assign data_addr   = adder_result_ex_i;</pre>
<pre>  assign data_offset = data_addr[1:0];</pre>
<pre>  always_comb begin</pre>
<pre>    unique case (data_type_ex_i) // Data type 00 Word, 01 Half word, 11,10 byte</pre>
<pre>      2'b00: begin // Writing a word</pre>
<pre>        if (!handle_misaligned_q) begin // first part of potentially misaligned transaction</pre>
<pre>          unique case (data_offset)</pre>
<pre>            2'b00:   data_be = 4'b1111;</pre>
<pre>            2'b01:   data_be = 4'b1110;</pre>
<pre>            2'b10:   data_be = 4'b1100;</pre>
<pre>            2'b11:   data_be = 4'b1000;</pre>
<pre>            default: data_be = 4'b1111;</pre>
<pre>        end else begin // second part of misaligned transaction</pre>
<pre>          unique case (data_offset)</pre>
<pre>            2'b00:   data_be = 4'b0000; // this is not used, but included for completeness</pre>
<pre>            2'b01:   data_be = 4'b0001;</pre>
<pre>            2'b10:   data_be = 4'b0011;</pre>
<pre>            2'b11:   data_be = 4'b0111;</pre>
<pre>            default: data_be = 4'b1111;</pre>
<pre>      2'b01: begin // Writing a half word</pre>
<pre>        if (!handle_misaligned_q) begin // first part of potentially misaligned transaction</pre>
<pre>          unique case (data_offset)</pre>
<pre>            2'b00:   data_be = 4'b0011;</pre>
<pre>            2'b01:   data_be = 4'b0110;</pre>
<pre>            2'b10:   data_be = 4'b1100;</pre>
<pre>            2'b11:   data_be = 4'b1000;</pre>
<pre>            default: data_be = 4'b1111;</pre>
<pre>        end else begin // second part of misaligned transaction</pre>
<pre>          data_be = 4'b0001;</pre>
<pre>      2'b10,</pre>
<pre>      2'b11: begin // Writing a byte</pre>
<pre>        unique case (data_offset)</pre>
<pre>          2'b00:   data_be = 4'b0001;</pre>
<pre>          2'b01:   data_be = 4'b0010;</pre>
<pre>          2'b10:   data_be = 4'b0100;</pre>
<pre>          2'b11:   data_be = 4'b1000;</pre>
<pre>          default: data_be = 4'b1111;</pre>
<pre>      default:     data_be = 4'b1111;</pre>
<pre>  always_comb begin</pre>
<pre>    unique case (data_offset)</pre>
<pre>      2'b00:   data_wdata =  data_wdata_ex_i[31:0];</pre>
<pre>      2'b01:   data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};</pre>
<pre>      2'b10:   data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};</pre>
<pre>      2'b11:   data_wdata = {data_wdata_ex_i[ 7:0], data_wdata_ex_i[31: 8]};</pre>
<pre>      default: data_wdata =  data_wdata_ex_i[31:0];</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rdata_q <= '0;</pre>
<pre>    end else if (rdata_update) begin</pre>
<pre>      rdata_q <= data_rdata_i[31:8];</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rdata_offset_q  <= 2'h0;</pre>
<pre>      data_type_q     <= 2'h0;</pre>
<pre>      data_sign_ext_q <= 1'b0;</pre>
<pre>      data_we_q       <= 1'b0;</pre>
<pre>    end else if (ctrl_update) begin</pre>
<pre>      rdata_offset_q  <= data_offset;</pre>
<pre>      data_type_q     <= data_type_ex_i;</pre>
<pre>      data_sign_ext_q <= data_sign_ext_ex_i;</pre>
<pre>      data_we_q       <= data_we_ex_i;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      addr_last_q <= '0;</pre>
<pre>    end else if (addr_update) begin</pre>
<pre>      addr_last_q <= data_addr;</pre>
<pre>  always_comb begin</pre>
<pre>    unique case (rdata_offset_q)</pre>
<pre>      2'b00:   rdata_w_ext =  data_rdata_i[31:0];</pre>
<pre>      2'b01:   rdata_w_ext = {data_rdata_i[ 7:0], rdata_q[31:8]};</pre>
<pre>      2'b10:   rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};</pre>
<pre>      2'b11:   rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};</pre>
<pre>      default: rdata_w_ext =  data_rdata_i[31:0];</pre>
<pre>  always_comb begin</pre>
<pre>    unique case (rdata_offset_q)</pre>
<pre>      2'b00: begin</pre>
<pre>        if (!data_sign_ext_q) begin</pre>
<pre>          rdata_h_ext = {16'h0000, data_rdata_i[15:0]};</pre>
<pre>        end else begin</pre>
<pre>          rdata_h_ext = {{16{data_rdata_i[15]}}, data_rdata_i[15:0]};</pre>
<pre>      2'b01: begin</pre>
<pre>        if (!data_sign_ext_q) begin</pre>
<pre>          rdata_h_ext = {16'h0000, data_rdata_i[23:8]};</pre>
<pre>        end else begin</pre>
<pre>          rdata_h_ext = {{16{data_rdata_i[23]}}, data_rdata_i[23:8]};</pre>
<pre>      2'b10: begin</pre>
<pre>        if (!data_sign_ext_q) begin</pre>
<pre>          rdata_h_ext = {16'h0000, data_rdata_i[31:16]};</pre>
<pre>        end else begin</pre>
<pre>          rdata_h_ext = {{16{data_rdata_i[31]}}, data_rdata_i[31:16]};</pre>
<pre>      2'b11: begin</pre>
<pre>        if (!data_sign_ext_q) begin</pre>
<pre>          rdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};</pre>
<pre>        end else begin</pre>
<pre>          rdata_h_ext = {{16{data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};</pre>
<pre>      default: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};</pre>
<pre>  always_comb begin</pre>
<pre>    unique case (rdata_offset_q)</pre>
<pre>      2'b00: begin</pre>
<pre>        if (!data_sign_ext_q) begin</pre>
<pre>          rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};</pre>
<pre>        end else begin</pre>
<pre>          rdata_b_ext = {{24{data_rdata_i[7]}}, data_rdata_i[7:0]};</pre>
<pre>      2'b01: begin</pre>
<pre>        if (!data_sign_ext_q) begin</pre>
<pre>          rdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};</pre>
<pre>        end else begin</pre>
<pre>          rdata_b_ext = {{24{data_rdata_i[15]}}, data_rdata_i[15:8]};</pre>
<pre>      2'b10: begin</pre>
<pre>        if (!data_sign_ext_q) begin</pre>
<pre>          rdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};</pre>
<pre>        end else begin</pre>
<pre>          rdata_b_ext = {{24{data_rdata_i[23]}}, data_rdata_i[23:16]};</pre>
<pre>      2'b11: begin</pre>
<pre>        if (!data_sign_ext_q) begin</pre>
<pre>          rdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};</pre>
<pre>        end else begin</pre>
<pre>          rdata_b_ext = {{24{data_rdata_i[31]}}, data_rdata_i[31:24]};</pre>
<pre>      default: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};</pre>
<pre>  always_comb begin</pre>
<pre>    unique case (data_type_q)</pre>
<pre>      2'b00:       data_rdata_ext = rdata_w_ext;</pre>
<pre>      2'b01:       data_rdata_ext = rdata_h_ext;</pre>
<pre>      2'b10,2'b11: data_rdata_ext = rdata_b_ext;</pre>
<pre>      default:     data_rdata_ext = rdata_w_ext;</pre>
<pre>  assign split_misaligned_access =</pre>
<pre>      ((data_type_ex_i == 2'b00) && (data_offset != 2'b00)) || // misaligned word access</pre>
<pre>      ((data_type_ex_i == 2'b01) && (data_offset == 2'b11));   // misaligned half-word access</pre>
<pre>  always_comb begin</pre>
<pre>    ls_fsm_ns       = ls_fsm_cs;</pre>
<pre>    data_req_o          = 1'b0;</pre>
<pre>    data_valid_o        = 1'b0;</pre>
<pre>    addr_incr_req_o     = 1'b0;</pre>
<pre>    handle_misaligned_d = handle_misaligned_q;</pre>
<pre>    data_or_pmp_err     = 1'b0;</pre>
<pre>    pmp_err_d           = pmp_err_q;</pre>
<pre>    lsu_err_d           = lsu_err_q;</pre>
<pre>    addr_update         = 1'b0;</pre>
<pre>    ctrl_update         = 1'b0;</pre>
<pre>    rdata_update        = 1'b0;</pre>
<pre>    unique case (ls_fsm_cs)</pre>
<pre>      IDLE: begin</pre>
<pre>        if (data_req_ex_i) begin</pre>
<pre>          data_req_o = 1'b1;</pre>
<pre>          pmp_err_d  = data_pmp_err_i;</pre>
<pre>          lsu_err_d  = 1'b0;</pre>
<pre>          if (data_gnt_i) begin</pre>
<pre>            ctrl_update         = 1'b1;</pre>
<pre>            addr_update         = 1'b1;</pre>
<pre>            handle_misaligned_d = split_misaligned_access;</pre>
<pre>            ls_fsm_ns           = split_misaligned_access ? WAIT_RVALID_MIS : WAIT_RVALID;</pre>
<pre>          end else begin</pre>
<pre>            ls_fsm_ns           = split_misaligned_access ? WAIT_GNT_MIS    : WAIT_GNT;</pre>
<pre>      WAIT_GNT_MIS: begin</pre>
<pre>        data_req_o = 1'b1;</pre>
<pre>        if (data_gnt_i || pmp_err_q) begin</pre>
<pre>          addr_update         = 1'b1;</pre>
<pre>          ctrl_update         = 1'b1;</pre>
<pre>          handle_misaligned_d = 1'b1;</pre>
<pre>          ls_fsm_ns           = WAIT_RVALID_MIS;</pre>
<pre>      WAIT_RVALID_MIS: begin</pre>
<pre>        data_req_o = 1'b1;</pre>
<pre>        addr_incr_req_o = 1'b1;</pre>
<pre>        if (data_rvalid_i || pmp_err_q) begin</pre>
<pre>          pmp_err_d = data_pmp_err_i;</pre>
<pre>          lsu_err_d = data_err_i | pmp_err_q;</pre>
<pre>          rdata_update = ~data_we_q;</pre>
<pre>          ls_fsm_ns = data_gnt_i ? WAIT_RVALID : WAIT_GNT;</pre>
<pre>          addr_update = data_gnt_i & ~(data_err_i | pmp_err_q);</pre>
<pre>        end else begin</pre>
<pre>          if (data_gnt_i) begin</pre>
<pre>            ls_fsm_ns = WAIT_RVALID_DONE;</pre>
<pre>      WAIT_GNT: begin</pre>
<pre>        addr_incr_req_o = handle_misaligned_q;</pre>
<pre>        data_req_o      = 1'b1;</pre>
<pre>        if (data_gnt_i || pmp_err_q) begin</pre>
<pre>          ctrl_update = 1'b1;</pre>
<pre>          addr_update = ~lsu_err_q;</pre>
<pre>          ls_fsm_ns   = WAIT_RVALID;</pre>
<pre>      WAIT_RVALID: begin</pre>
<pre>        if (data_rvalid_i || pmp_err_q) begin</pre>
<pre>          data_valid_o        = 1'b1;</pre>
<pre>          data_or_pmp_err     = lsu_err_q | data_err_i | pmp_err_q;</pre>
<pre>          handle_misaligned_d = 1'b0;</pre>
<pre>          ls_fsm_ns           = IDLE;</pre>
<pre>        end else begin</pre>
<pre>          ls_fsm_ns           = WAIT_RVALID;</pre>
<pre>      WAIT_RVALID_DONE: begin</pre>
<pre>        addr_incr_req_o = 1'b1;</pre>
<pre>        if (data_rvalid_i) begin</pre>
<pre>          pmp_err_d = data_pmp_err_i;</pre>
<pre>          lsu_err_d = data_err_i;</pre>
<pre>          addr_update = ~data_err_i;</pre>
<pre>          rdata_update = ~data_we_q;</pre>
<pre>          ls_fsm_ns = WAIT_RVALID;</pre>
<pre>      default: begin</pre>
<pre>        ls_fsm_ns = IDLE;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      ls_fsm_cs           <= IDLE;</pre>
<pre>      handle_misaligned_q <= '0;</pre>
<pre>      pmp_err_q           <= '0;</pre>
<pre>      lsu_err_q           <= '0;</pre>
<pre>    end else begin</pre>
<pre>      ls_fsm_cs           <= ls_fsm_ns;</pre>
<pre>      handle_misaligned_q <= handle_misaligned_d;</pre>
<pre>      pmp_err_q           <= pmp_err_d;</pre>
<pre>      lsu_err_q           <= lsu_err_d;</pre>
<pre>  assign data_rdata_ex_o = data_rdata_ext;</pre>
<pre>  assign data_addr_w_aligned = {data_addr[31:2], 2'b00};</pre>
<pre>  assign data_addr_o   = data_addr_w_aligned;</pre>
<pre>  assign data_wdata_o  = data_wdata;</pre>
<pre>  assign data_we_o     = data_we_ex_i;</pre>
<pre>  assign data_be_o     = data_be;</pre>
<pre>  assign addr_last_o   = addr_last_q;</pre>
<pre>  assign load_err_o    = data_or_pmp_err & ~data_we_q;</pre>
<pre>  assign store_err_o   = data_or_pmp_err &  data_we_q;</pre>
<pre>  assign busy_o = (ls_fsm_cs != IDLE);</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_prefetch_buffer.sv</h3>
<pre>    input  logic        clk_i,</pre>
<pre>    input  logic        rst_ni,</pre>
<pre>    input  logic        req_i,</pre>
<pre>    input  logic        branch_i,</pre>
<pre>    input  logic [31:0] addr_i,</pre>
<pre>    input  logic        ready_i,</pre>
<pre>    output logic        valid_o,</pre>
<pre>    output logic [31:0] rdata_o,</pre>
<pre>    output logic [31:0] addr_o,</pre>
<pre>    output logic        err_o,</pre>
<pre>    output logic        instr_req_o,</pre>
<pre>    input  logic        instr_gnt_i,</pre>
<pre>    output logic [31:0] instr_addr_o,</pre>
<pre>    input  logic [31:0] instr_rdata_i,</pre>
<pre>    input  logic        instr_err_i,</pre>
<pre>    input  logic        instr_pmp_err_i,</pre>
<pre>    input  logic        instr_rvalid_i,</pre>
<pre>    output logic        busy_o</pre>
<pre>  localparam int unsigned NUM_REQS  = 2;</pre>
<pre>  logic                valid_new_req, valid_req;</pre>
<pre>  logic                valid_req_d, valid_req_q;</pre>
<pre>  logic                discard_req_d, discard_req_q;</pre>
<pre>  logic                gnt_or_pmp_err, rvalid_or_pmp_err;</pre>
<pre>  logic [NUM_REQS-1:0] rdata_outstanding_n, rdata_outstanding_s, rdata_outstanding_q;</pre>
<pre>  logic [NUM_REQS-1:0] branch_discard_n, branch_discard_s, branch_discard_q;</pre>
<pre>  logic [NUM_REQS-1:0] rdata_pmp_err_n, rdata_pmp_err_s, rdata_pmp_err_q;</pre>
<pre>  logic [31:0]         stored_addr_d, stored_addr_q;</pre>
<pre>  logic                stored_addr_en;</pre>
<pre>  logic [31:0]         fetch_addr_d, fetch_addr_q;</pre>
<pre>  logic                fetch_addr_en;</pre>
<pre>  logic [31:0]         instr_addr, instr_addr_w_aligned;</pre>
<pre>  logic                instr_or_pmp_err;</pre>
<pre>  logic                fifo_valid;</pre>
<pre>  logic                fifo_ready;</pre>
<pre>  logic                fifo_clear;</pre>
<pre>  assign busy_o = (|rdata_outstanding_q) | instr_req_o;</pre>
<pre>  assign instr_or_pmp_err = instr_err_i | rdata_pmp_err_q[0];</pre>
<pre>  assign fifo_clear = branch_i;</pre>
<pre>  ibex_fetch_fifo #(</pre>
<pre>    .NUM_REQS (NUM_REQS)</pre>
<pre style="background-color: #FF0000;">  ) fifo_i (</pre>
<pre>      .clk_i                 ( clk_i             ),</pre>
<pre>      .rst_ni                ( rst_ni            ),</pre>
<pre>      .clear_i               ( fifo_clear        ),</pre>
<pre>      .in_valid_i            ( fifo_valid        ),</pre>
<pre>      .in_addr_i             ( addr_i            ),</pre>
<pre>      .in_rdata_i            ( instr_rdata_i     ),</pre>
<pre>      .in_err_i              ( instr_or_pmp_err  ),</pre>
<pre>      .in_ready_o            ( fifo_ready        ),</pre>
<pre>      .out_valid_o           ( valid_o           ),</pre>
<pre>      .out_ready_i           ( ready_i           ),</pre>
<pre>      .out_rdata_o           ( rdata_o           ),</pre>
<pre>      .out_addr_o            ( addr_o            ),</pre>
<pre>      .out_err_o             ( err_o             )</pre>
<pre>  assign valid_new_req = req_i & (fifo_ready | branch_i) & ~rdata_outstanding_q[NUM_REQS-1];</pre>
<pre>  assign valid_req = valid_req_q | valid_new_req;</pre>
<pre>  assign gnt_or_pmp_err = instr_gnt_i | instr_pmp_err_i;</pre>
<pre>  assign rvalid_or_pmp_err = rdata_outstanding_q[0] & (instr_rvalid_i | rdata_pmp_err_q[0]);</pre>
<pre>  assign valid_req_d = valid_req & ~gnt_or_pmp_err;</pre>
<pre>  assign discard_req_d = valid_req_q & (branch_i | discard_req_q);</pre>
<pre>  assign stored_addr_en = valid_new_req & ~valid_req_q & ~gnt_or_pmp_err;</pre>
<pre>  assign stored_addr_d = instr_addr;</pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>    if (stored_addr_en) begin</pre>
<pre>      stored_addr_q <= stored_addr_d;</pre>
<pre>  assign fetch_addr_en = branch_i | (valid_new_req & ~valid_req_q);</pre>
<pre>  assign fetch_addr_d = (branch_i ? addr_i : </pre>
<pre>                                    {fetch_addr_q[31:2], 2'b00}) +</pre>
<pre>                        {{29{1'b0}},(valid_new_req & ~valid_req_q),2'b00};</pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>    if (fetch_addr_en) begin</pre>
<pre>      fetch_addr_q <= fetch_addr_d;</pre>
<pre>  assign instr_addr = valid_req_q ? stored_addr_q :</pre>
<pre>                      branch_i    ? addr_i :</pre>
<pre>                                    fetch_addr_q;</pre>
<pre>  assign instr_addr_w_aligned = {instr_addr[31:2], 2'b00};</pre>
<pre>  for (genvar i = 0; i < NUM_REQS; i++) begin : g_outstanding_reqs</pre>
<pre>    if (i == 0) begin : g_req0</pre>
<pre>      assign rdata_outstanding_n[i] = (valid_req & gnt_or_pmp_err) |</pre>
<pre>                                      rdata_outstanding_q[i];</pre>
<pre>      assign branch_discard_n[i]    = (valid_req & gnt_or_pmp_err & discard_req_d) |</pre>
<pre>                                      (branch_i & rdata_outstanding_q[i]) | branch_discard_q[i];</pre>
<pre>      assign rdata_pmp_err_n[i]     = (valid_req & ~rdata_outstanding_q[i] & instr_pmp_err_i) |</pre>
<pre>                                      rdata_pmp_err_q[i];</pre>
<pre>    end else begin : g_reqtop</pre>
<pre>      assign rdata_outstanding_n[i] = (valid_req & gnt_or_pmp_err &</pre>
<pre>                                       rdata_outstanding_q[i-1]) |</pre>
<pre>                                      rdata_outstanding_q[i];</pre>
<pre>      assign branch_discard_n[i]    = (valid_req & gnt_or_pmp_err & discard_req_d &</pre>
<pre>                                       rdata_outstanding_q[i-1]) |</pre>
<pre>                                      (branch_i & rdata_outstanding_q[i]) | branch_discard_q[i];</pre>
<pre>      assign rdata_pmp_err_n[i]     = (valid_req & ~rdata_outstanding_q[i] & instr_pmp_err_i &</pre>
<pre>                                       rdata_outstanding_q[i-1]) |</pre>
<pre>                                      rdata_pmp_err_q[i];</pre>
<pre>  assign rdata_outstanding_s = rvalid_or_pmp_err ? {1'b0,rdata_outstanding_n[NUM_REQS-1:1]} :</pre>
<pre>                                                   rdata_outstanding_n;</pre>
<pre>  assign branch_discard_s    = rvalid_or_pmp_err ? {1'b0,branch_discard_n[NUM_REQS-1:1]} :</pre>
<pre>                                                   branch_discard_n;</pre>
<pre>  assign rdata_pmp_err_s     = rvalid_or_pmp_err ? {1'b0,rdata_pmp_err_n[NUM_REQS-1:1]} :</pre>
<pre>                                                   rdata_pmp_err_n;</pre>
<pre>  assign fifo_valid = rvalid_or_pmp_err & ~branch_discard_q[0];</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      valid_req_q          <= 1'b0;</pre>
<pre>      discard_req_q        <= 1'b0;</pre>
<pre>      rdata_outstanding_q  <= 'b0;</pre>
<pre>      branch_discard_q     <= 'b0;</pre>
<pre>      rdata_pmp_err_q      <= 'b0;</pre>
<pre>    end else begin</pre>
<pre>      valid_req_q          <= valid_req_d;</pre>
<pre>      discard_req_q        <= discard_req_d;</pre>
<pre>      rdata_outstanding_q  <= rdata_outstanding_s;</pre>
<pre>      branch_discard_q     <= branch_discard_s;</pre>
<pre>      rdata_pmp_err_q      <= rdata_pmp_err_s;</pre>
<pre>  assign instr_req_o  = valid_req;</pre>
<pre>  assign instr_addr_o = instr_addr_w_aligned;</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_alu.sv</h3>
<pre>    input  ibex_pkg::alu_op_e operator_i,</pre>
<pre>    input  logic [31:0]       operand_a_i,</pre>
<pre>    input  logic [31:0]       operand_b_i,</pre>
<pre>    input  logic [32:0]       multdiv_operand_a_i,</pre>
<pre>    input  logic [32:0]       multdiv_operand_b_i,</pre>
<pre>    input  logic              multdiv_en_i,</pre>
<pre>    output logic [31:0]       adder_result_o,</pre>
<pre>    output logic [33:0]       adder_result_ext_o,</pre>
<pre>    output logic [31:0]       result_o,</pre>
<pre>    output logic              comparison_result_o,</pre>
<pre>    output logic              is_equal_result_o</pre>
<pre>  logic [31:0] operand_a_rev;</pre>
<pre>  logic [32:0] operand_b_neg;</pre>
<pre>  for (genvar k = 0; k < 32; k++) begin : gen_rev_operand_a</pre>
<pre>    assign operand_a_rev[k] = operand_a_i[31-k];</pre>
<pre>  logic        adder_op_b_negate;</pre>
<pre>  logic [32:0] adder_in_a, adder_in_b;</pre>
<pre>  logic [31:0] adder_result;</pre>
<pre>  always_comb begin</pre>
<pre>    adder_op_b_negate = 1'b0;</pre>
<pre>    unique case (operator_i)</pre>
<pre>      ALU_SUB,</pre>
<pre>      ALU_EQ,   ALU_NE,</pre>
<pre>      ALU_GE,   ALU_GEU,</pre>
<pre>      ALU_LT,   ALU_LTU,</pre>
<pre>      ALU_SLT,  ALU_SLTU: adder_op_b_negate = 1'b1;</pre>
<pre>      default:;</pre>
<pre>  assign adder_in_a    = multdiv_en_i ? multdiv_operand_a_i : {operand_a_i,1'b1};</pre>
<pre>  assign operand_b_neg = {operand_b_i,1'b0} ^ {33{adder_op_b_negate}};</pre>
<pre>  assign adder_in_b    = multdiv_en_i ? multdiv_operand_b_i : operand_b_neg ;</pre>
<pre>  assign adder_result_ext_o = $unsigned(adder_in_a) + $unsigned(adder_in_b);</pre>
<pre>  assign adder_result       = adder_result_ext_o[32:1];</pre>
<pre>  assign adder_result_o     = adder_result;</pre>
<pre>  logic        shift_left;         // should we shift left</pre>
<pre>  logic        shift_arithmetic;</pre>
<pre>  logic  [4:0] shift_amt;          // amount of shift, to the right</pre>
<pre>  logic [31:0] shift_op_a;         // input of the shifter</pre>
<pre>  logic [31:0] shift_result;</pre>
<pre>  logic [31:0] shift_right_result;</pre>
<pre>  logic [31:0] shift_left_result;</pre>
<pre>  assign shift_amt = operand_b_i[4:0];</pre>
<pre>  assign shift_left = (operator_i == ALU_SLL);</pre>
<pre>  assign shift_arithmetic = (operator_i == ALU_SRA);</pre>
<pre>  assign shift_op_a    = shift_left ? operand_a_rev : operand_a_i;</pre>
<pre>  logic [32:0] shift_op_a_32;</pre>
<pre>  assign shift_op_a_32 = {shift_arithmetic & shift_op_a[31], shift_op_a};</pre>
<pre>  logic signed [32:0] shift_right_result_signed;</pre>
<pre>  logic        [32:0] shift_right_result_ext;</pre>
<pre>  assign shift_right_result_signed = $signed(shift_op_a_32) >>> shift_amt[4:0];</pre>
<pre>  assign shift_right_result_ext    = $unsigned(shift_right_result_signed);</pre>
<pre>  assign shift_right_result        = shift_right_result_ext[31:0];</pre>
<pre>  for (genvar j = 0; j < 32; j++) begin : gen_rev_shift_right_result</pre>
<pre>    assign shift_left_result[j] = shift_right_result[31-j];</pre>
<pre>  assign shift_result = shift_left ? shift_left_result : shift_right_result;</pre>
<pre>  logic is_equal;</pre>
<pre>  logic is_greater_equal;  // handles both signed and unsigned forms</pre>
<pre>  logic cmp_signed;</pre>
<pre>  always_comb begin</pre>
<pre>    cmp_signed = 1'b0;</pre>
<pre>    unique case (operator_i)</pre>
<pre>      ALU_GE,</pre>
<pre>      ALU_LT,</pre>
<pre>      ALU_SLT: begin</pre>
<pre>        cmp_signed = 1'b1;</pre>
<pre>      default:;</pre>
<pre>  assign is_equal = (adder_result == 32'b0);</pre>
<pre>  assign is_equal_result_o = is_equal;</pre>
<pre>  always_comb begin</pre>
<pre>    if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin</pre>
<pre>      is_greater_equal = (adder_result[31] == 1'b0);</pre>
<pre>    end else begin</pre>
<pre>      is_greater_equal = operand_a_i[31] ^ (cmp_signed);</pre>
<pre>  logic cmp_result;</pre>
<pre>  always_comb begin</pre>
<pre>    cmp_result = is_equal;</pre>
<pre>    unique case (operator_i)</pre>
<pre>      ALU_EQ:            cmp_result =  is_equal;</pre>
<pre>      ALU_NE:            cmp_result = ~is_equal;</pre>
<pre>      ALU_GE,  ALU_GEU:  cmp_result = is_greater_equal;</pre>
<pre>      ALU_LT,  ALU_LTU,</pre>
<pre>      ALU_SLT, ALU_SLTU: cmp_result = ~is_greater_equal;</pre>
<pre>      default:;</pre>
<pre>  assign comparison_result_o = cmp_result;</pre>
<pre>  always_comb begin</pre>
<pre>    result_o   = '0;</pre>
<pre>    unique case (operator_i)</pre>
<pre>      ALU_AND:  result_o = operand_a_i & operand_b_i;</pre>
<pre>      ALU_OR:   result_o = operand_a_i | operand_b_i;</pre>
<pre>      ALU_XOR:  result_o = operand_a_i ^ operand_b_i;</pre>
<pre>      ALU_ADD, ALU_SUB: result_o = adder_result;</pre>
<pre>      ALU_SLL,</pre>
<pre>      ALU_SRL, ALU_SRA: result_o = shift_result;</pre>
<pre>      ALU_EQ,   ALU_NE,</pre>
<pre>      ALU_GE,   ALU_GEU,</pre>
<pre>      ALU_LT,   ALU_LTU,</pre>
<pre>      ALU_SLT,  ALU_SLTU: result_o = {31'h0,cmp_result};</pre>
<pre>      default:;</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_if_stage.sv</h3>
<pre>module ibex_if_stage #(</pre>
<pre>    parameter int unsigned DmHaltAddr      = 32'h1A110800,</pre>
<pre>    parameter int unsigned DmExceptionAddr = 32'h1A110808</pre>
<pre>    input  logic                   clk_i,</pre>
<pre>    input  logic                   rst_ni,</pre>
<pre>    input  logic [31:0]            boot_addr_i,              // also used for mtvec</pre>
<pre>    input  logic                   req_i,                    // instruction request control</pre>
<pre>    output logic                  instr_req_o,</pre>
<pre>    output logic [31:0]           instr_addr_o,</pre>
<pre>    input  logic                  instr_gnt_i,</pre>
<pre>    input  logic                  instr_rvalid_i,</pre>
<pre>    input  logic [31:0]           instr_rdata_i,</pre>
<pre>    input  logic                  instr_err_i,</pre>
<pre>    input  logic                  instr_pmp_err_i,</pre>
<pre>    output logic                  instr_valid_id_o,         // instr in IF-ID is valid</pre>
<pre>    output logic                  instr_new_id_o,           // instr in IF-ID is new</pre>
<pre>    output logic [31:0]           instr_rdata_id_o,         // instr for ID stage</pre>
<pre>    output logic [15:0]           instr_rdata_c_id_o,       // compressed instr for ID stage</pre>
<pre>    output logic                  instr_is_compressed_id_o, // compressed decoder thinks this</pre>
<pre>    output logic                  instr_fetch_err_o,        // bus error on fetch</pre>
<pre>    output logic                  illegal_c_insn_id_o,      // compressed decoder thinks this</pre>
<pre>    output logic [31:0]           pc_if_o,</pre>
<pre>    output logic [31:0]           pc_id_o,</pre>
<pre>    input  logic                  instr_valid_clear_i,      // clear instr valid bit in IF-ID</pre>
<pre>    input  logic                  pc_set_i,                 // set the PC to a new value</pre>
<pre>    input  ibex_pkg::pc_sel_e     pc_mux_i,                 // selector for PC multiplexer</pre>
<pre>    input  ibex_pkg::exc_pc_sel_e exc_pc_mux_i,             // selects ISR address</pre>
<pre>    input  ibex_pkg::exc_cause_e  exc_cause,                // selects ISR address for</pre>
<pre>    input  logic [31:0]           jump_target_ex_i,         // jump target address</pre>
<pre>    input  logic [31:0]           csr_mepc_i,               // PC to restore after handling</pre>
<pre>    input  logic [31:0]           csr_depc_i,               // PC to restore after handling</pre>
<pre>    input  logic [31:0]           csr_mtvec_i,              // base PC to jump to on exception</pre>
<pre>    output logic                  csr_mtvec_init_o,         // tell CS regfile to init mtvec</pre>
<pre>    input  logic                  id_in_ready_i,            // ID stage is ready for new instr</pre>
<pre>    output logic                  if_busy_o,                // IF stage is busy fetching instr</pre>
<pre>    output logic                  perf_imiss_o              // instr fetch miss</pre>
<pre>  logic              offset_in_init_d, offset_in_init_q;</pre>
<pre>  logic              have_instr;</pre>
<pre>  logic              prefetch_busy;</pre>
<pre>  logic              branch_req;</pre>
<pre>  logic       [31:0] fetch_addr_n;</pre>
<pre>  logic              fetch_valid;</pre>
<pre>  logic              fetch_ready;</pre>
<pre>  logic       [31:0] fetch_rdata;</pre>
<pre>  logic       [31:0] fetch_addr;</pre>
<pre>  logic              fetch_err;</pre>
<pre>  logic       [31:0] exc_pc;</pre>
<pre>  logic        [5:0] irq_id;</pre>
<pre>  logic              unused_irq_bit;</pre>
<pre>  logic              if_id_pipe_reg_we; // IF-ID pipeline reg write enable</pre>
<pre>  logic        [7:0] unused_boot_addr;</pre>
<pre>  logic        [7:0] unused_csr_mtvec;</pre>
<pre>  assign unused_boot_addr = boot_addr_i[7:0];</pre>
<pre>  assign unused_csr_mtvec = csr_mtvec_i[7:0];</pre>
<pre>  assign irq_id         = {exc_cause};</pre>
<pre>  assign unused_irq_bit = irq_id[5];   // MSB distinguishes interrupts from exceptions</pre>
<pre>  always_comb begin : exc_pc_mux</pre>
<pre>    unique case (exc_pc_mux_i)</pre>
<pre>      EXC_PC_EXC:     exc_pc = { csr_mtvec_i[31:8], 8'h00                    };</pre>
<pre>      EXC_PC_IRQ:     exc_pc = { csr_mtvec_i[31:8], 1'b0, irq_id[4:0], 2'b00 };</pre>
<pre>      EXC_PC_DBD:     exc_pc = DmHaltAddr;</pre>
<pre>      EXC_PC_DBG_EXC: exc_pc = DmExceptionAddr;</pre>
<pre>      default:        exc_pc = { csr_mtvec_i[31:8], 8'h00                    };</pre>
<pre>  always_comb begin : fetch_addr_mux</pre>
<pre>    unique case (pc_mux_i)</pre>
<pre>      PC_BOOT: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };</pre>
<pre>      PC_JUMP: fetch_addr_n = jump_target_ex_i;</pre>
<pre>      PC_EXC:  fetch_addr_n = exc_pc;                       // set PC to exception handler</pre>
<pre>      PC_ERET: fetch_addr_n = csr_mepc_i;                   // restore PC when returning from EXC</pre>
<pre>      PC_DRET: fetch_addr_n = csr_depc_i;</pre>
<pre>      default: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };</pre>
<pre>  assign csr_mtvec_init_o = (pc_mux_i == PC_BOOT) & pc_set_i;</pre>
<pre>  ibex_prefetch_buffer prefetch_buffer_i (</pre>
<pre>      .clk_i             ( clk_i                       ),</pre>
<pre>      .rst_ni            ( rst_ni                      ),</pre>
<pre>      .req_i             ( req_i                       ),</pre>
<pre>      .branch_i          ( branch_req                  ),</pre>
<pre>      .addr_i            ( {fetch_addr_n[31:1], 1'b0}  ),</pre>
<pre>      .ready_i           ( fetch_ready                 ),</pre>
<pre>      .valid_o           ( fetch_valid                 ),</pre>
<pre>      .rdata_o           ( fetch_rdata                 ),</pre>
<pre>      .addr_o            ( fetch_addr                  ),</pre>
<pre>      .err_o             ( fetch_err                   ),</pre>
<pre>      .instr_req_o       ( instr_req_o                 ),</pre>
<pre>      .instr_addr_o      ( instr_addr_o                ),</pre>
<pre>      .instr_gnt_i       ( instr_gnt_i                 ),</pre>
<pre>      .instr_rvalid_i    ( instr_rvalid_i              ),</pre>
<pre>      .instr_rdata_i     ( instr_rdata_i               ),</pre>
<pre>      .instr_err_i       ( instr_err_i                 ),</pre>
<pre>      .instr_pmp_err_i   ( instr_pmp_err_i             ),</pre>
<pre>      .busy_o            ( prefetch_busy               )</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      offset_in_init_q <= 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      offset_in_init_q <= offset_in_init_d;</pre>
<pre>  always_comb begin</pre>
<pre>    offset_in_init_d = offset_in_init_q;</pre>
<pre>    fetch_ready      = 1'b0;</pre>
<pre>    branch_req       = 1'b0;</pre>
<pre>    have_instr       = 1'b0;</pre>
<pre>    if (offset_in_init_q) begin</pre>
<pre>      if (req_i) begin</pre>
<pre>        branch_req       = 1'b1;</pre>
<pre>        offset_in_init_d = 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      if (fetch_valid) begin</pre>
<pre>        have_instr = 1'b1;</pre>
<pre>        if (req_i && if_id_pipe_reg_we) begin</pre>
<pre>          fetch_ready      = 1'b1;</pre>
<pre>          offset_in_init_d = 1'b0;</pre>
<pre>    if (pc_set_i) begin</pre>
<pre>      have_instr       = 1'b0;</pre>
<pre>      branch_req       = 1'b1;</pre>
<pre>      offset_in_init_d = 1'b0;</pre>
<pre>  assign pc_if_o      = fetch_addr;</pre>
<pre>  assign if_busy_o    = prefetch_busy;</pre>
<pre>  assign perf_imiss_o = ~fetch_valid | branch_req;</pre>
<pre>  logic [31:0] instr_decompressed;</pre>
<pre>  logic        illegal_c_insn;</pre>
<pre>  logic        instr_is_compressed_int;</pre>
<pre>  ibex_compressed_decoder compressed_decoder_i (</pre>
<pre>      .clk_i           ( clk_i                   ),</pre>
<pre>      .rst_ni          ( rst_ni                  ),</pre>
<pre>      .valid_i         ( fetch_valid             ),</pre>
<pre>      .instr_i         ( fetch_rdata             ),</pre>
<pre>      .instr_o         ( instr_decompressed      ),</pre>
<pre>      .is_compressed_o ( instr_is_compressed_int ),</pre>
<pre>      .illegal_instr_o ( illegal_c_insn          )</pre>
<pre>  assign if_id_pipe_reg_we = have_instr & id_in_ready_i;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : if_id_pipeline_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      instr_new_id_o             <= 1'b0;</pre>
<pre>      instr_valid_id_o           <= 1'b0;</pre>
<pre>      instr_rdata_id_o           <= '0;</pre>
<pre>      instr_fetch_err_o          <= '0;</pre>
<pre>      instr_rdata_c_id_o         <= '0;</pre>
<pre>      instr_is_compressed_id_o   <= 1'b0;</pre>
<pre>      illegal_c_insn_id_o        <= 1'b0;</pre>
<pre>      pc_id_o                    <= '0;</pre>
<pre>    end else begin</pre>
<pre>      instr_new_id_o             <= if_id_pipe_reg_we;</pre>
<pre>      if (if_id_pipe_reg_we) begin</pre>
<pre>        instr_valid_id_o         <= 1'b1;</pre>
<pre>        instr_rdata_id_o         <= instr_decompressed;</pre>
<pre>        instr_fetch_err_o        <= fetch_err;</pre>
<pre>        instr_rdata_c_id_o       <= fetch_rdata[15:0];</pre>
<pre>        instr_is_compressed_id_o <= instr_is_compressed_int;</pre>
<pre>        illegal_c_insn_id_o      <= illegal_c_insn;</pre>
<pre>        pc_id_o                  <= pc_if_o;</pre>
<pre>      end else if (instr_valid_clear_i) begin</pre>
<pre>        instr_valid_id_o         <= 1'b0;</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv</h3>
<pre>module ibex_pmp #(</pre>
<pre>    parameter int unsigned PMPGranularity = 0,</pre>
<pre>    parameter int unsigned PMPNumChan     = 2,</pre>
<pre>    parameter int unsigned PMPNumRegions  = 4</pre>
<pre>    input  logic                    clk_i,</pre>
<pre>    input  logic                    rst_ni,</pre>
<pre>    input  ibex_pkg::pmp_cfg_t      csr_pmp_cfg_i  [PMPNumRegions],</pre>
<pre>    input  logic [33:0]             csr_pmp_addr_i [PMPNumRegions],</pre>
<pre>    input  ibex_pkg::priv_lvl_e     priv_mode_i    [PMPNumChan],</pre>
<pre>    input  logic [33:0]             pmp_req_addr_i [PMPNumChan],</pre>
<pre>    input  ibex_pkg::pmp_req_e      pmp_req_type_i [PMPNumChan],</pre>
<pre>    output logic                    pmp_req_err_o  [PMPNumChan]</pre>
<pre>  logic [33:0]                                region_start_addr [PMPNumRegions];</pre>
<pre>  logic [33:PMPGranularity+2]                 region_addr_mask  [PMPNumRegions];</pre>
<pre>  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_high;</pre>
<pre>  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_low;</pre>
<pre>  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_both;</pre>
<pre>  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_perm_check;</pre>
<pre>  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   machine_access_fault;</pre>
<pre>  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   user_access_allowed;</pre>
<pre>  logic [PMPNumChan-1:0]                      access_fault;</pre>
<pre style="background-color: #FF0000;">  for (genvar r = 0; r < PMPNumRegions; r++) begin : g_addr_exp</pre>
<pre style="background-color: #FF0000;">    if (r == 0) begin : g_entry0</pre>
<pre style="background-color: #FF0000;">      assign region_start_addr[r] = (csr_pmp_cfg_i[r].mode == PMP_MODE_TOR) ? 34'h000000000 :</pre>
<pre style="background-color: #FF0000;">                                                                              csr_pmp_addr_i[r];</pre>
<pre style="background-color: #FF0000;">    end else begin : g_oth</pre>
<pre style="background-color: #FF0000;">      assign region_start_addr[r] = (csr_pmp_cfg_i[r].mode == PMP_MODE_TOR) ? csr_pmp_addr_i[r-1] :</pre>
<pre style="background-color: #FF0000;">                                                                              csr_pmp_addr_i[r];</pre>
<pre style="background-color: #FF0000;">    for (genvar b = PMPGranularity+2; b < 34; b++) begin : g_bitmask</pre>
<pre style="background-color: #FF0000;">      if (b == PMPGranularity+2) begin : g_bit0</pre>
<pre style="background-color: #FF0000;">        assign region_addr_mask[r][b] = (csr_pmp_cfg_i[r].mode != PMP_MODE_NAPOT);</pre>
<pre style="background-color: #FF0000;">      end else begin : g_others</pre>
<pre style="background-color: #FF0000;">        assign region_addr_mask[r][b] = (csr_pmp_cfg_i[r].mode != PMP_MODE_NAPOT) |</pre>
<pre style="background-color: #FF0000;">                                        ~&csr_pmp_addr_i[r][b-1:PMPGranularity+2];</pre>
<pre style="background-color: #FF0000;">  for (genvar c = 0; c < PMPNumChan; c++) begin : g_access_check</pre>
<pre style="background-color: #FF0000;">    for (genvar r = 0; r < PMPNumRegions; r++) begin : g_regions</pre>
<pre style="background-color: #FF0000;">      assign region_match_low[c][r]     = (pmp_req_addr_i[c][33:PMPGranularity+2] >=</pre>
<pre style="background-color: #FF0000;">                                           (region_start_addr[r][33:PMPGranularity+2] &</pre>
<pre style="background-color: #FF0000;">                                            region_addr_mask[r]));</pre>
<pre style="background-color: #FF0000;">      assign region_match_high[c][r]    = (pmp_req_addr_i[c][33:PMPGranularity+2] <=</pre>
<pre style="background-color: #FF0000;">                                           csr_pmp_addr_i[r][33:PMPGranularity+2]);</pre>
<pre style="background-color: #FF0000;">      assign region_match_both[c][r]    = region_match_low[c][r] & region_match_high[c][r] &</pre>
<pre style="background-color: #FF0000;">                                          (csr_pmp_cfg_i[r].mode != PMP_MODE_OFF);</pre>
<pre style="background-color: #FF0000;">      assign region_perm_check[c][r] =</pre>
<pre style="background-color: #FF0000;">          ((pmp_req_type_i[c] == PMP_ACC_EXEC)  & csr_pmp_cfg_i[r].exec) |</pre>
<pre style="background-color: #FF0000;">          ((pmp_req_type_i[c] == PMP_ACC_WRITE) & csr_pmp_cfg_i[r].write) |</pre>
<pre style="background-color: #FF0000;">          ((pmp_req_type_i[c] == PMP_ACC_READ)  & csr_pmp_cfg_i[r].read);</pre>
<pre style="background-color: #FF0000;">      assign machine_access_fault[c][r] = region_match_both[c][r] & csr_pmp_cfg_i[r].lock &</pre>
<pre style="background-color: #FF0000;">                                          ~region_perm_check[c][r];</pre>
<pre style="background-color: #FF0000;">      assign user_access_allowed[c][r]  = region_match_both[c][r] & region_perm_check[c][r];</pre>
<pre style="background-color: #FF0000;">    assign access_fault[c] = (priv_mode_i[c] == PRIV_LVL_M) ? |machine_access_fault[c] :</pre>
<pre style="background-color: #FF0000;">                                                              ~|user_access_allowed[c];</pre>
<pre style="background-color: #FF0000;">    assign pmp_req_err_o[c] = access_fault[c];</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_fetch_fifo.sv</h3>
<pre>module ibex_fetch_fifo #(</pre>
<pre>  parameter int unsigned NUM_REQS = 2</pre>
<pre>    input  logic        clk_i,</pre>
<pre>    input  logic        rst_ni,</pre>
<pre>    input  logic        clear_i,          // clears the contents of the FIFO</pre>
<pre>    input  logic        in_valid_i,</pre>
<pre>    output logic        in_ready_o,</pre>
<pre>    input  logic [31:0] in_addr_i,</pre>
<pre>    input  logic [31:0] in_rdata_i,</pre>
<pre>    input  logic        in_err_i,</pre>
<pre>    output logic        out_valid_o,</pre>
<pre>    input  logic        out_ready_i,</pre>
<pre>    output logic [31:0] out_addr_o,</pre>
<pre>    output logic [31:0] out_rdata_o,</pre>
<pre>    output logic        out_err_o</pre>
<pre>  localparam int unsigned DEPTH = NUM_REQS+1;</pre>
<pre>  logic [DEPTH-1:0] [31:0]  rdata_d,   rdata_q;</pre>
<pre>  logic [DEPTH-1:0]         err_d,     err_q;</pre>
<pre>  logic [DEPTH-1:0]         valid_d,   valid_q;</pre>
<pre>  logic [DEPTH-1:0]         lowest_free_entry;</pre>
<pre>  logic [DEPTH-1:0]         valid_pushed, valid_popped;</pre>
<pre>  logic [DEPTH-1:0]         entry_en;</pre>
<pre>  logic                     pop_fifo;</pre>
<pre>  logic             [31:0]  rdata, rdata_unaligned;</pre>
<pre>  logic                     err,   err_unaligned;</pre>
<pre>  logic                     valid, valid_unaligned;</pre>
<pre>  logic                     aligned_is_compressed, unaligned_is_compressed;</pre>
<pre>  logic                     addr_incr_two;</pre>
<pre>  logic [31:1]              instr_addr_d, instr_addr_q;</pre>
<pre>  logic                     instr_addr_en;</pre>
<pre>  logic                     unused_addr_in;</pre>
<pre>  assign rdata = valid_q[0] ? rdata_q[0] : in_rdata_i;</pre>
<pre>  assign err   = valid_q[0] ? err_q[0]   : in_err_i;</pre>
<pre>  assign valid = valid_q[0] | in_valid_i;</pre>
<pre>  assign rdata_unaligned = valid_q[1] ? {rdata_q[1][15:0], rdata[31:16]} :</pre>
<pre>                                        {in_rdata_i[15:0], rdata[31:16]};</pre>
<pre>  assign err_unaligned   = valid_q[1] ? ((err_q[1] & ~unaligned_is_compressed) | err_q[0]) :</pre>
<pre>                                        ((valid_q[0] & err_q[0]) |</pre>
<pre>                                         (in_err_i & (~valid_q[0] | ~unaligned_is_compressed)));</pre>
<pre>  assign valid_unaligned = valid_q[1] ? 1'b1 :</pre>
<pre>                                        (valid_q[0] & in_valid_i);</pre>
<pre>  assign unaligned_is_compressed    = rdata[17:16] != 2'b11;</pre>
<pre>  assign aligned_is_compressed      = rdata[ 1: 0] != 2'b11;</pre>
<pre>  always_comb begin</pre>
<pre>    if (out_addr_o[1]) begin</pre>
<pre>      out_rdata_o = rdata_unaligned;</pre>
<pre>      out_err_o   = err_unaligned;</pre>
<pre>      if (unaligned_is_compressed) begin</pre>
<pre>        out_valid_o = valid;</pre>
<pre>      end else begin</pre>
<pre>        out_valid_o = valid_unaligned;</pre>
<pre>    end else begin</pre>
<pre>      out_rdata_o = rdata;</pre>
<pre>      out_err_o   = err;</pre>
<pre>      out_valid_o = valid;</pre>
<pre>  assign instr_addr_en = clear_i | (out_ready_i & out_valid_o);</pre>
<pre>  assign addr_incr_two = instr_addr_q[1] ? unaligned_is_compressed :</pre>
<pre>                                           aligned_is_compressed;</pre>
<pre>  assign instr_addr_d = clear_i ? in_addr_i[31:1] :</pre>
<pre>                                  (instr_addr_q[31:1] +</pre>
<pre>                                   {29'd0,~addr_incr_two,addr_incr_two});</pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>    if (instr_addr_en) begin</pre>
<pre>      instr_addr_q <= instr_addr_d;</pre>
<pre>  assign out_addr_o[31:1] = instr_addr_q[31:1];</pre>
<pre>  assign out_addr_o[0]    = 1'b0;</pre>
<pre>  assign unused_addr_in = in_addr_i[0];</pre>
<pre>  assign in_ready_o = ~valid_q[DEPTH-NUM_REQS];</pre>
<pre>  assign pop_fifo = out_ready_i & out_valid_o & (~aligned_is_compressed | out_addr_o[1]);</pre>
<pre>  for (genvar i = 0; i < (DEPTH - 1); i++) begin : g_fifo_next</pre>
<pre>    if (i == 0) begin : g_ent0</pre>
<pre>      assign lowest_free_entry[i] = ~valid_q[i];</pre>
<pre>    end else begin : g_ent_others</pre>
<pre>      assign lowest_free_entry[i] = ~valid_q[i] & valid_q[i-1];</pre>
<pre>    assign valid_pushed[i] = (in_valid_i & lowest_free_entry[i]) |</pre>
<pre>                             valid_q[i];</pre>
<pre>    assign valid_popped[i] = pop_fifo ? valid_pushed[i+1] : valid_pushed[i];</pre>
<pre>    assign valid_d[i] = valid_popped[i] & ~clear_i;</pre>
<pre>    assign entry_en[i] = (valid_pushed[i+1] & pop_fifo) |</pre>
<pre>                         (in_valid_i & lowest_free_entry[i] & ~pop_fifo);</pre>
<pre>    assign rdata_d[i]  = valid_q[i+1] ? rdata_q[i+1] : in_rdata_i;</pre>
<pre>    assign err_d  [i]  = valid_q[i+1] ? err_q  [i+1] : in_err_i;</pre>
<pre>  assign lowest_free_entry[DEPTH-1] = ~valid_q[DEPTH-1] & valid_q[DEPTH-2];</pre>
<pre>  assign valid_pushed     [DEPTH-1] = valid_q[DEPTH-1] | (in_valid_i & lowest_free_entry[DEPTH-1]);</pre>
<pre>  assign valid_popped     [DEPTH-1] = pop_fifo ? 1'b0 : valid_pushed[DEPTH-1];</pre>
<pre>  assign valid_d [DEPTH-1]          = valid_popped[DEPTH-1] & ~clear_i;</pre>
<pre>  assign entry_en[DEPTH-1]          = in_valid_i & lowest_free_entry[DEPTH-1];</pre>
<pre>  assign rdata_d [DEPTH-1]          = in_rdata_i;</pre>
<pre>  assign err_d   [DEPTH-1]          = in_err_i;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      valid_q <= '0;</pre>
<pre>    end else begin</pre>
<pre>      valid_q <= valid_d;</pre>
<pre>  for (genvar i = 0; i < DEPTH; i++) begin : g_fifo_regs</pre>
<pre>    always_ff @(posedge clk_i) begin</pre>
<pre>      if (entry_en[i]) begin</pre>
<pre>        rdata_q[i]   <= rdata_d[i];</pre>
<pre>        err_q[i]     <= err_d[i];</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv</h3>
<pre>module ibex_cs_registers #(</pre>
<pre>    parameter bit          DbgTriggerEn     = 0,</pre>
<pre>    parameter int unsigned MHPMCounterNum   = 8,</pre>
<pre>    parameter int unsigned MHPMCounterWidth = 40,</pre>
<pre>    parameter bit          PMPEnable        = 0,</pre>
<pre>    parameter int unsigned PMPGranularity   = 0,</pre>
<pre>    parameter int unsigned PMPNumRegions    = 4,</pre>
<pre>    parameter bit          RV32E            = 0,</pre>
<pre>    parameter bit          RV32M            = 0</pre>
<pre>    input  logic                 clk_i,</pre>
<pre>    input  logic                 rst_ni,</pre>
<pre>    input  logic [31:0]          hart_id_i,</pre>
<pre>    output ibex_pkg::priv_lvl_e  priv_mode_id_o,</pre>
<pre>    output ibex_pkg::priv_lvl_e  priv_mode_if_o,</pre>
<pre>    output ibex_pkg::priv_lvl_e  priv_mode_lsu_o,</pre>
<pre>    output logic                 csr_mstatus_tw_o,</pre>
<pre>    output logic [31:0]          csr_mtvec_o,</pre>
<pre>    input  logic                 csr_mtvec_init_i,</pre>
<pre>    input  logic [31:0]          boot_addr_i,</pre>
<pre>    input  logic                 csr_access_i,</pre>
<pre>    input  ibex_pkg::csr_num_e   csr_addr_i,</pre>
<pre>    input  logic [31:0]          csr_wdata_i,</pre>
<pre>    input  ibex_pkg::csr_op_e    csr_op_i,</pre>
<pre>    output logic [31:0]          csr_rdata_o,</pre>
<pre>    input  logic                 irq_software_i,</pre>
<pre>    input  logic                 irq_timer_i,</pre>
<pre>    input  logic                 irq_external_i,</pre>
<pre>    input  logic [14:0]          irq_fast_i,</pre>
<pre>    output logic                 irq_pending_o,          // interupt request pending</pre>
<pre>    input  logic                 nmi_mode_i,</pre>
<pre>    output logic                 csr_msip_o,             // software interrupt pending</pre>
<pre>    output logic                 csr_mtip_o,             // timer interrupt pending</pre>
<pre>    output logic                 csr_meip_o,             // external interrupt pending</pre>
<pre>    output logic [14:0]          csr_mfip_o,             // fast interrupt pending</pre>
<pre>    output logic                 csr_mstatus_mie_o,</pre>
<pre>    output logic [31:0]          csr_mepc_o,</pre>
<pre>    output ibex_pkg::pmp_cfg_t   csr_pmp_cfg_o  [PMPNumRegions],</pre>
<pre>    output logic [33:0]          csr_pmp_addr_o [PMPNumRegions],</pre>
<pre>    input  logic                 debug_mode_i,</pre>
<pre>    input  ibex_pkg::dbg_cause_e debug_cause_i,</pre>
<pre>    input  logic                 debug_csr_save_i,</pre>
<pre>    output logic [31:0]          csr_depc_o,</pre>
<pre>    output logic                 debug_single_step_o,</pre>
<pre>    output logic                 debug_ebreakm_o,</pre>
<pre>    output logic                 debug_ebreaku_o,</pre>
<pre>    output logic                 trigger_match_o,</pre>
<pre>    input  logic [31:0]          pc_if_i,</pre>
<pre>    input  logic [31:0]          pc_id_i,</pre>
<pre>    input  logic                 csr_save_if_i,</pre>
<pre>    input  logic                 csr_save_id_i,</pre>
<pre>    input  logic                 csr_restore_mret_i,</pre>
<pre>    input  logic                 csr_restore_dret_i,</pre>
<pre>    input  logic                 csr_save_cause_i,</pre>
<pre>    input  ibex_pkg::exc_cause_e csr_mcause_i,</pre>
<pre>    input  logic [31:0]          csr_mtval_i,</pre>
<pre>    output logic                 illegal_csr_insn_o,     // access to non-existent CSR,</pre>
<pre>    input  logic                 instr_new_id_i,         // ID stage sees a new instr</pre>
<pre>    input  logic                 instr_ret_i,            // instr retired in ID/EX stage</pre>
<pre>    input  logic                 instr_ret_compressed_i, // compressed instr retired</pre>
<pre>    input  logic                 imiss_i,                // instr fetch</pre>
<pre>    input  logic                 pc_set_i,               // PC was set to a new value</pre>
<pre>    input  logic                 jump_i,                 // jump instr seen (j, jr, jal, jalr)</pre>
<pre>    input  logic                 branch_i,               // branch instr seen (bf, bnf)</pre>
<pre>    input  logic                 branch_taken_i,         // branch was taken</pre>
<pre>    input  logic                 mem_load_i,             // load from memory in this cycle</pre>
<pre>    input  logic                 mem_store_i,            // store to memory in this cycle</pre>
<pre>    input  logic                 lsu_busy_i</pre>
<pre>  localparam logic [1:0] MXL = 2'd1; // M-XLEN: XLEN in M-Mode for RV32</pre>
<pre>  localparam logic [31:0] MISA_VALUE =</pre>
<pre>      (0          <<  0)  // A - Atomic Instructions extension</pre>
<pre>    | (1          <<  2)  // C - Compressed extension</pre>
<pre>    | (0          <<  3)  // D - Double precision floating-point extension</pre>
<pre>    | (32'(RV32E) <<  4)  // E - RV32E base ISA</pre>
<pre>    | (0          <<  5)  // F - Single precision floating-point extension</pre>
<pre>    | (1          <<  8)  // I - RV32I/64I/128I base ISA</pre>
<pre>    | (32'(RV32M) << 12)  // M - Integer Multiply/Divide extension</pre>
<pre>    | (0          << 13)  // N - User level interrupts supported</pre>
<pre>    | (0          << 18)  // S - Supervisor mode implemented</pre>
<pre>    | (1          << 20)  // U - User mode implemented</pre>
<pre>    | (0          << 23)  // X - Non-standard extensions present</pre>
<pre>    | (32'(MXL)   << 30); // M-XLEN</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic      mie;</pre>
<pre>    logic      mpie;</pre>
<pre>    priv_lvl_e mpp;</pre>
<pre>    logic      mprv;</pre>
<pre>    logic      tw;</pre>
<pre style="background-color: #FF0000;">  } Status_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic      mpie;</pre>
<pre>    priv_lvl_e mpp;</pre>
<pre style="background-color: #FF0000;">  } StatusStk_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        irq_software;</pre>
<pre>    logic        irq_timer;</pre>
<pre>    logic        irq_external;</pre>
<pre>    logic [14:0] irq_fast; // 15 fast interrupts,</pre>
<pre style="background-color: #FF0000;">  } Interrupts_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>      x_debug_ver_e xdebugver;</pre>
<pre>      logic [11:0]  zero2;</pre>
<pre>      logic         ebreakm;</pre>
<pre>      logic         zero1;</pre>
<pre>      logic         ebreaks;</pre>
<pre>      logic         ebreaku;</pre>
<pre>      logic         stepie;</pre>
<pre>      logic         stopcount;</pre>
<pre>      logic         stoptime;</pre>
<pre>      dbg_cause_e   cause;</pre>
<pre>      logic         zero0;</pre>
<pre>      logic         mprven;</pre>
<pre>      logic         nmip;</pre>
<pre>      logic         step;</pre>
<pre>      priv_lvl_e    prv;</pre>
<pre style="background-color: #FF0000;">  } Dcsr_t;</pre>
<pre>  logic [31:0] exception_pc;</pre>
<pre>  priv_lvl_e   priv_lvl_q, priv_lvl_d;</pre>
<pre>  Status_t     mstatus_q, mstatus_d;</pre>
<pre>  Interrupts_t mie_q, mie_d;</pre>
<pre>  logic [31:0] mscratch_q, mscratch_d;</pre>
<pre>  logic [31:0] mepc_q, mepc_d;</pre>
<pre>  logic  [5:0] mcause_q, mcause_d;</pre>
<pre>  logic [31:0] mtval_q, mtval_d;</pre>
<pre>  logic [31:0] mtvec_q, mtvec_d;</pre>
<pre>  Interrupts_t mip;</pre>
<pre>  Dcsr_t       dcsr_q, dcsr_d;</pre>
<pre>  logic [31:0] depc_q, depc_d;</pre>
<pre>  logic [31:0] dscratch0_q, dscratch0_d;</pre>
<pre>  logic [31:0] dscratch1_q, dscratch1_d;</pre>
<pre>  StatusStk_t  mstack_q, mstack_d;</pre>
<pre>  logic [31:0] mstack_epc_q, mstack_epc_d;</pre>
<pre>  logic  [5:0] mstack_cause_q, mstack_cause_d;</pre>
<pre>  logic [31:0]                 pmp_addr_rdata  [PMP_MAX_REGIONS];</pre>
<pre>  logic [PMP_CFG_W-1:0]        pmp_cfg_rdata   [PMP_MAX_REGIONS];</pre>
<pre>  logic [31:0]                 mcountinhibit;</pre>
<pre>  logic [MHPMCounterNum+3-1:0] mcountinhibit_d, mcountinhibit_q;</pre>
<pre>  logic                        mcountinhibit_we;</pre>
<pre>  logic [63:0] mhpmcounter_d [32];</pre>
<pre>  logic [63:0] mhpmcounter [32];</pre>
<pre>  logic [31:0] mhpmcounter_we;</pre>
<pre>  logic [31:0] mhpmcounterh_we;</pre>
<pre>  logic [31:0] mhpmcounter_incr;</pre>
<pre>  logic [31:0] mhpmevent [32];</pre>
<pre>  logic  [4:0] mhpmcounter_idx;</pre>
<pre>  logic [31:0] tselect_rdata;</pre>
<pre>  logic [31:0] tmatch_control_rdata;</pre>
<pre>  logic [31:0] tmatch_value_rdata;</pre>
<pre>  logic [31:0] csr_wdata_int;</pre>
<pre>  logic [31:0] csr_rdata_int;</pre>
<pre>  logic        csr_we_int;</pre>
<pre>  logic        csr_wreq;</pre>
<pre>  logic        illegal_csr;</pre>
<pre>  logic        illegal_csr_priv;</pre>
<pre>  logic        illegal_csr_write;</pre>
<pre>  logic [7:0]  unused_boot_addr;</pre>
<pre>  logic [2:0]  unused_csr_addr;</pre>
<pre>  assign unused_boot_addr = boot_addr_i[7:0];</pre>
<pre>  logic [$bits(csr_num_e)-1:0] csr_addr;</pre>
<pre>  assign csr_addr           = {csr_addr_i};</pre>
<pre>  assign unused_csr_addr    = csr_addr[7:5];</pre>
<pre>  assign mhpmcounter_idx    = csr_addr[4:0];</pre>
<pre>  assign illegal_csr_priv   = (csr_addr[9:8] > {priv_lvl_q});</pre>
<pre>  assign illegal_csr_write  = (csr_addr[11:10] == 2'b11) && csr_wreq;</pre>
<pre>  assign illegal_csr_insn_o = csr_access_i & (illegal_csr | illegal_csr_write | illegal_csr_priv);</pre>
<pre>  assign mip.irq_software = irq_software_i & mie_q.irq_software;</pre>
<pre>  assign mip.irq_timer    = irq_timer_i    & mie_q.irq_timer;</pre>
<pre>  assign mip.irq_external = irq_external_i & mie_q.irq_external;</pre>
<pre>  assign mip.irq_fast     = irq_fast_i     & mie_q.irq_fast;</pre>
<pre>  always_comb begin</pre>
<pre>    csr_rdata_int = '0;</pre>
<pre>    illegal_csr   = 1'b0;</pre>
<pre>    unique case (csr_addr_i)</pre>
<pre>      CSR_MHARTID: csr_rdata_int = hart_id_i;</pre>
<pre>      CSR_MSTATUS: begin</pre>
<pre>        csr_rdata_int                                                   = '0;</pre>
<pre>        csr_rdata_int[CSR_MSTATUS_MIE_BIT]                              = mstatus_q.mie;</pre>
<pre>        csr_rdata_int[CSR_MSTATUS_MPIE_BIT]                             = mstatus_q.mpie;</pre>
<pre>        csr_rdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW] = mstatus_q.mpp;</pre>
<pre>        csr_rdata_int[CSR_MSTATUS_MPRV_BIT]                             = mstatus_q.mprv;</pre>
<pre>        csr_rdata_int[CSR_MSTATUS_TW_BIT]                               = mstatus_q.tw;</pre>
<pre>      CSR_MISA: csr_rdata_int = MISA_VALUE;</pre>
<pre>      CSR_MIE: begin</pre>
<pre>        csr_rdata_int                                     = '0;</pre>
<pre>        csr_rdata_int[CSR_MSIX_BIT]                       = mie_q.irq_software;</pre>
<pre>        csr_rdata_int[CSR_MTIX_BIT]                       = mie_q.irq_timer;</pre>
<pre>        csr_rdata_int[CSR_MEIX_BIT]                       = mie_q.irq_external;</pre>
<pre>        csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mie_q.irq_fast;</pre>
<pre>      CSR_MSCRATCH: csr_rdata_int = mscratch_q;</pre>
<pre>      CSR_MTVEC: csr_rdata_int = mtvec_q;</pre>
<pre>      CSR_MEPC: csr_rdata_int = mepc_q;</pre>
<pre>      CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};</pre>
<pre>      CSR_MTVAL: csr_rdata_int = mtval_q;</pre>
<pre>      CSR_MIP: begin</pre>
<pre>        csr_rdata_int                                     = '0;</pre>
<pre>        csr_rdata_int[CSR_MSIX_BIT]                       = mip.irq_software;</pre>
<pre>        csr_rdata_int[CSR_MTIX_BIT]                       = mip.irq_timer;</pre>
<pre>        csr_rdata_int[CSR_MEIX_BIT]                       = mip.irq_external;</pre>
<pre>        csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mip.irq_fast;</pre>
<pre>      CSR_PMPCFG0:   csr_rdata_int = {pmp_cfg_rdata[3],  pmp_cfg_rdata[2],</pre>
<pre>                                      pmp_cfg_rdata[1],  pmp_cfg_rdata[0]};</pre>
<pre>      CSR_PMPCFG1:   csr_rdata_int = {pmp_cfg_rdata[7],  pmp_cfg_rdata[6],</pre>
<pre>                                      pmp_cfg_rdata[5],  pmp_cfg_rdata[4]};</pre>
<pre>      CSR_PMPCFG2:   csr_rdata_int = {pmp_cfg_rdata[11], pmp_cfg_rdata[10],</pre>
<pre>                                      pmp_cfg_rdata[9],  pmp_cfg_rdata[8]};</pre>
<pre>      CSR_PMPCFG3:   csr_rdata_int = {pmp_cfg_rdata[15], pmp_cfg_rdata[14],</pre>
<pre>                                      pmp_cfg_rdata[13], pmp_cfg_rdata[12]};</pre>
<pre>      CSR_PMPADDR0:  csr_rdata_int = pmp_addr_rdata[0];</pre>
<pre>      CSR_PMPADDR1:  csr_rdata_int = pmp_addr_rdata[1];</pre>
<pre>      CSR_PMPADDR2:  csr_rdata_int = pmp_addr_rdata[2];</pre>
<pre>      CSR_PMPADDR3:  csr_rdata_int = pmp_addr_rdata[3];</pre>
<pre>      CSR_PMPADDR4:  csr_rdata_int = pmp_addr_rdata[4];</pre>
<pre>      CSR_PMPADDR5:  csr_rdata_int = pmp_addr_rdata[5];</pre>
<pre>      CSR_PMPADDR6:  csr_rdata_int = pmp_addr_rdata[6];</pre>
<pre>      CSR_PMPADDR7:  csr_rdata_int = pmp_addr_rdata[7];</pre>
<pre>      CSR_PMPADDR8:  csr_rdata_int = pmp_addr_rdata[8];</pre>
<pre>      CSR_PMPADDR9:  csr_rdata_int = pmp_addr_rdata[9];</pre>
<pre>      CSR_PMPADDR10: csr_rdata_int = pmp_addr_rdata[10];</pre>
<pre>      CSR_PMPADDR11: csr_rdata_int = pmp_addr_rdata[11];</pre>
<pre>      CSR_PMPADDR12: csr_rdata_int = pmp_addr_rdata[12];</pre>
<pre>      CSR_PMPADDR13: csr_rdata_int = pmp_addr_rdata[13];</pre>
<pre>      CSR_PMPADDR14: csr_rdata_int = pmp_addr_rdata[14];</pre>
<pre>      CSR_PMPADDR15: csr_rdata_int = pmp_addr_rdata[15];</pre>
<pre>      CSR_DCSR: begin</pre>
<pre>        csr_rdata_int = dcsr_q;</pre>
<pre>        illegal_csr = ~debug_mode_i;</pre>
<pre>      CSR_DPC: begin</pre>
<pre>        csr_rdata_int = depc_q;</pre>
<pre>        illegal_csr = ~debug_mode_i;</pre>
<pre>      CSR_DSCRATCH0: begin</pre>
<pre>        csr_rdata_int = dscratch0_q;</pre>
<pre>        illegal_csr = ~debug_mode_i;</pre>
<pre>      CSR_DSCRATCH1: begin</pre>
<pre>        csr_rdata_int = dscratch1_q;</pre>
<pre>        illegal_csr = ~debug_mode_i;</pre>
<pre>      CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit;</pre>
<pre>      CSR_MHPMEVENT3,</pre>
<pre>      CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,</pre>
<pre>      CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,</pre>
<pre>      CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,</pre>
<pre>      CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,</pre>
<pre>      CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,</pre>
<pre>      CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,</pre>
<pre>      CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31: begin</pre>
<pre>        csr_rdata_int = mhpmevent[mhpmcounter_idx];</pre>
<pre>      CSR_MCYCLE,</pre>
<pre>      CSR_MINSTRET,</pre>
<pre>      CSR_MHPMCOUNTER3,</pre>
<pre>      CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,</pre>
<pre>      CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,</pre>
<pre>      CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,</pre>
<pre>      CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,</pre>
<pre>      CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,</pre>
<pre>      CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,</pre>
<pre>      CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin</pre>
<pre>        csr_rdata_int = mhpmcounter[mhpmcounter_idx][31:0];</pre>
<pre>      CSR_MCYCLEH,</pre>
<pre>      CSR_MINSTRETH,</pre>
<pre>      CSR_MHPMCOUNTER3H,</pre>
<pre>      CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,</pre>
<pre>      CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,</pre>
<pre>      CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,</pre>
<pre>      CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,</pre>
<pre>      CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,</pre>
<pre>      CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,</pre>
<pre>      CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin</pre>
<pre>        csr_rdata_int = mhpmcounter[mhpmcounter_idx][63:32];</pre>
<pre>      CSR_TSELECT: begin</pre>
<pre>        csr_rdata_int = tselect_rdata;</pre>
<pre>        illegal_csr   = ~DbgTriggerEn;</pre>
<pre>      CSR_TDATA1: begin</pre>
<pre>        csr_rdata_int = tmatch_control_rdata;</pre>
<pre>        illegal_csr   = ~DbgTriggerEn;</pre>
<pre>      CSR_TDATA2: begin</pre>
<pre>        csr_rdata_int = tmatch_value_rdata;</pre>
<pre>        illegal_csr   = ~DbgTriggerEn;</pre>
<pre>      CSR_TDATA3: begin</pre>
<pre>        csr_rdata_int = '0;</pre>
<pre>        illegal_csr   = ~DbgTriggerEn;</pre>
<pre>      CSR_MCONTEXT: begin</pre>
<pre>        csr_rdata_int = '0;</pre>
<pre>        illegal_csr   = ~DbgTriggerEn;</pre>
<pre>      CSR_SCONTEXT: begin</pre>
<pre>        csr_rdata_int = '0;</pre>
<pre>        illegal_csr   = ~DbgTriggerEn;</pre>
<pre>      default: begin</pre>
<pre>        illegal_csr = 1'b1;</pre>
<pre>  always_comb begin</pre>
<pre>    exception_pc = pc_id_i;</pre>
<pre>    priv_lvl_d   = priv_lvl_q;</pre>
<pre>    mstatus_d    = mstatus_q;</pre>
<pre>    mie_d        = mie_q;</pre>
<pre>    mscratch_d   = mscratch_q;</pre>
<pre>    mepc_d       = mepc_q;</pre>
<pre>    mcause_d     = mcause_q;</pre>
<pre>    mtval_d      = mtval_q;</pre>
<pre>    mtvec_d      = csr_mtvec_init_i ? {boot_addr_i[31:8], 6'b0, 2'b01} : mtvec_q;</pre>
<pre>    dcsr_d       = dcsr_q;</pre>
<pre>    depc_d       = depc_q;</pre>
<pre>    dscratch0_d  = dscratch0_q;</pre>
<pre>    dscratch1_d  = dscratch1_q;</pre>
<pre>    mstack_d       = mstack_q;</pre>
<pre>    mstack_epc_d   = mstack_epc_q;</pre>
<pre>    mstack_cause_d = mstack_cause_q;</pre>
<pre>    mcountinhibit_we = 1'b0;</pre>
<pre>    mhpmcounter_we   = '0;</pre>
<pre>    mhpmcounterh_we  = '0;</pre>
<pre>    if (csr_we_int) begin</pre>
<pre>      unique case (csr_addr_i)</pre>
<pre>        CSR_MSTATUS: begin</pre>
<pre>          mstatus_d = '{</pre>
<pre>              mie:  csr_wdata_int[CSR_MSTATUS_MIE_BIT],</pre>
<pre>              mpie: csr_wdata_int[CSR_MSTATUS_MPIE_BIT],</pre>
<pre>              mpp:  priv_lvl_e'(csr_wdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW]),</pre>
<pre>              mprv: csr_wdata_int[CSR_MSTATUS_MPRV_BIT],</pre>
<pre>              tw:   csr_wdata_int[CSR_MSTATUS_TW_BIT]</pre>
<pre>          if ((mstatus_d.mpp != PRIV_LVL_M) && (mstatus_d.mpp != PRIV_LVL_U)) begin</pre>
<pre>            mstatus_d.mpp = PRIV_LVL_M;</pre>
<pre>        CSR_MIE: begin</pre>
<pre>          mie_d.irq_software = csr_wdata_int[CSR_MSIX_BIT];</pre>
<pre>          mie_d.irq_timer    = csr_wdata_int[CSR_MTIX_BIT];</pre>
<pre>          mie_d.irq_external = csr_wdata_int[CSR_MEIX_BIT];</pre>
<pre>          mie_d.irq_fast     = csr_wdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW];</pre>
<pre>        CSR_MSCRATCH: mscratch_d = csr_wdata_int;</pre>
<pre>        CSR_MEPC: mepc_d = {csr_wdata_int[31:1], 1'b0};</pre>
<pre>        CSR_MCAUSE: mcause_d = {csr_wdata_int[31], csr_wdata_int[4:0]};</pre>
<pre>        CSR_MTVAL: mtval_d = csr_wdata_int;</pre>
<pre>        CSR_MTVEC: mtvec_d = {csr_wdata_int[31:8], 6'b0, 2'b01};</pre>
<pre>        CSR_DCSR: begin</pre>
<pre>          dcsr_d = csr_wdata_int;</pre>
<pre>          dcsr_d.xdebugver = XDEBUGVER_STD;</pre>
<pre>          if ((dcsr_d.prv != PRIV_LVL_M) && (dcsr_d.prv != PRIV_LVL_U)) begin</pre>
<pre>            dcsr_d.prv = PRIV_LVL_M;</pre>
<pre>          dcsr_d.nmip = 1'b0;</pre>
<pre>          dcsr_d.mprven = 1'b0;</pre>
<pre>          dcsr_d.stopcount = 1'b0;</pre>
<pre>          dcsr_d.stoptime = 1'b0;</pre>
<pre>          dcsr_d.zero0 = 1'b0;</pre>
<pre>          dcsr_d.zero1 = 1'b0;</pre>
<pre>          dcsr_d.zero2 = 12'h0;</pre>
<pre>        CSR_DPC: depc_d = {csr_wdata_int[31:1], 1'b0};</pre>
<pre>        CSR_DSCRATCH0: dscratch0_d = csr_wdata_int;</pre>
<pre>        CSR_DSCRATCH1: dscratch1_d = csr_wdata_int;</pre>
<pre>        CSR_MCOUNTINHIBIT: mcountinhibit_we = 1'b1;</pre>
<pre>        CSR_MCYCLE,</pre>
<pre>        CSR_MINSTRET,</pre>
<pre>        CSR_MHPMCOUNTER3,</pre>
<pre>        CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,</pre>
<pre>        CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,</pre>
<pre>        CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,</pre>
<pre>        CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,</pre>
<pre>        CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,</pre>
<pre>        CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,</pre>
<pre>        CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin</pre>
<pre>          mhpmcounter_we[mhpmcounter_idx] = 1'b1;</pre>
<pre>        CSR_MCYCLEH,</pre>
<pre>        CSR_MINSTRETH,</pre>
<pre>        CSR_MHPMCOUNTER3H,</pre>
<pre>        CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,</pre>
<pre>        CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,</pre>
<pre>        CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,</pre>
<pre>        CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,</pre>
<pre>        CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,</pre>
<pre>        CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,</pre>
<pre>        CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin</pre>
<pre>          mhpmcounterh_we[mhpmcounter_idx] = 1'b1;</pre>
<pre>        default:;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      csr_save_cause_i: begin</pre>
<pre>        unique case (1'b1)</pre>
<pre>          csr_save_if_i: begin</pre>
<pre>            exception_pc = pc_if_i;</pre>
<pre>          csr_save_id_i: begin</pre>
<pre>            exception_pc = pc_id_i;</pre>
<pre>          default:;</pre>
<pre>        priv_lvl_d = PRIV_LVL_M;</pre>
<pre>        if (debug_csr_save_i) begin</pre>
<pre>          dcsr_d.prv   = priv_lvl_q;</pre>
<pre>          dcsr_d.cause = debug_cause_i;</pre>
<pre>          depc_d       = exception_pc;</pre>
<pre>        end else if (!debug_mode_i) begin</pre>
<pre>          mtval_d        = csr_mtval_i;</pre>
<pre>          mstatus_d.mie  = 1'b0; // disable interrupts</pre>
<pre>          mstatus_d.mpie = mstatus_q.mie;</pre>
<pre>          mstatus_d.mpp  = priv_lvl_q;</pre>
<pre>          mepc_d         = exception_pc;</pre>
<pre>          mcause_d       = {csr_mcause_i};</pre>
<pre>          mstack_d.mpie  = mstatus_q.mpie;</pre>
<pre>          mstack_d.mpp   = mstatus_q.mpp;</pre>
<pre>          mstack_epc_d   = mepc_q;</pre>
<pre>          mstack_cause_d = mcause_q;</pre>
<pre>      csr_restore_dret_i: begin // DRET</pre>
<pre>        priv_lvl_d = dcsr_q.prv;</pre>
<pre>      csr_restore_mret_i: begin // MRET</pre>
<pre>        priv_lvl_d     = mstatus_q.mpp;</pre>
<pre>        mstatus_d.mie  = mstatus_q.mpie; // re-enable interrupts</pre>
<pre>        if (nmi_mode_i) begin</pre>
<pre>          mstatus_d.mpie = mstack_q.mpie;</pre>
<pre>          mstatus_d.mpp  = mstack_q.mpp;</pre>
<pre>          mepc_d         = mstack_epc_q;</pre>
<pre>          mcause_d       = mstack_cause_q;</pre>
<pre>        end else begin</pre>
<pre>          mstatus_d.mpie = 1'b1;</pre>
<pre>          mstatus_d.mpp  = PRIV_LVL_U;</pre>
<pre>      default:;</pre>
<pre>  always_comb begin</pre>
<pre>    csr_wreq = 1'b1;</pre>
<pre>    unique case (csr_op_i)</pre>
<pre>      CSR_OP_WRITE: csr_wdata_int =  csr_wdata_i;</pre>
<pre>      CSR_OP_SET:   csr_wdata_int =  csr_wdata_i | csr_rdata_o;</pre>
<pre>      CSR_OP_CLEAR: csr_wdata_int = ~csr_wdata_i & csr_rdata_o;</pre>
<pre>      CSR_OP_READ: begin</pre>
<pre>        csr_wdata_int = csr_wdata_i;</pre>
<pre>        csr_wreq      = 1'b0;</pre>
<pre>      default: begin</pre>
<pre>        csr_wdata_int = csr_wdata_i;</pre>
<pre>        csr_wreq      = 1'b0;</pre>
<pre>  assign csr_we_int  = csr_wreq & ~illegal_csr_insn_o & instr_new_id_i;</pre>
<pre>  assign csr_rdata_o = csr_rdata_int;</pre>
<pre>  assign csr_msip_o  = mip.irq_software;</pre>
<pre>  assign csr_mtip_o  = mip.irq_timer;</pre>
<pre>  assign csr_meip_o  = mip.irq_external;</pre>
<pre>  assign csr_mfip_o  = mip.irq_fast;</pre>
<pre>  assign csr_mepc_o  = mepc_q;</pre>
<pre>  assign csr_depc_o  = depc_q;</pre>
<pre>  assign csr_mtvec_o = mtvec_q;</pre>
<pre>  assign csr_mstatus_mie_o   = mstatus_q.mie;</pre>
<pre>  assign csr_mstatus_tw_o    = mstatus_q.tw;</pre>
<pre>  assign debug_single_step_o = dcsr_q.step;</pre>
<pre>  assign debug_ebreakm_o     = dcsr_q.ebreakm;</pre>
<pre>  assign debug_ebreaku_o     = dcsr_q.ebreaku;</pre>
<pre>  assign irq_pending_o = csr_msip_o | csr_mtip_o | csr_meip_o | (|csr_mfip_o);</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      priv_lvl_q     <= PRIV_LVL_M;</pre>
<pre>      mstatus_q      <= '{</pre>
<pre>          mie:  1'b0,</pre>
<pre>          mpie: 1'b1,</pre>
<pre>          mpp:  PRIV_LVL_U,</pre>
<pre>          mprv: 1'b0,</pre>
<pre>          tw:   1'b0</pre>
<pre>      mie_q          <= '0;</pre>
<pre>      mscratch_q     <= '0;</pre>
<pre>      mepc_q         <= '0;</pre>
<pre>      mcause_q       <= '0;</pre>
<pre>      mtval_q        <= '0;</pre>
<pre>      mtvec_q        <= 32'b01;</pre>
<pre>      dcsr_q         <= '{</pre>
<pre>          xdebugver: XDEBUGVER_STD,</pre>
<pre>          cause:     DBG_CAUSE_NONE, // 3'h0</pre>
<pre>          prv:       PRIV_LVL_M,</pre>
<pre>          default:   '0</pre>
<pre>      depc_q         <= '0;</pre>
<pre>      dscratch0_q    <= '0;</pre>
<pre>      dscratch1_q    <= '0;</pre>
<pre>      mstack_q       <= '{</pre>
<pre>          mpie: 1'b1,</pre>
<pre>          mpp:  PRIV_LVL_U</pre>
<pre>      mstack_epc_q   <= '0;</pre>
<pre>      mstack_cause_q <= '0;</pre>
<pre>    end else begin</pre>
<pre>      priv_lvl_q     <= priv_lvl_d;</pre>
<pre>      mstatus_q      <= mstatus_d;</pre>
<pre>      mie_q          <= mie_d;</pre>
<pre>      mscratch_q     <= mscratch_d;</pre>
<pre>      mepc_q         <= mepc_d;</pre>
<pre>      mcause_q       <= mcause_d;</pre>
<pre>      mtval_q        <= mtval_d;</pre>
<pre>      mtvec_q        <= mtvec_d;</pre>
<pre>      dcsr_q         <= dcsr_d;</pre>
<pre>      depc_q         <= depc_d;</pre>
<pre>      dscratch0_q    <= dscratch0_d;</pre>
<pre>      dscratch1_q    <= dscratch1_d;</pre>
<pre>      mstack_q       <= mstack_d;</pre>
<pre>      mstack_epc_q   <= mstack_epc_d;</pre>
<pre>      mstack_cause_q <= mstack_cause_d;</pre>
<pre>  assign priv_mode_id_o = priv_lvl_q;</pre>
<pre>  assign priv_mode_if_o = priv_lvl_d;</pre>
<pre>  assign priv_mode_lsu_o = mstatus_q.mprv ? mstatus_q.mpp : priv_lvl_q;</pre>
<pre style="background-color: #FF0000;">  if (PMPEnable) begin : g_pmp_registers</pre>
<pre style="background-color: #FF0000;">    pmp_cfg_t                    pmp_cfg         [PMPNumRegions];</pre>
<pre style="background-color: #FF0000;">    pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];</pre>
<pre style="background-color: #FF0000;">    logic [31:0]                 pmp_addr        [PMPNumRegions];</pre>
<pre style="background-color: #FF0000;">    logic [PMPNumRegions-1:0]    pmp_cfg_we;</pre>
<pre style="background-color: #FF0000;">    logic [PMPNumRegions-1:0]    pmp_addr_we;</pre>
<pre style="background-color: #FF0000;">    for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_exp_rd_data</pre>
<pre style="background-color: #FF0000;">      if (i < PMPNumRegions) begin : g_implemented_regions</pre>
<pre style="background-color: #FF0000;">        assign pmp_cfg_rdata[i] = {pmp_cfg[i].lock, 2'b00, pmp_cfg[i].mode,</pre>
<pre style="background-color: #FF0000;">                                   pmp_cfg[i].exec, pmp_cfg[i].write, pmp_cfg[i].read};</pre>
<pre style="background-color: #FF0000;">        if (PMPGranularity == 0) begin : g_pmp_g0</pre>
<pre style="background-color: #FF0000;">          assign pmp_addr_rdata[i] = pmp_addr[i];</pre>
<pre style="background-color: #FF0000;">        end else if (PMPGranularity == 1) begin : g_pmp_g1</pre>
<pre style="background-color: #FF0000;">          always_comb begin</pre>
<pre style="background-color: #FF0000;">            pmp_addr_rdata[i] = pmp_addr[i];</pre>
<pre style="background-color: #FF0000;">            if ((pmp_cfg[i].mode == PMP_MODE_OFF) || (pmp_cfg[i].mode == PMP_MODE_TOR)) begin</pre>
<pre style="background-color: #FF0000;">              pmp_addr_rdata[i][PMPGranularity-1:0] = '0;</pre>
<pre style="background-color: #FF0000;">        end else begin : g_pmp_g2</pre>
<pre style="background-color: #FF0000;">          always_comb begin</pre>
<pre style="background-color: #FF0000;">            pmp_addr_rdata[i] = pmp_addr[i];</pre>
<pre style="background-color: #FF0000;">            if ((pmp_cfg[i].mode == PMP_MODE_OFF) || (pmp_cfg[i].mode == PMP_MODE_TOR)) begin</pre>
<pre style="background-color: #FF0000;">              pmp_addr_rdata[i][PMPGranularity-1:0] = '0;</pre>
<pre style="background-color: #FF0000;">            end else if (pmp_cfg[i].mode == PMP_MODE_NAPOT) begin</pre>
<pre style="background-color: #FF0000;">              pmp_addr_rdata[i][PMPGranularity-2:0] = '1;</pre>
<pre style="background-color: #FF0000;">      end else begin : g_other_regions</pre>
<pre style="background-color: #FF0000;">        assign pmp_cfg_rdata[i]  = '0;</pre>
<pre style="background-color: #FF0000;">        assign pmp_addr_rdata[i] = '0;</pre>
<pre style="background-color: #FF0000;">    for (genvar i = 0; i < PMPNumRegions; i++) begin : g_pmp_csrs</pre>
<pre style="background-color: #FF0000;">      assign pmp_cfg_we[i] = csr_we_int & ~pmp_cfg[i].lock &</pre>
<pre style="background-color: #FF0000;">                             (csr_addr == (CSR_OFF_PMP_CFG + (i[11:0] >> 2)));</pre>
<pre style="background-color: #FF0000;">      assign pmp_cfg_wdata[i].lock  = csr_wdata_int[(i%4)*PMP_CFG_W+7];</pre>
<pre style="background-color: #FF0000;">      always_comb begin</pre>
<pre style="background-color: #FF0000;">        unique case (csr_wdata_int[(i%4)*PMP_CFG_W+3+:2])</pre>
<pre style="background-color: #FF0000;">          2'b00   : pmp_cfg_wdata[i].mode = PMP_MODE_OFF;</pre>
<pre style="background-color: #FF0000;">          2'b01   : pmp_cfg_wdata[i].mode = PMP_MODE_TOR;</pre>
<pre style="background-color: #FF0000;">          2'b10   : pmp_cfg_wdata[i].mode = (PMPGranularity == 0) ? PMP_MODE_NA4:</pre>
<pre style="background-color: #FF0000;">                                                                    PMP_MODE_OFF;</pre>
<pre style="background-color: #FF0000;">          2'b11   : pmp_cfg_wdata[i].mode = PMP_MODE_NAPOT;</pre>
<pre style="background-color: #FF0000;">          default : pmp_cfg_wdata[i].mode = PMP_MODE_OFF;</pre>
<pre style="background-color: #FF0000;">      assign pmp_cfg_wdata[i].exec  = csr_wdata_int[(i%4)*PMP_CFG_W+2];</pre>
<pre style="background-color: #FF0000;">      assign pmp_cfg_wdata[i].write = &csr_wdata_int[(i%4)*PMP_CFG_W+:2];</pre>
<pre style="background-color: #FF0000;">      assign pmp_cfg_wdata[i].read  = csr_wdata_int[(i%4)*PMP_CFG_W];</pre>
<pre style="background-color: #FF0000;">      always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #FF0000;">        if (!rst_ni) begin</pre>
<pre style="background-color: #FF0000;">          pmp_cfg[i] <= pmp_cfg_t'('b0);</pre>
<pre style="background-color: #FF0000;">        end else if (pmp_cfg_we[i]) begin</pre>
<pre style="background-color: #FF0000;">          pmp_cfg[i] <= pmp_cfg_wdata[i];</pre>
<pre style="background-color: #FF0000;">      if (i < PMPNumRegions - 1) begin : g_lower</pre>
<pre style="background-color: #FF0000;">        assign pmp_addr_we[i] = csr_we_int & ~pmp_cfg[i].lock &</pre>
<pre style="background-color: #FF0000;">                                (pmp_cfg[i+1].mode != PMP_MODE_TOR) &</pre>
<pre style="background-color: #FF0000;">                                (csr_addr == (CSR_OFF_PMP_ADDR + i[11:0]));</pre>
<pre style="background-color: #FF0000;">      end else begin : g_upper</pre>
<pre style="background-color: #FF0000;">        assign pmp_addr_we[i] = csr_we_int & ~pmp_cfg[i].lock &</pre>
<pre style="background-color: #FF0000;">                                (csr_addr == (CSR_OFF_PMP_ADDR + i[11:0]));</pre>
<pre style="background-color: #FF0000;">      always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #FF0000;">        if (!rst_ni) begin</pre>
<pre style="background-color: #FF0000;">          pmp_addr[i] <= 'b0;</pre>
<pre style="background-color: #FF0000;">        end else if (pmp_addr_we[i]) begin</pre>
<pre style="background-color: #FF0000;">          pmp_addr[i] <= csr_wdata_int;</pre>
<pre style="background-color: #FF0000;">      assign csr_pmp_cfg_o[i]  = pmp_cfg[i];</pre>
<pre style="background-color: #FF0000;">      assign csr_pmp_addr_o[i] = {pmp_addr[i],2'b00};</pre>
<pre>  end else begin : g_no_pmp_tieoffs</pre>
<pre>    for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_rdata</pre>
<pre>      assign pmp_addr_rdata[i] = '0;</pre>
<pre>      assign pmp_cfg_rdata[i]  = '0;</pre>
<pre>    for (genvar i = 0; i < PMPNumRegions; i++) begin : g_outputs</pre>
<pre>      assign csr_pmp_cfg_o[i]  = pmp_cfg_t'(1'b0);</pre>
<pre>      assign csr_pmp_addr_o[i] = '0;</pre>
<pre>  always_comb begin : mcountinhibit_update</pre>
<pre>    if (mcountinhibit_we == 1'b1) begin</pre>
<pre>      mcountinhibit_d = {csr_wdata_int[MHPMCounterNum+2:2], 1'b0, csr_wdata_int[0]}; // bit 1 must always be 0</pre>
<pre>    end else begin</pre>
<pre>      mcountinhibit_d = mcountinhibit_q;</pre>
<pre>  always_comb begin : gen_mhpmcounter_incr</pre>
<pre>    mhpmcounter_incr[0]  = 1'b1;                   // mcycle</pre>
<pre>    mhpmcounter_incr[1]  = 1'b0;                   // reserved</pre>
<pre>    mhpmcounter_incr[2]  = instr_ret_i;            // minstret</pre>
<pre>    mhpmcounter_incr[3]  = lsu_busy_i;             // cycles waiting for data memory</pre>
<pre>    mhpmcounter_incr[4]  = imiss_i & ~pc_set_i;    // cycles waiting for instr fetches</pre>
<pre>    mhpmcounter_incr[5]  = mem_load_i;             // num of loads</pre>
<pre>    mhpmcounter_incr[6]  = mem_store_i;            // num of stores</pre>
<pre>    mhpmcounter_incr[7]  = jump_i;                 // num of jumps (unconditional)</pre>
<pre>    mhpmcounter_incr[8]  = branch_i;               // num of branches (conditional)</pre>
<pre>    mhpmcounter_incr[9]  = branch_taken_i;         // num of taken branches (conditional)</pre>
<pre>    mhpmcounter_incr[10] = instr_ret_compressed_i; // num of compressed instr</pre>
<pre>    for (int unsigned i=3+MHPMCounterNum; i<32; i++) begin : gen_mhpmcounter_incr_inactive</pre>
<pre>      mhpmcounter_incr[i] = 1'b0;</pre>
<pre>  always_comb begin : gen_mhpmevent</pre>
<pre>    for (int i=0; i<32; i++) begin : gen_mhpmevent_active</pre>
<pre>      mhpmevent[i]    =   '0;</pre>
<pre>      mhpmevent[i][i] = 1'b1;</pre>
<pre>    mhpmevent[1] = '0; // not existing, reserved</pre>
<pre>    for (int unsigned i=3+MHPMCounterNum; i<32; i++) begin : gen_mhpmevent_inactive</pre>
<pre>      mhpmevent[i] = '0;</pre>
<pre>  always_comb begin : mhpmcounter_update</pre>
<pre>    mhpmcounter_d = mhpmcounter;</pre>
<pre>    for (int i=0; i<32; i++) begin : gen_mhpmcounter_update</pre>
<pre>      if (mhpmcounter_incr[i] & ~mcountinhibit[i]) begin</pre>
<pre>        mhpmcounter_d[i] = mhpmcounter[i] + 64'h1;</pre>
<pre>      if (mhpmcounter_we[i]) begin</pre>
<pre>        mhpmcounter_d[i][31: 0] = csr_wdata_int;</pre>
<pre>      end else if (mhpmcounterh_we[i]) begin</pre>
<pre>        mhpmcounter_d[i][63:32] = csr_wdata_int;</pre>
<pre>  for (genvar i = 0; i < 32; i++) begin : g_mhpmcounter</pre>
<pre>    if (i < 3 + MHPMCounterNum) begin : g_mhpmcounter_exists</pre>
<pre>      localparam int unsigned IMHPMCounterWidth = i < 3 ? 64 : MHPMCounterWidth;</pre>
<pre>      logic [IMHPMCounterWidth-1:0] mhpmcounter_q;</pre>
<pre>      always @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>        if(~rst_ni) begin</pre>
<pre>          mhpmcounter_q <= '0;</pre>
<pre>        end else begin</pre>
<pre>          mhpmcounter_q <= mhpmcounter_d[i][IMHPMCounterWidth-1:0];</pre>
<pre>      if (IMHPMCounterWidth < 64) begin : g_mhpmcounter_narrow</pre>
<pre>        assign mhpmcounter[i][IMHPMCounterWidth-1:0] = mhpmcounter_q;</pre>
<pre>        assign mhpmcounter[i][63:IMHPMCounterWidth]  = '0;</pre>
<pre style="background-color: #FF0000;">      end else begin : g_mhpmcounter_full</pre>
<pre style="background-color: #FF0000;">        assign mhpmcounter[i] = mhpmcounter_q;</pre>
<pre>    end else begin : g_no_mhpmcounter</pre>
<pre>      assign mhpmcounter[i] = '0;</pre>
<pre>  if(MHPMCounterNum < 29) begin : g_mcountinhibit_reduced</pre>
<pre>    assign mcountinhibit = {{29-MHPMCounterNum{1'b1}}, mcountinhibit_q};</pre>
<pre style="background-color: #FF0000;">  end else begin : g_mcountinhibit_full</pre>
<pre style="background-color: #FF0000;">    assign mcountinhibit = mcountinhibit_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      mcountinhibit_q <= '0;</pre>
<pre>    end else begin</pre>
<pre>      mcountinhibit_q <= mcountinhibit_d;</pre>
<pre style="background-color: #FF0000;">  if (DbgTriggerEn) begin : gen_trigger_regs</pre>
<pre style="background-color: #FF0000;">    logic        tmatch_control_d, tmatch_control_q;</pre>
<pre style="background-color: #FF0000;">    logic [31:0] tmatch_value_d, tmatch_value_q;</pre>
<pre style="background-color: #FF0000;">    logic tmatch_control_we;</pre>
<pre style="background-color: #FF0000;">    logic tmatch_value_we;</pre>
<pre style="background-color: #FF0000;">    assign tmatch_control_we = csr_we_int & debug_mode_i & (csr_addr_i == CSR_TDATA1);</pre>
<pre style="background-color: #FF0000;">    assign tmatch_value_we   = csr_we_int & debug_mode_i & (csr_addr_i == CSR_TDATA2);</pre>
<pre style="background-color: #FF0000;">    assign tmatch_control_d = tmatch_control_we ? csr_wdata_int[2] :</pre>
<pre style="background-color: #FF0000;">                                                  tmatch_control_q;</pre>
<pre style="background-color: #FF0000;">    assign tmatch_value_d   = csr_wdata_int[31:0];</pre>
<pre style="background-color: #FF0000;">    always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #FF0000;">      if (!rst_ni) begin</pre>
<pre style="background-color: #FF0000;">        tmatch_control_q <= 'b0;</pre>
<pre style="background-color: #FF0000;">      end else begin</pre>
<pre style="background-color: #FF0000;">        tmatch_control_q <= tmatch_control_d;</pre>
<pre style="background-color: #FF0000;">    always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #FF0000;">      if (!rst_ni) begin</pre>
<pre style="background-color: #FF0000;">        tmatch_value_q <= 'b0;</pre>
<pre style="background-color: #FF0000;">      end else if (tmatch_value_we) begin</pre>
<pre style="background-color: #FF0000;">        tmatch_value_q <= tmatch_value_d;</pre>
<pre style="background-color: #FF0000;">    assign tselect_rdata = 'b0;</pre>
<pre style="background-color: #FF0000;">    assign tmatch_control_rdata = {4'h2,              // type    : address/data match</pre>
<pre style="background-color: #FF0000;">                                   1'b1,              // dmode   : access from D mode only</pre>
<pre style="background-color: #FF0000;">                                   6'h00,             // maskmax : exact match only</pre>
<pre style="background-color: #FF0000;">                                   1'b0,              // hit     : not supported</pre>
<pre style="background-color: #FF0000;">                                   1'b0,              // select  : address match only</pre>
<pre style="background-color: #FF0000;">                                   1'b0,              // timing  : match before execution</pre>
<pre style="background-color: #FF0000;">                                   2'b00,             // sizelo  : match any access</pre>
<pre style="background-color: #FF0000;">                                   4'h1,              // action  : enter debug mode</pre>
<pre style="background-color: #FF0000;">                                   1'b0,              // chain   : not supported</pre>
<pre style="background-color: #FF0000;">                                   4'h0,              // match   : simple match</pre>
<pre style="background-color: #FF0000;">                                   1'b1,              // m       : match in m-mode</pre>
<pre style="background-color: #FF0000;">                                   1'b0,              // 0       : zero</pre>
<pre style="background-color: #FF0000;">                                   1'b0,              // s       : not supported</pre>
<pre style="background-color: #FF0000;">                                   1'b1,              // u       : match in u-mode</pre>
<pre style="background-color: #FF0000;">                                   tmatch_control_q,  // execute : match instruction address</pre>
<pre style="background-color: #FF0000;">                                   1'b0,              // store   : not supported</pre>
<pre style="background-color: #FF0000;">                                   1'b0};             // load    : not supported</pre>
<pre style="background-color: #FF0000;">    assign tmatch_value_rdata = tmatch_value_q;</pre>
<pre style="background-color: #FF0000;">    assign trigger_match_o = tmatch_control_q & (pc_if_i[31:0] == tmatch_value_q[31:0]);</pre>
<pre>  end else begin : gen_no_trigger_regs</pre>
<pre>    assign tselect_rdata        = 'b0;</pre>
<pre>    assign tmatch_control_rdata = 'b0;</pre>
<pre>    assign tmatch_value_rdata   = 'b0;</pre>
<pre>    assign trigger_match_o      = 'b0;</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_pkg.sv</h3>
<pre>package ibex_pkg;</pre>
<pre>typedef enum logic [6:0] {</pre>
<pre>  OPCODE_LOAD     = 7'h03,</pre>
<pre>  OPCODE_MISC_MEM = 7'h0f,</pre>
<pre>  OPCODE_OP_IMM   = 7'h13,</pre>
<pre>  OPCODE_AUIPC    = 7'h17,</pre>
<pre>  OPCODE_STORE    = 7'h23,</pre>
<pre>  OPCODE_OP       = 7'h33,</pre>
<pre>  OPCODE_LUI      = 7'h37,</pre>
<pre>  OPCODE_BRANCH   = 7'h63,</pre>
<pre>  OPCODE_JALR     = 7'h67,</pre>
<pre>  OPCODE_JAL      = 7'h6f,</pre>
<pre>  OPCODE_SYSTEM   = 7'h73</pre>
<pre>} opcode_e;</pre>
<pre>typedef enum logic [4:0] {</pre>
<pre>  ALU_ADD,</pre>
<pre>  ALU_SUB,</pre>
<pre>  ALU_XOR,</pre>
<pre>  ALU_OR,</pre>
<pre>  ALU_AND,</pre>
<pre>  ALU_SRA,</pre>
<pre>  ALU_SRL,</pre>
<pre>  ALU_SLL,</pre>
<pre>  ALU_LT,</pre>
<pre>  ALU_LTU,</pre>
<pre>  ALU_GE,</pre>
<pre>  ALU_GEU,</pre>
<pre>  ALU_EQ,</pre>
<pre>  ALU_NE,</pre>
<pre>  ALU_SLT,</pre>
<pre>  ALU_SLTU</pre>
<pre>} alu_op_e;</pre>
<pre>typedef enum logic [1:0] {</pre>
<pre>  MD_OP_MULL,</pre>
<pre>  MD_OP_MULH,</pre>
<pre>  MD_OP_DIV,</pre>
<pre>  MD_OP_REM</pre>
<pre>} md_op_e;</pre>
<pre>typedef enum logic [1:0] {</pre>
<pre>  CSR_OP_READ,</pre>
<pre>  CSR_OP_WRITE,</pre>
<pre>  CSR_OP_SET,</pre>
<pre>  CSR_OP_CLEAR</pre>
<pre>} csr_op_e;</pre>
<pre>typedef enum logic[1:0] {</pre>
<pre>  PRIV_LVL_M = 2'b11,</pre>
<pre>  PRIV_LVL_H = 2'b10,</pre>
<pre>  PRIV_LVL_S = 2'b01,</pre>
<pre>  PRIV_LVL_U = 2'b00</pre>
<pre>} priv_lvl_e;</pre>
<pre>typedef enum logic[3:0] {</pre>
<pre>   XDEBUGVER_NO     = 4'd0, // no external debug support</pre>
<pre>   XDEBUGVER_STD    = 4'd4, // external debug according to RISC-V debug spec</pre>
<pre>   XDEBUGVER_NONSTD = 4'd15 // debug not conforming to RISC-V debug spec</pre>
<pre>} x_debug_ver_e;</pre>
<pre>typedef enum logic[1:0] {</pre>
<pre>  OP_A_REG_A,</pre>
<pre>  OP_A_FWD,</pre>
<pre>  OP_A_CURRPC,</pre>
<pre>  OP_A_IMM</pre>
<pre>} op_a_sel_e;</pre>
<pre>typedef enum logic {</pre>
<pre>  IMM_A_Z,</pre>
<pre>  IMM_A_ZERO</pre>
<pre>} imm_a_sel_e;</pre>
<pre>typedef enum logic {</pre>
<pre>  OP_B_REG_B,</pre>
<pre>  OP_B_IMM</pre>
<pre>} op_b_sel_e;</pre>
<pre>typedef enum logic [2:0] {</pre>
<pre>  IMM_B_I,</pre>
<pre>  IMM_B_S,</pre>
<pre>  IMM_B_B,</pre>
<pre>  IMM_B_U,</pre>
<pre>  IMM_B_J,</pre>
<pre>  IMM_B_INCR_PC,</pre>
<pre>  IMM_B_INCR_ADDR</pre>
<pre>} imm_b_sel_e;</pre>
<pre>typedef enum logic [1:0] {</pre>
<pre>  RF_WD_LSU,</pre>
<pre>  RF_WD_EX,</pre>
<pre>  RF_WD_CSR</pre>
<pre>} rf_wd_sel_e;</pre>
<pre>typedef enum logic [2:0] {</pre>
<pre>  PC_BOOT,</pre>
<pre>  PC_JUMP,</pre>
<pre>  PC_EXC,</pre>
<pre>  PC_ERET,</pre>
<pre>  PC_DRET</pre>
<pre>} pc_sel_e;</pre>
<pre>typedef enum logic [1:0] {</pre>
<pre>  EXC_PC_EXC,</pre>
<pre>  EXC_PC_IRQ,</pre>
<pre>  EXC_PC_DBD,</pre>
<pre>  EXC_PC_DBG_EXC // Exception while in debug mode</pre>
<pre>} exc_pc_sel_e;</pre>
<pre>typedef enum logic [5:0] {</pre>
<pre>  EXC_CAUSE_IRQ_SOFTWARE_M     = {1'b1, 5'd03},</pre>
<pre>  EXC_CAUSE_IRQ_TIMER_M        = {1'b1, 5'd07},</pre>
<pre>  EXC_CAUSE_IRQ_EXTERNAL_M     = {1'b1, 5'd11},</pre>
<pre>  EXC_CAUSE_IRQ_NM             = {1'b1, 5'd31}, // == EXC_CAUSE_IRQ_FAST_15</pre>
<pre>  EXC_CAUSE_INSN_ADDR_MISA     = {1'b0, 5'd00},</pre>
<pre>  EXC_CAUSE_INSTR_ACCESS_FAULT = {1'b0, 5'd01},</pre>
<pre>  EXC_CAUSE_ILLEGAL_INSN       = {1'b0, 5'd02},</pre>
<pre>  EXC_CAUSE_BREAKPOINT         = {1'b0, 5'd03},</pre>
<pre>  EXC_CAUSE_LOAD_ACCESS_FAULT  = {1'b0, 5'd05},</pre>
<pre>  EXC_CAUSE_STORE_ACCESS_FAULT = {1'b0, 5'd07},</pre>
<pre>  EXC_CAUSE_ECALL_UMODE        = {1'b0, 5'd08},</pre>
<pre>  EXC_CAUSE_ECALL_MMODE        = {1'b0, 5'd11}</pre>
<pre>} exc_cause_e;</pre>
<pre>typedef enum logic [2:0] {</pre>
<pre>  DBG_CAUSE_NONE    = 3'h0,</pre>
<pre>  DBG_CAUSE_EBREAK  = 3'h1,</pre>
<pre>  DBG_CAUSE_TRIGGER = 3'h2,</pre>
<pre>  DBG_CAUSE_HALTREQ = 3'h3,</pre>
<pre>  DBG_CAUSE_STEP    = 3'h4</pre>
<pre>} dbg_cause_e;</pre>
<pre>parameter int unsigned PMP_MAX_REGIONS      = 16;</pre>
<pre>parameter int unsigned PMP_CFG_W            = 8;</pre>
<pre>parameter int unsigned PMP_I = 0;</pre>
<pre>parameter int unsigned PMP_D = 1;</pre>
<pre>typedef enum logic [1:0] {</pre>
<pre>  PMP_ACC_EXEC    = 2'b00,</pre>
<pre>  PMP_ACC_WRITE   = 2'b01,</pre>
<pre>  PMP_ACC_READ    = 2'b10</pre>
<pre>} pmp_req_e;</pre>
<pre>typedef enum logic [1:0] {</pre>
<pre>  PMP_MODE_OFF   = 2'b00,</pre>
<pre>  PMP_MODE_TOR   = 2'b01,</pre>
<pre>  PMP_MODE_NA4   = 2'b10,</pre>
<pre>  PMP_MODE_NAPOT = 2'b11</pre>
<pre>} pmp_cfg_mode_e;</pre>
<pre>typedef struct packed {</pre>
<pre>  logic          lock;</pre>
<pre>  pmp_cfg_mode_e mode;</pre>
<pre>  logic          exec;</pre>
<pre>  logic          write;</pre>
<pre>  logic          read;</pre>
<pre style="background-color: #FF0000;">} pmp_cfg_t;</pre>
<pre>typedef enum logic[11:0] {</pre>
<pre>  CSR_MHARTID   = 12'hF14,</pre>
<pre>  CSR_MSTATUS   = 12'h300,</pre>
<pre>  CSR_MISA      = 12'h301,</pre>
<pre>  CSR_MIE       = 12'h304,</pre>
<pre>  CSR_MTVEC     = 12'h305,</pre>
<pre>  CSR_MSCRATCH  = 12'h340,</pre>
<pre>  CSR_MEPC      = 12'h341,</pre>
<pre>  CSR_MCAUSE    = 12'h342,</pre>
<pre>  CSR_MTVAL     = 12'h343,</pre>
<pre>  CSR_MIP       = 12'h344,</pre>
<pre>  CSR_PMPCFG0   = 12'h3A0,</pre>
<pre>  CSR_PMPCFG1   = 12'h3A1,</pre>
<pre>  CSR_PMPCFG2   = 12'h3A2,</pre>
<pre>  CSR_PMPCFG3   = 12'h3A3,</pre>
<pre>  CSR_PMPADDR0  = 12'h3B0,</pre>
<pre>  CSR_PMPADDR1  = 12'h3B1,</pre>
<pre>  CSR_PMPADDR2  = 12'h3B2,</pre>
<pre>  CSR_PMPADDR3  = 12'h3B3,</pre>
<pre>  CSR_PMPADDR4  = 12'h3B4,</pre>
<pre>  CSR_PMPADDR5  = 12'h3B5,</pre>
<pre>  CSR_PMPADDR6  = 12'h3B6,</pre>
<pre>  CSR_PMPADDR7  = 12'h3B7,</pre>
<pre>  CSR_PMPADDR8  = 12'h3B8,</pre>
<pre>  CSR_PMPADDR9  = 12'h3B9,</pre>
<pre>  CSR_PMPADDR10 = 12'h3BA,</pre>
<pre>  CSR_PMPADDR11 = 12'h3BB,</pre>
<pre>  CSR_PMPADDR12 = 12'h3BC,</pre>
<pre>  CSR_PMPADDR13 = 12'h3BD,</pre>
<pre>  CSR_PMPADDR14 = 12'h3BE,</pre>
<pre>  CSR_PMPADDR15 = 12'h3BF,</pre>
<pre>  CSR_TSELECT   = 12'h7A0,</pre>
<pre>  CSR_TDATA1    = 12'h7A1,</pre>
<pre>  CSR_TDATA2    = 12'h7A2,</pre>
<pre>  CSR_TDATA3    = 12'h7A3,</pre>
<pre>  CSR_MCONTEXT  = 12'h7A8,</pre>
<pre>  CSR_SCONTEXT  = 12'h7AA,</pre>
<pre>  CSR_DCSR      = 12'h7b0,</pre>
<pre>  CSR_DPC       = 12'h7b1,</pre>
<pre>  CSR_DSCRATCH0 = 12'h7b2, // optional</pre>
<pre>  CSR_DSCRATCH1 = 12'h7b3, // optional</pre>
<pre>  CSR_MCOUNTINHIBIT  = 12'h320,</pre>
<pre>  CSR_MHPMEVENT3     = 12'h323,</pre>
<pre>  CSR_MHPMEVENT4     = 12'h324,</pre>
<pre>  CSR_MHPMEVENT5     = 12'h325,</pre>
<pre>  CSR_MHPMEVENT6     = 12'h326,</pre>
<pre>  CSR_MHPMEVENT7     = 12'h327,</pre>
<pre>  CSR_MHPMEVENT8     = 12'h328,</pre>
<pre>  CSR_MHPMEVENT9     = 12'h329,</pre>
<pre>  CSR_MHPMEVENT10    = 12'h32A,</pre>
<pre>  CSR_MHPMEVENT11    = 12'h32B,</pre>
<pre>  CSR_MHPMEVENT12    = 12'h32C,</pre>
<pre>  CSR_MHPMEVENT13    = 12'h32D,</pre>
<pre>  CSR_MHPMEVENT14    = 12'h32E,</pre>
<pre>  CSR_MHPMEVENT15    = 12'h32F,</pre>
<pre>  CSR_MHPMEVENT16    = 12'h330,</pre>
<pre>  CSR_MHPMEVENT17    = 12'h331,</pre>
<pre>  CSR_MHPMEVENT18    = 12'h332,</pre>
<pre>  CSR_MHPMEVENT19    = 12'h333,</pre>
<pre>  CSR_MHPMEVENT20    = 12'h334,</pre>
<pre>  CSR_MHPMEVENT21    = 12'h335,</pre>
<pre>  CSR_MHPMEVENT22    = 12'h336,</pre>
<pre>  CSR_MHPMEVENT23    = 12'h337,</pre>
<pre>  CSR_MHPMEVENT24    = 12'h338,</pre>
<pre>  CSR_MHPMEVENT25    = 12'h339,</pre>
<pre>  CSR_MHPMEVENT26    = 12'h33A,</pre>
<pre>  CSR_MHPMEVENT27    = 12'h33B,</pre>
<pre>  CSR_MHPMEVENT28    = 12'h33C,</pre>
<pre>  CSR_MHPMEVENT29    = 12'h33D,</pre>
<pre>  CSR_MHPMEVENT30    = 12'h33E,</pre>
<pre>  CSR_MHPMEVENT31    = 12'h33F,</pre>
<pre>  CSR_MCYCLE         = 12'hB00,</pre>
<pre>  CSR_MINSTRET       = 12'hB02,</pre>
<pre>  CSR_MHPMCOUNTER3   = 12'hB03,</pre>
<pre>  CSR_MHPMCOUNTER4   = 12'hB04,</pre>
<pre>  CSR_MHPMCOUNTER5   = 12'hB05,</pre>
<pre>  CSR_MHPMCOUNTER6   = 12'hB06,</pre>
<pre>  CSR_MHPMCOUNTER7   = 12'hB07,</pre>
<pre>  CSR_MHPMCOUNTER8   = 12'hB08,</pre>
<pre>  CSR_MHPMCOUNTER9   = 12'hB09,</pre>
<pre>  CSR_MHPMCOUNTER10  = 12'hB0A,</pre>
<pre>  CSR_MHPMCOUNTER11  = 12'hB0B,</pre>
<pre>  CSR_MHPMCOUNTER12  = 12'hB0C,</pre>
<pre>  CSR_MHPMCOUNTER13  = 12'hB0D,</pre>
<pre>  CSR_MHPMCOUNTER14  = 12'hB0E,</pre>
<pre>  CSR_MHPMCOUNTER15  = 12'hB0F,</pre>
<pre>  CSR_MHPMCOUNTER16  = 12'hB10,</pre>
<pre>  CSR_MHPMCOUNTER17  = 12'hB11,</pre>
<pre>  CSR_MHPMCOUNTER18  = 12'hB12,</pre>
<pre>  CSR_MHPMCOUNTER19  = 12'hB13,</pre>
<pre>  CSR_MHPMCOUNTER20  = 12'hB14,</pre>
<pre>  CSR_MHPMCOUNTER21  = 12'hB15,</pre>
<pre>  CSR_MHPMCOUNTER22  = 12'hB16,</pre>
<pre>  CSR_MHPMCOUNTER23  = 12'hB17,</pre>
<pre>  CSR_MHPMCOUNTER24  = 12'hB18,</pre>
<pre>  CSR_MHPMCOUNTER25  = 12'hB19,</pre>
<pre>  CSR_MHPMCOUNTER26  = 12'hB1A,</pre>
<pre>  CSR_MHPMCOUNTER27  = 12'hB1B,</pre>
<pre>  CSR_MHPMCOUNTER28  = 12'hB1C,</pre>
<pre>  CSR_MHPMCOUNTER29  = 12'hB1D,</pre>
<pre>  CSR_MHPMCOUNTER30  = 12'hB1E,</pre>
<pre>  CSR_MHPMCOUNTER31  = 12'hB1F,</pre>
<pre>  CSR_MCYCLEH        = 12'hB80,</pre>
<pre>  CSR_MINSTRETH      = 12'hB82,</pre>
<pre>  CSR_MHPMCOUNTER3H  = 12'hB83,</pre>
<pre>  CSR_MHPMCOUNTER4H  = 12'hB84,</pre>
<pre>  CSR_MHPMCOUNTER5H  = 12'hB85,</pre>
<pre>  CSR_MHPMCOUNTER6H  = 12'hB86,</pre>
<pre>  CSR_MHPMCOUNTER7H  = 12'hB87,</pre>
<pre>  CSR_MHPMCOUNTER8H  = 12'hB88,</pre>
<pre>  CSR_MHPMCOUNTER9H  = 12'hB89,</pre>
<pre>  CSR_MHPMCOUNTER10H = 12'hB8A,</pre>
<pre>  CSR_MHPMCOUNTER11H = 12'hB8B,</pre>
<pre>  CSR_MHPMCOUNTER12H = 12'hB8C,</pre>
<pre>  CSR_MHPMCOUNTER13H = 12'hB8D,</pre>
<pre>  CSR_MHPMCOUNTER14H = 12'hB8E,</pre>
<pre>  CSR_MHPMCOUNTER15H = 12'hB8F,</pre>
<pre>  CSR_MHPMCOUNTER16H = 12'hB90,</pre>
<pre>  CSR_MHPMCOUNTER17H = 12'hB91,</pre>
<pre>  CSR_MHPMCOUNTER18H = 12'hB92,</pre>
<pre>  CSR_MHPMCOUNTER19H = 12'hB93,</pre>
<pre>  CSR_MHPMCOUNTER20H = 12'hB94,</pre>
<pre>  CSR_MHPMCOUNTER21H = 12'hB95,</pre>
<pre>  CSR_MHPMCOUNTER22H = 12'hB96,</pre>
<pre>  CSR_MHPMCOUNTER23H = 12'hB97,</pre>
<pre>  CSR_MHPMCOUNTER24H = 12'hB98,</pre>
<pre>  CSR_MHPMCOUNTER25H = 12'hB99,</pre>
<pre>  CSR_MHPMCOUNTER26H = 12'hB9A,</pre>
<pre>  CSR_MHPMCOUNTER27H = 12'hB9B,</pre>
<pre>  CSR_MHPMCOUNTER28H = 12'hB9C,</pre>
<pre>  CSR_MHPMCOUNTER29H = 12'hB9D,</pre>
<pre>  CSR_MHPMCOUNTER30H = 12'hB9E,</pre>
<pre>  CSR_MHPMCOUNTER31H = 12'hB9F</pre>
<pre>} csr_num_e;</pre>
<pre>parameter logic [11:0] CSR_OFF_PMP_CFG  = 12'h3A0; // pmp_cfg  @ 12'h3a0 - 12'h3a3</pre>
<pre>parameter logic [11:0] CSR_OFF_PMP_ADDR = 12'h3B0; // pmp_addr @ 12'h3b0 - 12'h3bf</pre>
<pre>parameter int unsigned CSR_MSTATUS_MIE_BIT      = 3;</pre>
<pre>parameter int unsigned CSR_MSTATUS_MPIE_BIT     = 7;</pre>
<pre>parameter int unsigned CSR_MSTATUS_MPP_BIT_LOW  = 11;</pre>
<pre>parameter int unsigned CSR_MSTATUS_MPP_BIT_HIGH = 12;</pre>
<pre>parameter int unsigned CSR_MSTATUS_MPRV_BIT     = 17;</pre>
<pre>parameter int unsigned CSR_MSTATUS_TW_BIT       = 21;</pre>
<pre>parameter int unsigned CSR_MSIX_BIT      = 3;</pre>
<pre>parameter int unsigned CSR_MTIX_BIT      = 7;</pre>
<pre>parameter int unsigned CSR_MEIX_BIT      = 11;</pre>
<pre>parameter int unsigned CSR_MFIX_BIT_LOW  = 16;</pre>
<pre>parameter int unsigned CSR_MFIX_BIT_HIGH = 30;</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv</h3>
<pre>module ibex_id_stage #(</pre>
<pre>    parameter bit RV32E = 0,</pre>
<pre>    parameter bit RV32M = 1</pre>
<pre>    input  logic                  clk_i,</pre>
<pre>    input  logic                  rst_ni,</pre>
<pre>    input  logic                  test_en_i,</pre>
<pre>    input  logic                  fetch_enable_i,</pre>
<pre>    output logic                  ctrl_busy_o,</pre>
<pre>    output logic                  illegal_insn_o,</pre>
<pre>    input  logic                  instr_valid_i,</pre>
<pre>    input  logic                  instr_new_i,</pre>
<pre>    input  logic [31:0]           instr_rdata_i,         // from IF-ID pipeline registers</pre>
<pre>    input  logic [15:0]           instr_rdata_c_i,       // from IF-ID pipeline registers</pre>
<pre>    input  logic                  instr_is_compressed_i,</pre>
<pre>    output logic                  instr_req_o,</pre>
<pre>    output logic                  instr_valid_clear_o,   // kill instr in IF-ID reg</pre>
<pre>    output logic                  id_in_ready_o,         // ID stage is ready for next instr</pre>
<pre>    input  logic                  branch_decision_i,</pre>
<pre>    output logic                  pc_set_o,</pre>
<pre>    output ibex_pkg::pc_sel_e     pc_mux_o,</pre>
<pre>    output ibex_pkg::exc_pc_sel_e exc_pc_mux_o,</pre>
<pre>    output ibex_pkg::exc_cause_e  exc_cause_o,</pre>
<pre>    input  logic                  illegal_c_insn_i,</pre>
<pre>    input  logic                  instr_fetch_err_i,</pre>
<pre>    input  logic [31:0]           pc_id_i,</pre>
<pre>    input  logic                  ex_valid_i,     // EX stage has valid output</pre>
<pre>    input  logic                  lsu_valid_i,    // LSU has valid output, or is done</pre>
<pre>    output ibex_pkg::alu_op_e     alu_operator_ex_o,</pre>
<pre>    output logic [31:0]           alu_operand_a_ex_o,</pre>
<pre>    output logic [31:0]           alu_operand_b_ex_o,</pre>
<pre>    output logic                  mult_en_ex_o,</pre>
<pre>    output logic                  div_en_ex_o,</pre>
<pre>    output ibex_pkg::md_op_e      multdiv_operator_ex_o,</pre>
<pre>    output logic  [1:0]           multdiv_signed_mode_ex_o,</pre>
<pre>    output logic [31:0]           multdiv_operand_a_ex_o,</pre>
<pre>    output logic [31:0]           multdiv_operand_b_ex_o,</pre>
<pre>    output logic                  csr_access_o,</pre>
<pre>    output ibex_pkg::csr_op_e     csr_op_o,</pre>
<pre>    output logic                  csr_save_if_o,</pre>
<pre>    output logic                  csr_save_id_o,</pre>
<pre>    output logic                  csr_restore_mret_id_o,</pre>
<pre>    output logic                  csr_restore_dret_id_o,</pre>
<pre>    output logic                  csr_save_cause_o,</pre>
<pre>    output logic [31:0]           csr_mtval_o,</pre>
<pre>    input  ibex_pkg::priv_lvl_e   priv_mode_i,</pre>
<pre>    input  logic                  csr_mstatus_tw_i,</pre>
<pre>    input  logic                  illegal_csr_insn_i,</pre>
<pre>    output logic                  data_req_ex_o,</pre>
<pre>    output logic                  data_we_ex_o,</pre>
<pre>    output logic [1:0]            data_type_ex_o,</pre>
<pre>    output logic                  data_sign_ext_ex_o,</pre>
<pre>    output logic [31:0]           data_wdata_ex_o,</pre>
<pre>    input  logic                  lsu_addr_incr_req_i,</pre>
<pre>    input  logic [31:0]           lsu_addr_last_i,</pre>
<pre>    input  logic                  csr_mstatus_mie_i,</pre>
<pre>    input  logic                  csr_msip_i,</pre>
<pre>    input  logic                  csr_mtip_i,</pre>
<pre>    input  logic                  csr_meip_i,</pre>
<pre>    input  logic [14:0]           csr_mfip_i,</pre>
<pre>    input  logic                  irq_pending_i,</pre>
<pre>    input  logic                  irq_nm_i,</pre>
<pre>    output logic                  nmi_mode_o,</pre>
<pre>    input  logic                  lsu_load_err_i,</pre>
<pre>    input  logic                  lsu_store_err_i,</pre>
<pre>    output logic                  debug_mode_o,</pre>
<pre>    output ibex_pkg::dbg_cause_e  debug_cause_o,</pre>
<pre>    output logic                  debug_csr_save_o,</pre>
<pre>    input  logic                  debug_req_i,</pre>
<pre>    input  logic                  debug_single_step_i,</pre>
<pre>    input  logic                  debug_ebreakm_i,</pre>
<pre>    input  logic                  debug_ebreaku_i,</pre>
<pre>    input  logic                  trigger_match_i,</pre>
<pre>    input  logic [31:0]           regfile_wdata_lsu_i,</pre>
<pre>    input  logic [31:0]           regfile_wdata_ex_i,</pre>
<pre>    input  logic [31:0]           csr_rdata_i,</pre>
<pre>    output logic                  perf_jump_o,    // executing a jump instr</pre>
<pre>    output logic                  perf_branch_o,  // executing a branch instr</pre>
<pre>    output logic                  perf_tbranch_o, // executing a taken branch instr</pre>
<pre>    output logic                  instr_ret_o,</pre>
<pre>    output logic                  instr_ret_compressed_o</pre>
<pre>  logic        illegal_insn_dec;</pre>
<pre>  logic        ebrk_insn;</pre>
<pre>  logic        mret_insn_dec;</pre>
<pre>  logic        dret_insn_dec;</pre>
<pre>  logic        ecall_insn_dec;</pre>
<pre>  logic        wfi_insn_dec;</pre>
<pre>  logic        branch_in_dec;</pre>
<pre>  logic        branch_set_n, branch_set_q;</pre>
<pre>  logic        jump_in_dec;</pre>
<pre>  logic        jump_set;</pre>
<pre>  logic        instr_executing;</pre>
<pre>  logic        instr_multicycle;</pre>
<pre>  logic        instr_multicycle_done_n, instr_multicycle_done_q;</pre>
<pre>  logic        stall_lsu;</pre>
<pre>  logic        stall_multdiv;</pre>
<pre>  logic        stall_branch;</pre>
<pre>  logic        stall_jump;</pre>
<pre>  logic [31:0] imm_i_type;</pre>
<pre>  logic [31:0] imm_s_type;</pre>
<pre>  logic [31:0] imm_b_type;</pre>
<pre>  logic [31:0] imm_u_type;</pre>
<pre>  logic [31:0] imm_j_type;</pre>
<pre>  logic [31:0] zimm_rs1_type;</pre>
<pre>  logic [31:0] imm_a;       // contains the immediate for operand b</pre>
<pre>  logic [31:0] imm_b;       // contains the immediate for operand b</pre>
<pre>  logic [4:0]  regfile_raddr_a;</pre>
<pre>  logic [4:0]  regfile_raddr_b;</pre>
<pre>  logic [4:0]  regfile_waddr;</pre>
<pre>  logic [31:0] regfile_rdata_a;</pre>
<pre>  logic [31:0] regfile_rdata_b;</pre>
<pre>  logic [31:0] regfile_wdata;</pre>
<pre>  rf_wd_sel_e  regfile_wdata_sel;</pre>
<pre>  logic        regfile_we;</pre>
<pre>  logic        regfile_we_wb, regfile_we_dec;</pre>
<pre>  alu_op_e     alu_operator;</pre>
<pre>  op_a_sel_e   alu_op_a_mux_sel, alu_op_a_mux_sel_dec;</pre>
<pre>  op_b_sel_e   alu_op_b_mux_sel, alu_op_b_mux_sel_dec;</pre>
<pre>  imm_a_sel_e  imm_a_mux_sel;</pre>
<pre>  imm_b_sel_e  imm_b_mux_sel, imm_b_mux_sel_dec;</pre>
<pre>  logic        mult_en_id, mult_en_dec; // use integer multiplier</pre>
<pre>  logic        div_en_id, div_en_dec;   // use integer division or reminder</pre>
<pre>  logic        multdiv_en_dec;</pre>
<pre>  md_op_e      multdiv_operator;</pre>
<pre>  logic [1:0]  multdiv_signed_mode;</pre>
<pre>  logic        data_we_id;</pre>
<pre>  logic [1:0]  data_type_id;</pre>
<pre>  logic        data_sign_ext_id;</pre>
<pre>  logic        data_req_id, data_req_dec;</pre>
<pre>  logic        csr_pipe_flush;</pre>
<pre>  logic [31:0] alu_operand_a;</pre>
<pre>  logic [31:0] alu_operand_b;</pre>
<pre>  assign alu_op_a_mux_sel = lsu_addr_incr_req_i ? OP_A_FWD        : alu_op_a_mux_sel_dec;</pre>
<pre>  assign alu_op_b_mux_sel = lsu_addr_incr_req_i ? OP_B_IMM        : alu_op_b_mux_sel_dec;</pre>
<pre>  assign imm_b_mux_sel    = lsu_addr_incr_req_i ? IMM_B_INCR_ADDR : imm_b_mux_sel_dec;</pre>
<pre>  assign imm_a = (imm_a_mux_sel == IMM_A_Z) ? zimm_rs1_type : '0;</pre>
<pre>  always_comb begin : alu_operand_a_mux</pre>
<pre>    unique case (alu_op_a_mux_sel)</pre>
<pre>      OP_A_REG_A:  alu_operand_a = regfile_rdata_a;</pre>
<pre>      OP_A_FWD:    alu_operand_a = lsu_addr_last_i;</pre>
<pre>      OP_A_CURRPC: alu_operand_a = pc_id_i;</pre>
<pre>      OP_A_IMM:    alu_operand_a = imm_a;</pre>
<pre>      default:     alu_operand_a = pc_id_i;</pre>
<pre>  always_comb begin : immediate_b_mux</pre>
<pre>    unique case (imm_b_mux_sel)</pre>
<pre>      IMM_B_I:         imm_b = imm_i_type;</pre>
<pre>      IMM_B_S:         imm_b = imm_s_type;</pre>
<pre>      IMM_B_B:         imm_b = imm_b_type;</pre>
<pre>      IMM_B_U:         imm_b = imm_u_type;</pre>
<pre>      IMM_B_J:         imm_b = imm_j_type;</pre>
<pre>      IMM_B_INCR_PC:   imm_b = instr_is_compressed_i ? 32'h2 : 32'h4;</pre>
<pre>      IMM_B_INCR_ADDR: imm_b = 32'h4;</pre>
<pre>      default:         imm_b = 32'h4;</pre>
<pre>  assign alu_operand_b = (alu_op_b_mux_sel == OP_B_IMM) ? imm_b : regfile_rdata_b;</pre>
<pre>  assign regfile_we = (illegal_csr_insn_i || !instr_executing) ? 1'b0          :</pre>
<pre>                      (data_req_dec || multdiv_en_dec)         ? regfile_we_wb : regfile_we_dec;</pre>
<pre>  always_comb begin : regfile_wdata_mux</pre>
<pre>    unique case (regfile_wdata_sel)</pre>
<pre>      RF_WD_EX:  regfile_wdata = regfile_wdata_ex_i;</pre>
<pre>      RF_WD_LSU: regfile_wdata = regfile_wdata_lsu_i;</pre>
<pre>      RF_WD_CSR: regfile_wdata = csr_rdata_i;</pre>
<pre>      default:   regfile_wdata = regfile_wdata_ex_i;</pre>
<pre>  ibex_register_file #( .RV32E ( RV32E ) ) registers_i (</pre>
<pre>      .clk_i        ( clk_i           ),</pre>
<pre>      .rst_ni       ( rst_ni          ),</pre>
<pre>      .test_en_i    ( test_en_i       ),</pre>
<pre>      .raddr_a_i    ( regfile_raddr_a ),</pre>
<pre>      .rdata_a_o    ( regfile_rdata_a ),</pre>
<pre>      .raddr_b_i    ( regfile_raddr_b ),</pre>
<pre>      .rdata_b_o    ( regfile_rdata_b ),</pre>
<pre>      .waddr_a_i    ( regfile_waddr   ),</pre>
<pre>      .wdata_a_i    ( regfile_wdata   ),</pre>
<pre>      .we_a_i       ( regfile_we      )</pre>
<pre>  ibex_decoder #(</pre>
<pre>      .RV32E ( RV32E ),</pre>
<pre>      .RV32M ( RV32M )</pre>
<pre style="background-color: #FF0000;">  ) decoder_i (</pre>
<pre>      .clk_i                           ( clk_i                ),</pre>
<pre>      .rst_ni                          ( rst_ni               ),</pre>
<pre>      .illegal_insn_o                  ( illegal_insn_dec     ),</pre>
<pre>      .ebrk_insn_o                     ( ebrk_insn            ),</pre>
<pre>      .mret_insn_o                     ( mret_insn_dec        ),</pre>
<pre>      .dret_insn_o                     ( dret_insn_dec        ),</pre>
<pre>      .ecall_insn_o                    ( ecall_insn_dec       ),</pre>
<pre>      .wfi_insn_o                      ( wfi_insn_dec         ),</pre>
<pre>      .jump_set_o                      ( jump_set             ),</pre>
<pre>      .instr_new_i                     ( instr_new_i          ),</pre>
<pre>      .instr_rdata_i                   ( instr_rdata_i        ),</pre>
<pre>      .illegal_c_insn_i                ( illegal_c_insn_i     ),</pre>
<pre>      .imm_a_mux_sel_o                 ( imm_a_mux_sel        ),</pre>
<pre>      .imm_b_mux_sel_o                 ( imm_b_mux_sel_dec    ),</pre>
<pre>      .imm_i_type_o                    ( imm_i_type           ),</pre>
<pre>      .imm_s_type_o                    ( imm_s_type           ),</pre>
<pre>      .imm_b_type_o                    ( imm_b_type           ),</pre>
<pre>      .imm_u_type_o                    ( imm_u_type           ),</pre>
<pre>      .imm_j_type_o                    ( imm_j_type           ),</pre>
<pre>      .zimm_rs1_type_o                 ( zimm_rs1_type        ),</pre>
<pre>      .regfile_wdata_sel_o             ( regfile_wdata_sel    ),</pre>
<pre>      .regfile_we_o                    ( regfile_we_dec       ),</pre>
<pre>      .regfile_raddr_a_o               ( regfile_raddr_a      ),</pre>
<pre>      .regfile_raddr_b_o               ( regfile_raddr_b      ),</pre>
<pre>      .regfile_waddr_o                 ( regfile_waddr        ),</pre>
<pre>      .alu_operator_o                  ( alu_operator         ),</pre>
<pre>      .alu_op_a_mux_sel_o              ( alu_op_a_mux_sel_dec ),</pre>
<pre>      .alu_op_b_mux_sel_o              ( alu_op_b_mux_sel_dec ),</pre>
<pre>      .mult_en_o                       ( mult_en_dec          ),</pre>
<pre>      .div_en_o                        ( div_en_dec           ),</pre>
<pre>      .multdiv_operator_o              ( multdiv_operator     ),</pre>
<pre>      .multdiv_signed_mode_o           ( multdiv_signed_mode  ),</pre>
<pre>      .csr_access_o                    ( csr_access_o         ),</pre>
<pre>      .csr_op_o                        ( csr_op_o             ),</pre>
<pre>      .csr_pipe_flush_o                ( csr_pipe_flush       ),</pre>
<pre>      .data_req_o                      ( data_req_dec         ),</pre>
<pre>      .data_we_o                       ( data_we_id           ),</pre>
<pre>      .data_type_o                     ( data_type_id         ),</pre>
<pre>      .data_sign_extension_o           ( data_sign_ext_id     ),</pre>
<pre>      .jump_in_dec_o                   ( jump_in_dec          ),</pre>
<pre>      .branch_in_dec_o                 ( branch_in_dec        )</pre>
<pre>  assign illegal_insn_o = instr_valid_i & (illegal_insn_dec | illegal_csr_insn_i);</pre>
<pre>  ibex_controller controller_i (</pre>
<pre>      .clk_i                          ( clk_i                  ),</pre>
<pre>      .rst_ni                         ( rst_ni                 ),</pre>
<pre>      .fetch_enable_i                 ( fetch_enable_i         ),</pre>
<pre>      .ctrl_busy_o                    ( ctrl_busy_o            ),</pre>
<pre>      .illegal_insn_i                 ( illegal_insn_o         ),</pre>
<pre>      .ecall_insn_i                   ( ecall_insn_dec         ),</pre>
<pre>      .mret_insn_i                    ( mret_insn_dec          ),</pre>
<pre>      .dret_insn_i                    ( dret_insn_dec          ),</pre>
<pre>      .wfi_insn_i                     ( wfi_insn_dec           ),</pre>
<pre>      .ebrk_insn_i                    ( ebrk_insn              ),</pre>
<pre>      .csr_pipe_flush_i               ( csr_pipe_flush         ),</pre>
<pre>      .instr_valid_i                  ( instr_valid_i          ),</pre>
<pre>      .instr_i                        ( instr_rdata_i          ),</pre>
<pre>      .instr_compressed_i             ( instr_rdata_c_i        ),</pre>
<pre>      .instr_is_compressed_i          ( instr_is_compressed_i  ),</pre>
<pre>      .instr_fetch_err_i              ( instr_fetch_err_i      ),</pre>
<pre>      .pc_id_i                        ( pc_id_i                ),</pre>
<pre>      .instr_valid_clear_o            ( instr_valid_clear_o    ),</pre>
<pre>      .id_in_ready_o                  ( id_in_ready_o          ),</pre>
<pre>      .instr_req_o                    ( instr_req_o            ),</pre>
<pre>      .pc_set_o                       ( pc_set_o               ),</pre>
<pre>      .pc_mux_o                       ( pc_mux_o               ),</pre>
<pre>      .exc_pc_mux_o                   ( exc_pc_mux_o           ),</pre>
<pre>      .exc_cause_o                    ( exc_cause_o            ),</pre>
<pre>      .lsu_addr_last_i                ( lsu_addr_last_i        ),</pre>
<pre>      .load_err_i                     ( lsu_load_err_i         ),</pre>
<pre>      .store_err_i                    ( lsu_store_err_i        ),</pre>
<pre>      .branch_set_i                   ( branch_set_q           ),</pre>
<pre>      .jump_set_i                     ( jump_set               ),</pre>
<pre>      .csr_mstatus_mie_i              ( csr_mstatus_mie_i      ),</pre>
<pre>      .csr_msip_i                     ( csr_msip_i             ),</pre>
<pre>      .csr_mtip_i                     ( csr_mtip_i             ),</pre>
<pre>      .csr_meip_i                     ( csr_meip_i             ),</pre>
<pre>      .csr_mfip_i                     ( csr_mfip_i             ),</pre>
<pre>      .irq_pending_i                  ( irq_pending_i          ),</pre>
<pre>      .irq_nm_i                       ( irq_nm_i               ),</pre>
<pre>      .nmi_mode_o                     ( nmi_mode_o             ),</pre>
<pre>      .csr_save_if_o                  ( csr_save_if_o          ),</pre>
<pre>      .csr_save_id_o                  ( csr_save_id_o          ),</pre>
<pre>      .csr_restore_mret_id_o          ( csr_restore_mret_id_o  ),</pre>
<pre>      .csr_restore_dret_id_o          ( csr_restore_dret_id_o  ),</pre>
<pre>      .csr_save_cause_o               ( csr_save_cause_o       ),</pre>
<pre>      .csr_mtval_o                    ( csr_mtval_o            ),</pre>
<pre>      .priv_mode_i                    ( priv_mode_i            ),</pre>
<pre>      .csr_mstatus_tw_i               ( csr_mstatus_tw_i       ),</pre>
<pre>      .debug_mode_o                   ( debug_mode_o           ),</pre>
<pre>      .debug_cause_o                  ( debug_cause_o          ),</pre>
<pre>      .debug_csr_save_o               ( debug_csr_save_o       ),</pre>
<pre>      .debug_req_i                    ( debug_req_i            ),</pre>
<pre>      .debug_single_step_i            ( debug_single_step_i    ),</pre>
<pre>      .debug_ebreakm_i                ( debug_ebreakm_i        ),</pre>
<pre>      .debug_ebreaku_i                ( debug_ebreaku_i        ),</pre>
<pre>      .trigger_match_i                ( trigger_match_i        ),</pre>
<pre>      .stall_lsu_i                    ( stall_lsu              ),</pre>
<pre>      .stall_multdiv_i                ( stall_multdiv          ),</pre>
<pre>      .stall_jump_i                   ( stall_jump             ),</pre>
<pre>      .stall_branch_i                 ( stall_branch           ),</pre>
<pre>      .perf_jump_o                    ( perf_jump_o            ),</pre>
<pre>      .perf_tbranch_o                 ( perf_tbranch_o         )</pre>
<pre>  assign multdiv_en_dec   = mult_en_dec | div_en_dec;</pre>
<pre>  assign instr_multicycle = data_req_dec | multdiv_en_dec | branch_in_dec | jump_in_dec;</pre>
<pre>  assign instr_executing = (instr_new_i | (instr_multicycle & ~instr_multicycle_done_q)) &</pre>
<pre>                           ~instr_fetch_err_i;</pre>
<pre>  assign data_req_id     = instr_executing ? data_req_dec  : 1'b0;</pre>
<pre>  assign mult_en_id      = instr_executing ? mult_en_dec   : 1'b0;</pre>
<pre>  assign div_en_id       = instr_executing ? div_en_dec    : 1'b0;</pre>
<pre>  assign data_req_ex_o               = data_req_id;</pre>
<pre>  assign data_we_ex_o                = data_we_id;</pre>
<pre>  assign data_type_ex_o              = data_type_id;</pre>
<pre>  assign data_sign_ext_ex_o          = data_sign_ext_id;</pre>
<pre>  assign data_wdata_ex_o             = regfile_rdata_b;</pre>
<pre>  assign alu_operator_ex_o           = alu_operator;</pre>
<pre>  assign alu_operand_a_ex_o          = alu_operand_a;</pre>
<pre>  assign alu_operand_b_ex_o          = alu_operand_b;</pre>
<pre>  assign mult_en_ex_o                = mult_en_id;</pre>
<pre>  assign div_en_ex_o                 = div_en_id;</pre>
<pre>  assign multdiv_operator_ex_o       = multdiv_operator;</pre>
<pre>  assign multdiv_signed_mode_ex_o    = multdiv_signed_mode;</pre>
<pre>  assign multdiv_operand_a_ex_o      = regfile_rdata_a;</pre>
<pre>  assign multdiv_operand_b_ex_o      = regfile_rdata_b;</pre>
<pre>  typedef enum logic { IDLE, WAIT_MULTICYCLE } id_fsm_e;</pre>
<pre>  id_fsm_e id_wb_fsm_cs, id_wb_fsm_ns;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : id_wb_pipeline_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      id_wb_fsm_cs            <= IDLE;</pre>
<pre>      branch_set_q            <= 1'b0;</pre>
<pre>      instr_multicycle_done_q <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      id_wb_fsm_cs            <= id_wb_fsm_ns;</pre>
<pre>      branch_set_q            <= branch_set_n;</pre>
<pre>      instr_multicycle_done_q <= instr_multicycle_done_n;</pre>
<pre>  always_comb begin : id_wb_fsm</pre>
<pre>    id_wb_fsm_ns            = id_wb_fsm_cs;</pre>
<pre>    instr_multicycle_done_n = instr_multicycle_done_q;</pre>
<pre>    regfile_we_wb           = 1'b0;</pre>
<pre>    stall_lsu               = 1'b0;</pre>
<pre>    stall_multdiv           = 1'b0;</pre>
<pre>    stall_jump              = 1'b0;</pre>
<pre>    stall_branch            = 1'b0;</pre>
<pre>    branch_set_n            = 1'b0;</pre>
<pre>    perf_branch_o           = 1'b0;</pre>
<pre>    instr_ret_o             = 1'b0;</pre>
<pre>    unique case (id_wb_fsm_cs)</pre>
<pre>      IDLE: begin</pre>
<pre>        if (instr_new_i & ~instr_fetch_err_i) begin</pre>
<pre>          unique case (1'b1)</pre>
<pre>            data_req_dec: begin</pre>
<pre>              id_wb_fsm_ns            = WAIT_MULTICYCLE;</pre>
<pre>              stall_lsu               = 1'b1;</pre>
<pre>              instr_multicycle_done_n = 1'b0;</pre>
<pre>            multdiv_en_dec: begin</pre>
<pre>              id_wb_fsm_ns            = WAIT_MULTICYCLE;</pre>
<pre>              stall_multdiv           = 1'b1;</pre>
<pre>              instr_multicycle_done_n = 1'b0;</pre>
<pre>            branch_in_dec: begin</pre>
<pre>              id_wb_fsm_ns            =  branch_decision_i ? WAIT_MULTICYCLE : IDLE;</pre>
<pre>              stall_branch            =  branch_decision_i;</pre>
<pre>              instr_multicycle_done_n = ~branch_decision_i;</pre>
<pre>              branch_set_n            =  branch_decision_i;</pre>
<pre>              perf_branch_o           =  1'b1;</pre>
<pre>              instr_ret_o             = ~branch_decision_i;</pre>
<pre>            jump_in_dec: begin</pre>
<pre>              id_wb_fsm_ns            = WAIT_MULTICYCLE;</pre>
<pre>              stall_jump              = 1'b1;</pre>
<pre>              instr_multicycle_done_n = 1'b0;</pre>
<pre>            default: begin</pre>
<pre>              instr_multicycle_done_n = 1'b0;</pre>
<pre>              instr_ret_o             = 1'b1;</pre>
<pre>      WAIT_MULTICYCLE: begin</pre>
<pre>        if ((data_req_dec & lsu_valid_i) | (~data_req_dec & ex_valid_i)) begin</pre>
<pre>          id_wb_fsm_ns            = IDLE;</pre>
<pre>          instr_multicycle_done_n = 1'b1;</pre>
<pre>          regfile_we_wb           = regfile_we_dec & ~lsu_load_err_i;</pre>
<pre>          instr_ret_o             = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          stall_lsu               = data_req_dec;</pre>
<pre>          stall_multdiv           = multdiv_en_dec;</pre>
<pre>          stall_branch            = branch_in_dec;</pre>
<pre>          stall_jump              = jump_in_dec;</pre>
<pre>      default: begin</pre>
<pre>        id_wb_fsm_ns = IDLE;</pre>
<pre>  assign instr_ret_compressed_o = instr_ret_o & instr_is_compressed_i;</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_slow.sv</h3>
<pre>    input  logic             clk_i,</pre>
<pre>    input  logic             rst_ni,</pre>
<pre>    input  logic             mult_en_i,</pre>
<pre>    input  logic             div_en_i,</pre>
<pre>    input  ibex_pkg::md_op_e operator_i,</pre>
<pre>    input  logic  [1:0]      signed_mode_i,</pre>
<pre>    input  logic [31:0]      op_a_i,</pre>
<pre>    input  logic [31:0]      op_b_i,</pre>
<pre>    input  logic [33:0]      alu_adder_ext_i,</pre>
<pre>    input  logic [31:0]      alu_adder_i,</pre>
<pre>    input  logic             equal_to_zero,</pre>
<pre>    output logic [32:0]      alu_operand_a_o,</pre>
<pre>    output logic [32:0]      alu_operand_b_o,</pre>
<pre>    output logic [31:0]      multdiv_result_o,</pre>
<pre>    output logic             valid_o</pre>
<pre>  logic [ 4:0] multdiv_state_q, multdiv_state_d, multdiv_state_m1;</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    MD_IDLE, MD_ABS_A, MD_ABS_B, MD_COMP, MD_LAST, MD_CHANGE_SIGN, MD_FINISH</pre>
<pre>  } md_fsm_e;</pre>
<pre>  md_fsm_e md_state_q, md_state_d;</pre>
<pre>  logic [32:0] accum_window_q, accum_window_d;</pre>
<pre>  logic [32:0] res_adder_l;</pre>
<pre>  logic [32:0] res_adder_h;</pre>
<pre>  logic [32:0] op_b_shift_q, op_b_shift_d;</pre>
<pre>  logic [32:0] op_a_shift_q, op_a_shift_d;</pre>
<pre>  logic [32:0] op_a_ext, op_b_ext;</pre>
<pre>  logic [32:0] one_shift;</pre>
<pre>  logic [32:0] op_a_bw_pp, op_a_bw_last_pp;</pre>
<pre>  logic [31:0] b_0;</pre>
<pre>  logic        sign_a, sign_b;</pre>
<pre>  logic [32:0] next_reminder, next_quotient;</pre>
<pre>  logic [32:0] op_remainder;</pre>
<pre>  logic [31:0] op_numerator_q, op_numerator_d;</pre>
<pre>  logic        is_greater_equal;</pre>
<pre>  logic        div_change_sign, rem_change_sign;</pre>
<pre>  assign res_adder_l       = alu_adder_ext_i[32:0];</pre>
<pre>  assign res_adder_h       = alu_adder_ext_i[33:1];</pre>
<pre>  always_comb begin</pre>
<pre>    alu_operand_a_o   = accum_window_q;</pre>
<pre>    multdiv_result_o  = div_en_i ? accum_window_q[31:0] : res_adder_l;</pre>
<pre>    unique case(operator_i)</pre>
<pre>      MD_OP_MULL: begin</pre>
<pre>        alu_operand_b_o   = op_a_bw_pp;</pre>
<pre>      MD_OP_MULH: begin</pre>
<pre>        alu_operand_b_o = (md_state_q == MD_LAST) ? op_a_bw_last_pp : op_a_bw_pp;</pre>
<pre>      default: begin</pre>
<pre>        unique case(md_state_q)</pre>
<pre>          MD_IDLE: begin</pre>
<pre>            alu_operand_a_o     = {32'h0  , 1'b1};</pre>
<pre>            alu_operand_b_o     = {~op_b_i, 1'b1};</pre>
<pre>          MD_ABS_A: begin</pre>
<pre>            alu_operand_a_o     = {32'h0  , 1'b1};</pre>
<pre>            alu_operand_b_o     = {~op_a_i, 1'b1};</pre>
<pre>          MD_ABS_B: begin</pre>
<pre>            alu_operand_a_o     = {32'h0  , 1'b1};</pre>
<pre>            alu_operand_b_o     = {~op_b_i, 1'b1};</pre>
<pre>          MD_CHANGE_SIGN: begin</pre>
<pre>            alu_operand_a_o     = {32'h0  , 1'b1};</pre>
<pre>            alu_operand_b_o     = {~accum_window_q[31:0], 1'b1};</pre>
<pre>          default: begin</pre>
<pre>            alu_operand_a_o     = {accum_window_q[31:0], 1'b1}; // it contains the reminder</pre>
<pre>            alu_operand_b_o     = {~op_b_shift_q[31:0], 1'b1};  // -denominator two's compliment</pre>
<pre>  assign is_greater_equal = ((accum_window_q[31] ^ op_b_shift_q[31]) == 1'b0) ?</pre>
<pre>      (res_adder_h[31] == 1'b0) : accum_window_q[31];</pre>
<pre>  assign one_shift     = {32'b0, 1'b1} << multdiv_state_q;</pre>
<pre>  assign next_reminder = is_greater_equal ? res_adder_h              : op_remainder;</pre>
<pre>  assign next_quotient = is_greater_equal ? op_a_shift_q | one_shift : op_a_shift_q;</pre>
<pre>  assign b_0             = {32{op_b_shift_q[0]}};</pre>
<pre>  assign op_a_bw_pp       = { ~(op_a_shift_q[32] & op_b_shift_q[0]),  (op_a_shift_q[31:0] & b_0) };</pre>
<pre>  assign op_a_bw_last_pp  = {  (op_a_shift_q[32] & op_b_shift_q[0]), ~(op_a_shift_q[31:0] & b_0) };</pre>
<pre>  assign sign_a   = op_a_i[31] & signed_mode_i[0];</pre>
<pre>  assign sign_b   = op_b_i[31] & signed_mode_i[1];</pre>
<pre>  assign op_a_ext = {sign_a, op_a_i};</pre>
<pre>  assign op_b_ext = {sign_b, op_b_i};</pre>
<pre>  assign op_remainder = accum_window_q[32:0];</pre>
<pre>  assign multdiv_state_m1  = multdiv_state_q - 5'h1;</pre>
<pre>  assign div_change_sign  = sign_a ^ sign_b;</pre>
<pre>  assign rem_change_sign  = sign_a;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_multdiv_state_q</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      multdiv_state_q  <= 5'h0;</pre>
<pre>      accum_window_q   <= 33'h0;</pre>
<pre>      op_b_shift_q     <= 33'h0;</pre>
<pre>      op_a_shift_q     <= 33'h0;</pre>
<pre>      op_numerator_q   <= 32'h0;</pre>
<pre>      md_state_q       <= MD_IDLE;</pre>
<pre>    end else begin</pre>
<pre>      multdiv_state_q  <= multdiv_state_d;</pre>
<pre>      accum_window_q   <= accum_window_d;</pre>
<pre>      op_b_shift_q     <= op_b_shift_d;</pre>
<pre>      op_a_shift_q     <= op_a_shift_d;</pre>
<pre>      op_numerator_q   <= op_numerator_d;</pre>
<pre>      md_state_q       <= md_state_d;</pre>
<pre>  always_comb begin</pre>
<pre>    multdiv_state_d  = multdiv_state_q;</pre>
<pre>    accum_window_d   = accum_window_q;</pre>
<pre>    op_b_shift_d     = op_b_shift_q;</pre>
<pre>    op_a_shift_d     = op_a_shift_q;</pre>
<pre>    op_numerator_d   = op_numerator_q;</pre>
<pre>    md_state_d       = md_state_q;</pre>
<pre>    if (mult_en_i || div_en_i) begin</pre>
<pre>      unique case(md_state_q)</pre>
<pre>        MD_IDLE: begin</pre>
<pre>          unique case(operator_i)</pre>
<pre>            MD_OP_MULL: begin</pre>
<pre>              op_a_shift_d   = op_a_ext << 1;</pre>
<pre>              accum_window_d = {       ~(op_a_ext[32]   &     op_b_i[0]),</pre>
<pre>                                         op_a_ext[31:0] & {32{op_b_i[0]}}  };</pre>
<pre>              op_b_shift_d   = op_b_ext >> 1;</pre>
<pre>              md_state_d     = MD_COMP;</pre>
<pre>            MD_OP_MULH: begin</pre>
<pre>              op_a_shift_d   = op_a_ext;</pre>
<pre>              accum_window_d = { 1'b1, ~(op_a_ext[32]   &     op_b_i[0]),</pre>
<pre>                                         op_a_ext[31:1] & {31{op_b_i[0]}}  };</pre>
<pre>              op_b_shift_d   = op_b_ext >> 1;</pre>
<pre>              md_state_d     = MD_COMP;</pre>
<pre>            MD_OP_DIV: begin</pre>
<pre>              accum_window_d = {33{1'b1}};</pre>
<pre>              md_state_d     = equal_to_zero ? MD_FINISH : MD_ABS_A;</pre>
<pre>            default: begin</pre>
<pre>              accum_window_d = op_a_ext;</pre>
<pre>              md_state_d     = equal_to_zero ? MD_FINISH : MD_ABS_A;</pre>
<pre>          multdiv_state_d   = 5'd31;</pre>
<pre>        MD_ABS_A: begin</pre>
<pre>          op_a_shift_d   = '0;</pre>
<pre>          op_numerator_d = sign_a ? alu_adder_i : op_a_i;</pre>
<pre>          md_state_d     = MD_ABS_B;</pre>
<pre>        MD_ABS_B: begin</pre>
<pre>          accum_window_d = { 32'h0, op_numerator_q[31]};</pre>
<pre>          op_b_shift_d   = sign_b ? alu_adder_i : op_b_i;</pre>
<pre>          md_state_d     = MD_COMP;</pre>
<pre>        MD_COMP: begin</pre>
<pre>          multdiv_state_d   = multdiv_state_m1;</pre>
<pre>          unique case(operator_i)</pre>
<pre>            MD_OP_MULL: begin</pre>
<pre>              accum_window_d = res_adder_l;</pre>
<pre>              op_a_shift_d   = op_a_shift_q << 1;</pre>
<pre>              op_b_shift_d   = op_b_shift_q >> 1;</pre>
<pre>            MD_OP_MULH: begin</pre>
<pre>              accum_window_d = res_adder_h;</pre>
<pre>              op_a_shift_d   = op_a_shift_q;</pre>
<pre>              op_b_shift_d   = op_b_shift_q >> 1;</pre>
<pre>            default: begin</pre>
<pre>              accum_window_d = {next_reminder[31:0], op_numerator_q[multdiv_state_m1]};</pre>
<pre>              op_a_shift_d   = next_quotient;</pre>
<pre>          md_state_d = (multdiv_state_q == 5'd1) ? MD_LAST : MD_COMP;</pre>
<pre>        MD_LAST: begin</pre>
<pre>          unique case(operator_i)</pre>
<pre>            MD_OP_MULL: begin</pre>
<pre>              accum_window_d = res_adder_l;</pre>
<pre>              md_state_d     = MD_IDLE;</pre>
<pre>            MD_OP_MULH: begin</pre>
<pre>              accum_window_d = res_adder_l;</pre>
<pre>              md_state_d     = MD_IDLE;</pre>
<pre>            MD_OP_DIV: begin</pre>
<pre>              accum_window_d = next_quotient;</pre>
<pre>              md_state_d     = MD_CHANGE_SIGN;</pre>
<pre>            default: begin</pre>
<pre>              accum_window_d = {1'b0, next_reminder[31:0]};</pre>
<pre>              md_state_d     = MD_CHANGE_SIGN;</pre>
<pre>        MD_CHANGE_SIGN: begin</pre>
<pre>          md_state_d = MD_FINISH;</pre>
<pre>          unique case(operator_i)</pre>
<pre>            MD_OP_DIV:</pre>
<pre>              accum_window_d = (div_change_sign) ? alu_adder_i : accum_window_q;</pre>
<pre>            default:</pre>
<pre>              accum_window_d = (rem_change_sign) ? alu_adder_i : accum_window_q;</pre>
<pre>        MD_FINISH: begin</pre>
<pre>          md_state_d = MD_IDLE;</pre>
<pre>        default: begin</pre>
<pre>          md_state_d = MD_IDLE;</pre>
<pre>  assign valid_o = (md_state_q == MD_FINISH) |</pre>
<pre>                   (md_state_q == MD_LAST &</pre>
<pre>                   (operator_i == MD_OP_MULL |</pre>
<pre>                    operator_i == MD_OP_MULH));</pre>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_controller.sv</h3>
<pre>    input  logic                  clk_i,</pre>
<pre>    input  logic                  rst_ni,</pre>
<pre>    input  logic                  fetch_enable_i,        // start decoding</pre>
<pre>    output logic                  ctrl_busy_o,           // core is busy processing instrs</pre>
<pre>    input  logic                  illegal_insn_i,        // decoder has an invalid instr</pre>
<pre>    input  logic                  ecall_insn_i,          // decoder has ECALL instr</pre>
<pre>    input  logic                  mret_insn_i,           // decoder has MRET instr</pre>
<pre>    input  logic                  dret_insn_i,           // decoder has DRET instr</pre>
<pre>    input  logic                  wfi_insn_i,            // decoder has WFI instr</pre>
<pre>    input  logic                  ebrk_insn_i,           // decoder has EBREAK instr</pre>
<pre>    input  logic                  csr_pipe_flush_i,      // do CSR-related pipeline flush</pre>
<pre>    input  logic                  instr_valid_i,         // instr from IF-ID reg is valid</pre>
<pre>    input  logic [31:0]           instr_i,               // instr from IF-ID reg, for mtval</pre>
<pre>    input  logic [15:0]           instr_compressed_i,    // instr from IF-ID reg, for mtval</pre>
<pre>    input  logic                  instr_is_compressed_i, // instr from IF-ID reg is compressed</pre>
<pre>    input  logic                  instr_fetch_err_i,     // instr from IF-ID reg has error</pre>
<pre>    input  logic [31:0]           pc_id_i,               // instr from IF-ID reg address</pre>
<pre>    output logic                  instr_valid_clear_o,   // kill instr in IF-ID reg</pre>
<pre>    output logic                  id_in_ready_o,         // ID stage is ready for new instr</pre>
<pre>    output logic                  instr_req_o,           // start fetching instructions</pre>
<pre>    output logic                  pc_set_o,              // jump to address set by pc_mux</pre>
<pre>    output ibex_pkg::pc_sel_e     pc_mux_o,              // IF stage fetch address selector</pre>
<pre>    output ibex_pkg::exc_pc_sel_e exc_pc_mux_o,          // IF stage selector for exception PC</pre>
<pre>    output ibex_pkg::exc_cause_e  exc_cause_o,           // for IF stage, CSRs</pre>
<pre>    input  logic [31:0]           lsu_addr_last_i,       // for mtval</pre>
<pre>    input  logic                  load_err_i,</pre>
<pre>    input  logic                  store_err_i,</pre>
<pre>    input  logic                  branch_set_i,          // branch taken set signal</pre>
<pre>    input  logic                  jump_set_i,            // jump taken set signal</pre>
<pre>    input  logic                  csr_mstatus_mie_i,     // M-mode interrupt enable bit</pre>
<pre>    input  logic                  csr_msip_i,            // software interrupt pending</pre>
<pre>    input  logic                  csr_mtip_i,            // timer interrupt pending</pre>
<pre>    input  logic                  csr_meip_i,            // external interrupt pending</pre>
<pre>    input  logic [14:0]           csr_mfip_i,            // fast interrupt pending</pre>
<pre>    input  logic                  irq_pending_i,         // interrupt request pending</pre>
<pre>    input  logic                  irq_nm_i,              // non-maskeable interrupt</pre>
<pre>    output logic                  nmi_mode_o,            // core executing NMI handler</pre>
<pre>    input  logic                  debug_req_i,</pre>
<pre>    output ibex_pkg::dbg_cause_e  debug_cause_o,</pre>
<pre>    output logic                  debug_csr_save_o,</pre>
<pre>    output logic                  debug_mode_o,</pre>
<pre>    input  logic                  debug_single_step_i,</pre>
<pre>    input  logic                  debug_ebreakm_i,</pre>
<pre>    input  logic                  debug_ebreaku_i,</pre>
<pre>    input  logic                  trigger_match_i,</pre>
<pre>    output logic                  csr_save_if_o,</pre>
<pre>    output logic                  csr_save_id_o,</pre>
<pre>    output logic                  csr_restore_mret_id_o,</pre>
<pre>    output logic                  csr_restore_dret_id_o,</pre>
<pre>    output logic                  csr_save_cause_o,</pre>
<pre>    output logic [31:0]           csr_mtval_o,</pre>
<pre>    input  ibex_pkg::priv_lvl_e   priv_mode_i,</pre>
<pre>    input  logic                  csr_mstatus_tw_i,</pre>
<pre>    input  logic                  stall_lsu_i,</pre>
<pre>    input  logic                  stall_multdiv_i,</pre>
<pre>    input  logic                  stall_jump_i,</pre>
<pre>    input  logic                  stall_branch_i,</pre>
<pre>    output logic                  perf_jump_o,           // we are executing a jump</pre>
<pre>    output logic                  perf_tbranch_o         // we are executing a taken branch</pre>
<pre>  typedef enum logic [3:0] {</pre>
<pre>    RESET, BOOT_SET, WAIT_SLEEP, SLEEP, FIRST_FETCH, DECODE, FLUSH,</pre>
<pre>    IRQ_TAKEN, DBG_TAKEN_IF, DBG_TAKEN_ID</pre>
<pre>  } ctrl_fsm_e;</pre>
<pre>  ctrl_fsm_e ctrl_fsm_cs, ctrl_fsm_ns;</pre>
<pre>  logic nmi_mode_q, nmi_mode_d;</pre>
<pre>  logic debug_mode_q, debug_mode_d;</pre>
<pre>  logic load_err_q, load_err_d;</pre>
<pre>  logic store_err_q, store_err_d;</pre>
<pre>  logic exc_req_q, exc_req_d;</pre>
<pre>  logic illegal_insn_q, illegal_insn_d;</pre>
<pre>  logic stall;</pre>
<pre>  logic halt_if;</pre>
<pre>  logic flush_id;</pre>
<pre>  logic illegal_dret;</pre>
<pre>  logic illegal_umode;</pre>
<pre>  logic exc_req_lsu;</pre>
<pre>  logic special_req;</pre>
<pre>  logic enter_debug_mode;</pre>
<pre>  logic ebreak_into_debug;</pre>
<pre>  logic handle_irq;</pre>
<pre>  logic [3:0] mfip_id;</pre>
<pre>  logic       unused_csr_mtip;</pre>
<pre>  logic ecall_insn;</pre>
<pre>  logic mret_insn;</pre>
<pre>  logic dret_insn;</pre>
<pre>  logic wfi_insn;</pre>
<pre>  logic ebrk_insn;</pre>
<pre>  logic csr_pipe_flush;</pre>
<pre>  logic instr_fetch_err;</pre>
<pre></pre>
<pre>  ////////////////</pre>
<pre></pre>
<pre>  assign load_err_d  = load_err_i;</pre>
<pre>  assign store_err_d = store_err_i;</pre>
<pre></pre>
<pre>  // Decoder doesn't take instr_valid into account, factor it in here.</pre>
<pre>  assign ecall_insn      = ecall_insn_i      & instr_valid_i;</pre>
<pre>  assign mret_insn       = mret_insn_i       & instr_valid_i;</pre>
<pre>  assign csr_pipe_flush  = csr_pipe_flush_i  & instr_valid_i;</pre>
<pre>  // "Executing DRET outside of Debug Mode causes an illegal instruction exception."</pre>
<pre>  assign illegal_dret = dret_insn & ~debug_mode_q;</pre>
<pre></pre>
<pre></pre>
<pre>  // exception requests</pre>
<pre>  // exception request that has just been handled.</pre>
<pre></pre>
<pre>  // LSU exception requests</pre>
<pre>  // single step mode (dcsr.step == 1). Single step must be qualified with</pre>
<pre>  // instruction valid otherwise the core will immediately enter debug mode</pre>
<pre>  assign enter_debug_mode = (debug_req_i | (debug_single_step_i & instr_valid_i) |</pre>
<pre>                             trigger_match_i) & ~debug_mode_q;</pre>
<pre></pre>
<pre>  assign ebreak_into_debug = priv_mode_i == PRIV_LVL_M ? debug_ebreakm_i :</pre>
<pre>                             priv_mode_i == PRIV_LVL_U ? debug_ebreaku_i :</pre>
<pre>  // interrupts including NMI are ignored while in debug mode [Debug Spec v0.13.2, p.39]</pre>
<pre>  assign handle_irq       = ~debug_mode_q &</pre>
<pre>      ((irq_nm_i & ~nmi_mode_q) | (irq_pending_i & csr_mstatus_mie_i));</pre>
<pre></pre>
<pre>  // generate ID of fast interrupts, highest priority to highest ID</pre>
<pre>  always_comb begin : gen_mfip_id</pre>
<pre>    if      (csr_mfip_i[14]) mfip_id = 4'd14;</pre>
<pre>    else if (csr_mfip_i[13]) mfip_id = 4'd13;</pre>
<pre>    else if (csr_mfip_i[12]) mfip_id = 4'd12;</pre>
<pre>    else if (csr_mfip_i[11]) mfip_id = 4'd11;</pre>
<pre>    else if (csr_mfip_i[10]) mfip_id = 4'd10;</pre>
<pre>    else if (csr_mfip_i[ 9]) mfip_id = 4'd9;</pre>
<pre>    else if (csr_mfip_i[ 8]) mfip_id = 4'd8;</pre>
<pre>    else if (csr_mfip_i[ 7]) mfip_id = 4'd7;</pre>
<pre>    else if (csr_mfip_i[ 6]) mfip_id = 4'd6;</pre>
<pre>    else if (csr_mfip_i[ 5]) mfip_id = 4'd5;</pre>
<pre>    else if (csr_mfip_i[ 5]) mfip_id = 4'd5;</pre>
<pre>    else if (csr_mfip_i[ 2]) mfip_id = 4'd2;</pre>
<pre></pre>
<pre>  // Core controller //</pre>
<pre></pre>
<pre>  always_comb begin</pre>
<pre>    // Default values</pre>
<pre>    instr_req_o           = 1'b1;</pre>
<pre></pre>
<pre>    csr_save_if_o         = 1'b0;</pre>
<pre>    csr_restore_mret_id_o = 1'b0;</pre>
<pre>    csr_restore_dret_id_o = 1'b0;</pre>
<pre>    csr_mtval_o           = '0;</pre>
<pre></pre>
<pre>    pc_set_o              = 1'b0;</pre>
<pre>    exc_pc_mux_o          = EXC_PC_IRQ;</pre>
<pre></pre>
<pre>    ctrl_fsm_ns           = ctrl_fsm_cs;</pre>
<pre>    ctrl_busy_o           = 1'b1;</pre>
<pre></pre>
<pre>    halt_if               = 1'b0;</pre>
<pre>    flush_id              = 1'b0;</pre>
<pre>    debug_csr_save_o      = 1'b0;</pre>
<pre>    debug_cause_o         = DBG_CAUSE_EBREAK;</pre>
<pre>    nmi_mode_d            = nmi_mode_q;</pre>
<pre></pre>
<pre>    perf_jump_o           = 1'b0;</pre>
<pre></pre>
<pre>    unique case (ctrl_fsm_cs)</pre>
<pre>      RESET: begin</pre>
<pre>        // just wait for fetch_enable</pre>
<pre>        if (fetch_enable_i) begin</pre>
<pre>        end</pre>
<pre>      end</pre>
<pre></pre>
<pre>        // copy boot address to instr fetch address</pre>
<pre>        pc_set_o      = 1'b1;</pre>
<pre></pre>
<pre>        ctrl_fsm_ns = FIRST_FETCH;</pre>
<pre>      end</pre>
<pre></pre>
<pre>      WAIT_SLEEP: begin</pre>
<pre>        halt_if       = 1'b1;</pre>
<pre>      end</pre>
<pre></pre>
<pre>      SLEEP: begin</pre>
<pre>        halt_if       = 1'b1;</pre>
<pre>        flush_id      = 1'b1;</pre>
<pre></pre>
<pre>        // in debug mode or single step mode we leave immediately (wfi=nop)</pre>
<pre>          // Make sure clock remains disabled.</pre>
<pre>        end</pre>
<pre>      end</pre>
<pre>        if (id_in_ready_o) begin</pre>
<pre></pre>
<pre>        // handle interrupts</pre>
<pre>        if (handle_irq) begin</pre>
<pre>          halt_if     = 1'b1;</pre>
<pre>          flush_id    = 1'b1;</pre>
<pre>        // enter debug mode</pre>
<pre>          // ID state is needed for correct debug mode entry</pre>
<pre>        // priorities are as follows (lower number == higher priority)</pre>
<pre>        // 3. interrupt requests</pre>
<pre>          // get ready for special instructions, exceptions, pipeline flushes</pre>
<pre>          if (special_req) begin</pre>
<pre>            // ID so controller can determine appropriate action in the</pre>
<pre>            // FLUSH state.</pre>
<pre>            ctrl_fsm_ns = FLUSH;</pre>
<pre>          // set PC in IF stage to branch or jump target</pre>
<pre>          end else if (branch_set_i || jump_set_i) begin</pre>
<pre>          end</pre>
<pre></pre>
<pre>          if ((enter_debug_mode || handle_irq) && stall) begin</pre>
<pre>            halt_if = 1'b1;</pre>
<pre>        end // instr_valid_i</pre>
<pre>          if (enter_debug_mode) begin</pre>
<pre>            // enter debug mode</pre>
<pre>            // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the</pre>
<pre>            // ID state is needed for correct debug mode entry</pre>
<pre>            halt_if     = 1'b1;</pre>
<pre>          end</pre>
<pre>        end</pre>
<pre></pre>
<pre>      end // DECODE</pre>
<pre></pre>
<pre>        if (handle_irq) begin</pre>
<pre>          pc_mux_o         = PC_EXC;</pre>
<pre></pre>
<pre>          csr_save_if_o    = 1'b1;</pre>
<pre>          csr_save_cause_o = 1'b1;</pre>
<pre></pre>
<pre>          end else if (csr_mfip_i != 15'b0) begin</pre>
<pre>            // generate exception cause ID from fast interrupt ID:</pre>
<pre>            // - first bit distinguishes interrupts from exceptions,</pre>
<pre>            // - second bit adds 16 to fast interrupt ID</pre>
<pre>            // for example EXC_CAUSE_IRQ_FAST_0 = {1'b1, 5'd16}</pre>
<pre>            exc_cause_o = exc_cause_e'({2'b11, mfip_id});</pre>
<pre>          end else if (csr_meip_i) begin</pre>
<pre>          end else begin // csr_mtip_i</pre>
<pre>        end</pre>
<pre>      end</pre>
<pre></pre>
<pre>      DBG_TAKEN_IF: begin</pre>
<pre>        // enter debug mode and save PC in IF to dpc</pre>
<pre>        // jump to debug exception handler in debug memory</pre>
<pre>          flush_id         = 1'b1;</pre>
<pre>          pc_mux_o         = PC_EXC;</pre>
<pre>          exc_pc_mux_o     = EXC_PC_DBD;</pre>
<pre></pre>
<pre>          csr_save_if_o    = 1'b1;</pre>
<pre>          debug_csr_save_o = 1'b1;</pre>
<pre></pre>
<pre>          csr_save_cause_o = 1'b1;</pre>
<pre>          if (trigger_match_i) begin</pre>
<pre>          end else begin</pre>
<pre></pre>
<pre>        end</pre>
<pre>        // 2. EBREAK with forced entry into debug mode (ebreakm or ebreaku set).</pre>
<pre>        // regular ebreak's go through FLUSH.</pre>
<pre>        //</pre>
<pre>        // for 1. do not update dcsr and dpc, for 2. do so [Debug Spec v0.13.2, p.39]</pre>
<pre>        pc_mux_o     = PC_EXC;</pre>
<pre></pre>
<pre>        // update dcsr and dpc</pre>
<pre>          // dpc (set to the address of the EBREAK, i.e. set to PC in ID stage)</pre>
<pre>          csr_save_cause_o = 1'b1;</pre>
<pre>          debug_csr_save_o = 1'b1;</pre>
<pre>        end</pre>
<pre>        debug_mode_d = 1'b1;</pre>
<pre>        ctrl_fsm_ns  = DECODE;</pre>
<pre>      end</pre>
<pre></pre>
<pre>        flush_id    = 1'b1;</pre>
<pre>        ctrl_fsm_ns = DECODE;</pre>
<pre></pre>
<pre>        // exceptions: set exception PC, save PC and exception cause</pre>
<pre>        // exc_req_lsu is high for one clock cycle only (in DECODE)</pre>
<pre>        if (exc_req_q || store_err_q || load_err_q) begin</pre>
<pre>          exc_pc_mux_o     = debug_mode_q ? EXC_PC_DBG_EXC : EXC_PC_EXC;</pre>
<pre>          csr_save_id_o    = 1'b1;</pre>
<pre>          csr_save_cause_o = 1'b1;</pre>
<pre>          // set exception registers, priorities according to Table 3.7 of Privileged Spec v1.11</pre>
<pre>          if (instr_fetch_err) begin</pre>
<pre>            exc_cause_o = EXC_CAUSE_INSTR_ACCESS_FAULT;</pre>
<pre></pre>
<pre>          end else if (illegal_insn_q) begin</pre>
<pre>            exc_cause_o = EXC_CAUSE_ILLEGAL_INSN;</pre>
<pre></pre>
<pre>          end else if (ecall_insn) begin</pre>
<pre>              /*</pre>
<pre>               * dcsr.ebreakm == 1:</pre>
<pre>               * "EBREAK instructions in M-mode enter Debug Mode."</pre>
<pre>               * [Debug Spec v0.13.2, p.42]</pre>
<pre>               */</pre>
<pre>              pc_set_o         = 1'b0;</pre>
<pre>               * operation. [...] ECALL and EBREAK cause the receiving</pre>
<pre>               * following instruction." [Privileged Spec v1.11, p.40]</pre>
<pre>               */</pre>
<pre>              exc_cause_o      = EXC_CAUSE_BREAKPOINT;</pre>
<pre></pre>
<pre>          end else if (store_err_q) begin</pre>
<pre>            exc_cause_o = EXC_CAUSE_STORE_ACCESS_FAULT;</pre>
<pre>          end else begin // load_err_q</pre>
<pre>            csr_mtval_o = lsu_addr_last_i;</pre>
<pre>          end</pre>
<pre></pre>
<pre>        end else begin</pre>
<pre>          // special instructions and pipeline flushes</pre>
<pre>          if (mret_insn) begin</pre>
<pre>            pc_set_o              = 1'b1;</pre>
<pre>            csr_restore_mret_id_o = 1'b1;</pre>
<pre>            if (nmi_mode_q) begin</pre>
<pre>              nmi_mode_d          = 1'b0; // exit NMI mode</pre>
<pre>            end</pre>
<pre>          end else if (dret_insn) begin</pre>
<pre>            pc_mux_o              = PC_DRET;</pre>
<pre>            pc_set_o              = 1'b1;</pre>
<pre>            csr_restore_dret_id_o = 1'b1;</pre>
<pre>        // registers are set for exception but then enter debug handler rather</pre>
<pre>        // than exception handler [Debug Spec v0.13.2, p.44]</pre>
<pre>        if (enter_debug_mode) begin</pre>
<pre>          ctrl_fsm_ns = DBG_TAKEN_IF;</pre>
<pre>        end</pre>
<pre>      end</pre>
<pre></pre>
<pre>  ///////////////////</pre>
<pre>  // if low, current instr finishes in current cycle</pre>
<pre>  // kill instr in IF-ID pipeline reg that are done, or if a</pre>
<pre>  // set (unless flush_id is set also). It cannot be factored directly into</pre>
<pre>  // stall as this causes a combinational loop.</pre>
<pre>  assign instr_valid_clear_o = ~(stall | halt_if) | flush_id;</pre>
<pre></pre>
<pre>  // update registers</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : update_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      ctrl_fsm_cs    <= RESET;</pre>
<pre>      nmi_mode_q     <= 1'b0;</pre>
<pre>      debug_mode_q   <= 1'b0;</pre>
<pre>      load_err_q     <= 1'b0;</pre>
<pre>      store_err_q    <= 1'b0;</pre>
<pre>      exc_req_q      <= 1'b0;</pre>
<pre>      illegal_insn_q <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      ctrl_fsm_cs    <= ctrl_fsm_ns;</pre>
<pre>      nmi_mode_q     <= nmi_mode_d;</pre>
<h3>hw/ip/prim_generic/rtl/prim_generic_clock_mux2.sv</h3>
<pre>  input        clk0_i,</pre>
<pre>  input        clk1_i,</pre>
<pre>  input        sel_i,</pre>
<pre>  output logic clk_o</pre>
<pre>  assign clk_o = (sel_i) ? clk1_i : clk0_i;</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>hw/ip/tlul/rtl/tlul_adapter_reg.sv</h3>
<pre>module tlul_adapter_reg import tlul_pkg::*; #(</pre>
<pre>  parameter  int RegAw = 8,</pre>
<pre>  parameter  int RegDw = 32, // Shall be matched with TL_DW</pre>
<pre>  localparam int RegBw = RegDw/8</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tl_h2d_t tl_i,</pre>
<pre>  output tl_d2h_t tl_o,</pre>
<pre>  output logic             re_o,</pre>
<pre>  output logic             we_o,</pre>
<pre>  output logic [RegAw-1:0] addr_o,</pre>
<pre>  output logic [RegDw-1:0] wdata_o,</pre>
<pre>  output logic [RegBw-1:0] be_o,</pre>
<pre>  input        [RegDw-1:0] rdata_i,</pre>
<pre>  input                    error_i</pre>
<pre>  localparam int IW  = $bits(tl_i.a_source);</pre>
<pre>  localparam int SZW = $bits(tl_i.a_size);</pre>
<pre>  logic outstanding;    // Indicates current request is pending</pre>
<pre>  logic a_ack, d_ack;</pre>
<pre>  logic [RegDw-1:0] rdata;</pre>
<pre>  logic             error, err_internal;</pre>
<pre>  logic addr_align_err;     // Size and alignment</pre>
<pre>  logic malformed_meta_err; // User signal format error or unsupported</pre>
<pre>  logic tl_err;             // Common TL-UL error checker</pre>
<pre>  logic [IW-1:0]  reqid;</pre>
<pre>  logic [SZW-1:0] reqsz;</pre>
<pre>  tl_d_op_e       rspop;</pre>
<pre>  logic rd_req, wr_req;</pre>
<pre>  assign a_ack   = tl_i.a_valid & tl_o.a_ready;</pre>
<pre>  assign d_ack   = tl_o.d_valid & tl_i.d_ready;</pre>
<pre>  assign wr_req  = a_ack & ((tl_i.a_opcode == PutFullData) | (tl_i.a_opcode == PutPartialData));</pre>
<pre>  assign rd_req  = a_ack & (tl_i.a_opcode == Get);</pre>
<pre>  assign we_o    = wr_req & ~err_internal;</pre>
<pre>  assign re_o    = rd_req & ~err_internal;</pre>
<pre>  assign addr_o  = {tl_i.a_address[RegAw-1:2], 2'b00}; // generate always word-align</pre>
<pre>  assign wdata_o = tl_i.a_data;</pre>
<pre>  assign be_o    = tl_i.a_mask;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni)    outstanding <= 1'b0;</pre>
<pre>    else if (a_ack) outstanding <= 1'b1;</pre>
<pre>    else if (d_ack) outstanding <= 1'b0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      reqid <= '0;</pre>
<pre>      reqsz <= '0;</pre>
<pre>      rspop <= AccessAck;</pre>
<pre>    end else if (a_ack) begin</pre>
<pre>      reqid <= tl_i.a_source;</pre>
<pre>      reqsz <= tl_i.a_size;</pre>
<pre>      rspop <= (rd_req) ? AccessAckData : AccessAck ;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rdata  <= '0;</pre>
<pre>      error <= 1'b0;</pre>
<pre>    end else if (a_ack) begin</pre>
<pre>      rdata <= (err_internal) ? '1 : rdata_i;</pre>
<pre>      error <= error_i | err_internal;</pre>
<pre>  assign tl_o = '{</pre>
<pre>    a_ready:  ~outstanding,</pre>
<pre>    d_valid:  outstanding,</pre>
<pre>    d_opcode: rspop,</pre>
<pre>    d_param:  '0,</pre>
<pre>    d_size:   reqsz,</pre>
<pre>    d_source: reqid,</pre>
<pre>    d_sink:   '0,</pre>
<pre>    d_data:   rdata,</pre>
<pre>    d_user:  '0,</pre>
<pre>    d_error: error</pre>
<pre>  assign err_internal = addr_align_err | malformed_meta_err | tl_err ;</pre>
<pre>  assign malformed_meta_err = (tl_i.a_user.parity_en == 1'b1);</pre>
<pre>  always_comb begin</pre>
<pre>    if (wr_req) begin</pre>
<pre>      addr_align_err = |tl_i.a_address[1:0];</pre>
<pre>    end else begin</pre>
<pre>      addr_align_err = 1'b0;</pre>
<pre>  tlul_err u_err (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .err_o (tl_err)</pre>
<h3>hw/ip/tlul/rtl/tlul_socket_1n.sv</h3>
<pre>module tlul_socket_1n #(</pre>
<pre>  parameter int unsigned  N         = 4,</pre>
<pre>  parameter bit           HReqPass  = 1'b1,</pre>
<pre>  parameter bit           HRspPass  = 1'b1,</pre>
<pre>  parameter bit [N-1:0]   DReqPass  = {N{1'b1}},</pre>
<pre>  parameter bit [N-1:0]   DRspPass  = {N{1'b1}},</pre>
<pre>  parameter bit [3:0]     HReqDepth = 4'h2,</pre>
<pre>  parameter bit [3:0]     HRspDepth = 4'h2,</pre>
<pre>  parameter bit [N*4-1:0] DReqDepth = {N{4'h2}},</pre>
<pre>  parameter bit [N*4-1:0] DRspDepth = {N{4'h2}},</pre>
<pre>  localparam int unsigned NWD       = $clog2(N+1) // derived parameter</pre>
<pre>  input                     clk_i,</pre>
<pre>  input                     rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_h_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_h_o,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_d_o    [N],</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_d_i    [N],</pre>
<pre>  input  [NWD-1:0]          dev_select</pre>
<pre></pre>
<pre>  tlul_pkg::tl_d2h_t   tl_t_i;</pre>
<pre></pre>
<pre>    .ReqPass(HReqPass),</pre>
<pre>    .RspPass(HRspPass),</pre>
<pre>    .ReqDepth(HReqDepth),</pre>
<pre>    .RspDepth(HRspDepth),</pre>
<pre>    .SpareReqW(NWD)</pre>
<pre>  ) fifo_h (</pre>
<pre style="background-color: #FF0000;">    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_h_i,</pre>
<pre>    .tl_h_o,</pre>
<pre>    .tl_d_o     (tl_t_o),</pre>
<pre>    .tl_d_i     (tl_t_i),</pre>
<pre>    .spare_req_i (dev_select),</pre>
<pre>    .spare_req_o (dev_select_t),</pre>
<pre>    .spare_rsp_i (1'b0),</pre>
<pre>    .spare_rsp_o ());</pre>
<pre></pre>
<pre>  logic [NWD-1:0] dev_select_outstanding;</pre>
<pre>  logic           hold_all_requests;</pre>
<pre>  logic           accept_t_req, accept_t_rsp;</pre>
<pre></pre>
<pre>  assign  accept_t_rsp = tl_t_i.d_valid & tl_t_o.d_ready;</pre>
<pre></pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      num_req_outstanding <= 8'h0;</pre>
<pre>      dev_select_outstanding <= '0;</pre>
<pre>    end else if (accept_t_req) begin</pre>
<pre>      if (!accept_t_rsp) begin</pre>
<pre>        `ASSERT_I(NotOverflowed_A, num_req_outstanding != '1)</pre>
<pre>      end</pre>
<pre>    end else if (accept_t_rsp) begin</pre>
<pre>      num_req_outstanding <= num_req_outstanding - 8'h1;</pre>
<pre>    end</pre>
<pre>      (num_req_outstanding != 8'h0) &</pre>
<pre>      (dev_select_t != dev_select_outstanding);</pre>
<pre></pre>
<pre>  tlul_pkg::tl_d2h_t   tl_u_i [N+1];</pre>
<pre></pre>
<pre>    assign tl_u_o[i].a_valid   = tl_t_o.a_valid &</pre>
<pre>                                 (dev_select_t == NWD'(i)) &</pre>
<pre>                                 ~hold_all_requests;</pre>
<pre>    assign tl_u_o[i].a_opcode  = tl_t_o.a_opcode;</pre>
<pre>    assign tl_u_o[i].a_param   = tl_t_o.a_param;</pre>
<pre>    assign tl_u_o[i].a_size    = tl_t_o.a_size;</pre>
<pre>    assign tl_u_o[i].a_source  = tl_t_o.a_source;</pre>
<pre>    assign tl_u_o[i].a_address = tl_t_o.a_address;</pre>
<pre>    assign tl_u_o[i].a_mask    = tl_t_o.a_mask;</pre>
<pre>    assign tl_u_o[i].a_data    = tl_t_o.a_data;</pre>
<pre>    assign tl_u_o[i].a_user    = tl_t_o.a_user;</pre>
<pre>  end</pre>
<pre></pre>
<pre>  always_comb begin</pre>
<pre>    hfifo_reqready = tl_u_i[N].a_ready; // default to error</pre>
<pre>    for (int idx = 0 ; idx < N ; idx++) begin</pre>
<pre>      //if (dev_select_outstanding == NWD'(idx)) hfifo_reqready = tl_u_i[idx].a_ready;</pre>
<pre>    end</pre>
<pre>  end</pre>
<pre></pre>
<pre>    tl_t_p = tl_u_i[N];</pre>
<pre>    for (int idx = 0 ; idx < N ; idx++) begin</pre>
<pre>      if (dev_select_outstanding == NWD'(idx)) tl_t_p = tl_u_i[idx];</pre>
<pre>    end</pre>
<pre>  assign tl_t_i.d_opcode = tl_t_p.d_opcode;</pre>
<pre>  assign tl_t_i.d_param  = tl_t_p.d_param ;</pre>
<pre>  assign tl_t_i.d_size   = tl_t_p.d_size  ;</pre>
<pre>  assign tl_t_i.d_source = tl_t_p.d_source;</pre>
<pre>  assign tl_t_i.d_sink   = tl_t_p.d_sink  ;</pre>
<pre>  assign tl_t_i.d_data   = tl_t_p.d_data  ;</pre>
<pre>  assign tl_t_i.d_user   = tl_t_p.d_user  ;</pre>
<pre>  assign tl_t_i.d_error  = tl_t_p.d_error ;</pre>
<pre></pre>
<pre>    assign tl_u_o[i].d_ready = tl_t_o.d_ready;</pre>
<pre>  end</pre>
<pre>    tlul_fifo_sync #(</pre>
<pre>      .ReqPass(DReqPass[i]),</pre>
<pre>      .RspPass(DRspPass[i]),</pre>
<pre>      .ReqDepth(DReqDepth[i*4+:4]),</pre>
<pre>      .RspDepth(DRspDepth[i*4+:4])</pre>
<pre>    ) fifo_d (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .tl_h_i      (tl_u_o[i]),</pre>
<pre>      .tl_h_o      (tl_u_i[i]),</pre>
<pre>      .tl_d_o      (tl_d_o[i]),</pre>
<pre>      .tl_d_i      (tl_d_i[i]),</pre>
<pre>      .spare_req_i (1'b0),</pre>
<pre>      .spare_req_o (),</pre>
<pre>      .spare_rsp_i (1'b0),</pre>
<pre>      .spare_rsp_o ());</pre>
<pre>  end</pre>
<pre>                                 (dev_select_t == NWD'(N)) &</pre>
<pre>                                 ~hold_all_requests;</pre>
<pre>  assign tl_u_o[N].a_opcode    = tl_t_o.a_opcode;</pre>
<pre>  assign tl_u_o[N].a_param     = tl_t_o.a_param;</pre>
<pre>  assign tl_u_o[N].a_size      = tl_t_o.a_size;</pre>
<pre>  assign tl_u_o[N].a_source    = tl_t_o.a_source;</pre>
<pre>  assign tl_u_o[N].a_address   = tl_t_o.a_address;</pre>
<pre>  assign tl_u_o[N].a_mask      = tl_t_o.a_mask;</pre>
<pre>  assign tl_u_o[N].a_data      = tl_t_o.a_data;</pre>
<pre>  assign tl_u_o[N].a_user      = tl_t_o.a_user;</pre>
<pre>  tlul_err_resp err_resp (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_h_i     (tl_u_o[N]),</pre>
<pre>    .tl_h_o     (tl_u_i[N]));</pre>
<pre></pre>
<h3>hw/ip/tlul/rtl/tlul_err_resp.sv</h3>
<pre>  input                     clk_i,</pre>
<pre>  input                     rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_h_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_h_o</pre>
<pre>  tl_a_op_e                          err_opcode;</pre>
<pre>  logic [$bits(tl_h_i.a_source)-1:0] err_source;</pre>
<pre>  logic [$bits(tl_h_i.a_size)-1:0]   err_size;</pre>
<pre>  logic                              err_req_pending, err_rsp_pending;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      err_req_pending <= 1'b0;</pre>
<pre>      err_source      <= {top_pkg::TL_AIW{1'b0}};</pre>
<pre>      err_opcode      <= Get;</pre>
<pre>      err_size        <= '0;</pre>
<pre>    end else if (tl_h_i.a_valid && tl_h_o.a_ready) begin</pre>
<pre>      err_req_pending <= 1'b1;</pre>
<pre>      err_source      <= tl_h_i.a_source;</pre>
<pre>      err_opcode      <= tl_h_i.a_opcode;</pre>
<pre>      err_size        <= tl_h_i.a_size;</pre>
<pre>    end else if (!err_rsp_pending) begin</pre>
<pre>      err_req_pending <= 1'b0;</pre>
<pre>  assign tl_h_o.a_ready  = ~err_rsp_pending & ~(err_req_pending & ~tl_h_i.d_ready);</pre>
<pre>  assign tl_h_o.d_valid  = err_req_pending | err_rsp_pending;</pre>
<pre>  assign tl_h_o.d_data   = '1; // Return all F</pre>
<pre>  assign tl_h_o.d_source = err_source;</pre>
<pre>  assign tl_h_o.d_sink   = '0;</pre>
<pre>  assign tl_h_o.d_param  = '0;</pre>
<pre>  assign tl_h_o.d_size   = err_size;</pre>
<pre>  assign tl_h_o.d_opcode = (err_opcode == Get) ? AccessAckData : AccessAck;</pre>
<pre>  assign tl_h_o.d_user   = '0;</pre>
<pre>  assign tl_h_o.d_error  = 1'b1;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      err_rsp_pending <= 1'b0;</pre>
<pre>    end else if ((err_req_pending || err_rsp_pending) && !tl_h_i.d_ready) begin</pre>
<pre>      err_rsp_pending <= 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      err_rsp_pending <= 1'b0;</pre>
<h3>hw/ip/tlul/rtl/tlul_assert.sv</h3>
<pre>module tlul_assert #(</pre>
<pre>  parameter EndpointType = "Device" // can be either "Host" or "Device"</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input tlul_pkg::tl_h2d_t h2d,</pre>
<pre>  input tlul_pkg::tl_d2h_t d2h</pre>
<pre style="background-color: #FF0000;">  // assemble properties and check //</pre>
<h3>hw/ip/tlul/rtl/tlul_fifo_async.sv</h3>
<pre>module tlul_fifo_async #(</pre>
<pre>  parameter int unsigned ReqDepth = 3,</pre>
<pre>  parameter int unsigned RspDepth = 3</pre>
<pre>  input                      clk_h_i,</pre>
<pre>  input                      rst_h_ni,</pre>
<pre>  input                      clk_d_i,</pre>
<pre>  input                      rst_d_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t  tl_h_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t  tl_h_o,</pre>
<pre>  output tlul_pkg::tl_h2d_t  tl_d_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t  tl_d_i</pre>
<pre>  localparam int unsigned REQFIFO_WIDTH = $bits(tlul_pkg::tl_h2d_t)-2;</pre>
<pre>  prim_fifo_async #(.Width(REQFIFO_WIDTH), .Depth(ReqDepth)) reqfifo (</pre>
<pre>    .clk_wr_i      (clk_h_i),</pre>
<pre>    .rst_wr_ni     (rst_h_ni),</pre>
<pre>    .clk_rd_i      (clk_d_i),</pre>
<pre>    .rst_rd_ni     (rst_d_ni),</pre>
<pre>    .wvalid        (tl_h_i.a_valid),</pre>
<pre>    .wready        (tl_h_o.a_ready),</pre>
<pre>    .wdata         ({tl_h_i.a_opcode ,</pre>
<pre>                     tl_h_i.a_param  ,</pre>
<pre>                     tl_h_i.a_size   ,</pre>
<pre>                     tl_h_i.a_source ,</pre>
<pre>                     tl_h_i.a_address,</pre>
<pre>                     tl_h_i.a_mask   ,</pre>
<pre>                     tl_h_i.a_data   ,</pre>
<pre>                     tl_h_i.a_user   }),</pre>
<pre>    .rvalid        (tl_d_o.a_valid),</pre>
<pre>    .rready        (tl_d_i.a_ready),</pre>
<pre>    .rdata         ({tl_d_o.a_opcode ,</pre>
<pre>                     tl_d_o.a_param  ,</pre>
<pre>                     tl_d_o.a_size   ,</pre>
<pre>                     tl_d_o.a_source ,</pre>
<pre>                     tl_d_o.a_address,</pre>
<pre>                     tl_d_o.a_mask   ,</pre>
<pre>                     tl_d_o.a_data   ,</pre>
<pre>                     tl_d_o.a_user   }),</pre>
<pre>    .wdepth        (),</pre>
<pre>    .rdepth        ()</pre>
<pre>  localparam int unsigned RSPFIFO_WIDTH = $bits(tlul_pkg::tl_d2h_t) -2;</pre>
<pre>  prim_fifo_async #(.Width(RSPFIFO_WIDTH), .Depth(RspDepth)) rspfifo (</pre>
<pre>    .clk_wr_i      (clk_d_i),</pre>
<pre>    .rst_wr_ni     (rst_d_ni),</pre>
<pre>    .clk_rd_i      (clk_h_i),</pre>
<pre>    .rst_rd_ni     (rst_h_ni),</pre>
<pre>    .wvalid        (tl_d_i.d_valid),</pre>
<pre>    .wready        (tl_d_o.d_ready),</pre>
<pre>    .wdata         ({tl_d_i.d_opcode,</pre>
<pre>                     tl_d_i.d_param ,</pre>
<pre>                     tl_d_i.d_size  ,</pre>
<pre>                     tl_d_i.d_source,</pre>
<pre>                     tl_d_i.d_sink  ,</pre>
<pre>                     tl_d_i.d_data  ,</pre>
<pre>                     tl_d_i.d_user  ,</pre>
<pre>                     tl_d_i.d_error }),</pre>
<pre>    .rvalid        (tl_h_o.d_valid),</pre>
<pre>    .rready        (tl_h_i.d_ready),</pre>
<pre>    .rdata         ({tl_h_o.d_opcode,</pre>
<pre>                     tl_h_o.d_param ,</pre>
<pre>                     tl_h_o.d_size  ,</pre>
<pre>                     tl_h_o.d_source,</pre>
<pre>                     tl_h_o.d_sink  ,</pre>
<pre>                     tl_h_o.d_data  ,</pre>
<pre>                     tl_h_o.d_user  ,</pre>
<pre>                     tl_h_o.d_error }),</pre>
<pre>    .wdepth        (),</pre>
<pre>    .rdepth        ()</pre>
<h3>hw/ip/tlul/rtl/tlul_assert_multiple.sv</h3>
<pre>module tlul_assert_multiple #(</pre>
<pre>  parameter int unsigned N = 2,</pre>
<pre>  parameter EndpointType = "Device" // can be "Device" or "Host"</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input tlul_pkg::tl_h2d_t h2d [N],</pre>
<pre>  input tlul_pkg::tl_d2h_t d2h [N]</pre>
<pre>  for (genvar ii = 0; ii < N; ii++) begin : gen_assert</pre>
<pre>    tlul_assert #(</pre>
<pre>      .EndpointType(EndpointType)</pre>
<pre style="background-color: #FF0000;">    ) tlul_assert (</pre>
<pre>      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .h2d (h2d[ii]),</pre>
<pre>      .d2h (d2h[ii])</pre>
<h3>hw/ip/flash_ctrl/rtl/flash_ctrl_pkg.sv</h3>
<pre>package flash_ctrl_pkg;</pre>
<pre>  localparam int FlashTotalPages = top_pkg::FLASH_BANKS * top_pkg::FLASH_PAGES_PER_BANK;</pre>
<pre>  localparam int AllPagesW = $clog2(FlashTotalPages);</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    FlashRead      = 2'h0,</pre>
<pre>    FlashProg      = 2'h1,</pre>
<pre>    FlashErase     = 2'h2</pre>
<pre>  } flash_op_e;</pre>
<pre>  typedef enum logic  {</pre>
<pre>    PageErase     = 0,</pre>
<pre>    BankErase     = 1</pre>
<pre>  } flash_erase_op_e;</pre>
<pre>  typedef enum logic  {</pre>
<pre>    WriteDir     = 1'b0,</pre>
<pre>    ReadDir      = 1'b1</pre>
<pre>  } flash_flfo_dir_e;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic                         req;</pre>
<pre>    logic                         rd;</pre>
<pre>    logic                         prog;</pre>
<pre>    logic                         pg_erase;</pre>
<pre>    logic                         bk_erase;</pre>
<pre>    logic [top_pkg::FLASH_AW-1:0] addr;</pre>
<pre>    logic [top_pkg::FLASH_DW-1:0] prog_data;</pre>
<pre style="background-color: #FF0000;">  } flash_c2m_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic                         rd_done;</pre>
<pre>    logic                         prog_done;</pre>
<pre>    logic                         erase_done;</pre>
<pre>    logic [top_pkg::FLASH_DW-1:0] rd_data;</pre>
<pre>    logic                         init_busy;</pre>
<pre style="background-color: #FF0000;">  } flash_m2c_t;</pre>
<pre style="background-color: #FF0000;">endpackage : flash_ctrl_pkg</pre>
<h3>hw/ip/tlul/rtl/tlul_adapter_sram.sv</h3>
<pre>module tlul_adapter_sram #(</pre>
<pre>  parameter int SramAw      = 12,</pre>
<pre>  parameter int SramDw      = 32, // Current version supports TL-UL width only</pre>
<pre>  parameter int Outstanding = 1,  // Only one request is accepted</pre>
<pre>  parameter bit ByteAccess  = 1,  // 1: true, 0: false</pre>
<pre>  parameter bit ErrOnWrite  = 0,  // 1: Writes not allowed, automatically error</pre>
<pre>  parameter bit ErrOnRead   = 0   // 1: Reads not allowed, automatically error</pre>
<pre>  input   clk_i,</pre>
<pre>  input   rst_ni,</pre>
<pre>  input   tlul_pkg::tl_h2d_t  tl_i,</pre>
<pre>  output  tlul_pkg::tl_d2h_t  tl_o,</pre>
<pre>  output logic              req_o,</pre>
<pre>  input                     gnt_i,</pre>
<pre>  output logic              we_o,</pre>
<pre>  output logic [SramAw-1:0] addr_o,</pre>
<pre>  output logic [SramDw-1:0] wdata_o,</pre>
<pre>  output logic [SramDw-1:0] wmask_o,</pre>
<pre>  input        [SramDw-1:0] rdata_i,</pre>
<pre>  input                     rvalid_i,</pre>
<pre>  input        [1:0]        rerror_i // 2 bit error [1]: Uncorrectable, [0]: Correctable</pre>
<pre>  localparam int SramByte = SramDw/8; // TODO: Fatal if SramDw isn't multiple of 8</pre>
<pre>  localparam int DataBitWidth = $clog2(SramByte);</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    OpWrite,</pre>
<pre>    OpRead,</pre>
<pre>    OpUnknown</pre>
<pre>  } req_op_e ;</pre>
<pre>  typedef struct packed {</pre>
<pre>    req_op_e                    op ;</pre>
<pre>    logic                       error ;</pre>
<pre>    logic [top_pkg::TL_SZW-1:0] size ;</pre>
<pre>    logic [top_pkg::TL_AIW-1:0] source ;</pre>
<pre style="background-color: #FF0000;">  } req_t ;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [SramDw-1:0] data ;</pre>
<pre>    logic              error ;</pre>
<pre style="background-color: #FF0000;">  } rsp_t ;</pre>
<pre>  localparam int ReqFifoWidth = $bits(req_t) ;</pre>
<pre>  localparam int RspFifoWidth = $bits(rsp_t) ;</pre>
<pre>  logic reqfifo_wvalid, reqfifo_wready;</pre>
<pre>  logic reqfifo_rvalid, reqfifo_rready;</pre>
<pre>  req_t reqfifo_wdata,  reqfifo_rdata;</pre>
<pre>  logic rspfifo_wvalid, rspfifo_wready;</pre>
<pre>  logic rspfifo_rvalid, rspfifo_rready;</pre>
<pre>  rsp_t rspfifo_wdata,  rspfifo_rdata;</pre>
<pre>  logic error_internal; // Internal protocol error checker</pre>
<pre>  logic wr_attr_error;</pre>
<pre>  logic wr_vld_error;</pre>
<pre>  logic rd_vld_error;</pre>
<pre>  logic tlul_error;     // Error from `tlul_err` module</pre>
<pre>  logic a_ack, d_ack, unused_sram_ack;</pre>
<pre>  assign a_ack    = tl_i.a_valid & tl_o.a_ready ;</pre>
<pre>  assign d_ack    = tl_o.d_valid & tl_i.d_ready ;</pre>
<pre>  assign unused_sram_ack = req_o        & gnt_i ;</pre>
<pre>  logic d_valid, d_error;</pre>
<pre>  always_comb begin</pre>
<pre>    d_valid = 1'b0;</pre>
<pre>    if (reqfifo_rvalid) begin</pre>
<pre>      if (reqfifo_rdata.error) begin</pre>
<pre>        d_valid = 1'b1;</pre>
<pre>      end else if (reqfifo_rdata.op == OpRead) begin</pre>
<pre>        d_valid = rspfifo_rvalid;</pre>
<pre>      end else begin</pre>
<pre>        d_valid = 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      d_valid = 1'b0;</pre>
<pre>  always_comb begin</pre>
<pre>    d_error = 1'b0;</pre>
<pre>    if (reqfifo_rvalid) begin</pre>
<pre>      if (reqfifo_rdata.op == OpRead) begin</pre>
<pre>        d_error = rspfifo_rdata.error | reqfifo_rdata.error;</pre>
<pre>      end else begin</pre>
<pre>        d_error = reqfifo_rdata.error;</pre>
<pre>    end else begin</pre>
<pre>      d_error = 1'b0;</pre>
<pre>  assign tl_o = '{</pre>
<pre>      d_valid  : d_valid ,</pre>
<pre>      d_opcode : (d_valid && reqfifo_rdata.op != OpRead) ? AccessAck : AccessAckData,</pre>
<pre>      d_param  : '0,</pre>
<pre>      d_size   : (d_valid) ? reqfifo_rdata.size : '0,</pre>
<pre>      d_source : (d_valid) ? reqfifo_rdata.source : '0,</pre>
<pre>      d_sink   : 1'b0,</pre>
<pre>      d_data   : (d_valid && rspfifo_rvalid && reqfifo_rdata.op == OpRead)</pre>
<pre>                 ? rspfifo_rdata.data : '0,</pre>
<pre>      d_user   : '0,</pre>
<pre>      d_error  : d_error,</pre>
<pre>      a_ready  : (gnt_i | error_internal) & reqfifo_wready</pre>
<pre>  assign req_o    = tl_i.a_valid & reqfifo_wready & ~error_internal;</pre>
<pre>  assign we_o     = tl_i.a_valid & logic'(tl_i.a_opcode inside {PutFullData, PutPartialData});</pre>
<pre>  assign addr_o   = (tl_i.a_valid) ? tl_i.a_address[DataBitWidth+:SramAw] : '0;</pre>
<pre>    for (int i = 0 ; i < top_pkg::TL_DW/8 ; i++) begin</pre>
<pre>      wmask_o[8*i+:8] = (tl_i.a_valid) ? {8{tl_i.a_mask[i]}} : '0;</pre>
<pre>      // only forward valid data here.</pre>
<pre>    end</pre>
<pre>                         (ByteAccess == 0) ? (tl_i.a_mask != '1 || tl_i.a_size != 2'h2) : 1'b0 :</pre>
<pre>                         1'b0;</pre>
<pre></pre>
<pre>    assign wr_vld_error = tl_i.a_opcode != Get;</pre>
<pre>  end else begin : gen_writes_allowed</pre>
<pre>    assign wr_vld_error = 1'b0;</pre>
<pre>  end</pre>
<pre>    assign rd_vld_error = tl_i.a_opcode == Get;</pre>
<pre>  end else begin : gen_reads_allowed</pre>
<pre>    assign rd_vld_error = 1'b0;</pre>
<pre>  end</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .err_o (tlul_error)</pre>
<pre>  );</pre>
<pre>  // End: Request Error Detection</pre>
<pre>  assign reqfifo_wdata  = '{</pre>
<pre>    op:     (tl_i.a_opcode != Get) ? OpWrite : OpRead, // To return AccessAck for opcode error</pre>
<pre>    error:  error_internal,</pre>
<pre>    size:   tl_i.a_size,</pre>
<pre>    source: tl_i.a_source</pre>
<pre>  }; // Store the request only. Doesn't have to store data</pre>
<pre style="background-color: #FF0000;">  assign reqfifo_rready = d_ack ;</pre>
<pre></pre>
<pre>  assign rspfifo_wdata  = '{</pre>
<pre>    data:  rdata_i,</pre>
<pre>    error: rerror_i[1]  // Only care for Uncorrectable error</pre>
<pre>  };</pre>
<pre>                        ? reqfifo_rready : 1'b0 ;</pre>
<pre></pre>
<pre>    .Width  (ReqFifoWidth),</pre>
<pre>    .Pass   (1'b0),</pre>
<pre>  // The oustanding+1 allows the reqfifo to absorb back to back transactions</pre>
<pre>  ) u_reqfifo (</pre>
<pre style="background-color: #FF0000;">    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .clr_i  (1'b0),</pre>
<pre>    .wvalid (reqfifo_wvalid),</pre>
<pre>    .wready (reqfifo_wready),</pre>
<pre>    .wdata  (reqfifo_wdata),</pre>
<pre>    .depth  (),</pre>
<pre>    .rvalid (reqfifo_rvalid),</pre>
<pre>    .rready (reqfifo_rready),</pre>
<pre>    .rdata  (reqfifo_rdata)</pre>
<pre>  );</pre>
<pre>    .Width (RspFifoWidth),</pre>
<pre>    .Pass  (1'b1),</pre>
<pre>    .Depth (Outstanding)</pre>
<pre>  ) u_rspfifo (</pre>
<pre style="background-color: #FF0000;">    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .clr_i  (1'b0),</pre>
<pre>    .wvalid (rspfifo_wvalid),</pre>
<pre>    .wready (rspfifo_wready),</pre>
<pre>    .wdata  (rspfifo_wdata),</pre>
<pre>    .depth  (),</pre>
<pre>    .rvalid (rspfifo_rvalid),</pre>
<pre>    .rready (rspfifo_rready),</pre>
<pre>    .rdata  (rspfifo_rdata)</pre>
<pre>  );</pre>
<h3>hw/ip/tlul/rtl/tlul_err.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input tl_h2d_t tl_i,</pre>
<pre>  output logic err_o</pre>
<pre>  localparam int IW  = $bits(tl_i.a_source);</pre>
<pre>  localparam int SZW = $bits(tl_i.a_size);</pre>
<pre>  localparam int DW  = $bits(tl_i.a_data);</pre>
<pre>  localparam int MW  = $bits(tl_i.a_mask);</pre>
<pre>  localparam int SubAW = $clog2(DW/8);</pre>
<pre>  logic opcode_allowed, a_config_allowed;</pre>
<pre>  logic op_full, op_partial, op_get;</pre>
<pre>  assign op_full    = (tl_i.a_opcode == PutFullData);</pre>
<pre>  assign op_partial = (tl_i.a_opcode == PutPartialData);</pre>
<pre>  assign op_get     = (tl_i.a_opcode == Get);</pre>
<pre>  assign err_o = ~(opcode_allowed & a_config_allowed);</pre>
<pre>  assign opcode_allowed = (tl_i.a_opcode == PutFullData)</pre>
<pre>                        | (tl_i.a_opcode == PutPartialData)</pre>
<pre>                        | (tl_i.a_opcode == Get);</pre>
<pre>  logic addr_sz_chk;    // address and size alignment check</pre>
<pre>  logic mask_chk;       // inactive lane a_mask check</pre>
<pre>  logic fulldata_chk;   // PutFullData should have size match to mask</pre>
<pre>  logic [MW-1:0] mask;</pre>
<pre>  assign mask = (1 << tl_i.a_address[SubAW-1:0]);</pre>
<pre>  always_comb begin</pre>
<pre>    addr_sz_chk  = 1'b0;</pre>
<pre>    mask_chk     = 1'b0;</pre>
<pre>    fulldata_chk = 1'b0; // Only valid when opcode is PutFullData</pre>
<pre>    if (tl_i.a_valid) begin</pre>
<pre>      unique case (tl_i.a_size)</pre>
<pre>        'h0: begin // 1 Byte</pre>
<pre>          addr_sz_chk  = 1'b1;</pre>
<pre>          mask_chk     = ~|(tl_i.a_mask & ~mask);</pre>
<pre>          fulldata_chk = |(tl_i.a_mask & mask);</pre>
<pre>        'h1: begin // 2 Byte</pre>
<pre>          addr_sz_chk  = ~tl_i.a_address[0];</pre>
<pre>          mask_chk     = (tl_i.a_address[1]) ? ~|(tl_i.a_mask & 4'b0011)</pre>
<pre>                       : ~|(tl_i.a_mask & 4'b1100);</pre>
<pre>          fulldata_chk = (tl_i.a_address[1]) ? &tl_i.a_mask[3:2] : &tl_i.a_mask[1:0] ;</pre>
<pre>        'h2: begin // 4 Byte</pre>
<pre>          addr_sz_chk  = ~|tl_i.a_address[SubAW-1:0];</pre>
<pre>          mask_chk     = 1'b1;</pre>
<pre>          fulldata_chk = &tl_i.a_mask[3:0];</pre>
<pre>        default: begin // else</pre>
<pre>          addr_sz_chk  = 1'b0;</pre>
<pre>          mask_chk     = 1'b0;</pre>
<pre>          fulldata_chk = 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      addr_sz_chk  = 1'b0;</pre>
<pre>      mask_chk     = 1'b0;</pre>
<pre>      fulldata_chk = 1'b0;</pre>
<pre>  assign a_config_allowed = addr_sz_chk</pre>
<pre>                          & mask_chk</pre>
<pre>                          & (op_get | op_partial | fulldata_chk) ;</pre>
<h3>hw/ip/tlul/rtl/tlul_fifo_sync.sv</h3>
<pre>module tlul_fifo_sync #(</pre>
<pre>  parameter int unsigned ReqPass  = 1'b1,</pre>
<pre>  parameter int unsigned RspPass  = 1'b1,</pre>
<pre>  parameter int unsigned ReqDepth = 2,</pre>
<pre>  parameter int unsigned RspDepth = 2,</pre>
<pre>  parameter int unsigned SpareReqW = 1,</pre>
<pre>  parameter int unsigned SpareRspW = 1</pre>
<pre>  input                     clk_i,</pre>
<pre>  input                     rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_h_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_h_o,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_d_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_d_i,</pre>
<pre>  input  [SpareReqW-1:0]    spare_req_i,</pre>
<pre>  output [SpareReqW-1:0]    spare_req_o,</pre>
<pre>  input  [SpareRspW-1:0]    spare_rsp_i,</pre>
<pre>  output [SpareRspW-1:0]    spare_rsp_o</pre>
<pre>  localparam int unsigned REQFIFO_WIDTH = $bits(tlul_pkg::tl_h2d_t) -2 + SpareReqW;</pre>
<pre>  prim_fifo_sync #(.Width(REQFIFO_WIDTH), .Pass(ReqPass), .Depth(ReqDepth)) reqfifo (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .clr_i         (1'b0          ),</pre>
<pre>    .wvalid        (tl_h_i.a_valid),</pre>
<pre>    .wready        (tl_h_o.a_ready),</pre>
<pre>    .wdata         ({tl_h_i.a_opcode ,</pre>
<pre>                     tl_h_i.a_param  ,</pre>
<pre>                     tl_h_i.a_size   ,</pre>
<pre>                     tl_h_i.a_source ,</pre>
<pre>                     tl_h_i.a_address,</pre>
<pre>                     tl_h_i.a_mask   ,</pre>
<pre>                     tl_h_i.a_data   ,</pre>
<pre>                     tl_h_i.a_user   ,</pre>
<pre>                     spare_req_i}),</pre>
<pre>    .depth         (),</pre>
<pre>    .rvalid        (tl_d_o.a_valid),</pre>
<pre>    .rready        (tl_d_i.a_ready),</pre>
<pre>    .rdata         ({tl_d_o.a_opcode ,</pre>
<pre>                     tl_d_o.a_param  ,</pre>
<pre>                     tl_d_o.a_size   ,</pre>
<pre>                     tl_d_o.a_source ,</pre>
<pre>                     tl_d_o.a_address,</pre>
<pre>                     tl_d_o.a_mask   ,</pre>
<pre>                     tl_d_o.a_data   ,</pre>
<pre>                     tl_d_o.a_user   ,</pre>
<pre>                     spare_req_o}));</pre>
<pre>  localparam int unsigned RSPFIFO_WIDTH = $bits(tlul_pkg::tl_d2h_t) -2 + SpareRspW;</pre>
<pre>  prim_fifo_sync #(.Width(RSPFIFO_WIDTH), .Pass(RspPass), .Depth(RspDepth)) rspfifo (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .clr_i         (1'b0          ),</pre>
<pre>    .wvalid        (tl_d_i.d_valid),</pre>
<pre>    .wready        (tl_d_o.d_ready),</pre>
<pre>    .wdata         ({tl_d_i.d_opcode,</pre>
<pre>                     tl_d_i.d_param ,</pre>
<pre>                     tl_d_i.d_size  ,</pre>
<pre>                     tl_d_i.d_source,</pre>
<pre>                     tl_d_i.d_sink  ,</pre>
<pre>                     (tl_d_i.d_opcode == tlul_pkg::AccessAckData) ? tl_d_i.d_data :</pre>
<pre>                                                                    {top_pkg::TL_DW{1'b0}} ,</pre>
<pre>                     tl_d_i.d_user  ,</pre>
<pre>                     tl_d_i.d_error ,</pre>
<pre>                     spare_rsp_i}),</pre>
<pre>    .depth         (),</pre>
<pre>    .rvalid        (tl_h_o.d_valid),</pre>
<pre>    .rready        (tl_h_i.d_ready),</pre>
<pre>    .rdata         ({tl_h_o.d_opcode,</pre>
<pre>                     tl_h_o.d_param ,</pre>
<pre>                     tl_h_o.d_size  ,</pre>
<pre>                     tl_h_o.d_source,</pre>
<pre>                     tl_h_o.d_sink  ,</pre>
<pre>                     tl_h_o.d_data  ,</pre>
<pre>                     tl_h_o.d_user  ,</pre>
<pre>                     tl_h_o.d_error ,</pre>
<pre>                     spare_rsp_o}));</pre>
<h3>hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv</h3>
<pre>module prim_generic_pad_wrapper #(</pre>
<pre>  parameter int unsigned AttrDw = 6</pre>
<pre>  inout wire         inout_io, // bidirectional pad</pre>
<pre>  output logic       in_o,     // input data</pre>
<pre>  input              out_i,    // output data</pre>
<pre>  input              oe_i,     // output enable</pre>
<pre>  input [AttrDw-1:0] attr_i</pre>
<pre>  logic kp, pu, pd, od, inv;</pre>
<pre>  typedef enum logic {STRONG_DRIVE = 1'b0, WEAK_DRIVE = 1'b1} drv_e;</pre>
<pre>  drv_e drv;</pre>
<pre>  assign {drv, kp, pu, pd, od, inv} = attr_i[5:0];</pre>
<pre>  assign in_o     = inv ^ inout_io;</pre>
<pre>  logic oe, out;</pre>
<pre>  assign out      = out_i ^ inv;</pre>
<pre>  assign oe       = oe_i & ((od & ~out) | ~od);</pre>
<pre>  assign (strong0, strong1) inout_io = (oe && drv == STRONG_DRIVE) ? out : 1'bz;</pre>
<pre>  assign (pull0, pull1)     inout_io = (oe && drv == WEAK_DRIVE)   ? out : 1'bz;</pre>
<pre>  assign (highz0, weak1)    inout_io = pu;</pre>
<pre>  assign (weak0, highz1)    inout_io = ~pd;</pre>
<pre>  assign (weak0, weak1)     inout_io = (kp) ? inout_io : 1'bz;</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>hw/top_earlgrey/ip/alert_handler/rtl/autogen/alert_handler_reg_pkg.sv</h3>
<pre>package alert_handler_reg_pkg;</pre>
<pre>  localparam int NAlerts = 1;</pre>
<pre>  localparam int EscCntDw = 32;</pre>
<pre>  localparam int AccuCntDw = 16;</pre>
<pre>  localparam int LfsrSeed = 2147483647;</pre>
<pre>  localparam logic [NAlerts-1:0] AsyncOn = 1'b0;</pre>
<pre>  localparam int N_CLASSES = 4;</pre>
<pre>  localparam int N_ESC_SEV = 4;</pre>
<pre>  localparam int N_PHASES = 4;</pre>
<pre>  localparam int N_LOC_ALERT = 4;</pre>
<pre>  localparam int PING_CNT_DW = 24;</pre>
<pre>  localparam int PHASE_DW = 2;</pre>
<pre>  localparam int CLASS_DW = 2;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } classa;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } classb;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } classc;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } classd;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } classa;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } classb;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } classc;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } classd;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_intr_enable_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } classa;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } classb;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } classc;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } classd;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_intr_test_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_regen_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [23:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_ping_timeout_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_alert_en_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_alert_class_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_alert_cause_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_loc_alert_en_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_loc_alert_class_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_loc_alert_cause_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } lock;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e0;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e1;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e2;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e3;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e0;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e1;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e2;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e3;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classa_ctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classa_clr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [15:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classa_accum_thresh_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classa_timeout_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classa_phase0_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classa_phase1_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classa_phase2_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classa_phase3_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } lock;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e0;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e1;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e2;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e3;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e0;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e1;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e2;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e3;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classb_ctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classb_clr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [15:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classb_accum_thresh_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classb_timeout_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classb_phase0_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classb_phase1_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classb_phase2_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classb_phase3_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } lock;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e0;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e1;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e2;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e3;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e0;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e1;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e2;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e3;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classc_ctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classc_clr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [15:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classc_accum_thresh_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classc_timeout_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classc_phase0_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classc_phase1_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classc_phase2_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classc_phase3_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } lock;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e0;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e1;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e2;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en_e3;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e0;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e1;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e2;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } map_e3;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classd_ctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classd_clr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [15:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classd_accum_thresh_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classd_timeout_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classd_phase0_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classd_phase1_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classd_phase2_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_classd_phase3_cyc_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } classa;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } classb;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } classc;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } classd;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_alert_cause_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_loc_alert_cause_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classa_clren_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [15:0] d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classa_accum_cnt_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classa_esc_cnt_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [2:0]  d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classa_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classb_clren_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [15:0] d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classb_accum_cnt_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classb_esc_cnt_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [2:0]  d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classb_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classc_clren_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [15:0] d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classc_accum_cnt_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classc_esc_cnt_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [2:0]  d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classc_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classd_clren_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [15:0] d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classd_accum_cnt_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classd_esc_cnt_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [2:0]  d;</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_classd_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    alert_handler_reg2hw_intr_state_reg_t intr_state; // [828:825]</pre>
<pre>    alert_handler_reg2hw_intr_enable_reg_t intr_enable; // [824:821]</pre>
<pre>    alert_handler_reg2hw_intr_test_reg_t intr_test; // [820:813]</pre>
<pre>    alert_handler_reg2hw_regen_reg_t regen; // [812:812]</pre>
<pre>    alert_handler_reg2hw_ping_timeout_cyc_reg_t ping_timeout_cyc; // [811:788]</pre>
<pre>    alert_handler_reg2hw_alert_en_mreg_t [0:0] alert_en; // [787:787]</pre>
<pre>    alert_handler_reg2hw_alert_class_mreg_t [0:0] alert_class; // [786:785]</pre>
<pre>    alert_handler_reg2hw_alert_cause_mreg_t [0:0] alert_cause; // [784:784]</pre>
<pre>    alert_handler_reg2hw_loc_alert_en_mreg_t [3:0] loc_alert_en; // [783:780]</pre>
<pre>    alert_handler_reg2hw_loc_alert_class_mreg_t [3:0] loc_alert_class; // [779:772]</pre>
<pre>    alert_handler_reg2hw_loc_alert_cause_mreg_t [3:0] loc_alert_cause; // [771:768]</pre>
<pre>    alert_handler_reg2hw_classa_ctrl_reg_t classa_ctrl; // [767:754]</pre>
<pre>    alert_handler_reg2hw_classa_clr_reg_t classa_clr; // [753:752]</pre>
<pre>    alert_handler_reg2hw_classa_accum_thresh_reg_t classa_accum_thresh; // [751:736]</pre>
<pre>    alert_handler_reg2hw_classa_timeout_cyc_reg_t classa_timeout_cyc; // [735:704]</pre>
<pre>    alert_handler_reg2hw_classa_phase0_cyc_reg_t classa_phase0_cyc; // [703:672]</pre>
<pre>    alert_handler_reg2hw_classa_phase1_cyc_reg_t classa_phase1_cyc; // [671:640]</pre>
<pre>    alert_handler_reg2hw_classa_phase2_cyc_reg_t classa_phase2_cyc; // [639:608]</pre>
<pre>    alert_handler_reg2hw_classa_phase3_cyc_reg_t classa_phase3_cyc; // [607:576]</pre>
<pre>    alert_handler_reg2hw_classb_ctrl_reg_t classb_ctrl; // [575:562]</pre>
<pre>    alert_handler_reg2hw_classb_clr_reg_t classb_clr; // [561:560]</pre>
<pre>    alert_handler_reg2hw_classb_accum_thresh_reg_t classb_accum_thresh; // [559:544]</pre>
<pre>    alert_handler_reg2hw_classb_timeout_cyc_reg_t classb_timeout_cyc; // [543:512]</pre>
<pre>    alert_handler_reg2hw_classb_phase0_cyc_reg_t classb_phase0_cyc; // [511:480]</pre>
<pre>    alert_handler_reg2hw_classb_phase1_cyc_reg_t classb_phase1_cyc; // [479:448]</pre>
<pre>    alert_handler_reg2hw_classb_phase2_cyc_reg_t classb_phase2_cyc; // [447:416]</pre>
<pre>    alert_handler_reg2hw_classb_phase3_cyc_reg_t classb_phase3_cyc; // [415:384]</pre>
<pre>    alert_handler_reg2hw_classc_ctrl_reg_t classc_ctrl; // [383:370]</pre>
<pre>    alert_handler_reg2hw_classc_clr_reg_t classc_clr; // [369:368]</pre>
<pre>    alert_handler_reg2hw_classc_accum_thresh_reg_t classc_accum_thresh; // [367:352]</pre>
<pre>    alert_handler_reg2hw_classc_timeout_cyc_reg_t classc_timeout_cyc; // [351:320]</pre>
<pre>    alert_handler_reg2hw_classc_phase0_cyc_reg_t classc_phase0_cyc; // [319:288]</pre>
<pre>    alert_handler_reg2hw_classc_phase1_cyc_reg_t classc_phase1_cyc; // [287:256]</pre>
<pre>    alert_handler_reg2hw_classc_phase2_cyc_reg_t classc_phase2_cyc; // [255:224]</pre>
<pre>    alert_handler_reg2hw_classc_phase3_cyc_reg_t classc_phase3_cyc; // [223:192]</pre>
<pre>    alert_handler_reg2hw_classd_ctrl_reg_t classd_ctrl; // [191:178]</pre>
<pre>    alert_handler_reg2hw_classd_clr_reg_t classd_clr; // [177:176]</pre>
<pre>    alert_handler_reg2hw_classd_accum_thresh_reg_t classd_accum_thresh; // [175:160]</pre>
<pre>    alert_handler_reg2hw_classd_timeout_cyc_reg_t classd_timeout_cyc; // [159:128]</pre>
<pre>    alert_handler_reg2hw_classd_phase0_cyc_reg_t classd_phase0_cyc; // [127:96]</pre>
<pre>    alert_handler_reg2hw_classd_phase1_cyc_reg_t classd_phase1_cyc; // [95:64]</pre>
<pre>    alert_handler_reg2hw_classd_phase2_cyc_reg_t classd_phase2_cyc; // [63:32]</pre>
<pre>    alert_handler_reg2hw_classd_phase3_cyc_reg_t classd_phase3_cyc; // [31:0]</pre>
<pre style="background-color: #FF0000;">  } alert_handler_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    alert_handler_hw2reg_intr_state_reg_t intr_state; // [229:226]</pre>
<pre>    alert_handler_hw2reg_alert_cause_mreg_t [0:0] alert_cause; // [225:224]</pre>
<pre>    alert_handler_hw2reg_loc_alert_cause_mreg_t [3:0] loc_alert_cause; // [223:216]</pre>
<pre>    alert_handler_hw2reg_classa_clren_reg_t classa_clren; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classa_accum_cnt_reg_t classa_accum_cnt; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classa_esc_cnt_reg_t classa_esc_cnt; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classa_state_reg_t classa_state; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classb_clren_reg_t classb_clren; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classb_accum_cnt_reg_t classb_accum_cnt; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classb_esc_cnt_reg_t classb_esc_cnt; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classb_state_reg_t classb_state; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classc_clren_reg_t classc_clren; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classc_accum_cnt_reg_t classc_accum_cnt; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classc_esc_cnt_reg_t classc_esc_cnt; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classc_state_reg_t classc_state; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classd_clren_reg_t classd_clren; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classd_accum_cnt_reg_t classd_accum_cnt; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classd_esc_cnt_reg_t classd_esc_cnt; // [215:216]</pre>
<pre>    alert_handler_hw2reg_classd_state_reg_t classd_state; // [215:216]</pre>
<pre style="background-color: #FF0000;">  } alert_handler_hw2reg_t;</pre>
<pre>  parameter ALERT_HANDLER_INTR_STATE_OFFSET = 8'h 0;</pre>
<pre>  parameter ALERT_HANDLER_INTR_ENABLE_OFFSET = 8'h 4;</pre>
<pre>  parameter ALERT_HANDLER_INTR_TEST_OFFSET = 8'h 8;</pre>
<pre>  parameter ALERT_HANDLER_REGEN_OFFSET = 8'h c;</pre>
<pre>  parameter ALERT_HANDLER_PING_TIMEOUT_CYC_OFFSET = 8'h 10;</pre>
<pre>  parameter ALERT_HANDLER_ALERT_EN_OFFSET = 8'h 14;</pre>
<pre>  parameter ALERT_HANDLER_ALERT_CLASS_OFFSET = 8'h 18;</pre>
<pre>  parameter ALERT_HANDLER_ALERT_CAUSE_OFFSET = 8'h 1c;</pre>
<pre>  parameter ALERT_HANDLER_LOC_ALERT_EN_OFFSET = 8'h 20;</pre>
<pre>  parameter ALERT_HANDLER_LOC_ALERT_CLASS_OFFSET = 8'h 24;</pre>
<pre>  parameter ALERT_HANDLER_LOC_ALERT_CAUSE_OFFSET = 8'h 28;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_CTRL_OFFSET = 8'h 2c;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_CLREN_OFFSET = 8'h 30;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_CLR_OFFSET = 8'h 34;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_ACCUM_CNT_OFFSET = 8'h 38;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_ACCUM_THRESH_OFFSET = 8'h 3c;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_TIMEOUT_CYC_OFFSET = 8'h 40;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_PHASE0_CYC_OFFSET = 8'h 44;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_PHASE1_CYC_OFFSET = 8'h 48;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_PHASE2_CYC_OFFSET = 8'h 4c;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_PHASE3_CYC_OFFSET = 8'h 50;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_ESC_CNT_OFFSET = 8'h 54;</pre>
<pre>  parameter ALERT_HANDLER_CLASSA_STATE_OFFSET = 8'h 58;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_CTRL_OFFSET = 8'h 5c;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_CLREN_OFFSET = 8'h 60;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_CLR_OFFSET = 8'h 64;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_ACCUM_CNT_OFFSET = 8'h 68;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_ACCUM_THRESH_OFFSET = 8'h 6c;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_TIMEOUT_CYC_OFFSET = 8'h 70;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_PHASE0_CYC_OFFSET = 8'h 74;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_PHASE1_CYC_OFFSET = 8'h 78;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_PHASE2_CYC_OFFSET = 8'h 7c;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_PHASE3_CYC_OFFSET = 8'h 80;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_ESC_CNT_OFFSET = 8'h 84;</pre>
<pre>  parameter ALERT_HANDLER_CLASSB_STATE_OFFSET = 8'h 88;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_CTRL_OFFSET = 8'h 8c;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_CLREN_OFFSET = 8'h 90;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_CLR_OFFSET = 8'h 94;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_ACCUM_CNT_OFFSET = 8'h 98;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_ACCUM_THRESH_OFFSET = 8'h 9c;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_TIMEOUT_CYC_OFFSET = 8'h a0;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_PHASE0_CYC_OFFSET = 8'h a4;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_PHASE1_CYC_OFFSET = 8'h a8;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_PHASE2_CYC_OFFSET = 8'h ac;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_PHASE3_CYC_OFFSET = 8'h b0;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_ESC_CNT_OFFSET = 8'h b4;</pre>
<pre>  parameter ALERT_HANDLER_CLASSC_STATE_OFFSET = 8'h b8;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_CTRL_OFFSET = 8'h bc;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_CLREN_OFFSET = 8'h c0;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_CLR_OFFSET = 8'h c4;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_ACCUM_CNT_OFFSET = 8'h c8;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_ACCUM_THRESH_OFFSET = 8'h cc;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_TIMEOUT_CYC_OFFSET = 8'h d0;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_PHASE0_CYC_OFFSET = 8'h d4;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_PHASE1_CYC_OFFSET = 8'h d8;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_PHASE2_CYC_OFFSET = 8'h dc;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_PHASE3_CYC_OFFSET = 8'h e0;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_ESC_CNT_OFFSET = 8'h e4;</pre>
<pre>  parameter ALERT_HANDLER_CLASSD_STATE_OFFSET = 8'h e8;</pre>
<pre>  typedef enum int {</pre>
<pre>    ALERT_HANDLER_INTR_STATE,</pre>
<pre>    ALERT_HANDLER_INTR_ENABLE,</pre>
<pre>    ALERT_HANDLER_INTR_TEST,</pre>
<pre>    ALERT_HANDLER_REGEN,</pre>
<pre>    ALERT_HANDLER_PING_TIMEOUT_CYC,</pre>
<pre>    ALERT_HANDLER_ALERT_EN,</pre>
<pre>    ALERT_HANDLER_ALERT_CLASS,</pre>
<pre>    ALERT_HANDLER_ALERT_CAUSE,</pre>
<pre>    ALERT_HANDLER_LOC_ALERT_EN,</pre>
<pre>    ALERT_HANDLER_LOC_ALERT_CLASS,</pre>
<pre>    ALERT_HANDLER_LOC_ALERT_CAUSE,</pre>
<pre>    ALERT_HANDLER_CLASSA_CTRL,</pre>
<pre>    ALERT_HANDLER_CLASSA_CLREN,</pre>
<pre>    ALERT_HANDLER_CLASSA_CLR,</pre>
<pre>    ALERT_HANDLER_CLASSA_ACCUM_CNT,</pre>
<pre>    ALERT_HANDLER_CLASSA_ACCUM_THRESH,</pre>
<pre>    ALERT_HANDLER_CLASSA_TIMEOUT_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSA_PHASE0_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSA_PHASE1_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSA_PHASE2_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSA_PHASE3_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSA_ESC_CNT,</pre>
<pre>    ALERT_HANDLER_CLASSA_STATE,</pre>
<pre>    ALERT_HANDLER_CLASSB_CTRL,</pre>
<pre>    ALERT_HANDLER_CLASSB_CLREN,</pre>
<pre>    ALERT_HANDLER_CLASSB_CLR,</pre>
<pre>    ALERT_HANDLER_CLASSB_ACCUM_CNT,</pre>
<pre>    ALERT_HANDLER_CLASSB_ACCUM_THRESH,</pre>
<pre>    ALERT_HANDLER_CLASSB_TIMEOUT_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSB_PHASE0_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSB_PHASE1_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSB_PHASE2_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSB_PHASE3_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSB_ESC_CNT,</pre>
<pre>    ALERT_HANDLER_CLASSB_STATE,</pre>
<pre>    ALERT_HANDLER_CLASSC_CTRL,</pre>
<pre>    ALERT_HANDLER_CLASSC_CLREN,</pre>
<pre>    ALERT_HANDLER_CLASSC_CLR,</pre>
<pre>    ALERT_HANDLER_CLASSC_ACCUM_CNT,</pre>
<pre>    ALERT_HANDLER_CLASSC_ACCUM_THRESH,</pre>
<pre>    ALERT_HANDLER_CLASSC_TIMEOUT_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSC_PHASE0_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSC_PHASE1_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSC_PHASE2_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSC_PHASE3_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSC_ESC_CNT,</pre>
<pre>    ALERT_HANDLER_CLASSC_STATE,</pre>
<pre>    ALERT_HANDLER_CLASSD_CTRL,</pre>
<pre>    ALERT_HANDLER_CLASSD_CLREN,</pre>
<pre>    ALERT_HANDLER_CLASSD_CLR,</pre>
<pre>    ALERT_HANDLER_CLASSD_ACCUM_CNT,</pre>
<pre>    ALERT_HANDLER_CLASSD_ACCUM_THRESH,</pre>
<pre>    ALERT_HANDLER_CLASSD_TIMEOUT_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSD_PHASE0_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSD_PHASE1_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSD_PHASE2_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSD_PHASE3_CYC,</pre>
<pre>    ALERT_HANDLER_CLASSD_ESC_CNT,</pre>
<pre>    ALERT_HANDLER_CLASSD_STATE</pre>
<pre>  } alert_handler_id_e;</pre>
<pre>  localparam logic [3:0] ALERT_HANDLER_PERMIT [59] = '{</pre>
<pre>    4'b 0001, // index[ 0] ALERT_HANDLER_INTR_STATE</pre>
<pre>    4'b 0001, // index[ 1] ALERT_HANDLER_INTR_ENABLE</pre>
<pre>    4'b 0001, // index[ 2] ALERT_HANDLER_INTR_TEST</pre>
<pre>    4'b 0001, // index[ 3] ALERT_HANDLER_REGEN</pre>
<pre>    4'b 0111, // index[ 4] ALERT_HANDLER_PING_TIMEOUT_CYC</pre>
<pre>    4'b 0001, // index[ 5] ALERT_HANDLER_ALERT_EN</pre>
<pre>    4'b 0001, // index[ 6] ALERT_HANDLER_ALERT_CLASS</pre>
<pre>    4'b 0001, // index[ 7] ALERT_HANDLER_ALERT_CAUSE</pre>
<pre>    4'b 0001, // index[ 8] ALERT_HANDLER_LOC_ALERT_EN</pre>
<pre>    4'b 0001, // index[ 9] ALERT_HANDLER_LOC_ALERT_CLASS</pre>
<pre>    4'b 0001, // index[10] ALERT_HANDLER_LOC_ALERT_CAUSE</pre>
<pre>    4'b 0011, // index[11] ALERT_HANDLER_CLASSA_CTRL</pre>
<pre>    4'b 0001, // index[12] ALERT_HANDLER_CLASSA_CLREN</pre>
<pre>    4'b 0001, // index[13] ALERT_HANDLER_CLASSA_CLR</pre>
<pre>    4'b 0011, // index[14] ALERT_HANDLER_CLASSA_ACCUM_CNT</pre>
<pre>    4'b 0011, // index[15] ALERT_HANDLER_CLASSA_ACCUM_THRESH</pre>
<pre>    4'b 1111, // index[16] ALERT_HANDLER_CLASSA_TIMEOUT_CYC</pre>
<pre>    4'b 1111, // index[17] ALERT_HANDLER_CLASSA_PHASE0_CYC</pre>
<pre>    4'b 1111, // index[18] ALERT_HANDLER_CLASSA_PHASE1_CYC</pre>
<pre>    4'b 1111, // index[19] ALERT_HANDLER_CLASSA_PHASE2_CYC</pre>
<pre>    4'b 1111, // index[20] ALERT_HANDLER_CLASSA_PHASE3_CYC</pre>
<pre>    4'b 1111, // index[21] ALERT_HANDLER_CLASSA_ESC_CNT</pre>
<pre>    4'b 0001, // index[22] ALERT_HANDLER_CLASSA_STATE</pre>
<pre>    4'b 0011, // index[23] ALERT_HANDLER_CLASSB_CTRL</pre>
<pre>    4'b 0001, // index[24] ALERT_HANDLER_CLASSB_CLREN</pre>
<pre>    4'b 0001, // index[25] ALERT_HANDLER_CLASSB_CLR</pre>
<pre>    4'b 0011, // index[26] ALERT_HANDLER_CLASSB_ACCUM_CNT</pre>
<pre>    4'b 0011, // index[27] ALERT_HANDLER_CLASSB_ACCUM_THRESH</pre>
<pre>    4'b 1111, // index[28] ALERT_HANDLER_CLASSB_TIMEOUT_CYC</pre>
<pre>    4'b 1111, // index[29] ALERT_HANDLER_CLASSB_PHASE0_CYC</pre>
<pre>    4'b 1111, // index[30] ALERT_HANDLER_CLASSB_PHASE1_CYC</pre>
<pre>    4'b 1111, // index[31] ALERT_HANDLER_CLASSB_PHASE2_CYC</pre>
<pre>    4'b 1111, // index[32] ALERT_HANDLER_CLASSB_PHASE3_CYC</pre>
<pre>    4'b 1111, // index[33] ALERT_HANDLER_CLASSB_ESC_CNT</pre>
<pre>    4'b 0001, // index[34] ALERT_HANDLER_CLASSB_STATE</pre>
<pre>    4'b 0011, // index[35] ALERT_HANDLER_CLASSC_CTRL</pre>
<pre>    4'b 0001, // index[36] ALERT_HANDLER_CLASSC_CLREN</pre>
<pre>    4'b 0001, // index[37] ALERT_HANDLER_CLASSC_CLR</pre>
<pre>    4'b 0011, // index[38] ALERT_HANDLER_CLASSC_ACCUM_CNT</pre>
<pre>    4'b 0011, // index[39] ALERT_HANDLER_CLASSC_ACCUM_THRESH</pre>
<pre>    4'b 1111, // index[40] ALERT_HANDLER_CLASSC_TIMEOUT_CYC</pre>
<pre>    4'b 1111, // index[41] ALERT_HANDLER_CLASSC_PHASE0_CYC</pre>
<pre>    4'b 1111, // index[42] ALERT_HANDLER_CLASSC_PHASE1_CYC</pre>
<pre>    4'b 1111, // index[43] ALERT_HANDLER_CLASSC_PHASE2_CYC</pre>
<pre>    4'b 1111, // index[44] ALERT_HANDLER_CLASSC_PHASE3_CYC</pre>
<pre>    4'b 1111, // index[45] ALERT_HANDLER_CLASSC_ESC_CNT</pre>
<pre>    4'b 0001, // index[46] ALERT_HANDLER_CLASSC_STATE</pre>
<pre>    4'b 0011, // index[47] ALERT_HANDLER_CLASSD_CTRL</pre>
<pre>    4'b 0001, // index[48] ALERT_HANDLER_CLASSD_CLREN</pre>
<pre>    4'b 0001, // index[49] ALERT_HANDLER_CLASSD_CLR</pre>
<pre>    4'b 0011, // index[50] ALERT_HANDLER_CLASSD_ACCUM_CNT</pre>
<pre>    4'b 0011, // index[51] ALERT_HANDLER_CLASSD_ACCUM_THRESH</pre>
<pre>    4'b 1111, // index[52] ALERT_HANDLER_CLASSD_TIMEOUT_CYC</pre>
<pre>    4'b 1111, // index[53] ALERT_HANDLER_CLASSD_PHASE0_CYC</pre>
<pre>    4'b 1111, // index[54] ALERT_HANDLER_CLASSD_PHASE1_CYC</pre>
<pre>    4'b 1111, // index[55] ALERT_HANDLER_CLASSD_PHASE2_CYC</pre>
<pre>    4'b 1111, // index[56] ALERT_HANDLER_CLASSD_PHASE3_CYC</pre>
<pre>    4'b 1111, // index[57] ALERT_HANDLER_CLASSD_ESC_CNT</pre>
<pre>    4'b 0001  // index[58] ALERT_HANDLER_CLASSD_STATE</pre>
<h3>hw/top_earlgrey/ip/alert_handler/rtl/autogen/alert_handler_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output alert_handler_reg_pkg::alert_handler_reg2hw_t reg2hw, // Write</pre>
<pre>  input  alert_handler_reg_pkg::alert_handler_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam AW = 8;</pre>
<pre>  localparam DW = 32;</pre>
<pre>  localparam DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  assign tl_reg_h2d = tl_i;</pre>
<pre>  assign tl_o       = tl_reg_d2h;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic intr_state_classa_qs;</pre>
<pre>  logic intr_state_classa_wd;</pre>
<pre>  logic intr_state_classa_we;</pre>
<pre>  logic intr_state_classb_qs;</pre>
<pre>  logic intr_state_classb_wd;</pre>
<pre>  logic intr_state_classb_we;</pre>
<pre>  logic intr_state_classc_qs;</pre>
<pre>  logic intr_state_classc_wd;</pre>
<pre>  logic intr_state_classc_we;</pre>
<pre>  logic intr_state_classd_qs;</pre>
<pre>  logic intr_state_classd_wd;</pre>
<pre>  logic intr_state_classd_we;</pre>
<pre>  logic intr_enable_classa_qs;</pre>
<pre>  logic intr_enable_classa_wd;</pre>
<pre>  logic intr_enable_classa_we;</pre>
<pre>  logic intr_enable_classb_qs;</pre>
<pre>  logic intr_enable_classb_wd;</pre>
<pre>  logic intr_enable_classb_we;</pre>
<pre>  logic intr_enable_classc_qs;</pre>
<pre>  logic intr_enable_classc_wd;</pre>
<pre>  logic intr_enable_classc_we;</pre>
<pre>  logic intr_enable_classd_qs;</pre>
<pre>  logic intr_enable_classd_wd;</pre>
<pre>  logic intr_enable_classd_we;</pre>
<pre>  logic intr_test_classa_wd;</pre>
<pre>  logic intr_test_classa_we;</pre>
<pre>  logic intr_test_classb_wd;</pre>
<pre>  logic intr_test_classb_we;</pre>
<pre>  logic intr_test_classc_wd;</pre>
<pre>  logic intr_test_classc_we;</pre>
<pre>  logic intr_test_classd_wd;</pre>
<pre>  logic intr_test_classd_we;</pre>
<pre>  logic regen_qs;</pre>
<pre>  logic regen_wd;</pre>
<pre>  logic regen_we;</pre>
<pre>  logic [23:0] ping_timeout_cyc_qs;</pre>
<pre>  logic [23:0] ping_timeout_cyc_wd;</pre>
<pre>  logic ping_timeout_cyc_we;</pre>
<pre>  logic alert_en_qs;</pre>
<pre>  logic alert_en_wd;</pre>
<pre>  logic alert_en_we;</pre>
<pre>  logic [1:0] alert_class_qs;</pre>
<pre>  logic [1:0] alert_class_wd;</pre>
<pre>  logic alert_class_we;</pre>
<pre>  logic alert_cause_qs;</pre>
<pre>  logic alert_cause_wd;</pre>
<pre>  logic alert_cause_we;</pre>
<pre>  logic loc_alert_en_en_la0_qs;</pre>
<pre>  logic loc_alert_en_en_la0_wd;</pre>
<pre>  logic loc_alert_en_en_la0_we;</pre>
<pre>  logic loc_alert_en_en_la1_qs;</pre>
<pre>  logic loc_alert_en_en_la1_wd;</pre>
<pre>  logic loc_alert_en_en_la1_we;</pre>
<pre>  logic loc_alert_en_en_la2_qs;</pre>
<pre>  logic loc_alert_en_en_la2_wd;</pre>
<pre>  logic loc_alert_en_en_la2_we;</pre>
<pre>  logic loc_alert_en_en_la3_qs;</pre>
<pre>  logic loc_alert_en_en_la3_wd;</pre>
<pre>  logic loc_alert_en_en_la3_we;</pre>
<pre>  logic [1:0] loc_alert_class_class_la0_qs;</pre>
<pre>  logic [1:0] loc_alert_class_class_la0_wd;</pre>
<pre>  logic loc_alert_class_class_la0_we;</pre>
<pre>  logic [1:0] loc_alert_class_class_la1_qs;</pre>
<pre>  logic [1:0] loc_alert_class_class_la1_wd;</pre>
<pre>  logic loc_alert_class_class_la1_we;</pre>
<pre>  logic [1:0] loc_alert_class_class_la2_qs;</pre>
<pre>  logic [1:0] loc_alert_class_class_la2_wd;</pre>
<pre>  logic loc_alert_class_class_la2_we;</pre>
<pre>  logic [1:0] loc_alert_class_class_la3_qs;</pre>
<pre>  logic [1:0] loc_alert_class_class_la3_wd;</pre>
<pre>  logic loc_alert_class_class_la3_we;</pre>
<pre>  logic loc_alert_cause_la0_qs;</pre>
<pre>  logic loc_alert_cause_la0_wd;</pre>
<pre>  logic loc_alert_cause_la0_we;</pre>
<pre>  logic loc_alert_cause_la1_qs;</pre>
<pre>  logic loc_alert_cause_la1_wd;</pre>
<pre>  logic loc_alert_cause_la1_we;</pre>
<pre>  logic loc_alert_cause_la2_qs;</pre>
<pre>  logic loc_alert_cause_la2_wd;</pre>
<pre>  logic loc_alert_cause_la2_we;</pre>
<pre>  logic loc_alert_cause_la3_qs;</pre>
<pre>  logic loc_alert_cause_la3_wd;</pre>
<pre>  logic loc_alert_cause_la3_we;</pre>
<pre>  logic classa_ctrl_en_qs;</pre>
<pre>  logic classa_ctrl_en_wd;</pre>
<pre>  logic classa_ctrl_en_we;</pre>
<pre>  logic classa_ctrl_lock_qs;</pre>
<pre>  logic classa_ctrl_lock_wd;</pre>
<pre>  logic classa_ctrl_lock_we;</pre>
<pre>  logic classa_ctrl_en_e0_qs;</pre>
<pre>  logic classa_ctrl_en_e0_wd;</pre>
<pre>  logic classa_ctrl_en_e0_we;</pre>
<pre>  logic classa_ctrl_en_e1_qs;</pre>
<pre>  logic classa_ctrl_en_e1_wd;</pre>
<pre>  logic classa_ctrl_en_e1_we;</pre>
<pre>  logic classa_ctrl_en_e2_qs;</pre>
<pre>  logic classa_ctrl_en_e2_wd;</pre>
<pre>  logic classa_ctrl_en_e2_we;</pre>
<pre>  logic classa_ctrl_en_e3_qs;</pre>
<pre>  logic classa_ctrl_en_e3_wd;</pre>
<pre>  logic classa_ctrl_en_e3_we;</pre>
<pre>  logic [1:0] classa_ctrl_map_e0_qs;</pre>
<pre>  logic [1:0] classa_ctrl_map_e0_wd;</pre>
<pre>  logic classa_ctrl_map_e0_we;</pre>
<pre>  logic [1:0] classa_ctrl_map_e1_qs;</pre>
<pre>  logic [1:0] classa_ctrl_map_e1_wd;</pre>
<pre>  logic classa_ctrl_map_e1_we;</pre>
<pre>  logic [1:0] classa_ctrl_map_e2_qs;</pre>
<pre>  logic [1:0] classa_ctrl_map_e2_wd;</pre>
<pre>  logic classa_ctrl_map_e2_we;</pre>
<pre>  logic [1:0] classa_ctrl_map_e3_qs;</pre>
<pre>  logic [1:0] classa_ctrl_map_e3_wd;</pre>
<pre>  logic classa_ctrl_map_e3_we;</pre>
<pre>  logic classa_clren_qs;</pre>
<pre>  logic classa_clren_wd;</pre>
<pre>  logic classa_clren_we;</pre>
<pre>  logic classa_clr_wd;</pre>
<pre>  logic classa_clr_we;</pre>
<pre>  logic [15:0] classa_accum_cnt_qs;</pre>
<pre>  logic classa_accum_cnt_re;</pre>
<pre>  logic [15:0] classa_accum_thresh_qs;</pre>
<pre>  logic [15:0] classa_accum_thresh_wd;</pre>
<pre>  logic classa_accum_thresh_we;</pre>
<pre>  logic [31:0] classa_timeout_cyc_qs;</pre>
<pre>  logic [31:0] classa_timeout_cyc_wd;</pre>
<pre>  logic classa_timeout_cyc_we;</pre>
<pre>  logic [31:0] classa_phase0_cyc_qs;</pre>
<pre>  logic [31:0] classa_phase0_cyc_wd;</pre>
<pre>  logic classa_phase0_cyc_we;</pre>
<pre>  logic [31:0] classa_phase1_cyc_qs;</pre>
<pre>  logic [31:0] classa_phase1_cyc_wd;</pre>
<pre>  logic classa_phase1_cyc_we;</pre>
<pre>  logic [31:0] classa_phase2_cyc_qs;</pre>
<pre>  logic [31:0] classa_phase2_cyc_wd;</pre>
<pre>  logic classa_phase2_cyc_we;</pre>
<pre>  logic [31:0] classa_phase3_cyc_qs;</pre>
<pre>  logic [31:0] classa_phase3_cyc_wd;</pre>
<pre>  logic classa_phase3_cyc_we;</pre>
<pre>  logic [31:0] classa_esc_cnt_qs;</pre>
<pre>  logic classa_esc_cnt_re;</pre>
<pre>  logic [2:0] classa_state_qs;</pre>
<pre>  logic classa_state_re;</pre>
<pre>  logic classb_ctrl_en_qs;</pre>
<pre>  logic classb_ctrl_en_wd;</pre>
<pre>  logic classb_ctrl_en_we;</pre>
<pre>  logic classb_ctrl_lock_qs;</pre>
<pre>  logic classb_ctrl_lock_wd;</pre>
<pre>  logic classb_ctrl_lock_we;</pre>
<pre>  logic classb_ctrl_en_e0_qs;</pre>
<pre>  logic classb_ctrl_en_e0_wd;</pre>
<pre>  logic classb_ctrl_en_e0_we;</pre>
<pre>  logic classb_ctrl_en_e1_qs;</pre>
<pre>  logic classb_ctrl_en_e1_wd;</pre>
<pre>  logic classb_ctrl_en_e1_we;</pre>
<pre>  logic classb_ctrl_en_e2_qs;</pre>
<pre>  logic classb_ctrl_en_e2_wd;</pre>
<pre>  logic classb_ctrl_en_e2_we;</pre>
<pre>  logic classb_ctrl_en_e3_qs;</pre>
<pre>  logic classb_ctrl_en_e3_wd;</pre>
<pre>  logic classb_ctrl_en_e3_we;</pre>
<pre>  logic [1:0] classb_ctrl_map_e0_qs;</pre>
<pre>  logic [1:0] classb_ctrl_map_e0_wd;</pre>
<pre>  logic classb_ctrl_map_e0_we;</pre>
<pre>  logic [1:0] classb_ctrl_map_e1_qs;</pre>
<pre>  logic [1:0] classb_ctrl_map_e1_wd;</pre>
<pre>  logic classb_ctrl_map_e1_we;</pre>
<pre>  logic [1:0] classb_ctrl_map_e2_qs;</pre>
<pre>  logic [1:0] classb_ctrl_map_e2_wd;</pre>
<pre>  logic classb_ctrl_map_e2_we;</pre>
<pre>  logic [1:0] classb_ctrl_map_e3_qs;</pre>
<pre>  logic [1:0] classb_ctrl_map_e3_wd;</pre>
<pre>  logic classb_ctrl_map_e3_we;</pre>
<pre>  logic classb_clren_qs;</pre>
<pre>  logic classb_clren_wd;</pre>
<pre>  logic classb_clren_we;</pre>
<pre>  logic classb_clr_wd;</pre>
<pre>  logic classb_clr_we;</pre>
<pre>  logic [15:0] classb_accum_cnt_qs;</pre>
<pre>  logic classb_accum_cnt_re;</pre>
<pre>  logic [15:0] classb_accum_thresh_qs;</pre>
<pre>  logic [15:0] classb_accum_thresh_wd;</pre>
<pre>  logic classb_accum_thresh_we;</pre>
<pre>  logic [31:0] classb_timeout_cyc_qs;</pre>
<pre>  logic [31:0] classb_timeout_cyc_wd;</pre>
<pre>  logic classb_timeout_cyc_we;</pre>
<pre>  logic [31:0] classb_phase0_cyc_qs;</pre>
<pre>  logic [31:0] classb_phase0_cyc_wd;</pre>
<pre>  logic classb_phase0_cyc_we;</pre>
<pre>  logic [31:0] classb_phase1_cyc_qs;</pre>
<pre>  logic [31:0] classb_phase1_cyc_wd;</pre>
<pre>  logic classb_phase1_cyc_we;</pre>
<pre>  logic [31:0] classb_phase2_cyc_qs;</pre>
<pre>  logic [31:0] classb_phase2_cyc_wd;</pre>
<pre>  logic classb_phase2_cyc_we;</pre>
<pre>  logic [31:0] classb_phase3_cyc_qs;</pre>
<pre>  logic [31:0] classb_phase3_cyc_wd;</pre>
<pre>  logic classb_phase3_cyc_we;</pre>
<pre>  logic [31:0] classb_esc_cnt_qs;</pre>
<pre>  logic classb_esc_cnt_re;</pre>
<pre>  logic [2:0] classb_state_qs;</pre>
<pre>  logic classb_state_re;</pre>
<pre>  logic classc_ctrl_en_qs;</pre>
<pre>  logic classc_ctrl_en_wd;</pre>
<pre>  logic classc_ctrl_en_we;</pre>
<pre>  logic classc_ctrl_lock_qs;</pre>
<pre>  logic classc_ctrl_lock_wd;</pre>
<pre>  logic classc_ctrl_lock_we;</pre>
<pre>  logic classc_ctrl_en_e0_qs;</pre>
<pre>  logic classc_ctrl_en_e0_wd;</pre>
<pre>  logic classc_ctrl_en_e0_we;</pre>
<pre>  logic classc_ctrl_en_e1_qs;</pre>
<pre>  logic classc_ctrl_en_e1_wd;</pre>
<pre>  logic classc_ctrl_en_e1_we;</pre>
<pre>  logic classc_ctrl_en_e2_qs;</pre>
<pre>  logic classc_ctrl_en_e2_wd;</pre>
<pre>  logic classc_ctrl_en_e2_we;</pre>
<pre>  logic classc_ctrl_en_e3_qs;</pre>
<pre>  logic classc_ctrl_en_e3_wd;</pre>
<pre>  logic classc_ctrl_en_e3_we;</pre>
<pre>  logic [1:0] classc_ctrl_map_e0_qs;</pre>
<pre>  logic [1:0] classc_ctrl_map_e0_wd;</pre>
<pre>  logic classc_ctrl_map_e0_we;</pre>
<pre>  logic [1:0] classc_ctrl_map_e1_qs;</pre>
<pre>  logic [1:0] classc_ctrl_map_e1_wd;</pre>
<pre>  logic classc_ctrl_map_e1_we;</pre>
<pre>  logic [1:0] classc_ctrl_map_e2_qs;</pre>
<pre>  logic [1:0] classc_ctrl_map_e2_wd;</pre>
<pre>  logic classc_ctrl_map_e2_we;</pre>
<pre>  logic [1:0] classc_ctrl_map_e3_qs;</pre>
<pre>  logic [1:0] classc_ctrl_map_e3_wd;</pre>
<pre>  logic classc_ctrl_map_e3_we;</pre>
<pre>  logic classc_clren_qs;</pre>
<pre>  logic classc_clren_wd;</pre>
<pre>  logic classc_clren_we;</pre>
<pre>  logic classc_clr_wd;</pre>
<pre>  logic classc_clr_we;</pre>
<pre>  logic [15:0] classc_accum_cnt_qs;</pre>
<pre>  logic classc_accum_cnt_re;</pre>
<pre>  logic [15:0] classc_accum_thresh_qs;</pre>
<pre>  logic [15:0] classc_accum_thresh_wd;</pre>
<pre>  logic classc_accum_thresh_we;</pre>
<pre>  logic [31:0] classc_timeout_cyc_qs;</pre>
<pre>  logic [31:0] classc_timeout_cyc_wd;</pre>
<pre>  logic classc_timeout_cyc_we;</pre>
<pre>  logic [31:0] classc_phase0_cyc_qs;</pre>
<pre>  logic [31:0] classc_phase0_cyc_wd;</pre>
<pre>  logic classc_phase0_cyc_we;</pre>
<pre>  logic [31:0] classc_phase1_cyc_qs;</pre>
<pre>  logic [31:0] classc_phase1_cyc_wd;</pre>
<pre>  logic classc_phase1_cyc_we;</pre>
<pre>  logic [31:0] classc_phase2_cyc_qs;</pre>
<pre>  logic [31:0] classc_phase2_cyc_wd;</pre>
<pre>  logic classc_phase2_cyc_we;</pre>
<pre>  logic [31:0] classc_phase3_cyc_qs;</pre>
<pre>  logic [31:0] classc_phase3_cyc_wd;</pre>
<pre>  logic classc_phase3_cyc_we;</pre>
<pre>  logic [31:0] classc_esc_cnt_qs;</pre>
<pre>  logic classc_esc_cnt_re;</pre>
<pre>  logic [2:0] classc_state_qs;</pre>
<pre>  logic classc_state_re;</pre>
<pre>  logic classd_ctrl_en_qs;</pre>
<pre>  logic classd_ctrl_en_wd;</pre>
<pre>  logic classd_ctrl_en_we;</pre>
<pre>  logic classd_ctrl_lock_qs;</pre>
<pre>  logic classd_ctrl_lock_wd;</pre>
<pre>  logic classd_ctrl_lock_we;</pre>
<pre>  logic classd_ctrl_en_e0_qs;</pre>
<pre>  logic classd_ctrl_en_e0_wd;</pre>
<pre>  logic classd_ctrl_en_e0_we;</pre>
<pre>  logic classd_ctrl_en_e1_qs;</pre>
<pre>  logic classd_ctrl_en_e1_wd;</pre>
<pre>  logic classd_ctrl_en_e1_we;</pre>
<pre>  logic classd_ctrl_en_e2_qs;</pre>
<pre>  logic classd_ctrl_en_e2_wd;</pre>
<pre>  logic classd_ctrl_en_e2_we;</pre>
<pre>  logic classd_ctrl_en_e3_qs;</pre>
<pre>  logic classd_ctrl_en_e3_wd;</pre>
<pre>  logic classd_ctrl_en_e3_we;</pre>
<pre>  logic [1:0] classd_ctrl_map_e0_qs;</pre>
<pre>  logic [1:0] classd_ctrl_map_e0_wd;</pre>
<pre>  logic classd_ctrl_map_e0_we;</pre>
<pre>  logic [1:0] classd_ctrl_map_e1_qs;</pre>
<pre>  logic [1:0] classd_ctrl_map_e1_wd;</pre>
<pre>  logic classd_ctrl_map_e1_we;</pre>
<pre>  logic [1:0] classd_ctrl_map_e2_qs;</pre>
<pre>  logic [1:0] classd_ctrl_map_e2_wd;</pre>
<pre>  logic classd_ctrl_map_e2_we;</pre>
<pre>  logic [1:0] classd_ctrl_map_e3_qs;</pre>
<pre>  logic [1:0] classd_ctrl_map_e3_wd;</pre>
<pre>  logic classd_ctrl_map_e3_we;</pre>
<pre>  logic classd_clren_qs;</pre>
<pre>  logic classd_clren_wd;</pre>
<pre>  logic classd_clren_we;</pre>
<pre>  logic classd_clr_wd;</pre>
<pre>  logic classd_clr_we;</pre>
<pre>  logic [15:0] classd_accum_cnt_qs;</pre>
<pre>  logic classd_accum_cnt_re;</pre>
<pre>  logic [15:0] classd_accum_thresh_qs;</pre>
<pre>  logic [15:0] classd_accum_thresh_wd;</pre>
<pre>  logic classd_accum_thresh_we;</pre>
<pre>  logic [31:0] classd_timeout_cyc_qs;</pre>
<pre>  logic [31:0] classd_timeout_cyc_wd;</pre>
<pre>  logic classd_timeout_cyc_we;</pre>
<pre>  logic [31:0] classd_phase0_cyc_qs;</pre>
<pre>  logic [31:0] classd_phase0_cyc_wd;</pre>
<pre>  logic classd_phase0_cyc_we;</pre>
<pre>  logic [31:0] classd_phase1_cyc_qs;</pre>
<pre>  logic [31:0] classd_phase1_cyc_wd;</pre>
<pre>  logic classd_phase1_cyc_we;</pre>
<pre>  logic [31:0] classd_phase2_cyc_qs;</pre>
<pre>  logic [31:0] classd_phase2_cyc_wd;</pre>
<pre>  logic classd_phase2_cyc_we;</pre>
<pre>  logic [31:0] classd_phase3_cyc_qs;</pre>
<pre>  logic [31:0] classd_phase3_cyc_wd;</pre>
<pre>  logic classd_phase3_cyc_we;</pre>
<pre>  logic [31:0] classd_esc_cnt_qs;</pre>
<pre>  logic classd_esc_cnt_re;</pre>
<pre>  logic [2:0] classd_state_qs;</pre>
<pre>  logic classd_state_re;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_classa (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_classa_we),</pre>
<pre>    .wd     (intr_state_classa_wd),</pre>
<pre>    .de     (hw2reg.intr_state.classa.de),</pre>
<pre>    .d      (hw2reg.intr_state.classa.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.classa.q ),</pre>
<pre>    .qs     (intr_state_classa_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_classb (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_classb_we),</pre>
<pre>    .wd     (intr_state_classb_wd),</pre>
<pre>    .de     (hw2reg.intr_state.classb.de),</pre>
<pre>    .d      (hw2reg.intr_state.classb.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.classb.q ),</pre>
<pre>    .qs     (intr_state_classb_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_classc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_classc_we),</pre>
<pre>    .wd     (intr_state_classc_wd),</pre>
<pre>    .de     (hw2reg.intr_state.classc.de),</pre>
<pre>    .d      (hw2reg.intr_state.classc.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.classc.q ),</pre>
<pre>    .qs     (intr_state_classc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_classd (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_classd_we),</pre>
<pre>    .wd     (intr_state_classd_wd),</pre>
<pre>    .de     (hw2reg.intr_state.classd.de),</pre>
<pre>    .d      (hw2reg.intr_state.classd.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.classd.q ),</pre>
<pre>    .qs     (intr_state_classd_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_classa (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_classa_we),</pre>
<pre>    .wd     (intr_enable_classa_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.classa.q ),</pre>
<pre>    .qs     (intr_enable_classa_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_classb (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_classb_we),</pre>
<pre>    .wd     (intr_enable_classb_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.classb.q ),</pre>
<pre>    .qs     (intr_enable_classb_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_classc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_classc_we),</pre>
<pre>    .wd     (intr_enable_classc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.classc.q ),</pre>
<pre>    .qs     (intr_enable_classc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_classd (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_classd_we),</pre>
<pre>    .wd     (intr_enable_classd_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.classd.q ),</pre>
<pre>    .qs     (intr_enable_classd_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_classa (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_classa_we),</pre>
<pre>    .wd     (intr_test_classa_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.classa.qe),</pre>
<pre>    .q      (reg2hw.intr_test.classa.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_classb (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_classb_we),</pre>
<pre>    .wd     (intr_test_classb_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.classb.qe),</pre>
<pre>    .q      (reg2hw.intr_test.classb.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_classc (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_classc_we),</pre>
<pre>    .wd     (intr_test_classc_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.classc.qe),</pre>
<pre>    .q      (reg2hw.intr_test.classc.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_classd (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_classd_we),</pre>
<pre>    .wd     (intr_test_classd_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.classd.qe),</pre>
<pre>    .q      (reg2hw.intr_test.classd.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_regen (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (regen_we),</pre>
<pre>    .wd     (regen_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.regen.q ),</pre>
<pre>    .qs     (regen_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (24),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (24'h20)</pre>
<pre style="background-color: #FF0000;">  ) u_ping_timeout_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ping_timeout_cyc_we & regen_qs),</pre>
<pre>    .wd     (ping_timeout_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ping_timeout_cyc.q ),</pre>
<pre>    .qs     (ping_timeout_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_alert_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (alert_en_we & regen_qs),</pre>
<pre>    .wd     (alert_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.alert_en[0].q ),</pre>
<pre>    .qs     (alert_en_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_alert_class (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (alert_class_we & regen_qs),</pre>
<pre>    .wd     (alert_class_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.alert_class[0].q ),</pre>
<pre>    .qs     (alert_class_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_alert_cause (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (alert_cause_we),</pre>
<pre>    .wd     (alert_cause_wd),</pre>
<pre>    .de     (hw2reg.alert_cause[0].de),</pre>
<pre>    .d      (hw2reg.alert_cause[0].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.alert_cause[0].q ),</pre>
<pre>    .qs     (alert_cause_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_en_en_la0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_en_en_la0_we & regen_qs),</pre>
<pre>    .wd     (loc_alert_en_en_la0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_en[0].q ),</pre>
<pre>    .qs     (loc_alert_en_en_la0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_en_en_la1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_en_en_la1_we & regen_qs),</pre>
<pre>    .wd     (loc_alert_en_en_la1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_en[1].q ),</pre>
<pre>    .qs     (loc_alert_en_en_la1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_en_en_la2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_en_en_la2_we & regen_qs),</pre>
<pre>    .wd     (loc_alert_en_en_la2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_en[2].q ),</pre>
<pre>    .qs     (loc_alert_en_en_la2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_en_en_la3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_en_en_la3_we & regen_qs),</pre>
<pre>    .wd     (loc_alert_en_en_la3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_en[3].q ),</pre>
<pre>    .qs     (loc_alert_en_en_la3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_class_class_la0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_class_class_la0_we & regen_qs),</pre>
<pre>    .wd     (loc_alert_class_class_la0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_class[0].q ),</pre>
<pre>    .qs     (loc_alert_class_class_la0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_class_class_la1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_class_class_la1_we & regen_qs),</pre>
<pre>    .wd     (loc_alert_class_class_la1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_class[1].q ),</pre>
<pre>    .qs     (loc_alert_class_class_la1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_class_class_la2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_class_class_la2_we & regen_qs),</pre>
<pre>    .wd     (loc_alert_class_class_la2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_class[2].q ),</pre>
<pre>    .qs     (loc_alert_class_class_la2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_class_class_la3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_class_class_la3_we & regen_qs),</pre>
<pre>    .wd     (loc_alert_class_class_la3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_class[3].q ),</pre>
<pre>    .qs     (loc_alert_class_class_la3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_cause_la0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_cause_la0_we),</pre>
<pre>    .wd     (loc_alert_cause_la0_wd),</pre>
<pre>    .de     (hw2reg.loc_alert_cause[0].de),</pre>
<pre>    .d      (hw2reg.loc_alert_cause[0].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_cause[0].q ),</pre>
<pre>    .qs     (loc_alert_cause_la0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_cause_la1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_cause_la1_we),</pre>
<pre>    .wd     (loc_alert_cause_la1_wd),</pre>
<pre>    .de     (hw2reg.loc_alert_cause[1].de),</pre>
<pre>    .d      (hw2reg.loc_alert_cause[1].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_cause[1].q ),</pre>
<pre>    .qs     (loc_alert_cause_la1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_cause_la2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_cause_la2_we),</pre>
<pre>    .wd     (loc_alert_cause_la2_wd),</pre>
<pre>    .de     (hw2reg.loc_alert_cause[2].de),</pre>
<pre>    .d      (hw2reg.loc_alert_cause[2].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_cause[2].q ),</pre>
<pre>    .qs     (loc_alert_cause_la2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_loc_alert_cause_la3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (loc_alert_cause_la3_we),</pre>
<pre>    .wd     (loc_alert_cause_la3_wd),</pre>
<pre>    .de     (hw2reg.loc_alert_cause[3].de),</pre>
<pre>    .d      (hw2reg.loc_alert_cause[3].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.loc_alert_cause[3].q ),</pre>
<pre>    .qs     (loc_alert_cause_la3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_ctrl_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_ctrl_en_we & regen_qs),</pre>
<pre>    .wd     (classa_ctrl_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_ctrl.en.q ),</pre>
<pre>    .qs     (classa_ctrl_en_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_ctrl_lock (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_ctrl_lock_we & regen_qs),</pre>
<pre>    .wd     (classa_ctrl_lock_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_ctrl.lock.q ),</pre>
<pre>    .qs     (classa_ctrl_lock_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_ctrl_en_e0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_ctrl_en_e0_we & regen_qs),</pre>
<pre>    .wd     (classa_ctrl_en_e0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_ctrl.en_e0.q ),</pre>
<pre>    .qs     (classa_ctrl_en_e0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_ctrl_en_e1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_ctrl_en_e1_we & regen_qs),</pre>
<pre>    .wd     (classa_ctrl_en_e1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_ctrl.en_e1.q ),</pre>
<pre>    .qs     (classa_ctrl_en_e1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_ctrl_en_e2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_ctrl_en_e2_we & regen_qs),</pre>
<pre>    .wd     (classa_ctrl_en_e2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_ctrl.en_e2.q ),</pre>
<pre>    .qs     (classa_ctrl_en_e2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_ctrl_en_e3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_ctrl_en_e3_we & regen_qs),</pre>
<pre>    .wd     (classa_ctrl_en_e3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_ctrl.en_e3.q ),</pre>
<pre>    .qs     (classa_ctrl_en_e3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_ctrl_map_e0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_ctrl_map_e0_we & regen_qs),</pre>
<pre>    .wd     (classa_ctrl_map_e0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_ctrl.map_e0.q ),</pre>
<pre>    .qs     (classa_ctrl_map_e0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_ctrl_map_e1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_ctrl_map_e1_we & regen_qs),</pre>
<pre>    .wd     (classa_ctrl_map_e1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_ctrl.map_e1.q ),</pre>
<pre>    .qs     (classa_ctrl_map_e1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_ctrl_map_e2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_ctrl_map_e2_we & regen_qs),</pre>
<pre>    .wd     (classa_ctrl_map_e2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_ctrl.map_e2.q ),</pre>
<pre>    .qs     (classa_ctrl_map_e2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h3)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_ctrl_map_e3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_ctrl_map_e3_we & regen_qs),</pre>
<pre>    .wd     (classa_ctrl_map_e3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_ctrl.map_e3.q ),</pre>
<pre>    .qs     (classa_ctrl_map_e3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_clren (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_clren_we),</pre>
<pre>    .wd     (classa_clren_wd),</pre>
<pre>    .de     (hw2reg.classa_clren.de),</pre>
<pre>    .d      (hw2reg.classa_clren.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classa_clren_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_clr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_clr_we & classa_clren_qs),</pre>
<pre>    .wd     (classa_clr_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.classa_clr.qe),</pre>
<pre>    .q      (reg2hw.classa_clr.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_accum_cnt (</pre>
<pre>    .re     (classa_accum_cnt_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classa_accum_cnt.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classa_accum_cnt_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_accum_thresh (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_accum_thresh_we & regen_qs),</pre>
<pre>    .wd     (classa_accum_thresh_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_accum_thresh.q ),</pre>
<pre>    .qs     (classa_accum_thresh_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_timeout_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_timeout_cyc_we & regen_qs),</pre>
<pre>    .wd     (classa_timeout_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_timeout_cyc.q ),</pre>
<pre>    .qs     (classa_timeout_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_phase0_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_phase0_cyc_we & regen_qs),</pre>
<pre>    .wd     (classa_phase0_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_phase0_cyc.q ),</pre>
<pre>    .qs     (classa_phase0_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_phase1_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_phase1_cyc_we & regen_qs),</pre>
<pre>    .wd     (classa_phase1_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_phase1_cyc.q ),</pre>
<pre>    .qs     (classa_phase1_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_phase2_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_phase2_cyc_we & regen_qs),</pre>
<pre>    .wd     (classa_phase2_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_phase2_cyc.q ),</pre>
<pre>    .qs     (classa_phase2_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_phase3_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classa_phase3_cyc_we & regen_qs),</pre>
<pre>    .wd     (classa_phase3_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classa_phase3_cyc.q ),</pre>
<pre>    .qs     (classa_phase3_cyc_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_esc_cnt (</pre>
<pre>    .re     (classa_esc_cnt_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classa_esc_cnt.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classa_esc_cnt_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (3)</pre>
<pre style="background-color: #FF0000;">  ) u_classa_state (</pre>
<pre>    .re     (classa_state_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classa_state.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classa_state_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_ctrl_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_ctrl_en_we & regen_qs),</pre>
<pre>    .wd     (classb_ctrl_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_ctrl.en.q ),</pre>
<pre>    .qs     (classb_ctrl_en_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_ctrl_lock (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_ctrl_lock_we & regen_qs),</pre>
<pre>    .wd     (classb_ctrl_lock_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_ctrl.lock.q ),</pre>
<pre>    .qs     (classb_ctrl_lock_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_ctrl_en_e0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_ctrl_en_e0_we & regen_qs),</pre>
<pre>    .wd     (classb_ctrl_en_e0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_ctrl.en_e0.q ),</pre>
<pre>    .qs     (classb_ctrl_en_e0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_ctrl_en_e1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_ctrl_en_e1_we & regen_qs),</pre>
<pre>    .wd     (classb_ctrl_en_e1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_ctrl.en_e1.q ),</pre>
<pre>    .qs     (classb_ctrl_en_e1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_ctrl_en_e2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_ctrl_en_e2_we & regen_qs),</pre>
<pre>    .wd     (classb_ctrl_en_e2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_ctrl.en_e2.q ),</pre>
<pre>    .qs     (classb_ctrl_en_e2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_ctrl_en_e3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_ctrl_en_e3_we & regen_qs),</pre>
<pre>    .wd     (classb_ctrl_en_e3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_ctrl.en_e3.q ),</pre>
<pre>    .qs     (classb_ctrl_en_e3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_ctrl_map_e0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_ctrl_map_e0_we & regen_qs),</pre>
<pre>    .wd     (classb_ctrl_map_e0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_ctrl.map_e0.q ),</pre>
<pre>    .qs     (classb_ctrl_map_e0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_ctrl_map_e1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_ctrl_map_e1_we & regen_qs),</pre>
<pre>    .wd     (classb_ctrl_map_e1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_ctrl.map_e1.q ),</pre>
<pre>    .qs     (classb_ctrl_map_e1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_ctrl_map_e2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_ctrl_map_e2_we & regen_qs),</pre>
<pre>    .wd     (classb_ctrl_map_e2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_ctrl.map_e2.q ),</pre>
<pre>    .qs     (classb_ctrl_map_e2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h3)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_ctrl_map_e3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_ctrl_map_e3_we & regen_qs),</pre>
<pre>    .wd     (classb_ctrl_map_e3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_ctrl.map_e3.q ),</pre>
<pre>    .qs     (classb_ctrl_map_e3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_clren (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_clren_we),</pre>
<pre>    .wd     (classb_clren_wd),</pre>
<pre>    .de     (hw2reg.classb_clren.de),</pre>
<pre>    .d      (hw2reg.classb_clren.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classb_clren_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_clr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_clr_we & classb_clren_qs),</pre>
<pre>    .wd     (classb_clr_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.classb_clr.qe),</pre>
<pre>    .q      (reg2hw.classb_clr.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_accum_cnt (</pre>
<pre>    .re     (classb_accum_cnt_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classb_accum_cnt.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classb_accum_cnt_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_accum_thresh (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_accum_thresh_we & regen_qs),</pre>
<pre>    .wd     (classb_accum_thresh_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_accum_thresh.q ),</pre>
<pre>    .qs     (classb_accum_thresh_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_timeout_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_timeout_cyc_we & regen_qs),</pre>
<pre>    .wd     (classb_timeout_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_timeout_cyc.q ),</pre>
<pre>    .qs     (classb_timeout_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_phase0_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_phase0_cyc_we & regen_qs),</pre>
<pre>    .wd     (classb_phase0_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_phase0_cyc.q ),</pre>
<pre>    .qs     (classb_phase0_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_phase1_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_phase1_cyc_we & regen_qs),</pre>
<pre>    .wd     (classb_phase1_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_phase1_cyc.q ),</pre>
<pre>    .qs     (classb_phase1_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_phase2_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_phase2_cyc_we & regen_qs),</pre>
<pre>    .wd     (classb_phase2_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_phase2_cyc.q ),</pre>
<pre>    .qs     (classb_phase2_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_phase3_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classb_phase3_cyc_we & regen_qs),</pre>
<pre>    .wd     (classb_phase3_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classb_phase3_cyc.q ),</pre>
<pre>    .qs     (classb_phase3_cyc_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_esc_cnt (</pre>
<pre>    .re     (classb_esc_cnt_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classb_esc_cnt.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classb_esc_cnt_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (3)</pre>
<pre style="background-color: #FF0000;">  ) u_classb_state (</pre>
<pre>    .re     (classb_state_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classb_state.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classb_state_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_ctrl_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_ctrl_en_we & regen_qs),</pre>
<pre>    .wd     (classc_ctrl_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_ctrl.en.q ),</pre>
<pre>    .qs     (classc_ctrl_en_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_ctrl_lock (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_ctrl_lock_we & regen_qs),</pre>
<pre>    .wd     (classc_ctrl_lock_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_ctrl.lock.q ),</pre>
<pre>    .qs     (classc_ctrl_lock_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_ctrl_en_e0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_ctrl_en_e0_we & regen_qs),</pre>
<pre>    .wd     (classc_ctrl_en_e0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_ctrl.en_e0.q ),</pre>
<pre>    .qs     (classc_ctrl_en_e0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_ctrl_en_e1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_ctrl_en_e1_we & regen_qs),</pre>
<pre>    .wd     (classc_ctrl_en_e1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_ctrl.en_e1.q ),</pre>
<pre>    .qs     (classc_ctrl_en_e1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_ctrl_en_e2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_ctrl_en_e2_we & regen_qs),</pre>
<pre>    .wd     (classc_ctrl_en_e2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_ctrl.en_e2.q ),</pre>
<pre>    .qs     (classc_ctrl_en_e2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_ctrl_en_e3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_ctrl_en_e3_we & regen_qs),</pre>
<pre>    .wd     (classc_ctrl_en_e3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_ctrl.en_e3.q ),</pre>
<pre>    .qs     (classc_ctrl_en_e3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_ctrl_map_e0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_ctrl_map_e0_we & regen_qs),</pre>
<pre>    .wd     (classc_ctrl_map_e0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_ctrl.map_e0.q ),</pre>
<pre>    .qs     (classc_ctrl_map_e0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_ctrl_map_e1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_ctrl_map_e1_we & regen_qs),</pre>
<pre>    .wd     (classc_ctrl_map_e1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_ctrl.map_e1.q ),</pre>
<pre>    .qs     (classc_ctrl_map_e1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_ctrl_map_e2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_ctrl_map_e2_we & regen_qs),</pre>
<pre>    .wd     (classc_ctrl_map_e2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_ctrl.map_e2.q ),</pre>
<pre>    .qs     (classc_ctrl_map_e2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h3)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_ctrl_map_e3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_ctrl_map_e3_we & regen_qs),</pre>
<pre>    .wd     (classc_ctrl_map_e3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_ctrl.map_e3.q ),</pre>
<pre>    .qs     (classc_ctrl_map_e3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_clren (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_clren_we),</pre>
<pre>    .wd     (classc_clren_wd),</pre>
<pre>    .de     (hw2reg.classc_clren.de),</pre>
<pre>    .d      (hw2reg.classc_clren.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classc_clren_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_clr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_clr_we & classc_clren_qs),</pre>
<pre>    .wd     (classc_clr_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.classc_clr.qe),</pre>
<pre>    .q      (reg2hw.classc_clr.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_accum_cnt (</pre>
<pre>    .re     (classc_accum_cnt_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classc_accum_cnt.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classc_accum_cnt_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_accum_thresh (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_accum_thresh_we & regen_qs),</pre>
<pre>    .wd     (classc_accum_thresh_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_accum_thresh.q ),</pre>
<pre>    .qs     (classc_accum_thresh_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_timeout_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_timeout_cyc_we & regen_qs),</pre>
<pre>    .wd     (classc_timeout_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_timeout_cyc.q ),</pre>
<pre>    .qs     (classc_timeout_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_phase0_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_phase0_cyc_we & regen_qs),</pre>
<pre>    .wd     (classc_phase0_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_phase0_cyc.q ),</pre>
<pre>    .qs     (classc_phase0_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_phase1_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_phase1_cyc_we & regen_qs),</pre>
<pre>    .wd     (classc_phase1_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_phase1_cyc.q ),</pre>
<pre>    .qs     (classc_phase1_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_phase2_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_phase2_cyc_we & regen_qs),</pre>
<pre>    .wd     (classc_phase2_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_phase2_cyc.q ),</pre>
<pre>    .qs     (classc_phase2_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_phase3_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classc_phase3_cyc_we & regen_qs),</pre>
<pre>    .wd     (classc_phase3_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classc_phase3_cyc.q ),</pre>
<pre>    .qs     (classc_phase3_cyc_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_esc_cnt (</pre>
<pre>    .re     (classc_esc_cnt_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classc_esc_cnt.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classc_esc_cnt_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (3)</pre>
<pre style="background-color: #FF0000;">  ) u_classc_state (</pre>
<pre>    .re     (classc_state_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classc_state.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classc_state_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_ctrl_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_ctrl_en_we & regen_qs),</pre>
<pre>    .wd     (classd_ctrl_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_ctrl.en.q ),</pre>
<pre>    .qs     (classd_ctrl_en_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_ctrl_lock (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_ctrl_lock_we & regen_qs),</pre>
<pre>    .wd     (classd_ctrl_lock_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_ctrl.lock.q ),</pre>
<pre>    .qs     (classd_ctrl_lock_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_ctrl_en_e0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_ctrl_en_e0_we & regen_qs),</pre>
<pre>    .wd     (classd_ctrl_en_e0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_ctrl.en_e0.q ),</pre>
<pre>    .qs     (classd_ctrl_en_e0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_ctrl_en_e1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_ctrl_en_e1_we & regen_qs),</pre>
<pre>    .wd     (classd_ctrl_en_e1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_ctrl.en_e1.q ),</pre>
<pre>    .qs     (classd_ctrl_en_e1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_ctrl_en_e2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_ctrl_en_e2_we & regen_qs),</pre>
<pre>    .wd     (classd_ctrl_en_e2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_ctrl.en_e2.q ),</pre>
<pre>    .qs     (classd_ctrl_en_e2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_ctrl_en_e3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_ctrl_en_e3_we & regen_qs),</pre>
<pre>    .wd     (classd_ctrl_en_e3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_ctrl.en_e3.q ),</pre>
<pre>    .qs     (classd_ctrl_en_e3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_ctrl_map_e0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_ctrl_map_e0_we & regen_qs),</pre>
<pre>    .wd     (classd_ctrl_map_e0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_ctrl.map_e0.q ),</pre>
<pre>    .qs     (classd_ctrl_map_e0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_ctrl_map_e1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_ctrl_map_e1_we & regen_qs),</pre>
<pre>    .wd     (classd_ctrl_map_e1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_ctrl.map_e1.q ),</pre>
<pre>    .qs     (classd_ctrl_map_e1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_ctrl_map_e2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_ctrl_map_e2_we & regen_qs),</pre>
<pre>    .wd     (classd_ctrl_map_e2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_ctrl.map_e2.q ),</pre>
<pre>    .qs     (classd_ctrl_map_e2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h3)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_ctrl_map_e3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_ctrl_map_e3_we & regen_qs),</pre>
<pre>    .wd     (classd_ctrl_map_e3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_ctrl.map_e3.q ),</pre>
<pre>    .qs     (classd_ctrl_map_e3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_clren (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_clren_we),</pre>
<pre>    .wd     (classd_clren_wd),</pre>
<pre>    .de     (hw2reg.classd_clren.de),</pre>
<pre>    .d      (hw2reg.classd_clren.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classd_clren_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_clr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_clr_we & classd_clren_qs),</pre>
<pre>    .wd     (classd_clr_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.classd_clr.qe),</pre>
<pre>    .q      (reg2hw.classd_clr.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_accum_cnt (</pre>
<pre>    .re     (classd_accum_cnt_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classd_accum_cnt.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classd_accum_cnt_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_accum_thresh (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_accum_thresh_we & regen_qs),</pre>
<pre>    .wd     (classd_accum_thresh_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_accum_thresh.q ),</pre>
<pre>    .qs     (classd_accum_thresh_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_timeout_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_timeout_cyc_we & regen_qs),</pre>
<pre>    .wd     (classd_timeout_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_timeout_cyc.q ),</pre>
<pre>    .qs     (classd_timeout_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_phase0_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_phase0_cyc_we & regen_qs),</pre>
<pre>    .wd     (classd_phase0_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_phase0_cyc.q ),</pre>
<pre>    .qs     (classd_phase0_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_phase1_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_phase1_cyc_we & regen_qs),</pre>
<pre>    .wd     (classd_phase1_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_phase1_cyc.q ),</pre>
<pre>    .qs     (classd_phase1_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_phase2_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_phase2_cyc_we & regen_qs),</pre>
<pre>    .wd     (classd_phase2_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_phase2_cyc.q ),</pre>
<pre>    .qs     (classd_phase2_cyc_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_phase3_cyc (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (classd_phase3_cyc_we & regen_qs),</pre>
<pre>    .wd     (classd_phase3_cyc_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.classd_phase3_cyc.q ),</pre>
<pre>    .qs     (classd_phase3_cyc_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_esc_cnt (</pre>
<pre>    .re     (classd_esc_cnt_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classd_esc_cnt.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classd_esc_cnt_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (3)</pre>
<pre style="background-color: #FF0000;">  ) u_classd_state (</pre>
<pre>    .re     (classd_state_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.classd_state.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (classd_state_qs)</pre>
<pre>  logic [58:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[ 0] = (reg_addr == ALERT_HANDLER_INTR_STATE_OFFSET);</pre>
<pre>    addr_hit[ 1] = (reg_addr == ALERT_HANDLER_INTR_ENABLE_OFFSET);</pre>
<pre>    addr_hit[ 2] = (reg_addr == ALERT_HANDLER_INTR_TEST_OFFSET);</pre>
<pre>    addr_hit[ 3] = (reg_addr == ALERT_HANDLER_REGEN_OFFSET);</pre>
<pre>    addr_hit[ 4] = (reg_addr == ALERT_HANDLER_PING_TIMEOUT_CYC_OFFSET);</pre>
<pre>    addr_hit[ 5] = (reg_addr == ALERT_HANDLER_ALERT_EN_OFFSET);</pre>
<pre>    addr_hit[ 6] = (reg_addr == ALERT_HANDLER_ALERT_CLASS_OFFSET);</pre>
<pre>    addr_hit[ 7] = (reg_addr == ALERT_HANDLER_ALERT_CAUSE_OFFSET);</pre>
<pre>    addr_hit[ 8] = (reg_addr == ALERT_HANDLER_LOC_ALERT_EN_OFFSET);</pre>
<pre>    addr_hit[ 9] = (reg_addr == ALERT_HANDLER_LOC_ALERT_CLASS_OFFSET);</pre>
<pre>    addr_hit[10] = (reg_addr == ALERT_HANDLER_LOC_ALERT_CAUSE_OFFSET);</pre>
<pre>    addr_hit[11] = (reg_addr == ALERT_HANDLER_CLASSA_CTRL_OFFSET);</pre>
<pre>    addr_hit[12] = (reg_addr == ALERT_HANDLER_CLASSA_CLREN_OFFSET);</pre>
<pre>    addr_hit[13] = (reg_addr == ALERT_HANDLER_CLASSA_CLR_OFFSET);</pre>
<pre>    addr_hit[14] = (reg_addr == ALERT_HANDLER_CLASSA_ACCUM_CNT_OFFSET);</pre>
<pre>    addr_hit[15] = (reg_addr == ALERT_HANDLER_CLASSA_ACCUM_THRESH_OFFSET);</pre>
<pre>    addr_hit[16] = (reg_addr == ALERT_HANDLER_CLASSA_TIMEOUT_CYC_OFFSET);</pre>
<pre>    addr_hit[17] = (reg_addr == ALERT_HANDLER_CLASSA_PHASE0_CYC_OFFSET);</pre>
<pre>    addr_hit[18] = (reg_addr == ALERT_HANDLER_CLASSA_PHASE1_CYC_OFFSET);</pre>
<pre>    addr_hit[19] = (reg_addr == ALERT_HANDLER_CLASSA_PHASE2_CYC_OFFSET);</pre>
<pre>    addr_hit[20] = (reg_addr == ALERT_HANDLER_CLASSA_PHASE3_CYC_OFFSET);</pre>
<pre>    addr_hit[21] = (reg_addr == ALERT_HANDLER_CLASSA_ESC_CNT_OFFSET);</pre>
<pre>    addr_hit[22] = (reg_addr == ALERT_HANDLER_CLASSA_STATE_OFFSET);</pre>
<pre>    addr_hit[23] = (reg_addr == ALERT_HANDLER_CLASSB_CTRL_OFFSET);</pre>
<pre>    addr_hit[24] = (reg_addr == ALERT_HANDLER_CLASSB_CLREN_OFFSET);</pre>
<pre>    addr_hit[25] = (reg_addr == ALERT_HANDLER_CLASSB_CLR_OFFSET);</pre>
<pre>    addr_hit[26] = (reg_addr == ALERT_HANDLER_CLASSB_ACCUM_CNT_OFFSET);</pre>
<pre>    addr_hit[27] = (reg_addr == ALERT_HANDLER_CLASSB_ACCUM_THRESH_OFFSET);</pre>
<pre>    addr_hit[28] = (reg_addr == ALERT_HANDLER_CLASSB_TIMEOUT_CYC_OFFSET);</pre>
<pre>    addr_hit[29] = (reg_addr == ALERT_HANDLER_CLASSB_PHASE0_CYC_OFFSET);</pre>
<pre>    addr_hit[30] = (reg_addr == ALERT_HANDLER_CLASSB_PHASE1_CYC_OFFSET);</pre>
<pre>    addr_hit[31] = (reg_addr == ALERT_HANDLER_CLASSB_PHASE2_CYC_OFFSET);</pre>
<pre>    addr_hit[32] = (reg_addr == ALERT_HANDLER_CLASSB_PHASE3_CYC_OFFSET);</pre>
<pre>    addr_hit[33] = (reg_addr == ALERT_HANDLER_CLASSB_ESC_CNT_OFFSET);</pre>
<pre>    addr_hit[34] = (reg_addr == ALERT_HANDLER_CLASSB_STATE_OFFSET);</pre>
<pre>    addr_hit[35] = (reg_addr == ALERT_HANDLER_CLASSC_CTRL_OFFSET);</pre>
<pre>    addr_hit[36] = (reg_addr == ALERT_HANDLER_CLASSC_CLREN_OFFSET);</pre>
<pre>    addr_hit[37] = (reg_addr == ALERT_HANDLER_CLASSC_CLR_OFFSET);</pre>
<pre>    addr_hit[38] = (reg_addr == ALERT_HANDLER_CLASSC_ACCUM_CNT_OFFSET);</pre>
<pre>    addr_hit[39] = (reg_addr == ALERT_HANDLER_CLASSC_ACCUM_THRESH_OFFSET);</pre>
<pre>    addr_hit[40] = (reg_addr == ALERT_HANDLER_CLASSC_TIMEOUT_CYC_OFFSET);</pre>
<pre>    addr_hit[41] = (reg_addr == ALERT_HANDLER_CLASSC_PHASE0_CYC_OFFSET);</pre>
<pre>    addr_hit[42] = (reg_addr == ALERT_HANDLER_CLASSC_PHASE1_CYC_OFFSET);</pre>
<pre>    addr_hit[43] = (reg_addr == ALERT_HANDLER_CLASSC_PHASE2_CYC_OFFSET);</pre>
<pre>    addr_hit[44] = (reg_addr == ALERT_HANDLER_CLASSC_PHASE3_CYC_OFFSET);</pre>
<pre>    addr_hit[45] = (reg_addr == ALERT_HANDLER_CLASSC_ESC_CNT_OFFSET);</pre>
<pre>    addr_hit[46] = (reg_addr == ALERT_HANDLER_CLASSC_STATE_OFFSET);</pre>
<pre>    addr_hit[47] = (reg_addr == ALERT_HANDLER_CLASSD_CTRL_OFFSET);</pre>
<pre>    addr_hit[48] = (reg_addr == ALERT_HANDLER_CLASSD_CLREN_OFFSET);</pre>
<pre>    addr_hit[49] = (reg_addr == ALERT_HANDLER_CLASSD_CLR_OFFSET);</pre>
<pre>    addr_hit[50] = (reg_addr == ALERT_HANDLER_CLASSD_ACCUM_CNT_OFFSET);</pre>
<pre>    addr_hit[51] = (reg_addr == ALERT_HANDLER_CLASSD_ACCUM_THRESH_OFFSET);</pre>
<pre>    addr_hit[52] = (reg_addr == ALERT_HANDLER_CLASSD_TIMEOUT_CYC_OFFSET);</pre>
<pre>    addr_hit[53] = (reg_addr == ALERT_HANDLER_CLASSD_PHASE0_CYC_OFFSET);</pre>
<pre>    addr_hit[54] = (reg_addr == ALERT_HANDLER_CLASSD_PHASE1_CYC_OFFSET);</pre>
<pre>    addr_hit[55] = (reg_addr == ALERT_HANDLER_CLASSD_PHASE2_CYC_OFFSET);</pre>
<pre>    addr_hit[56] = (reg_addr == ALERT_HANDLER_CLASSD_PHASE3_CYC_OFFSET);</pre>
<pre>    addr_hit[57] = (reg_addr == ALERT_HANDLER_CLASSD_ESC_CNT_OFFSET);</pre>
<pre>    addr_hit[58] = (reg_addr == ALERT_HANDLER_CLASSD_STATE_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[ 0] && reg_we && (ALERT_HANDLER_PERMIT[ 0] != (ALERT_HANDLER_PERMIT[ 0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 1] && reg_we && (ALERT_HANDLER_PERMIT[ 1] != (ALERT_HANDLER_PERMIT[ 1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 2] && reg_we && (ALERT_HANDLER_PERMIT[ 2] != (ALERT_HANDLER_PERMIT[ 2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 3] && reg_we && (ALERT_HANDLER_PERMIT[ 3] != (ALERT_HANDLER_PERMIT[ 3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 4] && reg_we && (ALERT_HANDLER_PERMIT[ 4] != (ALERT_HANDLER_PERMIT[ 4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 5] && reg_we && (ALERT_HANDLER_PERMIT[ 5] != (ALERT_HANDLER_PERMIT[ 5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 6] && reg_we && (ALERT_HANDLER_PERMIT[ 6] != (ALERT_HANDLER_PERMIT[ 6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 7] && reg_we && (ALERT_HANDLER_PERMIT[ 7] != (ALERT_HANDLER_PERMIT[ 7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 8] && reg_we && (ALERT_HANDLER_PERMIT[ 8] != (ALERT_HANDLER_PERMIT[ 8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 9] && reg_we && (ALERT_HANDLER_PERMIT[ 9] != (ALERT_HANDLER_PERMIT[ 9] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[10] && reg_we && (ALERT_HANDLER_PERMIT[10] != (ALERT_HANDLER_PERMIT[10] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[11] && reg_we && (ALERT_HANDLER_PERMIT[11] != (ALERT_HANDLER_PERMIT[11] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[12] && reg_we && (ALERT_HANDLER_PERMIT[12] != (ALERT_HANDLER_PERMIT[12] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[13] && reg_we && (ALERT_HANDLER_PERMIT[13] != (ALERT_HANDLER_PERMIT[13] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[14] && reg_we && (ALERT_HANDLER_PERMIT[14] != (ALERT_HANDLER_PERMIT[14] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[15] && reg_we && (ALERT_HANDLER_PERMIT[15] != (ALERT_HANDLER_PERMIT[15] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[16] && reg_we && (ALERT_HANDLER_PERMIT[16] != (ALERT_HANDLER_PERMIT[16] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[17] && reg_we && (ALERT_HANDLER_PERMIT[17] != (ALERT_HANDLER_PERMIT[17] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[18] && reg_we && (ALERT_HANDLER_PERMIT[18] != (ALERT_HANDLER_PERMIT[18] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[19] && reg_we && (ALERT_HANDLER_PERMIT[19] != (ALERT_HANDLER_PERMIT[19] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[20] && reg_we && (ALERT_HANDLER_PERMIT[20] != (ALERT_HANDLER_PERMIT[20] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[21] && reg_we && (ALERT_HANDLER_PERMIT[21] != (ALERT_HANDLER_PERMIT[21] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[22] && reg_we && (ALERT_HANDLER_PERMIT[22] != (ALERT_HANDLER_PERMIT[22] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[23] && reg_we && (ALERT_HANDLER_PERMIT[23] != (ALERT_HANDLER_PERMIT[23] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[24] && reg_we && (ALERT_HANDLER_PERMIT[24] != (ALERT_HANDLER_PERMIT[24] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[25] && reg_we && (ALERT_HANDLER_PERMIT[25] != (ALERT_HANDLER_PERMIT[25] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[26] && reg_we && (ALERT_HANDLER_PERMIT[26] != (ALERT_HANDLER_PERMIT[26] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[27] && reg_we && (ALERT_HANDLER_PERMIT[27] != (ALERT_HANDLER_PERMIT[27] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[28] && reg_we && (ALERT_HANDLER_PERMIT[28] != (ALERT_HANDLER_PERMIT[28] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[29] && reg_we && (ALERT_HANDLER_PERMIT[29] != (ALERT_HANDLER_PERMIT[29] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[30] && reg_we && (ALERT_HANDLER_PERMIT[30] != (ALERT_HANDLER_PERMIT[30] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[31] && reg_we && (ALERT_HANDLER_PERMIT[31] != (ALERT_HANDLER_PERMIT[31] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[32] && reg_we && (ALERT_HANDLER_PERMIT[32] != (ALERT_HANDLER_PERMIT[32] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[33] && reg_we && (ALERT_HANDLER_PERMIT[33] != (ALERT_HANDLER_PERMIT[33] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[34] && reg_we && (ALERT_HANDLER_PERMIT[34] != (ALERT_HANDLER_PERMIT[34] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[35] && reg_we && (ALERT_HANDLER_PERMIT[35] != (ALERT_HANDLER_PERMIT[35] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[36] && reg_we && (ALERT_HANDLER_PERMIT[36] != (ALERT_HANDLER_PERMIT[36] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[37] && reg_we && (ALERT_HANDLER_PERMIT[37] != (ALERT_HANDLER_PERMIT[37] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[38] && reg_we && (ALERT_HANDLER_PERMIT[38] != (ALERT_HANDLER_PERMIT[38] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[39] && reg_we && (ALERT_HANDLER_PERMIT[39] != (ALERT_HANDLER_PERMIT[39] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[40] && reg_we && (ALERT_HANDLER_PERMIT[40] != (ALERT_HANDLER_PERMIT[40] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[41] && reg_we && (ALERT_HANDLER_PERMIT[41] != (ALERT_HANDLER_PERMIT[41] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[42] && reg_we && (ALERT_HANDLER_PERMIT[42] != (ALERT_HANDLER_PERMIT[42] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[43] && reg_we && (ALERT_HANDLER_PERMIT[43] != (ALERT_HANDLER_PERMIT[43] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[44] && reg_we && (ALERT_HANDLER_PERMIT[44] != (ALERT_HANDLER_PERMIT[44] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[45] && reg_we && (ALERT_HANDLER_PERMIT[45] != (ALERT_HANDLER_PERMIT[45] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[46] && reg_we && (ALERT_HANDLER_PERMIT[46] != (ALERT_HANDLER_PERMIT[46] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[47] && reg_we && (ALERT_HANDLER_PERMIT[47] != (ALERT_HANDLER_PERMIT[47] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[48] && reg_we && (ALERT_HANDLER_PERMIT[48] != (ALERT_HANDLER_PERMIT[48] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[49] && reg_we && (ALERT_HANDLER_PERMIT[49] != (ALERT_HANDLER_PERMIT[49] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[50] && reg_we && (ALERT_HANDLER_PERMIT[50] != (ALERT_HANDLER_PERMIT[50] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[51] && reg_we && (ALERT_HANDLER_PERMIT[51] != (ALERT_HANDLER_PERMIT[51] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[52] && reg_we && (ALERT_HANDLER_PERMIT[52] != (ALERT_HANDLER_PERMIT[52] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[53] && reg_we && (ALERT_HANDLER_PERMIT[53] != (ALERT_HANDLER_PERMIT[53] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[54] && reg_we && (ALERT_HANDLER_PERMIT[54] != (ALERT_HANDLER_PERMIT[54] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[55] && reg_we && (ALERT_HANDLER_PERMIT[55] != (ALERT_HANDLER_PERMIT[55] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[56] && reg_we && (ALERT_HANDLER_PERMIT[56] != (ALERT_HANDLER_PERMIT[56] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[57] && reg_we && (ALERT_HANDLER_PERMIT[57] != (ALERT_HANDLER_PERMIT[57] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[58] && reg_we && (ALERT_HANDLER_PERMIT[58] != (ALERT_HANDLER_PERMIT[58] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign intr_state_classa_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_classa_wd = reg_wdata[0];</pre>
<pre>  assign intr_state_classb_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_classb_wd = reg_wdata[1];</pre>
<pre>  assign intr_state_classc_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_classc_wd = reg_wdata[2];</pre>
<pre>  assign intr_state_classd_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_classd_wd = reg_wdata[3];</pre>
<pre>  assign intr_enable_classa_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_classa_wd = reg_wdata[0];</pre>
<pre>  assign intr_enable_classb_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_classb_wd = reg_wdata[1];</pre>
<pre>  assign intr_enable_classc_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_classc_wd = reg_wdata[2];</pre>
<pre>  assign intr_enable_classd_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_classd_wd = reg_wdata[3];</pre>
<pre>  assign intr_test_classa_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_classa_wd = reg_wdata[0];</pre>
<pre>  assign intr_test_classb_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_classb_wd = reg_wdata[1];</pre>
<pre>  assign intr_test_classc_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_classc_wd = reg_wdata[2];</pre>
<pre>  assign intr_test_classd_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_classd_wd = reg_wdata[3];</pre>
<pre>  assign regen_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign regen_wd = reg_wdata[0];</pre>
<pre>  assign ping_timeout_cyc_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign ping_timeout_cyc_wd = reg_wdata[23:0];</pre>
<pre>  assign alert_en_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign alert_en_wd = reg_wdata[0];</pre>
<pre>  assign alert_class_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign alert_class_wd = reg_wdata[1:0];</pre>
<pre>  assign alert_cause_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign alert_cause_wd = reg_wdata[0];</pre>
<pre>  assign loc_alert_en_en_la0_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_en_en_la0_wd = reg_wdata[0];</pre>
<pre>  assign loc_alert_en_en_la1_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_en_en_la1_wd = reg_wdata[1];</pre>
<pre>  assign loc_alert_en_en_la2_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_en_en_la2_wd = reg_wdata[2];</pre>
<pre>  assign loc_alert_en_en_la3_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_en_en_la3_wd = reg_wdata[3];</pre>
<pre>  assign loc_alert_class_class_la0_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_class_class_la0_wd = reg_wdata[1:0];</pre>
<pre>  assign loc_alert_class_class_la1_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_class_class_la1_wd = reg_wdata[3:2];</pre>
<pre>  assign loc_alert_class_class_la2_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_class_class_la2_wd = reg_wdata[5:4];</pre>
<pre>  assign loc_alert_class_class_la3_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_class_class_la3_wd = reg_wdata[7:6];</pre>
<pre>  assign loc_alert_cause_la0_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_cause_la0_wd = reg_wdata[0];</pre>
<pre>  assign loc_alert_cause_la1_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_cause_la1_wd = reg_wdata[1];</pre>
<pre>  assign loc_alert_cause_la2_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_cause_la2_wd = reg_wdata[2];</pre>
<pre>  assign loc_alert_cause_la3_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign loc_alert_cause_la3_wd = reg_wdata[3];</pre>
<pre>  assign classa_ctrl_en_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign classa_ctrl_en_wd = reg_wdata[0];</pre>
<pre>  assign classa_ctrl_lock_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign classa_ctrl_lock_wd = reg_wdata[1];</pre>
<pre>  assign classa_ctrl_en_e0_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign classa_ctrl_en_e0_wd = reg_wdata[2];</pre>
<pre>  assign classa_ctrl_en_e1_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign classa_ctrl_en_e1_wd = reg_wdata[3];</pre>
<pre>  assign classa_ctrl_en_e2_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign classa_ctrl_en_e2_wd = reg_wdata[4];</pre>
<pre>  assign classa_ctrl_en_e3_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign classa_ctrl_en_e3_wd = reg_wdata[5];</pre>
<pre>  assign classa_ctrl_map_e0_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign classa_ctrl_map_e0_wd = reg_wdata[7:6];</pre>
<pre>  assign classa_ctrl_map_e1_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign classa_ctrl_map_e1_wd = reg_wdata[9:8];</pre>
<pre>  assign classa_ctrl_map_e2_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign classa_ctrl_map_e2_wd = reg_wdata[11:10];</pre>
<pre>  assign classa_ctrl_map_e3_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign classa_ctrl_map_e3_wd = reg_wdata[13:12];</pre>
<pre>  assign classa_clren_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign classa_clren_wd = reg_wdata[0];</pre>
<pre>  assign classa_clr_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign classa_clr_wd = reg_wdata[0];</pre>
<pre>  assign classa_accum_cnt_re = addr_hit[14] && reg_re;</pre>
<pre>  assign classa_accum_thresh_we = addr_hit[15] & reg_we & ~wr_err;</pre>
<pre>  assign classa_accum_thresh_wd = reg_wdata[15:0];</pre>
<pre>  assign classa_timeout_cyc_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign classa_timeout_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classa_phase0_cyc_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign classa_phase0_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classa_phase1_cyc_we = addr_hit[18] & reg_we & ~wr_err;</pre>
<pre>  assign classa_phase1_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classa_phase2_cyc_we = addr_hit[19] & reg_we & ~wr_err;</pre>
<pre>  assign classa_phase2_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classa_phase3_cyc_we = addr_hit[20] & reg_we & ~wr_err;</pre>
<pre>  assign classa_phase3_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classa_esc_cnt_re = addr_hit[21] && reg_re;</pre>
<pre>  assign classa_state_re = addr_hit[22] && reg_re;</pre>
<pre>  assign classb_ctrl_en_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign classb_ctrl_en_wd = reg_wdata[0];</pre>
<pre>  assign classb_ctrl_lock_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign classb_ctrl_lock_wd = reg_wdata[1];</pre>
<pre>  assign classb_ctrl_en_e0_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign classb_ctrl_en_e0_wd = reg_wdata[2];</pre>
<pre>  assign classb_ctrl_en_e1_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign classb_ctrl_en_e1_wd = reg_wdata[3];</pre>
<pre>  assign classb_ctrl_en_e2_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign classb_ctrl_en_e2_wd = reg_wdata[4];</pre>
<pre>  assign classb_ctrl_en_e3_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign classb_ctrl_en_e3_wd = reg_wdata[5];</pre>
<pre>  assign classb_ctrl_map_e0_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign classb_ctrl_map_e0_wd = reg_wdata[7:6];</pre>
<pre>  assign classb_ctrl_map_e1_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign classb_ctrl_map_e1_wd = reg_wdata[9:8];</pre>
<pre>  assign classb_ctrl_map_e2_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign classb_ctrl_map_e2_wd = reg_wdata[11:10];</pre>
<pre>  assign classb_ctrl_map_e3_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign classb_ctrl_map_e3_wd = reg_wdata[13:12];</pre>
<pre>  assign classb_clren_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign classb_clren_wd = reg_wdata[0];</pre>
<pre>  assign classb_clr_we = addr_hit[25] & reg_we & ~wr_err;</pre>
<pre>  assign classb_clr_wd = reg_wdata[0];</pre>
<pre>  assign classb_accum_cnt_re = addr_hit[26] && reg_re;</pre>
<pre>  assign classb_accum_thresh_we = addr_hit[27] & reg_we & ~wr_err;</pre>
<pre>  assign classb_accum_thresh_wd = reg_wdata[15:0];</pre>
<pre>  assign classb_timeout_cyc_we = addr_hit[28] & reg_we & ~wr_err;</pre>
<pre>  assign classb_timeout_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classb_phase0_cyc_we = addr_hit[29] & reg_we & ~wr_err;</pre>
<pre>  assign classb_phase0_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classb_phase1_cyc_we = addr_hit[30] & reg_we & ~wr_err;</pre>
<pre>  assign classb_phase1_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classb_phase2_cyc_we = addr_hit[31] & reg_we & ~wr_err;</pre>
<pre>  assign classb_phase2_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classb_phase3_cyc_we = addr_hit[32] & reg_we & ~wr_err;</pre>
<pre>  assign classb_phase3_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classb_esc_cnt_re = addr_hit[33] && reg_re;</pre>
<pre>  assign classb_state_re = addr_hit[34] && reg_re;</pre>
<pre>  assign classc_ctrl_en_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign classc_ctrl_en_wd = reg_wdata[0];</pre>
<pre>  assign classc_ctrl_lock_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign classc_ctrl_lock_wd = reg_wdata[1];</pre>
<pre>  assign classc_ctrl_en_e0_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign classc_ctrl_en_e0_wd = reg_wdata[2];</pre>
<pre>  assign classc_ctrl_en_e1_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign classc_ctrl_en_e1_wd = reg_wdata[3];</pre>
<pre>  assign classc_ctrl_en_e2_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign classc_ctrl_en_e2_wd = reg_wdata[4];</pre>
<pre>  assign classc_ctrl_en_e3_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign classc_ctrl_en_e3_wd = reg_wdata[5];</pre>
<pre>  assign classc_ctrl_map_e0_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign classc_ctrl_map_e0_wd = reg_wdata[7:6];</pre>
<pre>  assign classc_ctrl_map_e1_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign classc_ctrl_map_e1_wd = reg_wdata[9:8];</pre>
<pre>  assign classc_ctrl_map_e2_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign classc_ctrl_map_e2_wd = reg_wdata[11:10];</pre>
<pre>  assign classc_ctrl_map_e3_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign classc_ctrl_map_e3_wd = reg_wdata[13:12];</pre>
<pre>  assign classc_clren_we = addr_hit[36] & reg_we & ~wr_err;</pre>
<pre>  assign classc_clren_wd = reg_wdata[0];</pre>
<pre>  assign classc_clr_we = addr_hit[37] & reg_we & ~wr_err;</pre>
<pre>  assign classc_clr_wd = reg_wdata[0];</pre>
<pre>  assign classc_accum_cnt_re = addr_hit[38] && reg_re;</pre>
<pre>  assign classc_accum_thresh_we = addr_hit[39] & reg_we & ~wr_err;</pre>
<pre>  assign classc_accum_thresh_wd = reg_wdata[15:0];</pre>
<pre>  assign classc_timeout_cyc_we = addr_hit[40] & reg_we & ~wr_err;</pre>
<pre>  assign classc_timeout_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classc_phase0_cyc_we = addr_hit[41] & reg_we & ~wr_err;</pre>
<pre>  assign classc_phase0_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classc_phase1_cyc_we = addr_hit[42] & reg_we & ~wr_err;</pre>
<pre>  assign classc_phase1_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classc_phase2_cyc_we = addr_hit[43] & reg_we & ~wr_err;</pre>
<pre>  assign classc_phase2_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classc_phase3_cyc_we = addr_hit[44] & reg_we & ~wr_err;</pre>
<pre>  assign classc_phase3_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classc_esc_cnt_re = addr_hit[45] && reg_re;</pre>
<pre>  assign classc_state_re = addr_hit[46] && reg_re;</pre>
<pre>  assign classd_ctrl_en_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign classd_ctrl_en_wd = reg_wdata[0];</pre>
<pre>  assign classd_ctrl_lock_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign classd_ctrl_lock_wd = reg_wdata[1];</pre>
<pre>  assign classd_ctrl_en_e0_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign classd_ctrl_en_e0_wd = reg_wdata[2];</pre>
<pre>  assign classd_ctrl_en_e1_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign classd_ctrl_en_e1_wd = reg_wdata[3];</pre>
<pre>  assign classd_ctrl_en_e2_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign classd_ctrl_en_e2_wd = reg_wdata[4];</pre>
<pre>  assign classd_ctrl_en_e3_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign classd_ctrl_en_e3_wd = reg_wdata[5];</pre>
<pre>  assign classd_ctrl_map_e0_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign classd_ctrl_map_e0_wd = reg_wdata[7:6];</pre>
<pre>  assign classd_ctrl_map_e1_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign classd_ctrl_map_e1_wd = reg_wdata[9:8];</pre>
<pre>  assign classd_ctrl_map_e2_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign classd_ctrl_map_e2_wd = reg_wdata[11:10];</pre>
<pre>  assign classd_ctrl_map_e3_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign classd_ctrl_map_e3_wd = reg_wdata[13:12];</pre>
<pre>  assign classd_clren_we = addr_hit[48] & reg_we & ~wr_err;</pre>
<pre>  assign classd_clren_wd = reg_wdata[0];</pre>
<pre>  assign classd_clr_we = addr_hit[49] & reg_we & ~wr_err;</pre>
<pre>  assign classd_clr_wd = reg_wdata[0];</pre>
<pre>  assign classd_accum_cnt_re = addr_hit[50] && reg_re;</pre>
<pre>  assign classd_accum_thresh_we = addr_hit[51] & reg_we & ~wr_err;</pre>
<pre>  assign classd_accum_thresh_wd = reg_wdata[15:0];</pre>
<pre>  assign classd_timeout_cyc_we = addr_hit[52] & reg_we & ~wr_err;</pre>
<pre>  assign classd_timeout_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classd_phase0_cyc_we = addr_hit[53] & reg_we & ~wr_err;</pre>
<pre>  assign classd_phase0_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classd_phase1_cyc_we = addr_hit[54] & reg_we & ~wr_err;</pre>
<pre>  assign classd_phase1_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classd_phase2_cyc_we = addr_hit[55] & reg_we & ~wr_err;</pre>
<pre>  assign classd_phase2_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classd_phase3_cyc_we = addr_hit[56] & reg_we & ~wr_err;</pre>
<pre>  assign classd_phase3_cyc_wd = reg_wdata[31:0];</pre>
<pre>  assign classd_esc_cnt_re = addr_hit[57] && reg_re;</pre>
<pre>  assign classd_state_re = addr_hit[58] && reg_re;</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[0] = intr_state_classa_qs;</pre>
<pre>        reg_rdata_next[1] = intr_state_classb_qs;</pre>
<pre>        reg_rdata_next[2] = intr_state_classc_qs;</pre>
<pre>        reg_rdata_next[3] = intr_state_classd_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[0] = intr_enable_classa_qs;</pre>
<pre>        reg_rdata_next[1] = intr_enable_classb_qs;</pre>
<pre>        reg_rdata_next[2] = intr_enable_classc_qs;</pre>
<pre>        reg_rdata_next[3] = intr_enable_classd_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>        reg_rdata_next[2] = '0;</pre>
<pre>        reg_rdata_next[3] = '0;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[0] = regen_qs;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[23:0] = ping_timeout_cyc_qs;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[0] = alert_en_qs;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[1:0] = alert_class_qs;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[0] = alert_cause_qs;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[0] = loc_alert_en_en_la0_qs;</pre>
<pre>        reg_rdata_next[1] = loc_alert_en_en_la1_qs;</pre>
<pre>        reg_rdata_next[2] = loc_alert_en_en_la2_qs;</pre>
<pre>        reg_rdata_next[3] = loc_alert_en_en_la3_qs;</pre>
<pre>      addr_hit[9]: begin</pre>
<pre>        reg_rdata_next[1:0] = loc_alert_class_class_la0_qs;</pre>
<pre>        reg_rdata_next[3:2] = loc_alert_class_class_la1_qs;</pre>
<pre>        reg_rdata_next[5:4] = loc_alert_class_class_la2_qs;</pre>
<pre>        reg_rdata_next[7:6] = loc_alert_class_class_la3_qs;</pre>
<pre>      addr_hit[10]: begin</pre>
<pre>        reg_rdata_next[0] = loc_alert_cause_la0_qs;</pre>
<pre>        reg_rdata_next[1] = loc_alert_cause_la1_qs;</pre>
<pre>        reg_rdata_next[2] = loc_alert_cause_la2_qs;</pre>
<pre>        reg_rdata_next[3] = loc_alert_cause_la3_qs;</pre>
<pre>      addr_hit[11]: begin</pre>
<pre>        reg_rdata_next[0] = classa_ctrl_en_qs;</pre>
<pre>        reg_rdata_next[1] = classa_ctrl_lock_qs;</pre>
<pre>        reg_rdata_next[2] = classa_ctrl_en_e0_qs;</pre>
<pre>        reg_rdata_next[3] = classa_ctrl_en_e1_qs;</pre>
<pre>        reg_rdata_next[4] = classa_ctrl_en_e2_qs;</pre>
<pre>        reg_rdata_next[5] = classa_ctrl_en_e3_qs;</pre>
<pre>        reg_rdata_next[7:6] = classa_ctrl_map_e0_qs;</pre>
<pre>        reg_rdata_next[9:8] = classa_ctrl_map_e1_qs;</pre>
<pre>        reg_rdata_next[11:10] = classa_ctrl_map_e2_qs;</pre>
<pre>        reg_rdata_next[13:12] = classa_ctrl_map_e3_qs;</pre>
<pre>      addr_hit[12]: begin</pre>
<pre>        reg_rdata_next[0] = classa_clren_qs;</pre>
<pre>      addr_hit[13]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>      addr_hit[14]: begin</pre>
<pre>        reg_rdata_next[15:0] = classa_accum_cnt_qs;</pre>
<pre>      addr_hit[15]: begin</pre>
<pre>        reg_rdata_next[15:0] = classa_accum_thresh_qs;</pre>
<pre>      addr_hit[16]: begin</pre>
<pre>        reg_rdata_next[31:0] = classa_timeout_cyc_qs;</pre>
<pre>      addr_hit[17]: begin</pre>
<pre>        reg_rdata_next[31:0] = classa_phase0_cyc_qs;</pre>
<pre>      addr_hit[18]: begin</pre>
<pre>        reg_rdata_next[31:0] = classa_phase1_cyc_qs;</pre>
<pre>      addr_hit[19]: begin</pre>
<pre>        reg_rdata_next[31:0] = classa_phase2_cyc_qs;</pre>
<pre>      addr_hit[20]: begin</pre>
<pre>        reg_rdata_next[31:0] = classa_phase3_cyc_qs;</pre>
<pre>      addr_hit[21]: begin</pre>
<pre>        reg_rdata_next[31:0] = classa_esc_cnt_qs;</pre>
<pre>      addr_hit[22]: begin</pre>
<pre>        reg_rdata_next[2:0] = classa_state_qs;</pre>
<pre>      addr_hit[23]: begin</pre>
<pre>        reg_rdata_next[0] = classb_ctrl_en_qs;</pre>
<pre>        reg_rdata_next[1] = classb_ctrl_lock_qs;</pre>
<pre>        reg_rdata_next[2] = classb_ctrl_en_e0_qs;</pre>
<pre>        reg_rdata_next[3] = classb_ctrl_en_e1_qs;</pre>
<pre>        reg_rdata_next[4] = classb_ctrl_en_e2_qs;</pre>
<pre>        reg_rdata_next[5] = classb_ctrl_en_e3_qs;</pre>
<pre>        reg_rdata_next[7:6] = classb_ctrl_map_e0_qs;</pre>
<pre>        reg_rdata_next[9:8] = classb_ctrl_map_e1_qs;</pre>
<pre>        reg_rdata_next[11:10] = classb_ctrl_map_e2_qs;</pre>
<pre>        reg_rdata_next[13:12] = classb_ctrl_map_e3_qs;</pre>
<pre>      addr_hit[24]: begin</pre>
<pre>        reg_rdata_next[0] = classb_clren_qs;</pre>
<pre>      addr_hit[25]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>      addr_hit[26]: begin</pre>
<pre>        reg_rdata_next[15:0] = classb_accum_cnt_qs;</pre>
<pre>      addr_hit[27]: begin</pre>
<pre>        reg_rdata_next[15:0] = classb_accum_thresh_qs;</pre>
<pre>      addr_hit[28]: begin</pre>
<pre>        reg_rdata_next[31:0] = classb_timeout_cyc_qs;</pre>
<pre>      addr_hit[29]: begin</pre>
<pre>        reg_rdata_next[31:0] = classb_phase0_cyc_qs;</pre>
<pre>      addr_hit[30]: begin</pre>
<pre>        reg_rdata_next[31:0] = classb_phase1_cyc_qs;</pre>
<pre>      addr_hit[31]: begin</pre>
<pre>        reg_rdata_next[31:0] = classb_phase2_cyc_qs;</pre>
<pre>      addr_hit[32]: begin</pre>
<pre>        reg_rdata_next[31:0] = classb_phase3_cyc_qs;</pre>
<pre>      addr_hit[33]: begin</pre>
<pre>        reg_rdata_next[31:0] = classb_esc_cnt_qs;</pre>
<pre>      addr_hit[34]: begin</pre>
<pre>        reg_rdata_next[2:0] = classb_state_qs;</pre>
<pre>      addr_hit[35]: begin</pre>
<pre>        reg_rdata_next[0] = classc_ctrl_en_qs;</pre>
<pre>        reg_rdata_next[1] = classc_ctrl_lock_qs;</pre>
<pre>        reg_rdata_next[2] = classc_ctrl_en_e0_qs;</pre>
<pre>        reg_rdata_next[3] = classc_ctrl_en_e1_qs;</pre>
<pre>        reg_rdata_next[4] = classc_ctrl_en_e2_qs;</pre>
<pre>        reg_rdata_next[5] = classc_ctrl_en_e3_qs;</pre>
<pre>        reg_rdata_next[7:6] = classc_ctrl_map_e0_qs;</pre>
<pre>        reg_rdata_next[9:8] = classc_ctrl_map_e1_qs;</pre>
<pre>        reg_rdata_next[11:10] = classc_ctrl_map_e2_qs;</pre>
<pre>        reg_rdata_next[13:12] = classc_ctrl_map_e3_qs;</pre>
<pre>      addr_hit[36]: begin</pre>
<pre>        reg_rdata_next[0] = classc_clren_qs;</pre>
<pre>      addr_hit[37]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>      addr_hit[38]: begin</pre>
<pre>        reg_rdata_next[15:0] = classc_accum_cnt_qs;</pre>
<pre>      addr_hit[39]: begin</pre>
<pre>        reg_rdata_next[15:0] = classc_accum_thresh_qs;</pre>
<pre>      addr_hit[40]: begin</pre>
<pre>        reg_rdata_next[31:0] = classc_timeout_cyc_qs;</pre>
<pre>      addr_hit[41]: begin</pre>
<pre>        reg_rdata_next[31:0] = classc_phase0_cyc_qs;</pre>
<pre>      addr_hit[42]: begin</pre>
<pre>        reg_rdata_next[31:0] = classc_phase1_cyc_qs;</pre>
<pre>      addr_hit[43]: begin</pre>
<pre>        reg_rdata_next[31:0] = classc_phase2_cyc_qs;</pre>
<pre>      addr_hit[44]: begin</pre>
<pre>        reg_rdata_next[31:0] = classc_phase3_cyc_qs;</pre>
<pre>      addr_hit[45]: begin</pre>
<pre>        reg_rdata_next[31:0] = classc_esc_cnt_qs;</pre>
<pre>      addr_hit[46]: begin</pre>
<pre>        reg_rdata_next[2:0] = classc_state_qs;</pre>
<pre>      addr_hit[47]: begin</pre>
<pre>        reg_rdata_next[0] = classd_ctrl_en_qs;</pre>
<pre>        reg_rdata_next[1] = classd_ctrl_lock_qs;</pre>
<pre>        reg_rdata_next[2] = classd_ctrl_en_e0_qs;</pre>
<pre>        reg_rdata_next[3] = classd_ctrl_en_e1_qs;</pre>
<pre>        reg_rdata_next[4] = classd_ctrl_en_e2_qs;</pre>
<pre>        reg_rdata_next[5] = classd_ctrl_en_e3_qs;</pre>
<pre>        reg_rdata_next[7:6] = classd_ctrl_map_e0_qs;</pre>
<pre>        reg_rdata_next[9:8] = classd_ctrl_map_e1_qs;</pre>
<pre>        reg_rdata_next[11:10] = classd_ctrl_map_e2_qs;</pre>
<pre>        reg_rdata_next[13:12] = classd_ctrl_map_e3_qs;</pre>
<pre>      addr_hit[48]: begin</pre>
<pre>        reg_rdata_next[0] = classd_clren_qs;</pre>
<pre>      addr_hit[49]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>      addr_hit[50]: begin</pre>
<pre>        reg_rdata_next[15:0] = classd_accum_cnt_qs;</pre>
<pre>      addr_hit[51]: begin</pre>
<pre>        reg_rdata_next[15:0] = classd_accum_thresh_qs;</pre>
<pre>      addr_hit[52]: begin</pre>
<pre>        reg_rdata_next[31:0] = classd_timeout_cyc_qs;</pre>
<pre>      addr_hit[53]: begin</pre>
<pre>        reg_rdata_next[31:0] = classd_phase0_cyc_qs;</pre>
<pre>      addr_hit[54]: begin</pre>
<pre>        reg_rdata_next[31:0] = classd_phase1_cyc_qs;</pre>
<pre>      addr_hit[55]: begin</pre>
<pre>        reg_rdata_next[31:0] = classd_phase2_cyc_qs;</pre>
<pre>      addr_hit[56]: begin</pre>
<pre>        reg_rdata_next[31:0] = classd_phase3_cyc_qs;</pre>
<pre>      addr_hit[57]: begin</pre>
<pre>        reg_rdata_next[31:0] = classd_esc_cnt_qs;</pre>
<pre>      addr_hit[58]: begin</pre>
<pre>        reg_rdata_next[2:0] = classd_state_qs;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/top_earlgrey/ip/rv_plic/rtl/autogen/rv_plic.sv</h3>
<pre>module rv_plic import rv_plic_reg_pkg::*; #(</pre>
<pre>  localparam int SRCW    = $clog2(NumSrc+1)</pre>
<pre>  input     clk_i,</pre>
<pre>  input     rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  input  [NumSrc-1:0] intr_src_i,</pre>
<pre>  output [NumTarget-1:0] irq_o,</pre>
<pre>  output [SRCW-1:0]      irq_id_o [NumTarget],</pre>
<pre>  output logic [NumTarget-1:0] msip_o</pre>
<pre>  rv_plic_reg2hw_t reg2hw;</pre>
<pre>  rv_plic_hw2reg_t hw2reg;</pre>
<pre>  localparam int MAX_PRIO    = 3;</pre>
<pre>  localparam int PRIOW = $clog2(MAX_PRIO+1);</pre>
<pre>  logic [NumSrc-1:0] le; // 0:level 1:edge</pre>
<pre>  logic [NumSrc-1:0] ip;</pre>
<pre>  logic [NumSrc-1:0] ie [NumTarget];</pre>
<pre>  logic [NumTarget-1:0] claim_re; // Target read indicator</pre>
<pre>  logic [SRCW-1:0]      claim_id [NumTarget];</pre>
<pre>  logic [NumSrc-1:0]    claim; // Converted from claim_re/claim_id</pre>
<pre>  logic [NumTarget-1:0] complete_we; // Target write indicator</pre>
<pre>  logic [SRCW-1:0]      complete_id [NumTarget];</pre>
<pre>  logic [NumSrc-1:0]    complete; // Converted from complete_re/complete_id</pre>
<pre>  logic [SRCW-1:0]      cc_id [NumTarget]; // Write ID</pre>
<pre>  logic [PRIOW-1:0] prio [NumSrc];</pre>
<pre>  logic [PRIOW-1:0] threshold [NumTarget];</pre>
<pre>  assign cc_id = irq_id_o;</pre>
<pre>  always_comb begin</pre>
<pre>    claim = '0;</pre>
<pre>    for (int i = 0 ; i < NumTarget ; i++) begin</pre>
<pre>      if (claim_re[i]) claim[claim_id[i] -1] = 1'b1;</pre>
<pre>  always_comb begin</pre>
<pre>    complete = '0;</pre>
<pre>    for (int i = 0 ; i < NumTarget ; i++) begin</pre>
<pre>      if (complete_we[i]) complete[complete_id[i] -1] = 1'b1;</pre>
<pre>  assign prio[1] = reg2hw.prio1.q;</pre>
<pre>  assign prio[2] = reg2hw.prio2.q;</pre>
<pre>  assign prio[3] = reg2hw.prio3.q;</pre>
<pre>  assign prio[4] = reg2hw.prio4.q;</pre>
<pre>  assign prio[5] = reg2hw.prio5.q;</pre>
<pre>  assign prio[6] = reg2hw.prio6.q;</pre>
<pre>  assign prio[7] = reg2hw.prio7.q;</pre>
<pre>  assign prio[8] = reg2hw.prio8.q;</pre>
<pre>  assign prio[9] = reg2hw.prio9.q;</pre>
<pre>  assign prio[10] = reg2hw.prio10.q;</pre>
<pre>  assign prio[11] = reg2hw.prio11.q;</pre>
<pre>  assign prio[12] = reg2hw.prio12.q;</pre>
<pre>  assign prio[13] = reg2hw.prio13.q;</pre>
<pre>  assign prio[14] = reg2hw.prio14.q;</pre>
<pre>  assign prio[15] = reg2hw.prio15.q;</pre>
<pre>  assign prio[16] = reg2hw.prio16.q;</pre>
<pre>  assign prio[17] = reg2hw.prio17.q;</pre>
<pre>  assign prio[18] = reg2hw.prio18.q;</pre>
<pre>  assign prio[19] = reg2hw.prio19.q;</pre>
<pre>  assign prio[20] = reg2hw.prio20.q;</pre>
<pre>  assign prio[21] = reg2hw.prio21.q;</pre>
<pre>  assign prio[22] = reg2hw.prio22.q;</pre>
<pre>  assign prio[23] = reg2hw.prio23.q;</pre>
<pre>  assign prio[24] = reg2hw.prio24.q;</pre>
<pre>  assign prio[25] = reg2hw.prio25.q;</pre>
<pre>  assign prio[26] = reg2hw.prio26.q;</pre>
<pre>  assign prio[27] = reg2hw.prio27.q;</pre>
<pre>  assign prio[28] = reg2hw.prio28.q;</pre>
<pre>  assign prio[29] = reg2hw.prio29.q;</pre>
<pre>  assign prio[30] = reg2hw.prio30.q;</pre>
<pre>  assign prio[31] = reg2hw.prio31.q;</pre>
<pre>  assign prio[32] = reg2hw.prio32.q;</pre>
<pre>  assign prio[33] = reg2hw.prio33.q;</pre>
<pre>  assign prio[34] = reg2hw.prio34.q;</pre>
<pre>  assign prio[35] = reg2hw.prio35.q;</pre>
<pre>  assign prio[36] = reg2hw.prio36.q;</pre>
<pre>  assign prio[37] = reg2hw.prio37.q;</pre>
<pre>  assign prio[38] = reg2hw.prio38.q;</pre>
<pre>  assign prio[39] = reg2hw.prio39.q;</pre>
<pre>  assign prio[40] = reg2hw.prio40.q;</pre>
<pre>  assign prio[41] = reg2hw.prio41.q;</pre>
<pre>  assign prio[42] = reg2hw.prio42.q;</pre>
<pre>  assign prio[43] = reg2hw.prio43.q;</pre>
<pre>  assign prio[44] = reg2hw.prio44.q;</pre>
<pre>  assign prio[45] = reg2hw.prio45.q;</pre>
<pre>  assign prio[46] = reg2hw.prio46.q;</pre>
<pre>  assign prio[47] = reg2hw.prio47.q;</pre>
<pre>  assign prio[48] = reg2hw.prio48.q;</pre>
<pre>  assign prio[49] = reg2hw.prio49.q;</pre>
<pre>  assign prio[50] = reg2hw.prio50.q;</pre>
<pre>  assign prio[51] = reg2hw.prio51.q;</pre>
<pre>  assign prio[52] = reg2hw.prio52.q;</pre>
<pre>  assign prio[53] = reg2hw.prio53.q;</pre>
<pre>  assign prio[54] = reg2hw.prio54.q;</pre>
<pre>  assign prio[55] = reg2hw.prio55.q;</pre>
<pre>  assign prio[56] = reg2hw.prio56.q;</pre>
<pre>  assign prio[57] = reg2hw.prio57.q;</pre>
<pre>  assign prio[58] = reg2hw.prio58.q;</pre>
<pre>  assign prio[59] = reg2hw.prio59.q;</pre>
<pre>  assign prio[60] = reg2hw.prio60.q;</pre>
<pre>  assign prio[61] = reg2hw.prio61.q;</pre>
<pre>  assign prio[62] = reg2hw.prio62.q;</pre>
<pre></pre>
<pre>    assign ie[0][s] = reg2hw.ie0[s].q;</pre>
<pre>  end</pre>
<pre></pre>
<pre>  assign claim_id[0]    = irq_id_o[0];</pre>
<pre>  assign complete_we[0] = reg2hw.cc0.qe;</pre>
<pre>  assign complete_id[0] = reg2hw.cc0.q;</pre>
<pre>  assign hw2reg.cc0.d   = cc_id[0];</pre>
<pre></pre>
<pre></pre>
<pre>    assign hw2reg.ip[s].de = 1'b1; // Always write</pre>
<pre>    assign hw2reg.ip[s].d  = ip[s];</pre>
<pre>  end</pre>
<pre>    assign le[s] = reg2hw.le[s].q;</pre>
<pre>  end</pre>
<pre>    .N_SOURCE (NumSrc)</pre>
<pre>  ) u_gateway (</pre>
<pre style="background-color: #FF0000;">    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre></pre>
<pre>    .le,</pre>
<pre></pre>
<pre>    .complete,</pre>
<pre></pre>
<pre>  );</pre>
<pre>    rv_plic_target #(</pre>
<pre>      .N_SOURCE (NumSrc),</pre>
<pre>      .MAX_PRIO (MAX_PRIO)</pre>
<pre>    ) u_target (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre></pre>
<pre>      .ie        (ie[i]),</pre>
<pre></pre>
<pre>      .threshold (threshold[i]),</pre>
<pre></pre>
<pre>      .irq_id    (irq_id_o[i])</pre>
<pre></pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre></pre>
<pre>    .tl_o,</pre>
<pre></pre>
<pre>    .hw2reg,</pre>
<pre></pre>
<pre>  );</pre>
<pre>    `ASSERT_KNOWN(IrqIdKnownO_A, irq_id_o[k], clk_i, !rst_ni)</pre>
<h3>hw/top_earlgrey/ip/rv_plic/rtl/autogen/rv_plic_reg_pkg.sv</h3>
<pre>package rv_plic_reg_pkg;</pre>
<pre>  localparam int NumSrc = 63;</pre>
<pre>  localparam int NumTarget = 1;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_le_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio1_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio2_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio3_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio4_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio5_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio6_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio7_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio8_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio9_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio10_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio11_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio12_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio13_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio14_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio15_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio16_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio17_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio18_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio19_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio20_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio21_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio22_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio23_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio24_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio25_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio26_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio27_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio28_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio29_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio30_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio31_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio32_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio33_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio34_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio35_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio36_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio37_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio38_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio39_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio40_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio41_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio42_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio43_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio44_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio45_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio46_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio47_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio48_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio49_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio50_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio51_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio52_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio53_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio54_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio55_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio56_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio57_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio58_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio59_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio60_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio61_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_prio62_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_ie0_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [1:0]  q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_threshold0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [5:0]  q;</pre>
<pre>    logic        qe;</pre>
<pre>    logic        re;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_cc0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_msip0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_hw2reg_ip_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [5:0]  d;</pre>
<pre style="background-color: #FF0000;">  } rv_plic_hw2reg_cc0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    rv_plic_reg2hw_le_mreg_t [62:0] le; // [262:200]</pre>
<pre>    rv_plic_reg2hw_prio0_reg_t prio0; // [199:198]</pre>
<pre>    rv_plic_reg2hw_prio1_reg_t prio1; // [197:196]</pre>
<pre>    rv_plic_reg2hw_prio2_reg_t prio2; // [195:194]</pre>
<pre>    rv_plic_reg2hw_prio3_reg_t prio3; // [193:192]</pre>
<pre>    rv_plic_reg2hw_prio4_reg_t prio4; // [191:190]</pre>
<pre>    rv_plic_reg2hw_prio5_reg_t prio5; // [189:188]</pre>
<pre>    rv_plic_reg2hw_prio6_reg_t prio6; // [187:186]</pre>
<pre>    rv_plic_reg2hw_prio7_reg_t prio7; // [185:184]</pre>
<pre>    rv_plic_reg2hw_prio8_reg_t prio8; // [183:182]</pre>
<pre>    rv_plic_reg2hw_prio9_reg_t prio9; // [181:180]</pre>
<pre>    rv_plic_reg2hw_prio10_reg_t prio10; // [179:178]</pre>
<pre>    rv_plic_reg2hw_prio11_reg_t prio11; // [177:176]</pre>
<pre>    rv_plic_reg2hw_prio12_reg_t prio12; // [175:174]</pre>
<pre>    rv_plic_reg2hw_prio13_reg_t prio13; // [173:172]</pre>
<pre>    rv_plic_reg2hw_prio14_reg_t prio14; // [171:170]</pre>
<pre>    rv_plic_reg2hw_prio15_reg_t prio15; // [169:168]</pre>
<pre>    rv_plic_reg2hw_prio16_reg_t prio16; // [167:166]</pre>
<pre>    rv_plic_reg2hw_prio17_reg_t prio17; // [165:164]</pre>
<pre>    rv_plic_reg2hw_prio18_reg_t prio18; // [163:162]</pre>
<pre>    rv_plic_reg2hw_prio19_reg_t prio19; // [161:160]</pre>
<pre>    rv_plic_reg2hw_prio20_reg_t prio20; // [159:158]</pre>
<pre>    rv_plic_reg2hw_prio21_reg_t prio21; // [157:156]</pre>
<pre>    rv_plic_reg2hw_prio22_reg_t prio22; // [155:154]</pre>
<pre>    rv_plic_reg2hw_prio23_reg_t prio23; // [153:152]</pre>
<pre>    rv_plic_reg2hw_prio24_reg_t prio24; // [151:150]</pre>
<pre>    rv_plic_reg2hw_prio25_reg_t prio25; // [149:148]</pre>
<pre>    rv_plic_reg2hw_prio26_reg_t prio26; // [147:146]</pre>
<pre>    rv_plic_reg2hw_prio27_reg_t prio27; // [145:144]</pre>
<pre>    rv_plic_reg2hw_prio28_reg_t prio28; // [143:142]</pre>
<pre>    rv_plic_reg2hw_prio29_reg_t prio29; // [141:140]</pre>
<pre>    rv_plic_reg2hw_prio30_reg_t prio30; // [139:138]</pre>
<pre>    rv_plic_reg2hw_prio31_reg_t prio31; // [137:136]</pre>
<pre>    rv_plic_reg2hw_prio32_reg_t prio32; // [135:134]</pre>
<pre>    rv_plic_reg2hw_prio33_reg_t prio33; // [133:132]</pre>
<pre>    rv_plic_reg2hw_prio34_reg_t prio34; // [131:130]</pre>
<pre>    rv_plic_reg2hw_prio35_reg_t prio35; // [129:128]</pre>
<pre>    rv_plic_reg2hw_prio36_reg_t prio36; // [127:126]</pre>
<pre>    rv_plic_reg2hw_prio37_reg_t prio37; // [125:124]</pre>
<pre>    rv_plic_reg2hw_prio38_reg_t prio38; // [123:122]</pre>
<pre>    rv_plic_reg2hw_prio39_reg_t prio39; // [121:120]</pre>
<pre>    rv_plic_reg2hw_prio40_reg_t prio40; // [119:118]</pre>
<pre>    rv_plic_reg2hw_prio41_reg_t prio41; // [117:116]</pre>
<pre>    rv_plic_reg2hw_prio42_reg_t prio42; // [115:114]</pre>
<pre>    rv_plic_reg2hw_prio43_reg_t prio43; // [113:112]</pre>
<pre>    rv_plic_reg2hw_prio44_reg_t prio44; // [111:110]</pre>
<pre>    rv_plic_reg2hw_prio45_reg_t prio45; // [109:108]</pre>
<pre>    rv_plic_reg2hw_prio46_reg_t prio46; // [107:106]</pre>
<pre>    rv_plic_reg2hw_prio47_reg_t prio47; // [105:104]</pre>
<pre>    rv_plic_reg2hw_prio48_reg_t prio48; // [103:102]</pre>
<pre>    rv_plic_reg2hw_prio49_reg_t prio49; // [101:100]</pre>
<pre>    rv_plic_reg2hw_prio50_reg_t prio50; // [99:98]</pre>
<pre>    rv_plic_reg2hw_prio51_reg_t prio51; // [97:96]</pre>
<pre>    rv_plic_reg2hw_prio52_reg_t prio52; // [95:94]</pre>
<pre>    rv_plic_reg2hw_prio53_reg_t prio53; // [93:92]</pre>
<pre>    rv_plic_reg2hw_prio54_reg_t prio54; // [91:90]</pre>
<pre>    rv_plic_reg2hw_prio55_reg_t prio55; // [89:88]</pre>
<pre>    rv_plic_reg2hw_prio56_reg_t prio56; // [87:86]</pre>
<pre>    rv_plic_reg2hw_prio57_reg_t prio57; // [85:84]</pre>
<pre>    rv_plic_reg2hw_prio58_reg_t prio58; // [83:82]</pre>
<pre>    rv_plic_reg2hw_prio59_reg_t prio59; // [81:80]</pre>
<pre>    rv_plic_reg2hw_prio60_reg_t prio60; // [79:78]</pre>
<pre>    rv_plic_reg2hw_prio61_reg_t prio61; // [77:76]</pre>
<pre>    rv_plic_reg2hw_prio62_reg_t prio62; // [75:74]</pre>
<pre>    rv_plic_reg2hw_ie0_mreg_t [62:0] ie0; // [73:11]</pre>
<pre>    rv_plic_reg2hw_threshold0_reg_t threshold0; // [10:9]</pre>
<pre>    rv_plic_reg2hw_cc0_reg_t cc0; // [8:1]</pre>
<pre>    rv_plic_reg2hw_msip0_reg_t msip0; // [0:0]</pre>
<pre style="background-color: #FF0000;">  } rv_plic_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    rv_plic_hw2reg_ip_mreg_t [62:0] ip; // [131:6]</pre>
<pre>    rv_plic_hw2reg_cc0_reg_t cc0; // [5:-2]</pre>
<pre style="background-color: #FF0000;">  } rv_plic_hw2reg_t;</pre>
<pre>  parameter RV_PLIC_IP0_OFFSET = 10'h 0;</pre>
<pre>  parameter RV_PLIC_IP1_OFFSET = 10'h 4;</pre>
<pre>  parameter RV_PLIC_LE0_OFFSET = 10'h 8;</pre>
<pre>  parameter RV_PLIC_LE1_OFFSET = 10'h c;</pre>
<pre>  parameter RV_PLIC_PRIO0_OFFSET = 10'h 10;</pre>
<pre>  parameter RV_PLIC_PRIO1_OFFSET = 10'h 14;</pre>
<pre>  parameter RV_PLIC_PRIO2_OFFSET = 10'h 18;</pre>
<pre>  parameter RV_PLIC_PRIO3_OFFSET = 10'h 1c;</pre>
<pre>  parameter RV_PLIC_PRIO4_OFFSET = 10'h 20;</pre>
<pre>  parameter RV_PLIC_PRIO5_OFFSET = 10'h 24;</pre>
<pre>  parameter RV_PLIC_PRIO6_OFFSET = 10'h 28;</pre>
<pre>  parameter RV_PLIC_PRIO7_OFFSET = 10'h 2c;</pre>
<pre>  parameter RV_PLIC_PRIO8_OFFSET = 10'h 30;</pre>
<pre>  parameter RV_PLIC_PRIO9_OFFSET = 10'h 34;</pre>
<pre>  parameter RV_PLIC_PRIO10_OFFSET = 10'h 38;</pre>
<pre>  parameter RV_PLIC_PRIO11_OFFSET = 10'h 3c;</pre>
<pre>  parameter RV_PLIC_PRIO12_OFFSET = 10'h 40;</pre>
<pre>  parameter RV_PLIC_PRIO13_OFFSET = 10'h 44;</pre>
<pre>  parameter RV_PLIC_PRIO14_OFFSET = 10'h 48;</pre>
<pre>  parameter RV_PLIC_PRIO15_OFFSET = 10'h 4c;</pre>
<pre>  parameter RV_PLIC_PRIO16_OFFSET = 10'h 50;</pre>
<pre>  parameter RV_PLIC_PRIO17_OFFSET = 10'h 54;</pre>
<pre>  parameter RV_PLIC_PRIO18_OFFSET = 10'h 58;</pre>
<pre>  parameter RV_PLIC_PRIO19_OFFSET = 10'h 5c;</pre>
<pre>  parameter RV_PLIC_PRIO20_OFFSET = 10'h 60;</pre>
<pre>  parameter RV_PLIC_PRIO21_OFFSET = 10'h 64;</pre>
<pre>  parameter RV_PLIC_PRIO22_OFFSET = 10'h 68;</pre>
<pre>  parameter RV_PLIC_PRIO23_OFFSET = 10'h 6c;</pre>
<pre>  parameter RV_PLIC_PRIO24_OFFSET = 10'h 70;</pre>
<pre>  parameter RV_PLIC_PRIO25_OFFSET = 10'h 74;</pre>
<pre>  parameter RV_PLIC_PRIO26_OFFSET = 10'h 78;</pre>
<pre>  parameter RV_PLIC_PRIO27_OFFSET = 10'h 7c;</pre>
<pre>  parameter RV_PLIC_PRIO28_OFFSET = 10'h 80;</pre>
<pre>  parameter RV_PLIC_PRIO29_OFFSET = 10'h 84;</pre>
<pre>  parameter RV_PLIC_PRIO30_OFFSET = 10'h 88;</pre>
<pre>  parameter RV_PLIC_PRIO31_OFFSET = 10'h 8c;</pre>
<pre>  parameter RV_PLIC_PRIO32_OFFSET = 10'h 90;</pre>
<pre>  parameter RV_PLIC_PRIO33_OFFSET = 10'h 94;</pre>
<pre>  parameter RV_PLIC_PRIO34_OFFSET = 10'h 98;</pre>
<pre>  parameter RV_PLIC_PRIO35_OFFSET = 10'h 9c;</pre>
<pre>  parameter RV_PLIC_PRIO36_OFFSET = 10'h a0;</pre>
<pre>  parameter RV_PLIC_PRIO37_OFFSET = 10'h a4;</pre>
<pre>  parameter RV_PLIC_PRIO38_OFFSET = 10'h a8;</pre>
<pre>  parameter RV_PLIC_PRIO39_OFFSET = 10'h ac;</pre>
<pre>  parameter RV_PLIC_PRIO40_OFFSET = 10'h b0;</pre>
<pre>  parameter RV_PLIC_PRIO41_OFFSET = 10'h b4;</pre>
<pre>  parameter RV_PLIC_PRIO42_OFFSET = 10'h b8;</pre>
<pre>  parameter RV_PLIC_PRIO43_OFFSET = 10'h bc;</pre>
<pre>  parameter RV_PLIC_PRIO44_OFFSET = 10'h c0;</pre>
<pre>  parameter RV_PLIC_PRIO45_OFFSET = 10'h c4;</pre>
<pre>  parameter RV_PLIC_PRIO46_OFFSET = 10'h c8;</pre>
<pre>  parameter RV_PLIC_PRIO47_OFFSET = 10'h cc;</pre>
<pre>  parameter RV_PLIC_PRIO48_OFFSET = 10'h d0;</pre>
<pre>  parameter RV_PLIC_PRIO49_OFFSET = 10'h d4;</pre>
<pre>  parameter RV_PLIC_PRIO50_OFFSET = 10'h d8;</pre>
<pre>  parameter RV_PLIC_PRIO51_OFFSET = 10'h dc;</pre>
<pre>  parameter RV_PLIC_PRIO52_OFFSET = 10'h e0;</pre>
<pre>  parameter RV_PLIC_PRIO53_OFFSET = 10'h e4;</pre>
<pre>  parameter RV_PLIC_PRIO54_OFFSET = 10'h e8;</pre>
<pre>  parameter RV_PLIC_PRIO55_OFFSET = 10'h ec;</pre>
<pre>  parameter RV_PLIC_PRIO56_OFFSET = 10'h f0;</pre>
<pre>  parameter RV_PLIC_PRIO57_OFFSET = 10'h f4;</pre>
<pre>  parameter RV_PLIC_PRIO58_OFFSET = 10'h f8;</pre>
<pre>  parameter RV_PLIC_PRIO59_OFFSET = 10'h fc;</pre>
<pre>  parameter RV_PLIC_PRIO60_OFFSET = 10'h 100;</pre>
<pre>  parameter RV_PLIC_PRIO61_OFFSET = 10'h 104;</pre>
<pre>  parameter RV_PLIC_PRIO62_OFFSET = 10'h 108;</pre>
<pre>  parameter RV_PLIC_IE00_OFFSET = 10'h 200;</pre>
<pre>  parameter RV_PLIC_IE01_OFFSET = 10'h 204;</pre>
<pre>  parameter RV_PLIC_THRESHOLD0_OFFSET = 10'h 208;</pre>
<pre>  parameter RV_PLIC_CC0_OFFSET = 10'h 20c;</pre>
<pre>  parameter RV_PLIC_MSIP0_OFFSET = 10'h 210;</pre>
<pre>  typedef enum int {</pre>
<pre>    RV_PLIC_IP0,</pre>
<pre>    RV_PLIC_IP1,</pre>
<pre>    RV_PLIC_LE0,</pre>
<pre>    RV_PLIC_LE1,</pre>
<pre>    RV_PLIC_PRIO0,</pre>
<pre>    RV_PLIC_PRIO1,</pre>
<pre>    RV_PLIC_PRIO2,</pre>
<pre>    RV_PLIC_PRIO3,</pre>
<pre>    RV_PLIC_PRIO4,</pre>
<pre>    RV_PLIC_PRIO5,</pre>
<pre>    RV_PLIC_PRIO6,</pre>
<pre>    RV_PLIC_PRIO7,</pre>
<pre>    RV_PLIC_PRIO8,</pre>
<pre>    RV_PLIC_PRIO9,</pre>
<pre>    RV_PLIC_PRIO10,</pre>
<pre>    RV_PLIC_PRIO11,</pre>
<pre>    RV_PLIC_PRIO12,</pre>
<pre>    RV_PLIC_PRIO13,</pre>
<pre>    RV_PLIC_PRIO14,</pre>
<pre>    RV_PLIC_PRIO15,</pre>
<pre>    RV_PLIC_PRIO16,</pre>
<pre>    RV_PLIC_PRIO17,</pre>
<pre>    RV_PLIC_PRIO18,</pre>
<pre>    RV_PLIC_PRIO19,</pre>
<pre>    RV_PLIC_PRIO20,</pre>
<pre>    RV_PLIC_PRIO21,</pre>
<pre>    RV_PLIC_PRIO22,</pre>
<pre>    RV_PLIC_PRIO23,</pre>
<pre>    RV_PLIC_PRIO24,</pre>
<pre>    RV_PLIC_PRIO25,</pre>
<pre>    RV_PLIC_PRIO26,</pre>
<pre>    RV_PLIC_PRIO27,</pre>
<pre>    RV_PLIC_PRIO28,</pre>
<pre>    RV_PLIC_PRIO29,</pre>
<pre>    RV_PLIC_PRIO30,</pre>
<pre>    RV_PLIC_PRIO31,</pre>
<pre>    RV_PLIC_PRIO32,</pre>
<pre>    RV_PLIC_PRIO33,</pre>
<pre>    RV_PLIC_PRIO34,</pre>
<pre>    RV_PLIC_PRIO35,</pre>
<pre>    RV_PLIC_PRIO36,</pre>
<pre>    RV_PLIC_PRIO37,</pre>
<pre>    RV_PLIC_PRIO38,</pre>
<pre>    RV_PLIC_PRIO39,</pre>
<pre>    RV_PLIC_PRIO40,</pre>
<pre>    RV_PLIC_PRIO41,</pre>
<pre>    RV_PLIC_PRIO42,</pre>
<pre>    RV_PLIC_PRIO43,</pre>
<pre>    RV_PLIC_PRIO44,</pre>
<pre>    RV_PLIC_PRIO45,</pre>
<pre>    RV_PLIC_PRIO46,</pre>
<pre>    RV_PLIC_PRIO47,</pre>
<pre>    RV_PLIC_PRIO48,</pre>
<pre>    RV_PLIC_PRIO49,</pre>
<pre>    RV_PLIC_PRIO50,</pre>
<pre>    RV_PLIC_PRIO51,</pre>
<pre>    RV_PLIC_PRIO52,</pre>
<pre>    RV_PLIC_PRIO53,</pre>
<pre>    RV_PLIC_PRIO54,</pre>
<pre>    RV_PLIC_PRIO55,</pre>
<pre>    RV_PLIC_PRIO56,</pre>
<pre>    RV_PLIC_PRIO57,</pre>
<pre>    RV_PLIC_PRIO58,</pre>
<pre>    RV_PLIC_PRIO59,</pre>
<pre>    RV_PLIC_PRIO60,</pre>
<pre>    RV_PLIC_PRIO61,</pre>
<pre>    RV_PLIC_PRIO62,</pre>
<pre>    RV_PLIC_IE00,</pre>
<pre>    RV_PLIC_IE01,</pre>
<pre>    RV_PLIC_THRESHOLD0,</pre>
<pre>    RV_PLIC_CC0,</pre>
<pre>    RV_PLIC_MSIP0</pre>
<pre>  } rv_plic_id_e;</pre>
<pre>  localparam logic [3:0] RV_PLIC_PERMIT [72] = '{</pre>
<pre>    4'b 1111, // index[ 0] RV_PLIC_IP0</pre>
<pre>    4'b 1111, // index[ 1] RV_PLIC_IP1</pre>
<pre>    4'b 1111, // index[ 2] RV_PLIC_LE0</pre>
<pre>    4'b 1111, // index[ 3] RV_PLIC_LE1</pre>
<pre>    4'b 0001, // index[ 4] RV_PLIC_PRIO0</pre>
<pre>    4'b 0001, // index[ 5] RV_PLIC_PRIO1</pre>
<pre>    4'b 0001, // index[ 6] RV_PLIC_PRIO2</pre>
<pre>    4'b 0001, // index[ 7] RV_PLIC_PRIO3</pre>
<pre>    4'b 0001, // index[ 8] RV_PLIC_PRIO4</pre>
<pre>    4'b 0001, // index[ 9] RV_PLIC_PRIO5</pre>
<pre>    4'b 0001, // index[10] RV_PLIC_PRIO6</pre>
<pre>    4'b 0001, // index[11] RV_PLIC_PRIO7</pre>
<pre>    4'b 0001, // index[12] RV_PLIC_PRIO8</pre>
<pre>    4'b 0001, // index[13] RV_PLIC_PRIO9</pre>
<pre>    4'b 0001, // index[14] RV_PLIC_PRIO10</pre>
<pre>    4'b 0001, // index[15] RV_PLIC_PRIO11</pre>
<pre>    4'b 0001, // index[16] RV_PLIC_PRIO12</pre>
<pre>    4'b 0001, // index[17] RV_PLIC_PRIO13</pre>
<pre>    4'b 0001, // index[18] RV_PLIC_PRIO14</pre>
<pre>    4'b 0001, // index[19] RV_PLIC_PRIO15</pre>
<pre>    4'b 0001, // index[20] RV_PLIC_PRIO16</pre>
<pre>    4'b 0001, // index[21] RV_PLIC_PRIO17</pre>
<pre>    4'b 0001, // index[22] RV_PLIC_PRIO18</pre>
<pre>    4'b 0001, // index[23] RV_PLIC_PRIO19</pre>
<pre>    4'b 0001, // index[24] RV_PLIC_PRIO20</pre>
<pre>    4'b 0001, // index[25] RV_PLIC_PRIO21</pre>
<pre>    4'b 0001, // index[26] RV_PLIC_PRIO22</pre>
<pre>    4'b 0001, // index[27] RV_PLIC_PRIO23</pre>
<pre>    4'b 0001, // index[28] RV_PLIC_PRIO24</pre>
<pre>    4'b 0001, // index[29] RV_PLIC_PRIO25</pre>
<pre>    4'b 0001, // index[30] RV_PLIC_PRIO26</pre>
<pre>    4'b 0001, // index[31] RV_PLIC_PRIO27</pre>
<pre>    4'b 0001, // index[32] RV_PLIC_PRIO28</pre>
<pre>    4'b 0001, // index[33] RV_PLIC_PRIO29</pre>
<pre>    4'b 0001, // index[34] RV_PLIC_PRIO30</pre>
<pre>    4'b 0001, // index[35] RV_PLIC_PRIO31</pre>
<pre>    4'b 0001, // index[36] RV_PLIC_PRIO32</pre>
<pre>    4'b 0001, // index[37] RV_PLIC_PRIO33</pre>
<pre>    4'b 0001, // index[38] RV_PLIC_PRIO34</pre>
<pre>    4'b 0001, // index[39] RV_PLIC_PRIO35</pre>
<pre>    4'b 0001, // index[40] RV_PLIC_PRIO36</pre>
<pre>    4'b 0001, // index[41] RV_PLIC_PRIO37</pre>
<pre>    4'b 0001, // index[42] RV_PLIC_PRIO38</pre>
<pre>    4'b 0001, // index[43] RV_PLIC_PRIO39</pre>
<pre>    4'b 0001, // index[44] RV_PLIC_PRIO40</pre>
<pre>    4'b 0001, // index[45] RV_PLIC_PRIO41</pre>
<pre>    4'b 0001, // index[46] RV_PLIC_PRIO42</pre>
<pre>    4'b 0001, // index[47] RV_PLIC_PRIO43</pre>
<pre>    4'b 0001, // index[48] RV_PLIC_PRIO44</pre>
<pre>    4'b 0001, // index[49] RV_PLIC_PRIO45</pre>
<pre>    4'b 0001, // index[50] RV_PLIC_PRIO46</pre>
<pre>    4'b 0001, // index[51] RV_PLIC_PRIO47</pre>
<pre>    4'b 0001, // index[52] RV_PLIC_PRIO48</pre>
<pre>    4'b 0001, // index[53] RV_PLIC_PRIO49</pre>
<pre>    4'b 0001, // index[54] RV_PLIC_PRIO50</pre>
<pre>    4'b 0001, // index[55] RV_PLIC_PRIO51</pre>
<pre>    4'b 0001, // index[56] RV_PLIC_PRIO52</pre>
<pre>    4'b 0001, // index[57] RV_PLIC_PRIO53</pre>
<pre>    4'b 0001, // index[58] RV_PLIC_PRIO54</pre>
<pre>    4'b 0001, // index[59] RV_PLIC_PRIO55</pre>
<pre>    4'b 0001, // index[60] RV_PLIC_PRIO56</pre>
<pre>    4'b 0001, // index[61] RV_PLIC_PRIO57</pre>
<pre>    4'b 0001, // index[62] RV_PLIC_PRIO58</pre>
<pre>    4'b 0001, // index[63] RV_PLIC_PRIO59</pre>
<pre>    4'b 0001, // index[64] RV_PLIC_PRIO60</pre>
<pre>    4'b 0001, // index[65] RV_PLIC_PRIO61</pre>
<pre>    4'b 0001, // index[66] RV_PLIC_PRIO62</pre>
<pre>    4'b 1111, // index[67] RV_PLIC_IE00</pre>
<pre>    4'b 1111, // index[68] RV_PLIC_IE01</pre>
<pre>    4'b 0001, // index[69] RV_PLIC_THRESHOLD0</pre>
<pre>    4'b 0001, // index[70] RV_PLIC_CC0</pre>
<pre>    4'b 0001  // index[71] RV_PLIC_MSIP0</pre>
<h3>hw/top_earlgrey/ip/rv_plic/rtl/autogen/rv_plic_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output rv_plic_reg_pkg::rv_plic_reg2hw_t reg2hw, // Write</pre>
<pre>  input  rv_plic_reg_pkg::rv_plic_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam AW = 10;</pre>
<pre>  localparam DW = 32;</pre>
<pre>  localparam DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  assign tl_reg_h2d = tl_i;</pre>
<pre>  assign tl_o       = tl_reg_d2h;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic ip0_p0_qs;</pre>
<pre>  logic ip0_p1_qs;</pre>
<pre>  logic ip0_p2_qs;</pre>
<pre>  logic ip0_p3_qs;</pre>
<pre>  logic ip0_p4_qs;</pre>
<pre>  logic ip0_p5_qs;</pre>
<pre>  logic ip0_p6_qs;</pre>
<pre>  logic ip0_p7_qs;</pre>
<pre>  logic ip0_p8_qs;</pre>
<pre>  logic ip0_p9_qs;</pre>
<pre>  logic ip0_p10_qs;</pre>
<pre>  logic ip0_p11_qs;</pre>
<pre>  logic ip0_p12_qs;</pre>
<pre>  logic ip0_p13_qs;</pre>
<pre>  logic ip0_p14_qs;</pre>
<pre>  logic ip0_p15_qs;</pre>
<pre>  logic ip0_p16_qs;</pre>
<pre>  logic ip0_p17_qs;</pre>
<pre>  logic ip0_p18_qs;</pre>
<pre>  logic ip0_p19_qs;</pre>
<pre>  logic ip0_p20_qs;</pre>
<pre>  logic ip0_p21_qs;</pre>
<pre>  logic ip0_p22_qs;</pre>
<pre>  logic ip0_p23_qs;</pre>
<pre>  logic ip0_p24_qs;</pre>
<pre>  logic ip0_p25_qs;</pre>
<pre>  logic ip0_p26_qs;</pre>
<pre>  logic ip0_p27_qs;</pre>
<pre>  logic ip0_p28_qs;</pre>
<pre>  logic ip0_p29_qs;</pre>
<pre>  logic ip0_p30_qs;</pre>
<pre>  logic ip0_p31_qs;</pre>
<pre>  logic ip1_p32_qs;</pre>
<pre>  logic ip1_p33_qs;</pre>
<pre>  logic ip1_p34_qs;</pre>
<pre>  logic ip1_p35_qs;</pre>
<pre>  logic ip1_p36_qs;</pre>
<pre>  logic ip1_p37_qs;</pre>
<pre>  logic ip1_p38_qs;</pre>
<pre>  logic ip1_p39_qs;</pre>
<pre>  logic ip1_p40_qs;</pre>
<pre>  logic ip1_p41_qs;</pre>
<pre>  logic ip1_p42_qs;</pre>
<pre>  logic ip1_p43_qs;</pre>
<pre>  logic ip1_p44_qs;</pre>
<pre>  logic ip1_p45_qs;</pre>
<pre>  logic ip1_p46_qs;</pre>
<pre>  logic ip1_p47_qs;</pre>
<pre>  logic ip1_p48_qs;</pre>
<pre>  logic ip1_p49_qs;</pre>
<pre>  logic ip1_p50_qs;</pre>
<pre>  logic ip1_p51_qs;</pre>
<pre>  logic ip1_p52_qs;</pre>
<pre>  logic ip1_p53_qs;</pre>
<pre>  logic ip1_p54_qs;</pre>
<pre>  logic ip1_p55_qs;</pre>
<pre>  logic ip1_p56_qs;</pre>
<pre>  logic ip1_p57_qs;</pre>
<pre>  logic ip1_p58_qs;</pre>
<pre>  logic ip1_p59_qs;</pre>
<pre>  logic ip1_p60_qs;</pre>
<pre>  logic ip1_p61_qs;</pre>
<pre>  logic ip1_p62_qs;</pre>
<pre>  logic le0_le0_qs;</pre>
<pre>  logic le0_le0_wd;</pre>
<pre>  logic le0_le0_we;</pre>
<pre>  logic le0_le1_qs;</pre>
<pre>  logic le0_le1_wd;</pre>
<pre>  logic le0_le1_we;</pre>
<pre>  logic le0_le2_qs;</pre>
<pre>  logic le0_le2_wd;</pre>
<pre>  logic le0_le2_we;</pre>
<pre>  logic le0_le3_qs;</pre>
<pre>  logic le0_le3_wd;</pre>
<pre>  logic le0_le3_we;</pre>
<pre>  logic le0_le4_qs;</pre>
<pre>  logic le0_le4_wd;</pre>
<pre>  logic le0_le4_we;</pre>
<pre>  logic le0_le5_qs;</pre>
<pre>  logic le0_le5_wd;</pre>
<pre>  logic le0_le5_we;</pre>
<pre>  logic le0_le6_qs;</pre>
<pre>  logic le0_le6_wd;</pre>
<pre>  logic le0_le6_we;</pre>
<pre>  logic le0_le7_qs;</pre>
<pre>  logic le0_le7_wd;</pre>
<pre>  logic le0_le7_we;</pre>
<pre>  logic le0_le8_qs;</pre>
<pre>  logic le0_le8_wd;</pre>
<pre>  logic le0_le8_we;</pre>
<pre>  logic le0_le9_qs;</pre>
<pre>  logic le0_le9_wd;</pre>
<pre>  logic le0_le9_we;</pre>
<pre>  logic le0_le10_qs;</pre>
<pre>  logic le0_le10_wd;</pre>
<pre>  logic le0_le10_we;</pre>
<pre>  logic le0_le11_qs;</pre>
<pre>  logic le0_le11_wd;</pre>
<pre>  logic le0_le11_we;</pre>
<pre>  logic le0_le12_qs;</pre>
<pre>  logic le0_le12_wd;</pre>
<pre>  logic le0_le12_we;</pre>
<pre>  logic le0_le13_qs;</pre>
<pre>  logic le0_le13_wd;</pre>
<pre>  logic le0_le13_we;</pre>
<pre>  logic le0_le14_qs;</pre>
<pre>  logic le0_le14_wd;</pre>
<pre>  logic le0_le14_we;</pre>
<pre>  logic le0_le15_qs;</pre>
<pre>  logic le0_le15_wd;</pre>
<pre>  logic le0_le15_we;</pre>
<pre>  logic le0_le16_qs;</pre>
<pre>  logic le0_le16_wd;</pre>
<pre>  logic le0_le16_we;</pre>
<pre>  logic le0_le17_qs;</pre>
<pre>  logic le0_le17_wd;</pre>
<pre>  logic le0_le17_we;</pre>
<pre>  logic le0_le18_qs;</pre>
<pre>  logic le0_le18_wd;</pre>
<pre>  logic le0_le18_we;</pre>
<pre>  logic le0_le19_qs;</pre>
<pre>  logic le0_le19_wd;</pre>
<pre>  logic le0_le19_we;</pre>
<pre>  logic le0_le20_qs;</pre>
<pre>  logic le0_le20_wd;</pre>
<pre>  logic le0_le20_we;</pre>
<pre>  logic le0_le21_qs;</pre>
<pre>  logic le0_le21_wd;</pre>
<pre>  logic le0_le21_we;</pre>
<pre>  logic le0_le22_qs;</pre>
<pre>  logic le0_le22_wd;</pre>
<pre>  logic le0_le22_we;</pre>
<pre>  logic le0_le23_qs;</pre>
<pre>  logic le0_le23_wd;</pre>
<pre>  logic le0_le23_we;</pre>
<pre>  logic le0_le24_qs;</pre>
<pre>  logic le0_le24_wd;</pre>
<pre>  logic le0_le24_we;</pre>
<pre>  logic le0_le25_qs;</pre>
<pre>  logic le0_le25_wd;</pre>
<pre>  logic le0_le25_we;</pre>
<pre>  logic le0_le26_qs;</pre>
<pre>  logic le0_le26_wd;</pre>
<pre>  logic le0_le26_we;</pre>
<pre>  logic le0_le27_qs;</pre>
<pre>  logic le0_le27_wd;</pre>
<pre>  logic le0_le27_we;</pre>
<pre>  logic le0_le28_qs;</pre>
<pre>  logic le0_le28_wd;</pre>
<pre>  logic le0_le28_we;</pre>
<pre>  logic le0_le29_qs;</pre>
<pre>  logic le0_le29_wd;</pre>
<pre>  logic le0_le29_we;</pre>
<pre>  logic le0_le30_qs;</pre>
<pre>  logic le0_le30_wd;</pre>
<pre>  logic le0_le30_we;</pre>
<pre>  logic le0_le31_qs;</pre>
<pre>  logic le0_le31_wd;</pre>
<pre>  logic le0_le31_we;</pre>
<pre>  logic le1_le32_qs;</pre>
<pre>  logic le1_le32_wd;</pre>
<pre>  logic le1_le32_we;</pre>
<pre>  logic le1_le33_qs;</pre>
<pre>  logic le1_le33_wd;</pre>
<pre>  logic le1_le33_we;</pre>
<pre>  logic le1_le34_qs;</pre>
<pre>  logic le1_le34_wd;</pre>
<pre>  logic le1_le34_we;</pre>
<pre>  logic le1_le35_qs;</pre>
<pre>  logic le1_le35_wd;</pre>
<pre>  logic le1_le35_we;</pre>
<pre>  logic le1_le36_qs;</pre>
<pre>  logic le1_le36_wd;</pre>
<pre>  logic le1_le36_we;</pre>
<pre>  logic le1_le37_qs;</pre>
<pre>  logic le1_le37_wd;</pre>
<pre>  logic le1_le37_we;</pre>
<pre>  logic le1_le38_qs;</pre>
<pre>  logic le1_le38_wd;</pre>
<pre>  logic le1_le38_we;</pre>
<pre>  logic le1_le39_qs;</pre>
<pre>  logic le1_le39_wd;</pre>
<pre>  logic le1_le39_we;</pre>
<pre>  logic le1_le40_qs;</pre>
<pre>  logic le1_le40_wd;</pre>
<pre>  logic le1_le40_we;</pre>
<pre>  logic le1_le41_qs;</pre>
<pre>  logic le1_le41_wd;</pre>
<pre>  logic le1_le41_we;</pre>
<pre>  logic le1_le42_qs;</pre>
<pre>  logic le1_le42_wd;</pre>
<pre>  logic le1_le42_we;</pre>
<pre>  logic le1_le43_qs;</pre>
<pre>  logic le1_le43_wd;</pre>
<pre>  logic le1_le43_we;</pre>
<pre>  logic le1_le44_qs;</pre>
<pre>  logic le1_le44_wd;</pre>
<pre>  logic le1_le44_we;</pre>
<pre>  logic le1_le45_qs;</pre>
<pre>  logic le1_le45_wd;</pre>
<pre>  logic le1_le45_we;</pre>
<pre>  logic le1_le46_qs;</pre>
<pre>  logic le1_le46_wd;</pre>
<pre>  logic le1_le46_we;</pre>
<pre>  logic le1_le47_qs;</pre>
<pre>  logic le1_le47_wd;</pre>
<pre>  logic le1_le47_we;</pre>
<pre>  logic le1_le48_qs;</pre>
<pre>  logic le1_le48_wd;</pre>
<pre>  logic le1_le48_we;</pre>
<pre>  logic le1_le49_qs;</pre>
<pre>  logic le1_le49_wd;</pre>
<pre>  logic le1_le49_we;</pre>
<pre>  logic le1_le50_qs;</pre>
<pre>  logic le1_le50_wd;</pre>
<pre>  logic le1_le50_we;</pre>
<pre>  logic le1_le51_qs;</pre>
<pre>  logic le1_le51_wd;</pre>
<pre>  logic le1_le51_we;</pre>
<pre>  logic le1_le52_qs;</pre>
<pre>  logic le1_le52_wd;</pre>
<pre>  logic le1_le52_we;</pre>
<pre>  logic le1_le53_qs;</pre>
<pre>  logic le1_le53_wd;</pre>
<pre>  logic le1_le53_we;</pre>
<pre>  logic le1_le54_qs;</pre>
<pre>  logic le1_le54_wd;</pre>
<pre>  logic le1_le54_we;</pre>
<pre>  logic le1_le55_qs;</pre>
<pre>  logic le1_le55_wd;</pre>
<pre>  logic le1_le55_we;</pre>
<pre>  logic le1_le56_qs;</pre>
<pre>  logic le1_le56_wd;</pre>
<pre>  logic le1_le56_we;</pre>
<pre>  logic le1_le57_qs;</pre>
<pre>  logic le1_le57_wd;</pre>
<pre>  logic le1_le57_we;</pre>
<pre>  logic le1_le58_qs;</pre>
<pre>  logic le1_le58_wd;</pre>
<pre>  logic le1_le58_we;</pre>
<pre>  logic le1_le59_qs;</pre>
<pre>  logic le1_le59_wd;</pre>
<pre>  logic le1_le59_we;</pre>
<pre>  logic le1_le60_qs;</pre>
<pre>  logic le1_le60_wd;</pre>
<pre>  logic le1_le60_we;</pre>
<pre>  logic le1_le61_qs;</pre>
<pre>  logic le1_le61_wd;</pre>
<pre>  logic le1_le61_we;</pre>
<pre>  logic le1_le62_qs;</pre>
<pre>  logic le1_le62_wd;</pre>
<pre>  logic le1_le62_we;</pre>
<pre>  logic [1:0] prio0_qs;</pre>
<pre>  logic [1:0] prio0_wd;</pre>
<pre>  logic prio0_we;</pre>
<pre>  logic [1:0] prio1_qs;</pre>
<pre>  logic [1:0] prio1_wd;</pre>
<pre>  logic prio1_we;</pre>
<pre>  logic [1:0] prio2_qs;</pre>
<pre>  logic [1:0] prio2_wd;</pre>
<pre>  logic prio2_we;</pre>
<pre>  logic [1:0] prio3_qs;</pre>
<pre>  logic [1:0] prio3_wd;</pre>
<pre>  logic prio3_we;</pre>
<pre>  logic [1:0] prio4_qs;</pre>
<pre>  logic [1:0] prio4_wd;</pre>
<pre>  logic prio4_we;</pre>
<pre>  logic [1:0] prio5_qs;</pre>
<pre>  logic [1:0] prio5_wd;</pre>
<pre>  logic prio5_we;</pre>
<pre>  logic [1:0] prio6_qs;</pre>
<pre>  logic [1:0] prio6_wd;</pre>
<pre>  logic prio6_we;</pre>
<pre>  logic [1:0] prio7_qs;</pre>
<pre>  logic [1:0] prio7_wd;</pre>
<pre>  logic prio7_we;</pre>
<pre>  logic [1:0] prio8_qs;</pre>
<pre>  logic [1:0] prio8_wd;</pre>
<pre>  logic prio8_we;</pre>
<pre>  logic [1:0] prio9_qs;</pre>
<pre>  logic [1:0] prio9_wd;</pre>
<pre>  logic prio9_we;</pre>
<pre>  logic [1:0] prio10_qs;</pre>
<pre>  logic [1:0] prio10_wd;</pre>
<pre>  logic prio10_we;</pre>
<pre>  logic [1:0] prio11_qs;</pre>
<pre>  logic [1:0] prio11_wd;</pre>
<pre>  logic prio11_we;</pre>
<pre>  logic [1:0] prio12_qs;</pre>
<pre>  logic [1:0] prio12_wd;</pre>
<pre>  logic prio12_we;</pre>
<pre>  logic [1:0] prio13_qs;</pre>
<pre>  logic [1:0] prio13_wd;</pre>
<pre>  logic prio13_we;</pre>
<pre>  logic [1:0] prio14_qs;</pre>
<pre>  logic [1:0] prio14_wd;</pre>
<pre>  logic prio14_we;</pre>
<pre>  logic [1:0] prio15_qs;</pre>
<pre>  logic [1:0] prio15_wd;</pre>
<pre>  logic prio15_we;</pre>
<pre>  logic [1:0] prio16_qs;</pre>
<pre>  logic [1:0] prio16_wd;</pre>
<pre>  logic prio16_we;</pre>
<pre>  logic [1:0] prio17_qs;</pre>
<pre>  logic [1:0] prio17_wd;</pre>
<pre>  logic prio17_we;</pre>
<pre>  logic [1:0] prio18_qs;</pre>
<pre>  logic [1:0] prio18_wd;</pre>
<pre>  logic prio18_we;</pre>
<pre>  logic [1:0] prio19_qs;</pre>
<pre>  logic [1:0] prio19_wd;</pre>
<pre>  logic prio19_we;</pre>
<pre>  logic [1:0] prio20_qs;</pre>
<pre>  logic [1:0] prio20_wd;</pre>
<pre>  logic prio20_we;</pre>
<pre>  logic [1:0] prio21_qs;</pre>
<pre>  logic [1:0] prio21_wd;</pre>
<pre>  logic prio21_we;</pre>
<pre>  logic [1:0] prio22_qs;</pre>
<pre>  logic [1:0] prio22_wd;</pre>
<pre>  logic prio22_we;</pre>
<pre>  logic [1:0] prio23_qs;</pre>
<pre>  logic [1:0] prio23_wd;</pre>
<pre>  logic prio23_we;</pre>
<pre>  logic [1:0] prio24_qs;</pre>
<pre>  logic [1:0] prio24_wd;</pre>
<pre>  logic prio24_we;</pre>
<pre>  logic [1:0] prio25_qs;</pre>
<pre>  logic [1:0] prio25_wd;</pre>
<pre>  logic prio25_we;</pre>
<pre>  logic [1:0] prio26_qs;</pre>
<pre>  logic [1:0] prio26_wd;</pre>
<pre>  logic prio26_we;</pre>
<pre>  logic [1:0] prio27_qs;</pre>
<pre>  logic [1:0] prio27_wd;</pre>
<pre>  logic prio27_we;</pre>
<pre>  logic [1:0] prio28_qs;</pre>
<pre>  logic [1:0] prio28_wd;</pre>
<pre>  logic prio28_we;</pre>
<pre>  logic [1:0] prio29_qs;</pre>
<pre>  logic [1:0] prio29_wd;</pre>
<pre>  logic prio29_we;</pre>
<pre>  logic [1:0] prio30_qs;</pre>
<pre>  logic [1:0] prio30_wd;</pre>
<pre>  logic prio30_we;</pre>
<pre>  logic [1:0] prio31_qs;</pre>
<pre>  logic [1:0] prio31_wd;</pre>
<pre>  logic prio31_we;</pre>
<pre>  logic [1:0] prio32_qs;</pre>
<pre>  logic [1:0] prio32_wd;</pre>
<pre>  logic prio32_we;</pre>
<pre>  logic [1:0] prio33_qs;</pre>
<pre>  logic [1:0] prio33_wd;</pre>
<pre>  logic prio33_we;</pre>
<pre>  logic [1:0] prio34_qs;</pre>
<pre>  logic [1:0] prio34_wd;</pre>
<pre>  logic prio34_we;</pre>
<pre>  logic [1:0] prio35_qs;</pre>
<pre>  logic [1:0] prio35_wd;</pre>
<pre>  logic prio35_we;</pre>
<pre>  logic [1:0] prio36_qs;</pre>
<pre>  logic [1:0] prio36_wd;</pre>
<pre>  logic prio36_we;</pre>
<pre>  logic [1:0] prio37_qs;</pre>
<pre>  logic [1:0] prio37_wd;</pre>
<pre>  logic prio37_we;</pre>
<pre>  logic [1:0] prio38_qs;</pre>
<pre>  logic [1:0] prio38_wd;</pre>
<pre>  logic prio38_we;</pre>
<pre>  logic [1:0] prio39_qs;</pre>
<pre>  logic [1:0] prio39_wd;</pre>
<pre>  logic prio39_we;</pre>
<pre>  logic [1:0] prio40_qs;</pre>
<pre>  logic [1:0] prio40_wd;</pre>
<pre>  logic prio40_we;</pre>
<pre>  logic [1:0] prio41_qs;</pre>
<pre>  logic [1:0] prio41_wd;</pre>
<pre>  logic prio41_we;</pre>
<pre>  logic [1:0] prio42_qs;</pre>
<pre>  logic [1:0] prio42_wd;</pre>
<pre>  logic prio42_we;</pre>
<pre>  logic [1:0] prio43_qs;</pre>
<pre>  logic [1:0] prio43_wd;</pre>
<pre>  logic prio43_we;</pre>
<pre>  logic [1:0] prio44_qs;</pre>
<pre>  logic [1:0] prio44_wd;</pre>
<pre>  logic prio44_we;</pre>
<pre>  logic [1:0] prio45_qs;</pre>
<pre>  logic [1:0] prio45_wd;</pre>
<pre>  logic prio45_we;</pre>
<pre>  logic [1:0] prio46_qs;</pre>
<pre>  logic [1:0] prio46_wd;</pre>
<pre>  logic prio46_we;</pre>
<pre>  logic [1:0] prio47_qs;</pre>
<pre>  logic [1:0] prio47_wd;</pre>
<pre>  logic prio47_we;</pre>
<pre>  logic [1:0] prio48_qs;</pre>
<pre>  logic [1:0] prio48_wd;</pre>
<pre>  logic prio48_we;</pre>
<pre>  logic [1:0] prio49_qs;</pre>
<pre>  logic [1:0] prio49_wd;</pre>
<pre>  logic prio49_we;</pre>
<pre>  logic [1:0] prio50_qs;</pre>
<pre>  logic [1:0] prio50_wd;</pre>
<pre>  logic prio50_we;</pre>
<pre>  logic [1:0] prio51_qs;</pre>
<pre>  logic [1:0] prio51_wd;</pre>
<pre>  logic prio51_we;</pre>
<pre>  logic [1:0] prio52_qs;</pre>
<pre>  logic [1:0] prio52_wd;</pre>
<pre>  logic prio52_we;</pre>
<pre>  logic [1:0] prio53_qs;</pre>
<pre>  logic [1:0] prio53_wd;</pre>
<pre>  logic prio53_we;</pre>
<pre>  logic [1:0] prio54_qs;</pre>
<pre>  logic [1:0] prio54_wd;</pre>
<pre>  logic prio54_we;</pre>
<pre>  logic [1:0] prio55_qs;</pre>
<pre>  logic [1:0] prio55_wd;</pre>
<pre>  logic prio55_we;</pre>
<pre>  logic [1:0] prio56_qs;</pre>
<pre>  logic [1:0] prio56_wd;</pre>
<pre>  logic prio56_we;</pre>
<pre>  logic [1:0] prio57_qs;</pre>
<pre>  logic [1:0] prio57_wd;</pre>
<pre>  logic prio57_we;</pre>
<pre>  logic [1:0] prio58_qs;</pre>
<pre>  logic [1:0] prio58_wd;</pre>
<pre>  logic prio58_we;</pre>
<pre>  logic [1:0] prio59_qs;</pre>
<pre>  logic [1:0] prio59_wd;</pre>
<pre>  logic prio59_we;</pre>
<pre>  logic [1:0] prio60_qs;</pre>
<pre>  logic [1:0] prio60_wd;</pre>
<pre>  logic prio60_we;</pre>
<pre>  logic [1:0] prio61_qs;</pre>
<pre>  logic [1:0] prio61_wd;</pre>
<pre>  logic prio61_we;</pre>
<pre>  logic [1:0] prio62_qs;</pre>
<pre>  logic [1:0] prio62_wd;</pre>
<pre>  logic prio62_we;</pre>
<pre>  logic ie00_e0_qs;</pre>
<pre>  logic ie00_e0_wd;</pre>
<pre>  logic ie00_e0_we;</pre>
<pre>  logic ie00_e1_qs;</pre>
<pre>  logic ie00_e1_wd;</pre>
<pre>  logic ie00_e1_we;</pre>
<pre>  logic ie00_e2_qs;</pre>
<pre>  logic ie00_e2_wd;</pre>
<pre>  logic ie00_e2_we;</pre>
<pre>  logic ie00_e3_qs;</pre>
<pre>  logic ie00_e3_wd;</pre>
<pre>  logic ie00_e3_we;</pre>
<pre>  logic ie00_e4_qs;</pre>
<pre>  logic ie00_e4_wd;</pre>
<pre>  logic ie00_e4_we;</pre>
<pre>  logic ie00_e5_qs;</pre>
<pre>  logic ie00_e5_wd;</pre>
<pre>  logic ie00_e5_we;</pre>
<pre>  logic ie00_e6_qs;</pre>
<pre>  logic ie00_e6_wd;</pre>
<pre>  logic ie00_e6_we;</pre>
<pre>  logic ie00_e7_qs;</pre>
<pre>  logic ie00_e7_wd;</pre>
<pre>  logic ie00_e7_we;</pre>
<pre>  logic ie00_e8_qs;</pre>
<pre>  logic ie00_e8_wd;</pre>
<pre>  logic ie00_e8_we;</pre>
<pre>  logic ie00_e9_qs;</pre>
<pre>  logic ie00_e9_wd;</pre>
<pre>  logic ie00_e9_we;</pre>
<pre>  logic ie00_e10_qs;</pre>
<pre>  logic ie00_e10_wd;</pre>
<pre>  logic ie00_e10_we;</pre>
<pre>  logic ie00_e11_qs;</pre>
<pre>  logic ie00_e11_wd;</pre>
<pre>  logic ie00_e11_we;</pre>
<pre>  logic ie00_e12_qs;</pre>
<pre>  logic ie00_e12_wd;</pre>
<pre>  logic ie00_e12_we;</pre>
<pre>  logic ie00_e13_qs;</pre>
<pre>  logic ie00_e13_wd;</pre>
<pre>  logic ie00_e13_we;</pre>
<pre>  logic ie00_e14_qs;</pre>
<pre>  logic ie00_e14_wd;</pre>
<pre>  logic ie00_e14_we;</pre>
<pre>  logic ie00_e15_qs;</pre>
<pre>  logic ie00_e15_wd;</pre>
<pre>  logic ie00_e15_we;</pre>
<pre>  logic ie00_e16_qs;</pre>
<pre>  logic ie00_e16_wd;</pre>
<pre>  logic ie00_e16_we;</pre>
<pre>  logic ie00_e17_qs;</pre>
<pre>  logic ie00_e17_wd;</pre>
<pre>  logic ie00_e17_we;</pre>
<pre>  logic ie00_e18_qs;</pre>
<pre>  logic ie00_e18_wd;</pre>
<pre>  logic ie00_e18_we;</pre>
<pre>  logic ie00_e19_qs;</pre>
<pre>  logic ie00_e19_wd;</pre>
<pre>  logic ie00_e19_we;</pre>
<pre>  logic ie00_e20_qs;</pre>
<pre>  logic ie00_e20_wd;</pre>
<pre>  logic ie00_e20_we;</pre>
<pre>  logic ie00_e21_qs;</pre>
<pre>  logic ie00_e21_wd;</pre>
<pre>  logic ie00_e21_we;</pre>
<pre>  logic ie00_e22_qs;</pre>
<pre>  logic ie00_e22_wd;</pre>
<pre>  logic ie00_e22_we;</pre>
<pre>  logic ie00_e23_qs;</pre>
<pre>  logic ie00_e23_wd;</pre>
<pre>  logic ie00_e23_we;</pre>
<pre>  logic ie00_e24_qs;</pre>
<pre>  logic ie00_e24_wd;</pre>
<pre>  logic ie00_e24_we;</pre>
<pre>  logic ie00_e25_qs;</pre>
<pre>  logic ie00_e25_wd;</pre>
<pre>  logic ie00_e25_we;</pre>
<pre>  logic ie00_e26_qs;</pre>
<pre>  logic ie00_e26_wd;</pre>
<pre>  logic ie00_e26_we;</pre>
<pre>  logic ie00_e27_qs;</pre>
<pre>  logic ie00_e27_wd;</pre>
<pre>  logic ie00_e27_we;</pre>
<pre>  logic ie00_e28_qs;</pre>
<pre>  logic ie00_e28_wd;</pre>
<pre>  logic ie00_e28_we;</pre>
<pre>  logic ie00_e29_qs;</pre>
<pre>  logic ie00_e29_wd;</pre>
<pre>  logic ie00_e29_we;</pre>
<pre>  logic ie00_e30_qs;</pre>
<pre>  logic ie00_e30_wd;</pre>
<pre>  logic ie00_e30_we;</pre>
<pre>  logic ie00_e31_qs;</pre>
<pre>  logic ie00_e31_wd;</pre>
<pre>  logic ie00_e31_we;</pre>
<pre>  logic ie01_e32_qs;</pre>
<pre>  logic ie01_e32_wd;</pre>
<pre>  logic ie01_e32_we;</pre>
<pre>  logic ie01_e33_qs;</pre>
<pre>  logic ie01_e33_wd;</pre>
<pre>  logic ie01_e33_we;</pre>
<pre>  logic ie01_e34_qs;</pre>
<pre>  logic ie01_e34_wd;</pre>
<pre>  logic ie01_e34_we;</pre>
<pre>  logic ie01_e35_qs;</pre>
<pre>  logic ie01_e35_wd;</pre>
<pre>  logic ie01_e35_we;</pre>
<pre>  logic ie01_e36_qs;</pre>
<pre>  logic ie01_e36_wd;</pre>
<pre>  logic ie01_e36_we;</pre>
<pre>  logic ie01_e37_qs;</pre>
<pre>  logic ie01_e37_wd;</pre>
<pre>  logic ie01_e37_we;</pre>
<pre>  logic ie01_e38_qs;</pre>
<pre>  logic ie01_e38_wd;</pre>
<pre>  logic ie01_e38_we;</pre>
<pre>  logic ie01_e39_qs;</pre>
<pre>  logic ie01_e39_wd;</pre>
<pre>  logic ie01_e39_we;</pre>
<pre>  logic ie01_e40_qs;</pre>
<pre>  logic ie01_e40_wd;</pre>
<pre>  logic ie01_e40_we;</pre>
<pre>  logic ie01_e41_qs;</pre>
<pre>  logic ie01_e41_wd;</pre>
<pre>  logic ie01_e41_we;</pre>
<pre>  logic ie01_e42_qs;</pre>
<pre>  logic ie01_e42_wd;</pre>
<pre>  logic ie01_e42_we;</pre>
<pre>  logic ie01_e43_qs;</pre>
<pre>  logic ie01_e43_wd;</pre>
<pre>  logic ie01_e43_we;</pre>
<pre>  logic ie01_e44_qs;</pre>
<pre>  logic ie01_e44_wd;</pre>
<pre>  logic ie01_e44_we;</pre>
<pre>  logic ie01_e45_qs;</pre>
<pre>  logic ie01_e45_wd;</pre>
<pre>  logic ie01_e45_we;</pre>
<pre>  logic ie01_e46_qs;</pre>
<pre>  logic ie01_e46_wd;</pre>
<pre>  logic ie01_e46_we;</pre>
<pre>  logic ie01_e47_qs;</pre>
<pre>  logic ie01_e47_wd;</pre>
<pre>  logic ie01_e47_we;</pre>
<pre>  logic ie01_e48_qs;</pre>
<pre>  logic ie01_e48_wd;</pre>
<pre>  logic ie01_e48_we;</pre>
<pre>  logic ie01_e49_qs;</pre>
<pre>  logic ie01_e49_wd;</pre>
<pre>  logic ie01_e49_we;</pre>
<pre>  logic ie01_e50_qs;</pre>
<pre>  logic ie01_e50_wd;</pre>
<pre>  logic ie01_e50_we;</pre>
<pre>  logic ie01_e51_qs;</pre>
<pre>  logic ie01_e51_wd;</pre>
<pre>  logic ie01_e51_we;</pre>
<pre>  logic ie01_e52_qs;</pre>
<pre>  logic ie01_e52_wd;</pre>
<pre>  logic ie01_e52_we;</pre>
<pre>  logic ie01_e53_qs;</pre>
<pre>  logic ie01_e53_wd;</pre>
<pre>  logic ie01_e53_we;</pre>
<pre>  logic ie01_e54_qs;</pre>
<pre>  logic ie01_e54_wd;</pre>
<pre>  logic ie01_e54_we;</pre>
<pre>  logic ie01_e55_qs;</pre>
<pre>  logic ie01_e55_wd;</pre>
<pre>  logic ie01_e55_we;</pre>
<pre>  logic ie01_e56_qs;</pre>
<pre>  logic ie01_e56_wd;</pre>
<pre>  logic ie01_e56_we;</pre>
<pre>  logic ie01_e57_qs;</pre>
<pre>  logic ie01_e57_wd;</pre>
<pre>  logic ie01_e57_we;</pre>
<pre>  logic ie01_e58_qs;</pre>
<pre>  logic ie01_e58_wd;</pre>
<pre>  logic ie01_e58_we;</pre>
<pre>  logic ie01_e59_qs;</pre>
<pre>  logic ie01_e59_wd;</pre>
<pre>  logic ie01_e59_we;</pre>
<pre>  logic ie01_e60_qs;</pre>
<pre>  logic ie01_e60_wd;</pre>
<pre>  logic ie01_e60_we;</pre>
<pre>  logic ie01_e61_qs;</pre>
<pre>  logic ie01_e61_wd;</pre>
<pre>  logic ie01_e61_we;</pre>
<pre>  logic ie01_e62_qs;</pre>
<pre>  logic ie01_e62_wd;</pre>
<pre>  logic ie01_e62_we;</pre>
<pre>  logic [1:0] threshold0_qs;</pre>
<pre>  logic [1:0] threshold0_wd;</pre>
<pre>  logic threshold0_we;</pre>
<pre>  logic [5:0] cc0_qs;</pre>
<pre>  logic [5:0] cc0_wd;</pre>
<pre>  logic cc0_we;</pre>
<pre>  logic cc0_re;</pre>
<pre>  logic msip0_qs;</pre>
<pre>  logic msip0_wd;</pre>
<pre>  logic msip0_we;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[0].de),</pre>
<pre>    .d      (hw2reg.ip[0].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[1].de),</pre>
<pre>    .d      (hw2reg.ip[1].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[2].de),</pre>
<pre>    .d      (hw2reg.ip[2].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[3].de),</pre>
<pre>    .d      (hw2reg.ip[3].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[4].de),</pre>
<pre>    .d      (hw2reg.ip[4].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[5].de),</pre>
<pre>    .d      (hw2reg.ip[5].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[6].de),</pre>
<pre>    .d      (hw2reg.ip[6].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[7].de),</pre>
<pre>    .d      (hw2reg.ip[7].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[8].de),</pre>
<pre>    .d      (hw2reg.ip[8].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[9].de),</pre>
<pre>    .d      (hw2reg.ip[9].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[10].de),</pre>
<pre>    .d      (hw2reg.ip[10].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[11].de),</pre>
<pre>    .d      (hw2reg.ip[11].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p12 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[12].de),</pre>
<pre>    .d      (hw2reg.ip[12].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p12_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p13 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[13].de),</pre>
<pre>    .d      (hw2reg.ip[13].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p13_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p14 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[14].de),</pre>
<pre>    .d      (hw2reg.ip[14].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p14_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p15 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[15].de),</pre>
<pre>    .d      (hw2reg.ip[15].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p15_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p16 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[16].de),</pre>
<pre>    .d      (hw2reg.ip[16].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p16_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p17 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[17].de),</pre>
<pre>    .d      (hw2reg.ip[17].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p17_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p18 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[18].de),</pre>
<pre>    .d      (hw2reg.ip[18].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p18_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p19 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[19].de),</pre>
<pre>    .d      (hw2reg.ip[19].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p19_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p20 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[20].de),</pre>
<pre>    .d      (hw2reg.ip[20].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p20_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p21 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[21].de),</pre>
<pre>    .d      (hw2reg.ip[21].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p21_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p22 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[22].de),</pre>
<pre>    .d      (hw2reg.ip[22].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p22_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p23 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[23].de),</pre>
<pre>    .d      (hw2reg.ip[23].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p23_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p24 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[24].de),</pre>
<pre>    .d      (hw2reg.ip[24].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p24_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p25 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[25].de),</pre>
<pre>    .d      (hw2reg.ip[25].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p25_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p26 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[26].de),</pre>
<pre>    .d      (hw2reg.ip[26].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p26_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p27 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[27].de),</pre>
<pre>    .d      (hw2reg.ip[27].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p27_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p28 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[28].de),</pre>
<pre>    .d      (hw2reg.ip[28].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p28_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p29 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[29].de),</pre>
<pre>    .d      (hw2reg.ip[29].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p29_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p30 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[30].de),</pre>
<pre>    .d      (hw2reg.ip[30].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p30_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip0_p31 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[31].de),</pre>
<pre>    .d      (hw2reg.ip[31].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip0_p31_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p32 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[32].de),</pre>
<pre>    .d      (hw2reg.ip[32].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p32_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p33 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[33].de),</pre>
<pre>    .d      (hw2reg.ip[33].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p33_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p34 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[34].de),</pre>
<pre>    .d      (hw2reg.ip[34].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p34_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p35 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[35].de),</pre>
<pre>    .d      (hw2reg.ip[35].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p35_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p36 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[36].de),</pre>
<pre>    .d      (hw2reg.ip[36].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p36_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p37 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[37].de),</pre>
<pre>    .d      (hw2reg.ip[37].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p37_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p38 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[38].de),</pre>
<pre>    .d      (hw2reg.ip[38].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p38_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p39 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[39].de),</pre>
<pre>    .d      (hw2reg.ip[39].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p39_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p40 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[40].de),</pre>
<pre>    .d      (hw2reg.ip[40].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p40_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p41 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[41].de),</pre>
<pre>    .d      (hw2reg.ip[41].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p41_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p42 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[42].de),</pre>
<pre>    .d      (hw2reg.ip[42].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p42_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p43 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[43].de),</pre>
<pre>    .d      (hw2reg.ip[43].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p43_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p44 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[44].de),</pre>
<pre>    .d      (hw2reg.ip[44].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p44_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p45 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[45].de),</pre>
<pre>    .d      (hw2reg.ip[45].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p45_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p46 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[46].de),</pre>
<pre>    .d      (hw2reg.ip[46].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p46_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p47 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[47].de),</pre>
<pre>    .d      (hw2reg.ip[47].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p47_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p48 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[48].de),</pre>
<pre>    .d      (hw2reg.ip[48].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p48_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p49 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[49].de),</pre>
<pre>    .d      (hw2reg.ip[49].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p49_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p50 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[50].de),</pre>
<pre>    .d      (hw2reg.ip[50].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p50_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p51 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[51].de),</pre>
<pre>    .d      (hw2reg.ip[51].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p51_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p52 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[52].de),</pre>
<pre>    .d      (hw2reg.ip[52].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p52_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p53 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[53].de),</pre>
<pre>    .d      (hw2reg.ip[53].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p53_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p54 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[54].de),</pre>
<pre>    .d      (hw2reg.ip[54].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p54_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p55 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[55].de),</pre>
<pre>    .d      (hw2reg.ip[55].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p55_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p56 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[56].de),</pre>
<pre>    .d      (hw2reg.ip[56].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p56_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p57 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[57].de),</pre>
<pre>    .d      (hw2reg.ip[57].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p57_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p58 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[58].de),</pre>
<pre>    .d      (hw2reg.ip[58].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p58_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p59 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[59].de),</pre>
<pre>    .d      (hw2reg.ip[59].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p59_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p60 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[60].de),</pre>
<pre>    .d      (hw2reg.ip[60].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p60_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p61 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[61].de),</pre>
<pre>    .d      (hw2reg.ip[61].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p61_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ip1_p62 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.ip[62].de),</pre>
<pre>    .d      (hw2reg.ip[62].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (ip1_p62_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le0_we),</pre>
<pre>    .wd     (le0_le0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[0].q ),</pre>
<pre>    .qs     (le0_le0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le1_we),</pre>
<pre>    .wd     (le0_le1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[1].q ),</pre>
<pre>    .qs     (le0_le1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le2_we),</pre>
<pre>    .wd     (le0_le2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[2].q ),</pre>
<pre>    .qs     (le0_le2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le3_we),</pre>
<pre>    .wd     (le0_le3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[3].q ),</pre>
<pre>    .qs     (le0_le3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le4_we),</pre>
<pre>    .wd     (le0_le4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[4].q ),</pre>
<pre>    .qs     (le0_le4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le5_we),</pre>
<pre>    .wd     (le0_le5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[5].q ),</pre>
<pre>    .qs     (le0_le5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le6_we),</pre>
<pre>    .wd     (le0_le6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[6].q ),</pre>
<pre>    .qs     (le0_le6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le7_we),</pre>
<pre>    .wd     (le0_le7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[7].q ),</pre>
<pre>    .qs     (le0_le7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le8_we),</pre>
<pre>    .wd     (le0_le8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[8].q ),</pre>
<pre>    .qs     (le0_le8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le9_we),</pre>
<pre>    .wd     (le0_le9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[9].q ),</pre>
<pre>    .qs     (le0_le9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le10_we),</pre>
<pre>    .wd     (le0_le10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[10].q ),</pre>
<pre>    .qs     (le0_le10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le11_we),</pre>
<pre>    .wd     (le0_le11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[11].q ),</pre>
<pre>    .qs     (le0_le11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le12 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le12_we),</pre>
<pre>    .wd     (le0_le12_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[12].q ),</pre>
<pre>    .qs     (le0_le12_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le13 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le13_we),</pre>
<pre>    .wd     (le0_le13_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[13].q ),</pre>
<pre>    .qs     (le0_le13_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le14 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le14_we),</pre>
<pre>    .wd     (le0_le14_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[14].q ),</pre>
<pre>    .qs     (le0_le14_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le15 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le15_we),</pre>
<pre>    .wd     (le0_le15_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[15].q ),</pre>
<pre>    .qs     (le0_le15_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le16 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le16_we),</pre>
<pre>    .wd     (le0_le16_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[16].q ),</pre>
<pre>    .qs     (le0_le16_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le17 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le17_we),</pre>
<pre>    .wd     (le0_le17_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[17].q ),</pre>
<pre>    .qs     (le0_le17_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le18 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le18_we),</pre>
<pre>    .wd     (le0_le18_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[18].q ),</pre>
<pre>    .qs     (le0_le18_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le19 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le19_we),</pre>
<pre>    .wd     (le0_le19_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[19].q ),</pre>
<pre>    .qs     (le0_le19_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le20 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le20_we),</pre>
<pre>    .wd     (le0_le20_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[20].q ),</pre>
<pre>    .qs     (le0_le20_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le21 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le21_we),</pre>
<pre>    .wd     (le0_le21_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[21].q ),</pre>
<pre>    .qs     (le0_le21_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le22 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le22_we),</pre>
<pre>    .wd     (le0_le22_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[22].q ),</pre>
<pre>    .qs     (le0_le22_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le23 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le23_we),</pre>
<pre>    .wd     (le0_le23_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[23].q ),</pre>
<pre>    .qs     (le0_le23_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le24 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le24_we),</pre>
<pre>    .wd     (le0_le24_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[24].q ),</pre>
<pre>    .qs     (le0_le24_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le25 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le25_we),</pre>
<pre>    .wd     (le0_le25_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[25].q ),</pre>
<pre>    .qs     (le0_le25_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le26 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le26_we),</pre>
<pre>    .wd     (le0_le26_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[26].q ),</pre>
<pre>    .qs     (le0_le26_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le27 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le27_we),</pre>
<pre>    .wd     (le0_le27_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[27].q ),</pre>
<pre>    .qs     (le0_le27_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le28 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le28_we),</pre>
<pre>    .wd     (le0_le28_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[28].q ),</pre>
<pre>    .qs     (le0_le28_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le29 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le29_we),</pre>
<pre>    .wd     (le0_le29_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[29].q ),</pre>
<pre>    .qs     (le0_le29_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le30 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le30_we),</pre>
<pre>    .wd     (le0_le30_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[30].q ),</pre>
<pre>    .qs     (le0_le30_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le0_le31 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le0_le31_we),</pre>
<pre>    .wd     (le0_le31_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[31].q ),</pre>
<pre>    .qs     (le0_le31_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le32 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le32_we),</pre>
<pre>    .wd     (le1_le32_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[32].q ),</pre>
<pre>    .qs     (le1_le32_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le33 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le33_we),</pre>
<pre>    .wd     (le1_le33_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[33].q ),</pre>
<pre>    .qs     (le1_le33_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le34 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le34_we),</pre>
<pre>    .wd     (le1_le34_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[34].q ),</pre>
<pre>    .qs     (le1_le34_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le35 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le35_we),</pre>
<pre>    .wd     (le1_le35_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[35].q ),</pre>
<pre>    .qs     (le1_le35_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le36 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le36_we),</pre>
<pre>    .wd     (le1_le36_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[36].q ),</pre>
<pre>    .qs     (le1_le36_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le37 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le37_we),</pre>
<pre>    .wd     (le1_le37_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[37].q ),</pre>
<pre>    .qs     (le1_le37_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le38 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le38_we),</pre>
<pre>    .wd     (le1_le38_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[38].q ),</pre>
<pre>    .qs     (le1_le38_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le39 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le39_we),</pre>
<pre>    .wd     (le1_le39_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[39].q ),</pre>
<pre>    .qs     (le1_le39_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le40 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le40_we),</pre>
<pre>    .wd     (le1_le40_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[40].q ),</pre>
<pre>    .qs     (le1_le40_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le41 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le41_we),</pre>
<pre>    .wd     (le1_le41_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[41].q ),</pre>
<pre>    .qs     (le1_le41_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le42 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le42_we),</pre>
<pre>    .wd     (le1_le42_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[42].q ),</pre>
<pre>    .qs     (le1_le42_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le43 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le43_we),</pre>
<pre>    .wd     (le1_le43_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[43].q ),</pre>
<pre>    .qs     (le1_le43_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le44 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le44_we),</pre>
<pre>    .wd     (le1_le44_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[44].q ),</pre>
<pre>    .qs     (le1_le44_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le45 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le45_we),</pre>
<pre>    .wd     (le1_le45_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[45].q ),</pre>
<pre>    .qs     (le1_le45_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le46 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le46_we),</pre>
<pre>    .wd     (le1_le46_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[46].q ),</pre>
<pre>    .qs     (le1_le46_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le47 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le47_we),</pre>
<pre>    .wd     (le1_le47_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[47].q ),</pre>
<pre>    .qs     (le1_le47_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le48 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le48_we),</pre>
<pre>    .wd     (le1_le48_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[48].q ),</pre>
<pre>    .qs     (le1_le48_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le49 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le49_we),</pre>
<pre>    .wd     (le1_le49_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[49].q ),</pre>
<pre>    .qs     (le1_le49_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le50 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le50_we),</pre>
<pre>    .wd     (le1_le50_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[50].q ),</pre>
<pre>    .qs     (le1_le50_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le51 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le51_we),</pre>
<pre>    .wd     (le1_le51_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[51].q ),</pre>
<pre>    .qs     (le1_le51_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le52 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le52_we),</pre>
<pre>    .wd     (le1_le52_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[52].q ),</pre>
<pre>    .qs     (le1_le52_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le53 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le53_we),</pre>
<pre>    .wd     (le1_le53_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[53].q ),</pre>
<pre>    .qs     (le1_le53_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le54 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le54_we),</pre>
<pre>    .wd     (le1_le54_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[54].q ),</pre>
<pre>    .qs     (le1_le54_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le55 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le55_we),</pre>
<pre>    .wd     (le1_le55_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[55].q ),</pre>
<pre>    .qs     (le1_le55_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le56 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le56_we),</pre>
<pre>    .wd     (le1_le56_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[56].q ),</pre>
<pre>    .qs     (le1_le56_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le57 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le57_we),</pre>
<pre>    .wd     (le1_le57_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[57].q ),</pre>
<pre>    .qs     (le1_le57_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le58 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le58_we),</pre>
<pre>    .wd     (le1_le58_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[58].q ),</pre>
<pre>    .qs     (le1_le58_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le59 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le59_we),</pre>
<pre>    .wd     (le1_le59_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[59].q ),</pre>
<pre>    .qs     (le1_le59_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le60 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le60_we),</pre>
<pre>    .wd     (le1_le60_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[60].q ),</pre>
<pre>    .qs     (le1_le60_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le61 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le61_we),</pre>
<pre>    .wd     (le1_le61_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[61].q ),</pre>
<pre>    .qs     (le1_le61_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_le1_le62 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (le1_le62_we),</pre>
<pre>    .wd     (le1_le62_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.le[62].q ),</pre>
<pre>    .qs     (le1_le62_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio0_we),</pre>
<pre>    .wd     (prio0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio0.q ),</pre>
<pre>    .qs     (prio0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio1_we),</pre>
<pre>    .wd     (prio1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio1.q ),</pre>
<pre>    .qs     (prio1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio2_we),</pre>
<pre>    .wd     (prio2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio2.q ),</pre>
<pre>    .qs     (prio2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio3_we),</pre>
<pre>    .wd     (prio3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio3.q ),</pre>
<pre>    .qs     (prio3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio4_we),</pre>
<pre>    .wd     (prio4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio4.q ),</pre>
<pre>    .qs     (prio4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio5_we),</pre>
<pre>    .wd     (prio5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio5.q ),</pre>
<pre>    .qs     (prio5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio6_we),</pre>
<pre>    .wd     (prio6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio6.q ),</pre>
<pre>    .qs     (prio6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio7_we),</pre>
<pre>    .wd     (prio7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio7.q ),</pre>
<pre>    .qs     (prio7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio8_we),</pre>
<pre>    .wd     (prio8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio8.q ),</pre>
<pre>    .qs     (prio8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio9_we),</pre>
<pre>    .wd     (prio9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio9.q ),</pre>
<pre>    .qs     (prio9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio10_we),</pre>
<pre>    .wd     (prio10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio10.q ),</pre>
<pre>    .qs     (prio10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio11_we),</pre>
<pre>    .wd     (prio11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio11.q ),</pre>
<pre>    .qs     (prio11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio12 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio12_we),</pre>
<pre>    .wd     (prio12_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio12.q ),</pre>
<pre>    .qs     (prio12_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio13 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio13_we),</pre>
<pre>    .wd     (prio13_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio13.q ),</pre>
<pre>    .qs     (prio13_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio14 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio14_we),</pre>
<pre>    .wd     (prio14_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio14.q ),</pre>
<pre>    .qs     (prio14_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio15 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio15_we),</pre>
<pre>    .wd     (prio15_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio15.q ),</pre>
<pre>    .qs     (prio15_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio16 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio16_we),</pre>
<pre>    .wd     (prio16_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio16.q ),</pre>
<pre>    .qs     (prio16_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio17 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio17_we),</pre>
<pre>    .wd     (prio17_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio17.q ),</pre>
<pre>    .qs     (prio17_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio18 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio18_we),</pre>
<pre>    .wd     (prio18_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio18.q ),</pre>
<pre>    .qs     (prio18_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio19 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio19_we),</pre>
<pre>    .wd     (prio19_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio19.q ),</pre>
<pre>    .qs     (prio19_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio20 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio20_we),</pre>
<pre>    .wd     (prio20_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio20.q ),</pre>
<pre>    .qs     (prio20_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio21 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio21_we),</pre>
<pre>    .wd     (prio21_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio21.q ),</pre>
<pre>    .qs     (prio21_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio22 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio22_we),</pre>
<pre>    .wd     (prio22_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio22.q ),</pre>
<pre>    .qs     (prio22_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio23 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio23_we),</pre>
<pre>    .wd     (prio23_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio23.q ),</pre>
<pre>    .qs     (prio23_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio24 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio24_we),</pre>
<pre>    .wd     (prio24_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio24.q ),</pre>
<pre>    .qs     (prio24_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio25 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio25_we),</pre>
<pre>    .wd     (prio25_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio25.q ),</pre>
<pre>    .qs     (prio25_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio26 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio26_we),</pre>
<pre>    .wd     (prio26_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio26.q ),</pre>
<pre>    .qs     (prio26_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio27 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio27_we),</pre>
<pre>    .wd     (prio27_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio27.q ),</pre>
<pre>    .qs     (prio27_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio28 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio28_we),</pre>
<pre>    .wd     (prio28_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio28.q ),</pre>
<pre>    .qs     (prio28_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio29 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio29_we),</pre>
<pre>    .wd     (prio29_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio29.q ),</pre>
<pre>    .qs     (prio29_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio30 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio30_we),</pre>
<pre>    .wd     (prio30_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio30.q ),</pre>
<pre>    .qs     (prio30_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio31 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio31_we),</pre>
<pre>    .wd     (prio31_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio31.q ),</pre>
<pre>    .qs     (prio31_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio32 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio32_we),</pre>
<pre>    .wd     (prio32_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio32.q ),</pre>
<pre>    .qs     (prio32_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio33 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio33_we),</pre>
<pre>    .wd     (prio33_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio33.q ),</pre>
<pre>    .qs     (prio33_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio34 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio34_we),</pre>
<pre>    .wd     (prio34_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio34.q ),</pre>
<pre>    .qs     (prio34_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio35 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio35_we),</pre>
<pre>    .wd     (prio35_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio35.q ),</pre>
<pre>    .qs     (prio35_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio36 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio36_we),</pre>
<pre>    .wd     (prio36_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio36.q ),</pre>
<pre>    .qs     (prio36_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio37 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio37_we),</pre>
<pre>    .wd     (prio37_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio37.q ),</pre>
<pre>    .qs     (prio37_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio38 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio38_we),</pre>
<pre>    .wd     (prio38_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio38.q ),</pre>
<pre>    .qs     (prio38_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio39 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio39_we),</pre>
<pre>    .wd     (prio39_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio39.q ),</pre>
<pre>    .qs     (prio39_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio40 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio40_we),</pre>
<pre>    .wd     (prio40_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio40.q ),</pre>
<pre>    .qs     (prio40_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio41 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio41_we),</pre>
<pre>    .wd     (prio41_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio41.q ),</pre>
<pre>    .qs     (prio41_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio42 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio42_we),</pre>
<pre>    .wd     (prio42_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio42.q ),</pre>
<pre>    .qs     (prio42_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio43 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio43_we),</pre>
<pre>    .wd     (prio43_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio43.q ),</pre>
<pre>    .qs     (prio43_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio44 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio44_we),</pre>
<pre>    .wd     (prio44_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio44.q ),</pre>
<pre>    .qs     (prio44_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio45 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio45_we),</pre>
<pre>    .wd     (prio45_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio45.q ),</pre>
<pre>    .qs     (prio45_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio46 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio46_we),</pre>
<pre>    .wd     (prio46_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio46.q ),</pre>
<pre>    .qs     (prio46_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio47 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio47_we),</pre>
<pre>    .wd     (prio47_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio47.q ),</pre>
<pre>    .qs     (prio47_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio48 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio48_we),</pre>
<pre>    .wd     (prio48_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio48.q ),</pre>
<pre>    .qs     (prio48_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio49 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio49_we),</pre>
<pre>    .wd     (prio49_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio49.q ),</pre>
<pre>    .qs     (prio49_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio50 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio50_we),</pre>
<pre>    .wd     (prio50_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio50.q ),</pre>
<pre>    .qs     (prio50_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio51 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio51_we),</pre>
<pre>    .wd     (prio51_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio51.q ),</pre>
<pre>    .qs     (prio51_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio52 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio52_we),</pre>
<pre>    .wd     (prio52_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio52.q ),</pre>
<pre>    .qs     (prio52_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio53 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio53_we),</pre>
<pre>    .wd     (prio53_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio53.q ),</pre>
<pre>    .qs     (prio53_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio54 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio54_we),</pre>
<pre>    .wd     (prio54_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio54.q ),</pre>
<pre>    .qs     (prio54_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio55 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio55_we),</pre>
<pre>    .wd     (prio55_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio55.q ),</pre>
<pre>    .qs     (prio55_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio56 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio56_we),</pre>
<pre>    .wd     (prio56_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio56.q ),</pre>
<pre>    .qs     (prio56_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio57 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio57_we),</pre>
<pre>    .wd     (prio57_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio57.q ),</pre>
<pre>    .qs     (prio57_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio58 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio58_we),</pre>
<pre>    .wd     (prio58_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio58.q ),</pre>
<pre>    .qs     (prio58_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio59 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio59_we),</pre>
<pre>    .wd     (prio59_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio59.q ),</pre>
<pre>    .qs     (prio59_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio60 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio60_we),</pre>
<pre>    .wd     (prio60_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio60.q ),</pre>
<pre>    .qs     (prio60_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio61 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio61_we),</pre>
<pre>    .wd     (prio61_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio61.q ),</pre>
<pre>    .qs     (prio61_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_prio62 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (prio62_we),</pre>
<pre>    .wd     (prio62_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.prio62.q ),</pre>
<pre>    .qs     (prio62_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e0_we),</pre>
<pre>    .wd     (ie00_e0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[0].q ),</pre>
<pre>    .qs     (ie00_e0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e1_we),</pre>
<pre>    .wd     (ie00_e1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[1].q ),</pre>
<pre>    .qs     (ie00_e1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e2_we),</pre>
<pre>    .wd     (ie00_e2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[2].q ),</pre>
<pre>    .qs     (ie00_e2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e3_we),</pre>
<pre>    .wd     (ie00_e3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[3].q ),</pre>
<pre>    .qs     (ie00_e3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e4_we),</pre>
<pre>    .wd     (ie00_e4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[4].q ),</pre>
<pre>    .qs     (ie00_e4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e5_we),</pre>
<pre>    .wd     (ie00_e5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[5].q ),</pre>
<pre>    .qs     (ie00_e5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e6_we),</pre>
<pre>    .wd     (ie00_e6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[6].q ),</pre>
<pre>    .qs     (ie00_e6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e7_we),</pre>
<pre>    .wd     (ie00_e7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[7].q ),</pre>
<pre>    .qs     (ie00_e7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e8_we),</pre>
<pre>    .wd     (ie00_e8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[8].q ),</pre>
<pre>    .qs     (ie00_e8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e9_we),</pre>
<pre>    .wd     (ie00_e9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[9].q ),</pre>
<pre>    .qs     (ie00_e9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e10_we),</pre>
<pre>    .wd     (ie00_e10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[10].q ),</pre>
<pre>    .qs     (ie00_e10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e11_we),</pre>
<pre>    .wd     (ie00_e11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[11].q ),</pre>
<pre>    .qs     (ie00_e11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e12 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e12_we),</pre>
<pre>    .wd     (ie00_e12_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[12].q ),</pre>
<pre>    .qs     (ie00_e12_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e13 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e13_we),</pre>
<pre>    .wd     (ie00_e13_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[13].q ),</pre>
<pre>    .qs     (ie00_e13_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e14 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e14_we),</pre>
<pre>    .wd     (ie00_e14_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[14].q ),</pre>
<pre>    .qs     (ie00_e14_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e15 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e15_we),</pre>
<pre>    .wd     (ie00_e15_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[15].q ),</pre>
<pre>    .qs     (ie00_e15_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e16 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e16_we),</pre>
<pre>    .wd     (ie00_e16_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[16].q ),</pre>
<pre>    .qs     (ie00_e16_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e17 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e17_we),</pre>
<pre>    .wd     (ie00_e17_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[17].q ),</pre>
<pre>    .qs     (ie00_e17_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e18 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e18_we),</pre>
<pre>    .wd     (ie00_e18_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[18].q ),</pre>
<pre>    .qs     (ie00_e18_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e19 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e19_we),</pre>
<pre>    .wd     (ie00_e19_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[19].q ),</pre>
<pre>    .qs     (ie00_e19_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e20 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e20_we),</pre>
<pre>    .wd     (ie00_e20_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[20].q ),</pre>
<pre>    .qs     (ie00_e20_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e21 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e21_we),</pre>
<pre>    .wd     (ie00_e21_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[21].q ),</pre>
<pre>    .qs     (ie00_e21_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e22 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e22_we),</pre>
<pre>    .wd     (ie00_e22_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[22].q ),</pre>
<pre>    .qs     (ie00_e22_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e23 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e23_we),</pre>
<pre>    .wd     (ie00_e23_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[23].q ),</pre>
<pre>    .qs     (ie00_e23_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e24 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e24_we),</pre>
<pre>    .wd     (ie00_e24_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[24].q ),</pre>
<pre>    .qs     (ie00_e24_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e25 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e25_we),</pre>
<pre>    .wd     (ie00_e25_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[25].q ),</pre>
<pre>    .qs     (ie00_e25_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e26 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e26_we),</pre>
<pre>    .wd     (ie00_e26_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[26].q ),</pre>
<pre>    .qs     (ie00_e26_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e27 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e27_we),</pre>
<pre>    .wd     (ie00_e27_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[27].q ),</pre>
<pre>    .qs     (ie00_e27_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e28 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e28_we),</pre>
<pre>    .wd     (ie00_e28_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[28].q ),</pre>
<pre>    .qs     (ie00_e28_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e29 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e29_we),</pre>
<pre>    .wd     (ie00_e29_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[29].q ),</pre>
<pre>    .qs     (ie00_e29_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e30 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e30_we),</pre>
<pre>    .wd     (ie00_e30_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[30].q ),</pre>
<pre>    .qs     (ie00_e30_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie00_e31 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie00_e31_we),</pre>
<pre>    .wd     (ie00_e31_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[31].q ),</pre>
<pre>    .qs     (ie00_e31_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e32 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e32_we),</pre>
<pre>    .wd     (ie01_e32_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[32].q ),</pre>
<pre>    .qs     (ie01_e32_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e33 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e33_we),</pre>
<pre>    .wd     (ie01_e33_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[33].q ),</pre>
<pre>    .qs     (ie01_e33_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e34 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e34_we),</pre>
<pre>    .wd     (ie01_e34_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[34].q ),</pre>
<pre>    .qs     (ie01_e34_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e35 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e35_we),</pre>
<pre>    .wd     (ie01_e35_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[35].q ),</pre>
<pre>    .qs     (ie01_e35_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e36 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e36_we),</pre>
<pre>    .wd     (ie01_e36_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[36].q ),</pre>
<pre>    .qs     (ie01_e36_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e37 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e37_we),</pre>
<pre>    .wd     (ie01_e37_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[37].q ),</pre>
<pre>    .qs     (ie01_e37_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e38 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e38_we),</pre>
<pre>    .wd     (ie01_e38_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[38].q ),</pre>
<pre>    .qs     (ie01_e38_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e39 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e39_we),</pre>
<pre>    .wd     (ie01_e39_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[39].q ),</pre>
<pre>    .qs     (ie01_e39_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e40 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e40_we),</pre>
<pre>    .wd     (ie01_e40_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[40].q ),</pre>
<pre>    .qs     (ie01_e40_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e41 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e41_we),</pre>
<pre>    .wd     (ie01_e41_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[41].q ),</pre>
<pre>    .qs     (ie01_e41_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e42 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e42_we),</pre>
<pre>    .wd     (ie01_e42_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[42].q ),</pre>
<pre>    .qs     (ie01_e42_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e43 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e43_we),</pre>
<pre>    .wd     (ie01_e43_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[43].q ),</pre>
<pre>    .qs     (ie01_e43_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e44 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e44_we),</pre>
<pre>    .wd     (ie01_e44_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[44].q ),</pre>
<pre>    .qs     (ie01_e44_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e45 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e45_we),</pre>
<pre>    .wd     (ie01_e45_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[45].q ),</pre>
<pre>    .qs     (ie01_e45_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e46 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e46_we),</pre>
<pre>    .wd     (ie01_e46_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[46].q ),</pre>
<pre>    .qs     (ie01_e46_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e47 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e47_we),</pre>
<pre>    .wd     (ie01_e47_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[47].q ),</pre>
<pre>    .qs     (ie01_e47_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e48 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e48_we),</pre>
<pre>    .wd     (ie01_e48_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[48].q ),</pre>
<pre>    .qs     (ie01_e48_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e49 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e49_we),</pre>
<pre>    .wd     (ie01_e49_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[49].q ),</pre>
<pre>    .qs     (ie01_e49_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e50 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e50_we),</pre>
<pre>    .wd     (ie01_e50_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[50].q ),</pre>
<pre>    .qs     (ie01_e50_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e51 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e51_we),</pre>
<pre>    .wd     (ie01_e51_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[51].q ),</pre>
<pre>    .qs     (ie01_e51_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e52 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e52_we),</pre>
<pre>    .wd     (ie01_e52_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[52].q ),</pre>
<pre>    .qs     (ie01_e52_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e53 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e53_we),</pre>
<pre>    .wd     (ie01_e53_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[53].q ),</pre>
<pre>    .qs     (ie01_e53_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e54 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e54_we),</pre>
<pre>    .wd     (ie01_e54_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[54].q ),</pre>
<pre>    .qs     (ie01_e54_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e55 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e55_we),</pre>
<pre>    .wd     (ie01_e55_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[55].q ),</pre>
<pre>    .qs     (ie01_e55_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e56 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e56_we),</pre>
<pre>    .wd     (ie01_e56_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[56].q ),</pre>
<pre>    .qs     (ie01_e56_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e57 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e57_we),</pre>
<pre>    .wd     (ie01_e57_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[57].q ),</pre>
<pre>    .qs     (ie01_e57_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e58 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e58_we),</pre>
<pre>    .wd     (ie01_e58_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[58].q ),</pre>
<pre>    .qs     (ie01_e58_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e59 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e59_we),</pre>
<pre>    .wd     (ie01_e59_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[59].q ),</pre>
<pre>    .qs     (ie01_e59_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e60 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e60_we),</pre>
<pre>    .wd     (ie01_e60_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[60].q ),</pre>
<pre>    .qs     (ie01_e60_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e61 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e61_we),</pre>
<pre>    .wd     (ie01_e61_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[61].q ),</pre>
<pre>    .qs     (ie01_e61_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ie01_e62 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ie01_e62_we),</pre>
<pre>    .wd     (ie01_e62_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ie0[62].q ),</pre>
<pre>    .qs     (ie01_e62_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_threshold0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (threshold0_we),</pre>
<pre>    .wd     (threshold0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.threshold0.q ),</pre>
<pre>    .qs     (threshold0_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (6)</pre>
<pre style="background-color: #FF0000;">  ) u_cc0 (</pre>
<pre>    .re     (cc0_re),</pre>
<pre>    .we     (cc0_we),</pre>
<pre>    .wd     (cc0_wd),</pre>
<pre>    .d      (hw2reg.cc0.d),</pre>
<pre>    .qre    (reg2hw.cc0.re),</pre>
<pre>    .qe     (reg2hw.cc0.qe),</pre>
<pre>    .q      (reg2hw.cc0.q ),</pre>
<pre>    .qs     (cc0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_msip0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (msip0_we),</pre>
<pre>    .wd     (msip0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.msip0.q ),</pre>
<pre>    .qs     (msip0_qs)</pre>
<pre>  logic [71:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[ 0] = (reg_addr == RV_PLIC_IP0_OFFSET);</pre>
<pre>    addr_hit[ 1] = (reg_addr == RV_PLIC_IP1_OFFSET);</pre>
<pre>    addr_hit[ 2] = (reg_addr == RV_PLIC_LE0_OFFSET);</pre>
<pre>    addr_hit[ 3] = (reg_addr == RV_PLIC_LE1_OFFSET);</pre>
<pre>    addr_hit[ 4] = (reg_addr == RV_PLIC_PRIO0_OFFSET);</pre>
<pre>    addr_hit[ 5] = (reg_addr == RV_PLIC_PRIO1_OFFSET);</pre>
<pre>    addr_hit[ 6] = (reg_addr == RV_PLIC_PRIO2_OFFSET);</pre>
<pre>    addr_hit[ 7] = (reg_addr == RV_PLIC_PRIO3_OFFSET);</pre>
<pre>    addr_hit[ 8] = (reg_addr == RV_PLIC_PRIO4_OFFSET);</pre>
<pre>    addr_hit[ 9] = (reg_addr == RV_PLIC_PRIO5_OFFSET);</pre>
<pre>    addr_hit[10] = (reg_addr == RV_PLIC_PRIO6_OFFSET);</pre>
<pre>    addr_hit[11] = (reg_addr == RV_PLIC_PRIO7_OFFSET);</pre>
<pre>    addr_hit[12] = (reg_addr == RV_PLIC_PRIO8_OFFSET);</pre>
<pre>    addr_hit[13] = (reg_addr == RV_PLIC_PRIO9_OFFSET);</pre>
<pre>    addr_hit[14] = (reg_addr == RV_PLIC_PRIO10_OFFSET);</pre>
<pre>    addr_hit[15] = (reg_addr == RV_PLIC_PRIO11_OFFSET);</pre>
<pre>    addr_hit[16] = (reg_addr == RV_PLIC_PRIO12_OFFSET);</pre>
<pre>    addr_hit[17] = (reg_addr == RV_PLIC_PRIO13_OFFSET);</pre>
<pre>    addr_hit[18] = (reg_addr == RV_PLIC_PRIO14_OFFSET);</pre>
<pre>    addr_hit[19] = (reg_addr == RV_PLIC_PRIO15_OFFSET);</pre>
<pre>    addr_hit[20] = (reg_addr == RV_PLIC_PRIO16_OFFSET);</pre>
<pre>    addr_hit[21] = (reg_addr == RV_PLIC_PRIO17_OFFSET);</pre>
<pre>    addr_hit[22] = (reg_addr == RV_PLIC_PRIO18_OFFSET);</pre>
<pre>    addr_hit[23] = (reg_addr == RV_PLIC_PRIO19_OFFSET);</pre>
<pre>    addr_hit[24] = (reg_addr == RV_PLIC_PRIO20_OFFSET);</pre>
<pre>    addr_hit[25] = (reg_addr == RV_PLIC_PRIO21_OFFSET);</pre>
<pre>    addr_hit[26] = (reg_addr == RV_PLIC_PRIO22_OFFSET);</pre>
<pre>    addr_hit[27] = (reg_addr == RV_PLIC_PRIO23_OFFSET);</pre>
<pre>    addr_hit[28] = (reg_addr == RV_PLIC_PRIO24_OFFSET);</pre>
<pre>    addr_hit[29] = (reg_addr == RV_PLIC_PRIO25_OFFSET);</pre>
<pre>    addr_hit[30] = (reg_addr == RV_PLIC_PRIO26_OFFSET);</pre>
<pre>    addr_hit[31] = (reg_addr == RV_PLIC_PRIO27_OFFSET);</pre>
<pre>    addr_hit[32] = (reg_addr == RV_PLIC_PRIO28_OFFSET);</pre>
<pre>    addr_hit[33] = (reg_addr == RV_PLIC_PRIO29_OFFSET);</pre>
<pre>    addr_hit[34] = (reg_addr == RV_PLIC_PRIO30_OFFSET);</pre>
<pre>    addr_hit[35] = (reg_addr == RV_PLIC_PRIO31_OFFSET);</pre>
<pre>    addr_hit[36] = (reg_addr == RV_PLIC_PRIO32_OFFSET);</pre>
<pre>    addr_hit[37] = (reg_addr == RV_PLIC_PRIO33_OFFSET);</pre>
<pre>    addr_hit[38] = (reg_addr == RV_PLIC_PRIO34_OFFSET);</pre>
<pre>    addr_hit[39] = (reg_addr == RV_PLIC_PRIO35_OFFSET);</pre>
<pre>    addr_hit[40] = (reg_addr == RV_PLIC_PRIO36_OFFSET);</pre>
<pre>    addr_hit[41] = (reg_addr == RV_PLIC_PRIO37_OFFSET);</pre>
<pre>    addr_hit[42] = (reg_addr == RV_PLIC_PRIO38_OFFSET);</pre>
<pre>    addr_hit[43] = (reg_addr == RV_PLIC_PRIO39_OFFSET);</pre>
<pre>    addr_hit[44] = (reg_addr == RV_PLIC_PRIO40_OFFSET);</pre>
<pre>    addr_hit[45] = (reg_addr == RV_PLIC_PRIO41_OFFSET);</pre>
<pre>    addr_hit[46] = (reg_addr == RV_PLIC_PRIO42_OFFSET);</pre>
<pre>    addr_hit[47] = (reg_addr == RV_PLIC_PRIO43_OFFSET);</pre>
<pre>    addr_hit[48] = (reg_addr == RV_PLIC_PRIO44_OFFSET);</pre>
<pre>    addr_hit[49] = (reg_addr == RV_PLIC_PRIO45_OFFSET);</pre>
<pre>    addr_hit[50] = (reg_addr == RV_PLIC_PRIO46_OFFSET);</pre>
<pre>    addr_hit[51] = (reg_addr == RV_PLIC_PRIO47_OFFSET);</pre>
<pre>    addr_hit[52] = (reg_addr == RV_PLIC_PRIO48_OFFSET);</pre>
<pre>    addr_hit[53] = (reg_addr == RV_PLIC_PRIO49_OFFSET);</pre>
<pre>    addr_hit[54] = (reg_addr == RV_PLIC_PRIO50_OFFSET);</pre>
<pre>    addr_hit[55] = (reg_addr == RV_PLIC_PRIO51_OFFSET);</pre>
<pre>    addr_hit[56] = (reg_addr == RV_PLIC_PRIO52_OFFSET);</pre>
<pre>    addr_hit[57] = (reg_addr == RV_PLIC_PRIO53_OFFSET);</pre>
<pre>    addr_hit[58] = (reg_addr == RV_PLIC_PRIO54_OFFSET);</pre>
<pre>    addr_hit[59] = (reg_addr == RV_PLIC_PRIO55_OFFSET);</pre>
<pre>    addr_hit[60] = (reg_addr == RV_PLIC_PRIO56_OFFSET);</pre>
<pre>    addr_hit[61] = (reg_addr == RV_PLIC_PRIO57_OFFSET);</pre>
<pre>    addr_hit[62] = (reg_addr == RV_PLIC_PRIO58_OFFSET);</pre>
<pre>    addr_hit[63] = (reg_addr == RV_PLIC_PRIO59_OFFSET);</pre>
<pre>    addr_hit[64] = (reg_addr == RV_PLIC_PRIO60_OFFSET);</pre>
<pre>    addr_hit[65] = (reg_addr == RV_PLIC_PRIO61_OFFSET);</pre>
<pre>    addr_hit[66] = (reg_addr == RV_PLIC_PRIO62_OFFSET);</pre>
<pre>    addr_hit[67] = (reg_addr == RV_PLIC_IE00_OFFSET);</pre>
<pre>    addr_hit[68] = (reg_addr == RV_PLIC_IE01_OFFSET);</pre>
<pre>    addr_hit[69] = (reg_addr == RV_PLIC_THRESHOLD0_OFFSET);</pre>
<pre>    addr_hit[70] = (reg_addr == RV_PLIC_CC0_OFFSET);</pre>
<pre>    addr_hit[71] = (reg_addr == RV_PLIC_MSIP0_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[ 0] && reg_we && (RV_PLIC_PERMIT[ 0] != (RV_PLIC_PERMIT[ 0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 1] && reg_we && (RV_PLIC_PERMIT[ 1] != (RV_PLIC_PERMIT[ 1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 2] && reg_we && (RV_PLIC_PERMIT[ 2] != (RV_PLIC_PERMIT[ 2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 3] && reg_we && (RV_PLIC_PERMIT[ 3] != (RV_PLIC_PERMIT[ 3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 4] && reg_we && (RV_PLIC_PERMIT[ 4] != (RV_PLIC_PERMIT[ 4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 5] && reg_we && (RV_PLIC_PERMIT[ 5] != (RV_PLIC_PERMIT[ 5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 6] && reg_we && (RV_PLIC_PERMIT[ 6] != (RV_PLIC_PERMIT[ 6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 7] && reg_we && (RV_PLIC_PERMIT[ 7] != (RV_PLIC_PERMIT[ 7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 8] && reg_we && (RV_PLIC_PERMIT[ 8] != (RV_PLIC_PERMIT[ 8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 9] && reg_we && (RV_PLIC_PERMIT[ 9] != (RV_PLIC_PERMIT[ 9] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[10] && reg_we && (RV_PLIC_PERMIT[10] != (RV_PLIC_PERMIT[10] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[11] && reg_we && (RV_PLIC_PERMIT[11] != (RV_PLIC_PERMIT[11] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[12] && reg_we && (RV_PLIC_PERMIT[12] != (RV_PLIC_PERMIT[12] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[13] && reg_we && (RV_PLIC_PERMIT[13] != (RV_PLIC_PERMIT[13] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[14] && reg_we && (RV_PLIC_PERMIT[14] != (RV_PLIC_PERMIT[14] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[15] && reg_we && (RV_PLIC_PERMIT[15] != (RV_PLIC_PERMIT[15] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[16] && reg_we && (RV_PLIC_PERMIT[16] != (RV_PLIC_PERMIT[16] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[17] && reg_we && (RV_PLIC_PERMIT[17] != (RV_PLIC_PERMIT[17] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[18] && reg_we && (RV_PLIC_PERMIT[18] != (RV_PLIC_PERMIT[18] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[19] && reg_we && (RV_PLIC_PERMIT[19] != (RV_PLIC_PERMIT[19] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[20] && reg_we && (RV_PLIC_PERMIT[20] != (RV_PLIC_PERMIT[20] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[21] && reg_we && (RV_PLIC_PERMIT[21] != (RV_PLIC_PERMIT[21] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[22] && reg_we && (RV_PLIC_PERMIT[22] != (RV_PLIC_PERMIT[22] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[23] && reg_we && (RV_PLIC_PERMIT[23] != (RV_PLIC_PERMIT[23] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[24] && reg_we && (RV_PLIC_PERMIT[24] != (RV_PLIC_PERMIT[24] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[25] && reg_we && (RV_PLIC_PERMIT[25] != (RV_PLIC_PERMIT[25] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[26] && reg_we && (RV_PLIC_PERMIT[26] != (RV_PLIC_PERMIT[26] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[27] && reg_we && (RV_PLIC_PERMIT[27] != (RV_PLIC_PERMIT[27] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[28] && reg_we && (RV_PLIC_PERMIT[28] != (RV_PLIC_PERMIT[28] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[29] && reg_we && (RV_PLIC_PERMIT[29] != (RV_PLIC_PERMIT[29] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[30] && reg_we && (RV_PLIC_PERMIT[30] != (RV_PLIC_PERMIT[30] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[31] && reg_we && (RV_PLIC_PERMIT[31] != (RV_PLIC_PERMIT[31] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[32] && reg_we && (RV_PLIC_PERMIT[32] != (RV_PLIC_PERMIT[32] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[33] && reg_we && (RV_PLIC_PERMIT[33] != (RV_PLIC_PERMIT[33] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[34] && reg_we && (RV_PLIC_PERMIT[34] != (RV_PLIC_PERMIT[34] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[35] && reg_we && (RV_PLIC_PERMIT[35] != (RV_PLIC_PERMIT[35] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[36] && reg_we && (RV_PLIC_PERMIT[36] != (RV_PLIC_PERMIT[36] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[37] && reg_we && (RV_PLIC_PERMIT[37] != (RV_PLIC_PERMIT[37] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[38] && reg_we && (RV_PLIC_PERMIT[38] != (RV_PLIC_PERMIT[38] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[39] && reg_we && (RV_PLIC_PERMIT[39] != (RV_PLIC_PERMIT[39] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[40] && reg_we && (RV_PLIC_PERMIT[40] != (RV_PLIC_PERMIT[40] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[41] && reg_we && (RV_PLIC_PERMIT[41] != (RV_PLIC_PERMIT[41] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[42] && reg_we && (RV_PLIC_PERMIT[42] != (RV_PLIC_PERMIT[42] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[43] && reg_we && (RV_PLIC_PERMIT[43] != (RV_PLIC_PERMIT[43] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[44] && reg_we && (RV_PLIC_PERMIT[44] != (RV_PLIC_PERMIT[44] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[45] && reg_we && (RV_PLIC_PERMIT[45] != (RV_PLIC_PERMIT[45] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[46] && reg_we && (RV_PLIC_PERMIT[46] != (RV_PLIC_PERMIT[46] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[47] && reg_we && (RV_PLIC_PERMIT[47] != (RV_PLIC_PERMIT[47] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[48] && reg_we && (RV_PLIC_PERMIT[48] != (RV_PLIC_PERMIT[48] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[49] && reg_we && (RV_PLIC_PERMIT[49] != (RV_PLIC_PERMIT[49] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[50] && reg_we && (RV_PLIC_PERMIT[50] != (RV_PLIC_PERMIT[50] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[51] && reg_we && (RV_PLIC_PERMIT[51] != (RV_PLIC_PERMIT[51] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[52] && reg_we && (RV_PLIC_PERMIT[52] != (RV_PLIC_PERMIT[52] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[53] && reg_we && (RV_PLIC_PERMIT[53] != (RV_PLIC_PERMIT[53] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[54] && reg_we && (RV_PLIC_PERMIT[54] != (RV_PLIC_PERMIT[54] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[55] && reg_we && (RV_PLIC_PERMIT[55] != (RV_PLIC_PERMIT[55] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[56] && reg_we && (RV_PLIC_PERMIT[56] != (RV_PLIC_PERMIT[56] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[57] && reg_we && (RV_PLIC_PERMIT[57] != (RV_PLIC_PERMIT[57] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[58] && reg_we && (RV_PLIC_PERMIT[58] != (RV_PLIC_PERMIT[58] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[59] && reg_we && (RV_PLIC_PERMIT[59] != (RV_PLIC_PERMIT[59] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[60] && reg_we && (RV_PLIC_PERMIT[60] != (RV_PLIC_PERMIT[60] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[61] && reg_we && (RV_PLIC_PERMIT[61] != (RV_PLIC_PERMIT[61] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[62] && reg_we && (RV_PLIC_PERMIT[62] != (RV_PLIC_PERMIT[62] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[63] && reg_we && (RV_PLIC_PERMIT[63] != (RV_PLIC_PERMIT[63] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[64] && reg_we && (RV_PLIC_PERMIT[64] != (RV_PLIC_PERMIT[64] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[65] && reg_we && (RV_PLIC_PERMIT[65] != (RV_PLIC_PERMIT[65] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[66] && reg_we && (RV_PLIC_PERMIT[66] != (RV_PLIC_PERMIT[66] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[67] && reg_we && (RV_PLIC_PERMIT[67] != (RV_PLIC_PERMIT[67] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[68] && reg_we && (RV_PLIC_PERMIT[68] != (RV_PLIC_PERMIT[68] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[69] && reg_we && (RV_PLIC_PERMIT[69] != (RV_PLIC_PERMIT[69] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[70] && reg_we && (RV_PLIC_PERMIT[70] != (RV_PLIC_PERMIT[70] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[71] && reg_we && (RV_PLIC_PERMIT[71] != (RV_PLIC_PERMIT[71] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign le0_le0_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le0_wd = reg_wdata[0];</pre>
<pre>  assign le0_le1_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le1_wd = reg_wdata[1];</pre>
<pre>  assign le0_le2_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le2_wd = reg_wdata[2];</pre>
<pre>  assign le0_le3_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le3_wd = reg_wdata[3];</pre>
<pre>  assign le0_le4_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le4_wd = reg_wdata[4];</pre>
<pre>  assign le0_le5_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le5_wd = reg_wdata[5];</pre>
<pre>  assign le0_le6_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le6_wd = reg_wdata[6];</pre>
<pre>  assign le0_le7_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le7_wd = reg_wdata[7];</pre>
<pre>  assign le0_le8_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le8_wd = reg_wdata[8];</pre>
<pre>  assign le0_le9_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le9_wd = reg_wdata[9];</pre>
<pre>  assign le0_le10_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le10_wd = reg_wdata[10];</pre>
<pre>  assign le0_le11_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le11_wd = reg_wdata[11];</pre>
<pre>  assign le0_le12_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le12_wd = reg_wdata[12];</pre>
<pre>  assign le0_le13_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le13_wd = reg_wdata[13];</pre>
<pre>  assign le0_le14_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le14_wd = reg_wdata[14];</pre>
<pre>  assign le0_le15_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le15_wd = reg_wdata[15];</pre>
<pre>  assign le0_le16_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le16_wd = reg_wdata[16];</pre>
<pre>  assign le0_le17_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le17_wd = reg_wdata[17];</pre>
<pre>  assign le0_le18_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le18_wd = reg_wdata[18];</pre>
<pre>  assign le0_le19_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le19_wd = reg_wdata[19];</pre>
<pre>  assign le0_le20_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le20_wd = reg_wdata[20];</pre>
<pre>  assign le0_le21_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le21_wd = reg_wdata[21];</pre>
<pre>  assign le0_le22_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le22_wd = reg_wdata[22];</pre>
<pre>  assign le0_le23_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le23_wd = reg_wdata[23];</pre>
<pre>  assign le0_le24_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le24_wd = reg_wdata[24];</pre>
<pre>  assign le0_le25_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le25_wd = reg_wdata[25];</pre>
<pre>  assign le0_le26_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le26_wd = reg_wdata[26];</pre>
<pre>  assign le0_le27_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le27_wd = reg_wdata[27];</pre>
<pre>  assign le0_le28_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le28_wd = reg_wdata[28];</pre>
<pre>  assign le0_le29_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le29_wd = reg_wdata[29];</pre>
<pre>  assign le0_le30_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le30_wd = reg_wdata[30];</pre>
<pre>  assign le0_le31_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign le0_le31_wd = reg_wdata[31];</pre>
<pre>  assign le1_le32_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le32_wd = reg_wdata[0];</pre>
<pre>  assign le1_le33_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le33_wd = reg_wdata[1];</pre>
<pre>  assign le1_le34_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le34_wd = reg_wdata[2];</pre>
<pre>  assign le1_le35_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le35_wd = reg_wdata[3];</pre>
<pre>  assign le1_le36_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le36_wd = reg_wdata[4];</pre>
<pre>  assign le1_le37_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le37_wd = reg_wdata[5];</pre>
<pre>  assign le1_le38_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le38_wd = reg_wdata[6];</pre>
<pre>  assign le1_le39_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le39_wd = reg_wdata[7];</pre>
<pre>  assign le1_le40_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le40_wd = reg_wdata[8];</pre>
<pre>  assign le1_le41_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le41_wd = reg_wdata[9];</pre>
<pre>  assign le1_le42_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le42_wd = reg_wdata[10];</pre>
<pre>  assign le1_le43_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le43_wd = reg_wdata[11];</pre>
<pre>  assign le1_le44_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le44_wd = reg_wdata[12];</pre>
<pre>  assign le1_le45_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le45_wd = reg_wdata[13];</pre>
<pre>  assign le1_le46_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le46_wd = reg_wdata[14];</pre>
<pre>  assign le1_le47_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le47_wd = reg_wdata[15];</pre>
<pre>  assign le1_le48_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le48_wd = reg_wdata[16];</pre>
<pre>  assign le1_le49_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le49_wd = reg_wdata[17];</pre>
<pre>  assign le1_le50_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le50_wd = reg_wdata[18];</pre>
<pre>  assign le1_le51_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le51_wd = reg_wdata[19];</pre>
<pre>  assign le1_le52_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le52_wd = reg_wdata[20];</pre>
<pre>  assign le1_le53_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le53_wd = reg_wdata[21];</pre>
<pre>  assign le1_le54_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le54_wd = reg_wdata[22];</pre>
<pre>  assign le1_le55_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le55_wd = reg_wdata[23];</pre>
<pre>  assign le1_le56_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le56_wd = reg_wdata[24];</pre>
<pre>  assign le1_le57_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le57_wd = reg_wdata[25];</pre>
<pre>  assign le1_le58_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le58_wd = reg_wdata[26];</pre>
<pre>  assign le1_le59_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le59_wd = reg_wdata[27];</pre>
<pre>  assign le1_le60_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le60_wd = reg_wdata[28];</pre>
<pre>  assign le1_le61_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le61_wd = reg_wdata[29];</pre>
<pre>  assign le1_le62_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign le1_le62_wd = reg_wdata[30];</pre>
<pre>  assign prio0_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign prio0_wd = reg_wdata[1:0];</pre>
<pre>  assign prio1_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign prio1_wd = reg_wdata[1:0];</pre>
<pre>  assign prio2_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign prio2_wd = reg_wdata[1:0];</pre>
<pre>  assign prio3_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign prio3_wd = reg_wdata[1:0];</pre>
<pre>  assign prio4_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign prio4_wd = reg_wdata[1:0];</pre>
<pre>  assign prio5_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign prio5_wd = reg_wdata[1:0];</pre>
<pre>  assign prio6_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign prio6_wd = reg_wdata[1:0];</pre>
<pre>  assign prio7_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign prio7_wd = reg_wdata[1:0];</pre>
<pre>  assign prio8_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign prio8_wd = reg_wdata[1:0];</pre>
<pre>  assign prio9_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign prio9_wd = reg_wdata[1:0];</pre>
<pre>  assign prio10_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign prio10_wd = reg_wdata[1:0];</pre>
<pre>  assign prio11_we = addr_hit[15] & reg_we & ~wr_err;</pre>
<pre>  assign prio11_wd = reg_wdata[1:0];</pre>
<pre>  assign prio12_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign prio12_wd = reg_wdata[1:0];</pre>
<pre>  assign prio13_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign prio13_wd = reg_wdata[1:0];</pre>
<pre>  assign prio14_we = addr_hit[18] & reg_we & ~wr_err;</pre>
<pre>  assign prio14_wd = reg_wdata[1:0];</pre>
<pre>  assign prio15_we = addr_hit[19] & reg_we & ~wr_err;</pre>
<pre>  assign prio15_wd = reg_wdata[1:0];</pre>
<pre>  assign prio16_we = addr_hit[20] & reg_we & ~wr_err;</pre>
<pre>  assign prio16_wd = reg_wdata[1:0];</pre>
<pre>  assign prio17_we = addr_hit[21] & reg_we & ~wr_err;</pre>
<pre>  assign prio17_wd = reg_wdata[1:0];</pre>
<pre>  assign prio18_we = addr_hit[22] & reg_we & ~wr_err;</pre>
<pre>  assign prio18_wd = reg_wdata[1:0];</pre>
<pre>  assign prio19_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign prio19_wd = reg_wdata[1:0];</pre>
<pre>  assign prio20_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign prio20_wd = reg_wdata[1:0];</pre>
<pre>  assign prio21_we = addr_hit[25] & reg_we & ~wr_err;</pre>
<pre>  assign prio21_wd = reg_wdata[1:0];</pre>
<pre>  assign prio22_we = addr_hit[26] & reg_we & ~wr_err;</pre>
<pre>  assign prio22_wd = reg_wdata[1:0];</pre>
<pre>  assign prio23_we = addr_hit[27] & reg_we & ~wr_err;</pre>
<pre>  assign prio23_wd = reg_wdata[1:0];</pre>
<pre>  assign prio24_we = addr_hit[28] & reg_we & ~wr_err;</pre>
<pre>  assign prio24_wd = reg_wdata[1:0];</pre>
<pre>  assign prio25_we = addr_hit[29] & reg_we & ~wr_err;</pre>
<pre>  assign prio25_wd = reg_wdata[1:0];</pre>
<pre>  assign prio26_we = addr_hit[30] & reg_we & ~wr_err;</pre>
<pre>  assign prio26_wd = reg_wdata[1:0];</pre>
<pre>  assign prio27_we = addr_hit[31] & reg_we & ~wr_err;</pre>
<pre>  assign prio27_wd = reg_wdata[1:0];</pre>
<pre>  assign prio28_we = addr_hit[32] & reg_we & ~wr_err;</pre>
<pre>  assign prio28_wd = reg_wdata[1:0];</pre>
<pre>  assign prio29_we = addr_hit[33] & reg_we & ~wr_err;</pre>
<pre>  assign prio29_wd = reg_wdata[1:0];</pre>
<pre>  assign prio30_we = addr_hit[34] & reg_we & ~wr_err;</pre>
<pre>  assign prio30_wd = reg_wdata[1:0];</pre>
<pre>  assign prio31_we = addr_hit[35] & reg_we & ~wr_err;</pre>
<pre>  assign prio31_wd = reg_wdata[1:0];</pre>
<pre>  assign prio32_we = addr_hit[36] & reg_we & ~wr_err;</pre>
<pre>  assign prio32_wd = reg_wdata[1:0];</pre>
<pre>  assign prio33_we = addr_hit[37] & reg_we & ~wr_err;</pre>
<pre>  assign prio33_wd = reg_wdata[1:0];</pre>
<pre>  assign prio34_we = addr_hit[38] & reg_we & ~wr_err;</pre>
<pre>  assign prio34_wd = reg_wdata[1:0];</pre>
<pre>  assign prio35_we = addr_hit[39] & reg_we & ~wr_err;</pre>
<pre>  assign prio35_wd = reg_wdata[1:0];</pre>
<pre>  assign prio36_we = addr_hit[40] & reg_we & ~wr_err;</pre>
<pre>  assign prio36_wd = reg_wdata[1:0];</pre>
<pre>  assign prio37_we = addr_hit[41] & reg_we & ~wr_err;</pre>
<pre>  assign prio37_wd = reg_wdata[1:0];</pre>
<pre>  assign prio38_we = addr_hit[42] & reg_we & ~wr_err;</pre>
<pre>  assign prio38_wd = reg_wdata[1:0];</pre>
<pre>  assign prio39_we = addr_hit[43] & reg_we & ~wr_err;</pre>
<pre>  assign prio39_wd = reg_wdata[1:0];</pre>
<pre>  assign prio40_we = addr_hit[44] & reg_we & ~wr_err;</pre>
<pre>  assign prio40_wd = reg_wdata[1:0];</pre>
<pre>  assign prio41_we = addr_hit[45] & reg_we & ~wr_err;</pre>
<pre>  assign prio41_wd = reg_wdata[1:0];</pre>
<pre>  assign prio42_we = addr_hit[46] & reg_we & ~wr_err;</pre>
<pre>  assign prio42_wd = reg_wdata[1:0];</pre>
<pre>  assign prio43_we = addr_hit[47] & reg_we & ~wr_err;</pre>
<pre>  assign prio43_wd = reg_wdata[1:0];</pre>
<pre>  assign prio44_we = addr_hit[48] & reg_we & ~wr_err;</pre>
<pre>  assign prio44_wd = reg_wdata[1:0];</pre>
<pre>  assign prio45_we = addr_hit[49] & reg_we & ~wr_err;</pre>
<pre>  assign prio45_wd = reg_wdata[1:0];</pre>
<pre>  assign prio46_we = addr_hit[50] & reg_we & ~wr_err;</pre>
<pre>  assign prio46_wd = reg_wdata[1:0];</pre>
<pre>  assign prio47_we = addr_hit[51] & reg_we & ~wr_err;</pre>
<pre>  assign prio47_wd = reg_wdata[1:0];</pre>
<pre>  assign prio48_we = addr_hit[52] & reg_we & ~wr_err;</pre>
<pre>  assign prio48_wd = reg_wdata[1:0];</pre>
<pre>  assign prio49_we = addr_hit[53] & reg_we & ~wr_err;</pre>
<pre>  assign prio49_wd = reg_wdata[1:0];</pre>
<pre>  assign prio50_we = addr_hit[54] & reg_we & ~wr_err;</pre>
<pre>  assign prio50_wd = reg_wdata[1:0];</pre>
<pre>  assign prio51_we = addr_hit[55] & reg_we & ~wr_err;</pre>
<pre>  assign prio51_wd = reg_wdata[1:0];</pre>
<pre>  assign prio52_we = addr_hit[56] & reg_we & ~wr_err;</pre>
<pre>  assign prio52_wd = reg_wdata[1:0];</pre>
<pre>  assign prio53_we = addr_hit[57] & reg_we & ~wr_err;</pre>
<pre>  assign prio53_wd = reg_wdata[1:0];</pre>
<pre>  assign prio54_we = addr_hit[58] & reg_we & ~wr_err;</pre>
<pre>  assign prio54_wd = reg_wdata[1:0];</pre>
<pre>  assign prio55_we = addr_hit[59] & reg_we & ~wr_err;</pre>
<pre>  assign prio55_wd = reg_wdata[1:0];</pre>
<pre>  assign prio56_we = addr_hit[60] & reg_we & ~wr_err;</pre>
<pre>  assign prio56_wd = reg_wdata[1:0];</pre>
<pre>  assign prio57_we = addr_hit[61] & reg_we & ~wr_err;</pre>
<pre>  assign prio57_wd = reg_wdata[1:0];</pre>
<pre>  assign prio58_we = addr_hit[62] & reg_we & ~wr_err;</pre>
<pre>  assign prio58_wd = reg_wdata[1:0];</pre>
<pre>  assign prio59_we = addr_hit[63] & reg_we & ~wr_err;</pre>
<pre>  assign prio59_wd = reg_wdata[1:0];</pre>
<pre>  assign prio60_we = addr_hit[64] & reg_we & ~wr_err;</pre>
<pre>  assign prio60_wd = reg_wdata[1:0];</pre>
<pre>  assign prio61_we = addr_hit[65] & reg_we & ~wr_err;</pre>
<pre>  assign prio61_wd = reg_wdata[1:0];</pre>
<pre>  assign prio62_we = addr_hit[66] & reg_we & ~wr_err;</pre>
<pre>  assign prio62_wd = reg_wdata[1:0];</pre>
<pre>  assign ie00_e0_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e0_wd = reg_wdata[0];</pre>
<pre>  assign ie00_e1_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e1_wd = reg_wdata[1];</pre>
<pre>  assign ie00_e2_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e2_wd = reg_wdata[2];</pre>
<pre>  assign ie00_e3_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e3_wd = reg_wdata[3];</pre>
<pre>  assign ie00_e4_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e4_wd = reg_wdata[4];</pre>
<pre>  assign ie00_e5_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e5_wd = reg_wdata[5];</pre>
<pre>  assign ie00_e6_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e6_wd = reg_wdata[6];</pre>
<pre>  assign ie00_e7_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e7_wd = reg_wdata[7];</pre>
<pre>  assign ie00_e8_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e8_wd = reg_wdata[8];</pre>
<pre>  assign ie00_e9_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e9_wd = reg_wdata[9];</pre>
<pre>  assign ie00_e10_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e10_wd = reg_wdata[10];</pre>
<pre>  assign ie00_e11_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e11_wd = reg_wdata[11];</pre>
<pre>  assign ie00_e12_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e12_wd = reg_wdata[12];</pre>
<pre>  assign ie00_e13_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e13_wd = reg_wdata[13];</pre>
<pre>  assign ie00_e14_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e14_wd = reg_wdata[14];</pre>
<pre>  assign ie00_e15_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e15_wd = reg_wdata[15];</pre>
<pre>  assign ie00_e16_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e16_wd = reg_wdata[16];</pre>
<pre>  assign ie00_e17_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e17_wd = reg_wdata[17];</pre>
<pre>  assign ie00_e18_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e18_wd = reg_wdata[18];</pre>
<pre>  assign ie00_e19_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e19_wd = reg_wdata[19];</pre>
<pre>  assign ie00_e20_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e20_wd = reg_wdata[20];</pre>
<pre>  assign ie00_e21_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e21_wd = reg_wdata[21];</pre>
<pre>  assign ie00_e22_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e22_wd = reg_wdata[22];</pre>
<pre>  assign ie00_e23_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e23_wd = reg_wdata[23];</pre>
<pre>  assign ie00_e24_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e24_wd = reg_wdata[24];</pre>
<pre>  assign ie00_e25_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e25_wd = reg_wdata[25];</pre>
<pre>  assign ie00_e26_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e26_wd = reg_wdata[26];</pre>
<pre>  assign ie00_e27_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e27_wd = reg_wdata[27];</pre>
<pre>  assign ie00_e28_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e28_wd = reg_wdata[28];</pre>
<pre>  assign ie00_e29_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e29_wd = reg_wdata[29];</pre>
<pre>  assign ie00_e30_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e30_wd = reg_wdata[30];</pre>
<pre>  assign ie00_e31_we = addr_hit[67] & reg_we & ~wr_err;</pre>
<pre>  assign ie00_e31_wd = reg_wdata[31];</pre>
<pre>  assign ie01_e32_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e32_wd = reg_wdata[0];</pre>
<pre>  assign ie01_e33_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e33_wd = reg_wdata[1];</pre>
<pre>  assign ie01_e34_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e34_wd = reg_wdata[2];</pre>
<pre>  assign ie01_e35_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e35_wd = reg_wdata[3];</pre>
<pre>  assign ie01_e36_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e36_wd = reg_wdata[4];</pre>
<pre>  assign ie01_e37_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e37_wd = reg_wdata[5];</pre>
<pre>  assign ie01_e38_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e38_wd = reg_wdata[6];</pre>
<pre>  assign ie01_e39_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e39_wd = reg_wdata[7];</pre>
<pre>  assign ie01_e40_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e40_wd = reg_wdata[8];</pre>
<pre>  assign ie01_e41_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e41_wd = reg_wdata[9];</pre>
<pre>  assign ie01_e42_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e42_wd = reg_wdata[10];</pre>
<pre>  assign ie01_e43_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e43_wd = reg_wdata[11];</pre>
<pre>  assign ie01_e44_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e44_wd = reg_wdata[12];</pre>
<pre>  assign ie01_e45_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e45_wd = reg_wdata[13];</pre>
<pre>  assign ie01_e46_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e46_wd = reg_wdata[14];</pre>
<pre>  assign ie01_e47_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e47_wd = reg_wdata[15];</pre>
<pre>  assign ie01_e48_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e48_wd = reg_wdata[16];</pre>
<pre>  assign ie01_e49_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e49_wd = reg_wdata[17];</pre>
<pre>  assign ie01_e50_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e50_wd = reg_wdata[18];</pre>
<pre>  assign ie01_e51_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e51_wd = reg_wdata[19];</pre>
<pre>  assign ie01_e52_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e52_wd = reg_wdata[20];</pre>
<pre>  assign ie01_e53_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e53_wd = reg_wdata[21];</pre>
<pre>  assign ie01_e54_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e54_wd = reg_wdata[22];</pre>
<pre>  assign ie01_e55_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e55_wd = reg_wdata[23];</pre>
<pre>  assign ie01_e56_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e56_wd = reg_wdata[24];</pre>
<pre>  assign ie01_e57_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e57_wd = reg_wdata[25];</pre>
<pre>  assign ie01_e58_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e58_wd = reg_wdata[26];</pre>
<pre>  assign ie01_e59_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e59_wd = reg_wdata[27];</pre>
<pre>  assign ie01_e60_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e60_wd = reg_wdata[28];</pre>
<pre>  assign ie01_e61_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e61_wd = reg_wdata[29];</pre>
<pre>  assign ie01_e62_we = addr_hit[68] & reg_we & ~wr_err;</pre>
<pre>  assign ie01_e62_wd = reg_wdata[30];</pre>
<pre>  assign threshold0_we = addr_hit[69] & reg_we & ~wr_err;</pre>
<pre>  assign threshold0_wd = reg_wdata[1:0];</pre>
<pre>  assign cc0_we = addr_hit[70] & reg_we & ~wr_err;</pre>
<pre>  assign cc0_wd = reg_wdata[5:0];</pre>
<pre>  assign cc0_re = addr_hit[70] && reg_re;</pre>
<pre>  assign msip0_we = addr_hit[71] & reg_we & ~wr_err;</pre>
<pre>  assign msip0_wd = reg_wdata[0];</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[0] = ip0_p0_qs;</pre>
<pre>        reg_rdata_next[1] = ip0_p1_qs;</pre>
<pre>        reg_rdata_next[2] = ip0_p2_qs;</pre>
<pre>        reg_rdata_next[3] = ip0_p3_qs;</pre>
<pre>        reg_rdata_next[4] = ip0_p4_qs;</pre>
<pre>        reg_rdata_next[5] = ip0_p5_qs;</pre>
<pre>        reg_rdata_next[6] = ip0_p6_qs;</pre>
<pre>        reg_rdata_next[7] = ip0_p7_qs;</pre>
<pre>        reg_rdata_next[8] = ip0_p8_qs;</pre>
<pre>        reg_rdata_next[9] = ip0_p9_qs;</pre>
<pre>        reg_rdata_next[10] = ip0_p10_qs;</pre>
<pre>        reg_rdata_next[11] = ip0_p11_qs;</pre>
<pre>        reg_rdata_next[12] = ip0_p12_qs;</pre>
<pre>        reg_rdata_next[13] = ip0_p13_qs;</pre>
<pre>        reg_rdata_next[14] = ip0_p14_qs;</pre>
<pre>        reg_rdata_next[15] = ip0_p15_qs;</pre>
<pre>        reg_rdata_next[16] = ip0_p16_qs;</pre>
<pre>        reg_rdata_next[17] = ip0_p17_qs;</pre>
<pre>        reg_rdata_next[18] = ip0_p18_qs;</pre>
<pre>        reg_rdata_next[19] = ip0_p19_qs;</pre>
<pre>        reg_rdata_next[20] = ip0_p20_qs;</pre>
<pre>        reg_rdata_next[21] = ip0_p21_qs;</pre>
<pre>        reg_rdata_next[22] = ip0_p22_qs;</pre>
<pre>        reg_rdata_next[23] = ip0_p23_qs;</pre>
<pre>        reg_rdata_next[24] = ip0_p24_qs;</pre>
<pre>        reg_rdata_next[25] = ip0_p25_qs;</pre>
<pre>        reg_rdata_next[26] = ip0_p26_qs;</pre>
<pre>        reg_rdata_next[27] = ip0_p27_qs;</pre>
<pre>        reg_rdata_next[28] = ip0_p28_qs;</pre>
<pre>        reg_rdata_next[29] = ip0_p29_qs;</pre>
<pre>        reg_rdata_next[30] = ip0_p30_qs;</pre>
<pre>        reg_rdata_next[31] = ip0_p31_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[0] = ip1_p32_qs;</pre>
<pre>        reg_rdata_next[1] = ip1_p33_qs;</pre>
<pre>        reg_rdata_next[2] = ip1_p34_qs;</pre>
<pre>        reg_rdata_next[3] = ip1_p35_qs;</pre>
<pre>        reg_rdata_next[4] = ip1_p36_qs;</pre>
<pre>        reg_rdata_next[5] = ip1_p37_qs;</pre>
<pre>        reg_rdata_next[6] = ip1_p38_qs;</pre>
<pre>        reg_rdata_next[7] = ip1_p39_qs;</pre>
<pre>        reg_rdata_next[8] = ip1_p40_qs;</pre>
<pre>        reg_rdata_next[9] = ip1_p41_qs;</pre>
<pre>        reg_rdata_next[10] = ip1_p42_qs;</pre>
<pre>        reg_rdata_next[11] = ip1_p43_qs;</pre>
<pre>        reg_rdata_next[12] = ip1_p44_qs;</pre>
<pre>        reg_rdata_next[13] = ip1_p45_qs;</pre>
<pre>        reg_rdata_next[14] = ip1_p46_qs;</pre>
<pre>        reg_rdata_next[15] = ip1_p47_qs;</pre>
<pre>        reg_rdata_next[16] = ip1_p48_qs;</pre>
<pre>        reg_rdata_next[17] = ip1_p49_qs;</pre>
<pre>        reg_rdata_next[18] = ip1_p50_qs;</pre>
<pre>        reg_rdata_next[19] = ip1_p51_qs;</pre>
<pre>        reg_rdata_next[20] = ip1_p52_qs;</pre>
<pre>        reg_rdata_next[21] = ip1_p53_qs;</pre>
<pre>        reg_rdata_next[22] = ip1_p54_qs;</pre>
<pre>        reg_rdata_next[23] = ip1_p55_qs;</pre>
<pre>        reg_rdata_next[24] = ip1_p56_qs;</pre>
<pre>        reg_rdata_next[25] = ip1_p57_qs;</pre>
<pre>        reg_rdata_next[26] = ip1_p58_qs;</pre>
<pre>        reg_rdata_next[27] = ip1_p59_qs;</pre>
<pre>        reg_rdata_next[28] = ip1_p60_qs;</pre>
<pre>        reg_rdata_next[29] = ip1_p61_qs;</pre>
<pre>        reg_rdata_next[30] = ip1_p62_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[0] = le0_le0_qs;</pre>
<pre>        reg_rdata_next[1] = le0_le1_qs;</pre>
<pre>        reg_rdata_next[2] = le0_le2_qs;</pre>
<pre>        reg_rdata_next[3] = le0_le3_qs;</pre>
<pre>        reg_rdata_next[4] = le0_le4_qs;</pre>
<pre>        reg_rdata_next[5] = le0_le5_qs;</pre>
<pre>        reg_rdata_next[6] = le0_le6_qs;</pre>
<pre>        reg_rdata_next[7] = le0_le7_qs;</pre>
<pre>        reg_rdata_next[8] = le0_le8_qs;</pre>
<pre>        reg_rdata_next[9] = le0_le9_qs;</pre>
<pre>        reg_rdata_next[10] = le0_le10_qs;</pre>
<pre>        reg_rdata_next[11] = le0_le11_qs;</pre>
<pre>        reg_rdata_next[12] = le0_le12_qs;</pre>
<pre>        reg_rdata_next[13] = le0_le13_qs;</pre>
<pre>        reg_rdata_next[14] = le0_le14_qs;</pre>
<pre>        reg_rdata_next[15] = le0_le15_qs;</pre>
<pre>        reg_rdata_next[16] = le0_le16_qs;</pre>
<pre>        reg_rdata_next[17] = le0_le17_qs;</pre>
<pre>        reg_rdata_next[18] = le0_le18_qs;</pre>
<pre>        reg_rdata_next[19] = le0_le19_qs;</pre>
<pre>        reg_rdata_next[20] = le0_le20_qs;</pre>
<pre>        reg_rdata_next[21] = le0_le21_qs;</pre>
<pre>        reg_rdata_next[22] = le0_le22_qs;</pre>
<pre>        reg_rdata_next[23] = le0_le23_qs;</pre>
<pre>        reg_rdata_next[24] = le0_le24_qs;</pre>
<pre>        reg_rdata_next[25] = le0_le25_qs;</pre>
<pre>        reg_rdata_next[26] = le0_le26_qs;</pre>
<pre>        reg_rdata_next[27] = le0_le27_qs;</pre>
<pre>        reg_rdata_next[28] = le0_le28_qs;</pre>
<pre>        reg_rdata_next[29] = le0_le29_qs;</pre>
<pre>        reg_rdata_next[30] = le0_le30_qs;</pre>
<pre>        reg_rdata_next[31] = le0_le31_qs;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[0] = le1_le32_qs;</pre>
<pre>        reg_rdata_next[1] = le1_le33_qs;</pre>
<pre>        reg_rdata_next[2] = le1_le34_qs;</pre>
<pre>        reg_rdata_next[3] = le1_le35_qs;</pre>
<pre>        reg_rdata_next[4] = le1_le36_qs;</pre>
<pre>        reg_rdata_next[5] = le1_le37_qs;</pre>
<pre>        reg_rdata_next[6] = le1_le38_qs;</pre>
<pre>        reg_rdata_next[7] = le1_le39_qs;</pre>
<pre>        reg_rdata_next[8] = le1_le40_qs;</pre>
<pre>        reg_rdata_next[9] = le1_le41_qs;</pre>
<pre>        reg_rdata_next[10] = le1_le42_qs;</pre>
<pre>        reg_rdata_next[11] = le1_le43_qs;</pre>
<pre>        reg_rdata_next[12] = le1_le44_qs;</pre>
<pre>        reg_rdata_next[13] = le1_le45_qs;</pre>
<pre>        reg_rdata_next[14] = le1_le46_qs;</pre>
<pre>        reg_rdata_next[15] = le1_le47_qs;</pre>
<pre>        reg_rdata_next[16] = le1_le48_qs;</pre>
<pre>        reg_rdata_next[17] = le1_le49_qs;</pre>
<pre>        reg_rdata_next[18] = le1_le50_qs;</pre>
<pre>        reg_rdata_next[19] = le1_le51_qs;</pre>
<pre>        reg_rdata_next[20] = le1_le52_qs;</pre>
<pre>        reg_rdata_next[21] = le1_le53_qs;</pre>
<pre>        reg_rdata_next[22] = le1_le54_qs;</pre>
<pre>        reg_rdata_next[23] = le1_le55_qs;</pre>
<pre>        reg_rdata_next[24] = le1_le56_qs;</pre>
<pre>        reg_rdata_next[25] = le1_le57_qs;</pre>
<pre>        reg_rdata_next[26] = le1_le58_qs;</pre>
<pre>        reg_rdata_next[27] = le1_le59_qs;</pre>
<pre>        reg_rdata_next[28] = le1_le60_qs;</pre>
<pre>        reg_rdata_next[29] = le1_le61_qs;</pre>
<pre>        reg_rdata_next[30] = le1_le62_qs;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio0_qs;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio1_qs;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio2_qs;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio3_qs;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio4_qs;</pre>
<pre>      addr_hit[9]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio5_qs;</pre>
<pre>      addr_hit[10]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio6_qs;</pre>
<pre>      addr_hit[11]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio7_qs;</pre>
<pre>      addr_hit[12]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio8_qs;</pre>
<pre>      addr_hit[13]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio9_qs;</pre>
<pre>      addr_hit[14]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio10_qs;</pre>
<pre>      addr_hit[15]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio11_qs;</pre>
<pre>      addr_hit[16]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio12_qs;</pre>
<pre>      addr_hit[17]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio13_qs;</pre>
<pre>      addr_hit[18]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio14_qs;</pre>
<pre>      addr_hit[19]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio15_qs;</pre>
<pre>      addr_hit[20]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio16_qs;</pre>
<pre>      addr_hit[21]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio17_qs;</pre>
<pre>      addr_hit[22]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio18_qs;</pre>
<pre>      addr_hit[23]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio19_qs;</pre>
<pre>      addr_hit[24]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio20_qs;</pre>
<pre>      addr_hit[25]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio21_qs;</pre>
<pre>      addr_hit[26]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio22_qs;</pre>
<pre>      addr_hit[27]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio23_qs;</pre>
<pre>      addr_hit[28]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio24_qs;</pre>
<pre>      addr_hit[29]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio25_qs;</pre>
<pre>      addr_hit[30]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio26_qs;</pre>
<pre>      addr_hit[31]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio27_qs;</pre>
<pre>      addr_hit[32]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio28_qs;</pre>
<pre>      addr_hit[33]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio29_qs;</pre>
<pre>      addr_hit[34]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio30_qs;</pre>
<pre>      addr_hit[35]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio31_qs;</pre>
<pre>      addr_hit[36]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio32_qs;</pre>
<pre>      addr_hit[37]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio33_qs;</pre>
<pre>      addr_hit[38]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio34_qs;</pre>
<pre>      addr_hit[39]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio35_qs;</pre>
<pre>      addr_hit[40]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio36_qs;</pre>
<pre>      addr_hit[41]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio37_qs;</pre>
<pre>      addr_hit[42]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio38_qs;</pre>
<pre>      addr_hit[43]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio39_qs;</pre>
<pre>      addr_hit[44]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio40_qs;</pre>
<pre>      addr_hit[45]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio41_qs;</pre>
<pre>      addr_hit[46]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio42_qs;</pre>
<pre>      addr_hit[47]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio43_qs;</pre>
<pre>      addr_hit[48]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio44_qs;</pre>
<pre>      addr_hit[49]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio45_qs;</pre>
<pre>      addr_hit[50]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio46_qs;</pre>
<pre>      addr_hit[51]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio47_qs;</pre>
<pre>      addr_hit[52]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio48_qs;</pre>
<pre>      addr_hit[53]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio49_qs;</pre>
<pre>      addr_hit[54]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio50_qs;</pre>
<pre>      addr_hit[55]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio51_qs;</pre>
<pre>      addr_hit[56]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio52_qs;</pre>
<pre>      addr_hit[57]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio53_qs;</pre>
<pre>      addr_hit[58]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio54_qs;</pre>
<pre>      addr_hit[59]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio55_qs;</pre>
<pre>      addr_hit[60]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio56_qs;</pre>
<pre>      addr_hit[61]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio57_qs;</pre>
<pre>      addr_hit[62]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio58_qs;</pre>
<pre>      addr_hit[63]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio59_qs;</pre>
<pre>      addr_hit[64]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio60_qs;</pre>
<pre>      addr_hit[65]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio61_qs;</pre>
<pre>      addr_hit[66]: begin</pre>
<pre>        reg_rdata_next[1:0] = prio62_qs;</pre>
<pre>      addr_hit[67]: begin</pre>
<pre>        reg_rdata_next[0] = ie00_e0_qs;</pre>
<pre>        reg_rdata_next[1] = ie00_e1_qs;</pre>
<pre>        reg_rdata_next[2] = ie00_e2_qs;</pre>
<pre>        reg_rdata_next[3] = ie00_e3_qs;</pre>
<pre>        reg_rdata_next[4] = ie00_e4_qs;</pre>
<pre>        reg_rdata_next[5] = ie00_e5_qs;</pre>
<pre>        reg_rdata_next[6] = ie00_e6_qs;</pre>
<pre>        reg_rdata_next[7] = ie00_e7_qs;</pre>
<pre>        reg_rdata_next[8] = ie00_e8_qs;</pre>
<pre>        reg_rdata_next[9] = ie00_e9_qs;</pre>
<pre>        reg_rdata_next[10] = ie00_e10_qs;</pre>
<pre>        reg_rdata_next[11] = ie00_e11_qs;</pre>
<pre>        reg_rdata_next[12] = ie00_e12_qs;</pre>
<pre>        reg_rdata_next[13] = ie00_e13_qs;</pre>
<pre>        reg_rdata_next[14] = ie00_e14_qs;</pre>
<pre>        reg_rdata_next[15] = ie00_e15_qs;</pre>
<pre>        reg_rdata_next[16] = ie00_e16_qs;</pre>
<pre>        reg_rdata_next[17] = ie00_e17_qs;</pre>
<pre>        reg_rdata_next[18] = ie00_e18_qs;</pre>
<pre>        reg_rdata_next[19] = ie00_e19_qs;</pre>
<pre>        reg_rdata_next[20] = ie00_e20_qs;</pre>
<pre>        reg_rdata_next[21] = ie00_e21_qs;</pre>
<pre>        reg_rdata_next[22] = ie00_e22_qs;</pre>
<pre>        reg_rdata_next[23] = ie00_e23_qs;</pre>
<pre>        reg_rdata_next[24] = ie00_e24_qs;</pre>
<pre>        reg_rdata_next[25] = ie00_e25_qs;</pre>
<pre>        reg_rdata_next[26] = ie00_e26_qs;</pre>
<pre>        reg_rdata_next[27] = ie00_e27_qs;</pre>
<pre>        reg_rdata_next[28] = ie00_e28_qs;</pre>
<pre>        reg_rdata_next[29] = ie00_e29_qs;</pre>
<pre>        reg_rdata_next[30] = ie00_e30_qs;</pre>
<pre>        reg_rdata_next[31] = ie00_e31_qs;</pre>
<pre>      addr_hit[68]: begin</pre>
<pre>        reg_rdata_next[0] = ie01_e32_qs;</pre>
<pre>        reg_rdata_next[1] = ie01_e33_qs;</pre>
<pre>        reg_rdata_next[2] = ie01_e34_qs;</pre>
<pre>        reg_rdata_next[3] = ie01_e35_qs;</pre>
<pre>        reg_rdata_next[4] = ie01_e36_qs;</pre>
<pre>        reg_rdata_next[5] = ie01_e37_qs;</pre>
<pre>        reg_rdata_next[6] = ie01_e38_qs;</pre>
<pre>        reg_rdata_next[7] = ie01_e39_qs;</pre>
<pre>        reg_rdata_next[8] = ie01_e40_qs;</pre>
<pre>        reg_rdata_next[9] = ie01_e41_qs;</pre>
<pre>        reg_rdata_next[10] = ie01_e42_qs;</pre>
<pre>        reg_rdata_next[11] = ie01_e43_qs;</pre>
<pre>        reg_rdata_next[12] = ie01_e44_qs;</pre>
<pre>        reg_rdata_next[13] = ie01_e45_qs;</pre>
<pre>        reg_rdata_next[14] = ie01_e46_qs;</pre>
<pre>        reg_rdata_next[15] = ie01_e47_qs;</pre>
<pre>        reg_rdata_next[16] = ie01_e48_qs;</pre>
<pre>        reg_rdata_next[17] = ie01_e49_qs;</pre>
<pre>        reg_rdata_next[18] = ie01_e50_qs;</pre>
<pre>        reg_rdata_next[19] = ie01_e51_qs;</pre>
<pre>        reg_rdata_next[20] = ie01_e52_qs;</pre>
<pre>        reg_rdata_next[21] = ie01_e53_qs;</pre>
<pre>        reg_rdata_next[22] = ie01_e54_qs;</pre>
<pre>        reg_rdata_next[23] = ie01_e55_qs;</pre>
<pre>        reg_rdata_next[24] = ie01_e56_qs;</pre>
<pre>        reg_rdata_next[25] = ie01_e57_qs;</pre>
<pre>        reg_rdata_next[26] = ie01_e58_qs;</pre>
<pre>        reg_rdata_next[27] = ie01_e59_qs;</pre>
<pre>        reg_rdata_next[28] = ie01_e60_qs;</pre>
<pre>        reg_rdata_next[29] = ie01_e61_qs;</pre>
<pre>        reg_rdata_next[30] = ie01_e62_qs;</pre>
<pre>      addr_hit[69]: begin</pre>
<pre>        reg_rdata_next[1:0] = threshold0_qs;</pre>
<pre>      addr_hit[70]: begin</pre>
<pre>        reg_rdata_next[5:0] = cc0_qs;</pre>
<pre>      addr_hit[71]: begin</pre>
<pre>        reg_rdata_next[0] = msip0_qs;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/top_earlgrey/ip/pinmux/rtl/autogen/pinmux_reg_pkg.sv</h3>
<pre>package pinmux_reg_pkg;</pre>
<pre>  localparam int NPeriphIn = 32;</pre>
<pre>  localparam int NPeriphOut = 32;</pre>
<pre>  localparam int NMioPads = 32;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [5:0]  q;</pre>
<pre style="background-color: #FF0000;">  } pinmux_reg2hw_periph_insel_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [5:0]  q;</pre>
<pre style="background-color: #FF0000;">  } pinmux_reg2hw_mio_outsel_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    pinmux_reg2hw_periph_insel_mreg_t [31:0] periph_insel; // [383:192]</pre>
<pre>    pinmux_reg2hw_mio_outsel_mreg_t [31:0] mio_outsel; // [191:0]</pre>
<pre style="background-color: #FF0000;">  } pinmux_reg2hw_t;</pre>
<pre>  parameter PINMUX_REGEN_OFFSET = 6'h 0;</pre>
<pre>  parameter PINMUX_PERIPH_INSEL0_OFFSET = 6'h 4;</pre>
<pre>  parameter PINMUX_PERIPH_INSEL1_OFFSET = 6'h 8;</pre>
<pre>  parameter PINMUX_PERIPH_INSEL2_OFFSET = 6'h c;</pre>
<pre>  parameter PINMUX_PERIPH_INSEL3_OFFSET = 6'h 10;</pre>
<pre>  parameter PINMUX_PERIPH_INSEL4_OFFSET = 6'h 14;</pre>
<pre>  parameter PINMUX_PERIPH_INSEL5_OFFSET = 6'h 18;</pre>
<pre>  parameter PINMUX_PERIPH_INSEL6_OFFSET = 6'h 1c;</pre>
<pre>  parameter PINMUX_MIO_OUTSEL0_OFFSET = 6'h 20;</pre>
<pre>  parameter PINMUX_MIO_OUTSEL1_OFFSET = 6'h 24;</pre>
<pre>  parameter PINMUX_MIO_OUTSEL2_OFFSET = 6'h 28;</pre>
<pre>  parameter PINMUX_MIO_OUTSEL3_OFFSET = 6'h 2c;</pre>
<pre>  parameter PINMUX_MIO_OUTSEL4_OFFSET = 6'h 30;</pre>
<pre>  parameter PINMUX_MIO_OUTSEL5_OFFSET = 6'h 34;</pre>
<pre>  parameter PINMUX_MIO_OUTSEL6_OFFSET = 6'h 38;</pre>
<pre>  typedef enum int {</pre>
<pre>    PINMUX_REGEN,</pre>
<pre>    PINMUX_PERIPH_INSEL0,</pre>
<pre>    PINMUX_PERIPH_INSEL1,</pre>
<pre>    PINMUX_PERIPH_INSEL2,</pre>
<pre>    PINMUX_PERIPH_INSEL3,</pre>
<pre>    PINMUX_PERIPH_INSEL4,</pre>
<pre>    PINMUX_PERIPH_INSEL5,</pre>
<pre>    PINMUX_PERIPH_INSEL6,</pre>
<pre>    PINMUX_MIO_OUTSEL0,</pre>
<pre>    PINMUX_MIO_OUTSEL1,</pre>
<pre>    PINMUX_MIO_OUTSEL2,</pre>
<pre>    PINMUX_MIO_OUTSEL3,</pre>
<pre>    PINMUX_MIO_OUTSEL4,</pre>
<pre>    PINMUX_MIO_OUTSEL5,</pre>
<pre>    PINMUX_MIO_OUTSEL6</pre>
<pre>  } pinmux_id_e;</pre>
<pre>  localparam logic [3:0] PINMUX_PERMIT [15] = '{</pre>
<pre>    4'b 0001, // index[ 0] PINMUX_REGEN</pre>
<pre>    4'b 1111, // index[ 1] PINMUX_PERIPH_INSEL0</pre>
<pre>    4'b 1111, // index[ 2] PINMUX_PERIPH_INSEL1</pre>
<pre>    4'b 1111, // index[ 3] PINMUX_PERIPH_INSEL2</pre>
<pre>    4'b 1111, // index[ 4] PINMUX_PERIPH_INSEL3</pre>
<pre>    4'b 1111, // index[ 5] PINMUX_PERIPH_INSEL4</pre>
<pre>    4'b 1111, // index[ 6] PINMUX_PERIPH_INSEL5</pre>
<pre>    4'b 0011, // index[ 7] PINMUX_PERIPH_INSEL6</pre>
<pre>    4'b 1111, // index[ 8] PINMUX_MIO_OUTSEL0</pre>
<pre>    4'b 1111, // index[ 9] PINMUX_MIO_OUTSEL1</pre>
<pre>    4'b 1111, // index[10] PINMUX_MIO_OUTSEL2</pre>
<pre>    4'b 1111, // index[11] PINMUX_MIO_OUTSEL3</pre>
<pre>    4'b 1111, // index[12] PINMUX_MIO_OUTSEL4</pre>
<pre>    4'b 1111, // index[13] PINMUX_MIO_OUTSEL5</pre>
<pre>    4'b 0011  // index[14] PINMUX_MIO_OUTSEL6</pre>
<h3>hw/top_earlgrey/ip/pinmux/rtl/autogen/pinmux_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output pinmux_reg_pkg::pinmux_reg2hw_t reg2hw, // Write</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam AW = 6;</pre>
<pre>  localparam DW = 32;</pre>
<pre>  localparam DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  assign tl_reg_h2d = tl_i;</pre>
<pre>  assign tl_o       = tl_reg_d2h;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic regen_qs;</pre>
<pre>  logic regen_wd;</pre>
<pre>  logic regen_we;</pre>
<pre>  logic [5:0] periph_insel0_in0_qs;</pre>
<pre>  logic [5:0] periph_insel0_in0_wd;</pre>
<pre>  logic periph_insel0_in0_we;</pre>
<pre>  logic [5:0] periph_insel0_in1_qs;</pre>
<pre>  logic [5:0] periph_insel0_in1_wd;</pre>
<pre>  logic periph_insel0_in1_we;</pre>
<pre>  logic [5:0] periph_insel0_in2_qs;</pre>
<pre>  logic [5:0] periph_insel0_in2_wd;</pre>
<pre>  logic periph_insel0_in2_we;</pre>
<pre>  logic [5:0] periph_insel0_in3_qs;</pre>
<pre>  logic [5:0] periph_insel0_in3_wd;</pre>
<pre>  logic periph_insel0_in3_we;</pre>
<pre>  logic [5:0] periph_insel0_in4_qs;</pre>
<pre>  logic [5:0] periph_insel0_in4_wd;</pre>
<pre>  logic periph_insel0_in4_we;</pre>
<pre>  logic [5:0] periph_insel1_in5_qs;</pre>
<pre>  logic [5:0] periph_insel1_in5_wd;</pre>
<pre>  logic periph_insel1_in5_we;</pre>
<pre>  logic [5:0] periph_insel1_in6_qs;</pre>
<pre>  logic [5:0] periph_insel1_in6_wd;</pre>
<pre>  logic periph_insel1_in6_we;</pre>
<pre>  logic [5:0] periph_insel1_in7_qs;</pre>
<pre>  logic [5:0] periph_insel1_in7_wd;</pre>
<pre>  logic periph_insel1_in7_we;</pre>
<pre>  logic [5:0] periph_insel1_in8_qs;</pre>
<pre>  logic [5:0] periph_insel1_in8_wd;</pre>
<pre>  logic periph_insel1_in8_we;</pre>
<pre>  logic [5:0] periph_insel1_in9_qs;</pre>
<pre>  logic [5:0] periph_insel1_in9_wd;</pre>
<pre>  logic periph_insel1_in9_we;</pre>
<pre>  logic [5:0] periph_insel2_in10_qs;</pre>
<pre>  logic [5:0] periph_insel2_in10_wd;</pre>
<pre>  logic periph_insel2_in10_we;</pre>
<pre>  logic [5:0] periph_insel2_in11_qs;</pre>
<pre>  logic [5:0] periph_insel2_in11_wd;</pre>
<pre>  logic periph_insel2_in11_we;</pre>
<pre>  logic [5:0] periph_insel2_in12_qs;</pre>
<pre>  logic [5:0] periph_insel2_in12_wd;</pre>
<pre>  logic periph_insel2_in12_we;</pre>
<pre>  logic [5:0] periph_insel2_in13_qs;</pre>
<pre>  logic [5:0] periph_insel2_in13_wd;</pre>
<pre>  logic periph_insel2_in13_we;</pre>
<pre>  logic [5:0] periph_insel2_in14_qs;</pre>
<pre>  logic [5:0] periph_insel2_in14_wd;</pre>
<pre>  logic periph_insel2_in14_we;</pre>
<pre>  logic [5:0] periph_insel3_in15_qs;</pre>
<pre>  logic [5:0] periph_insel3_in15_wd;</pre>
<pre>  logic periph_insel3_in15_we;</pre>
<pre>  logic [5:0] periph_insel3_in16_qs;</pre>
<pre>  logic [5:0] periph_insel3_in16_wd;</pre>
<pre>  logic periph_insel3_in16_we;</pre>
<pre>  logic [5:0] periph_insel3_in17_qs;</pre>
<pre>  logic [5:0] periph_insel3_in17_wd;</pre>
<pre>  logic periph_insel3_in17_we;</pre>
<pre>  logic [5:0] periph_insel3_in18_qs;</pre>
<pre>  logic [5:0] periph_insel3_in18_wd;</pre>
<pre>  logic periph_insel3_in18_we;</pre>
<pre>  logic [5:0] periph_insel3_in19_qs;</pre>
<pre>  logic [5:0] periph_insel3_in19_wd;</pre>
<pre>  logic periph_insel3_in19_we;</pre>
<pre>  logic [5:0] periph_insel4_in20_qs;</pre>
<pre>  logic [5:0] periph_insel4_in20_wd;</pre>
<pre>  logic periph_insel4_in20_we;</pre>
<pre>  logic [5:0] periph_insel4_in21_qs;</pre>
<pre>  logic [5:0] periph_insel4_in21_wd;</pre>
<pre>  logic periph_insel4_in21_we;</pre>
<pre>  logic [5:0] periph_insel4_in22_qs;</pre>
<pre>  logic [5:0] periph_insel4_in22_wd;</pre>
<pre>  logic periph_insel4_in22_we;</pre>
<pre>  logic [5:0] periph_insel4_in23_qs;</pre>
<pre>  logic [5:0] periph_insel4_in23_wd;</pre>
<pre>  logic periph_insel4_in23_we;</pre>
<pre>  logic [5:0] periph_insel4_in24_qs;</pre>
<pre>  logic [5:0] periph_insel4_in24_wd;</pre>
<pre>  logic periph_insel4_in24_we;</pre>
<pre>  logic [5:0] periph_insel5_in25_qs;</pre>
<pre>  logic [5:0] periph_insel5_in25_wd;</pre>
<pre>  logic periph_insel5_in25_we;</pre>
<pre>  logic [5:0] periph_insel5_in26_qs;</pre>
<pre>  logic [5:0] periph_insel5_in26_wd;</pre>
<pre>  logic periph_insel5_in26_we;</pre>
<pre>  logic [5:0] periph_insel5_in27_qs;</pre>
<pre>  logic [5:0] periph_insel5_in27_wd;</pre>
<pre>  logic periph_insel5_in27_we;</pre>
<pre>  logic [5:0] periph_insel5_in28_qs;</pre>
<pre>  logic [5:0] periph_insel5_in28_wd;</pre>
<pre>  logic periph_insel5_in28_we;</pre>
<pre>  logic [5:0] periph_insel5_in29_qs;</pre>
<pre>  logic [5:0] periph_insel5_in29_wd;</pre>
<pre>  logic periph_insel5_in29_we;</pre>
<pre>  logic [5:0] periph_insel6_in30_qs;</pre>
<pre>  logic [5:0] periph_insel6_in30_wd;</pre>
<pre>  logic periph_insel6_in30_we;</pre>
<pre>  logic [5:0] periph_insel6_in31_qs;</pre>
<pre>  logic [5:0] periph_insel6_in31_wd;</pre>
<pre>  logic periph_insel6_in31_we;</pre>
<pre>  logic [5:0] mio_outsel0_out0_qs;</pre>
<pre>  logic [5:0] mio_outsel0_out0_wd;</pre>
<pre>  logic mio_outsel0_out0_we;</pre>
<pre>  logic [5:0] mio_outsel0_out1_qs;</pre>
<pre>  logic [5:0] mio_outsel0_out1_wd;</pre>
<pre>  logic mio_outsel0_out1_we;</pre>
<pre>  logic [5:0] mio_outsel0_out2_qs;</pre>
<pre>  logic [5:0] mio_outsel0_out2_wd;</pre>
<pre>  logic mio_outsel0_out2_we;</pre>
<pre>  logic [5:0] mio_outsel0_out3_qs;</pre>
<pre>  logic [5:0] mio_outsel0_out3_wd;</pre>
<pre>  logic mio_outsel0_out3_we;</pre>
<pre>  logic [5:0] mio_outsel0_out4_qs;</pre>
<pre>  logic [5:0] mio_outsel0_out4_wd;</pre>
<pre>  logic mio_outsel0_out4_we;</pre>
<pre>  logic [5:0] mio_outsel1_out5_qs;</pre>
<pre>  logic [5:0] mio_outsel1_out5_wd;</pre>
<pre>  logic mio_outsel1_out5_we;</pre>
<pre>  logic [5:0] mio_outsel1_out6_qs;</pre>
<pre>  logic [5:0] mio_outsel1_out6_wd;</pre>
<pre>  logic mio_outsel1_out6_we;</pre>
<pre>  logic [5:0] mio_outsel1_out7_qs;</pre>
<pre>  logic [5:0] mio_outsel1_out7_wd;</pre>
<pre>  logic mio_outsel1_out7_we;</pre>
<pre>  logic [5:0] mio_outsel1_out8_qs;</pre>
<pre>  logic [5:0] mio_outsel1_out8_wd;</pre>
<pre>  logic mio_outsel1_out8_we;</pre>
<pre>  logic [5:0] mio_outsel1_out9_qs;</pre>
<pre>  logic [5:0] mio_outsel1_out9_wd;</pre>
<pre>  logic mio_outsel1_out9_we;</pre>
<pre>  logic [5:0] mio_outsel2_out10_qs;</pre>
<pre>  logic [5:0] mio_outsel2_out10_wd;</pre>
<pre>  logic mio_outsel2_out10_we;</pre>
<pre>  logic [5:0] mio_outsel2_out11_qs;</pre>
<pre>  logic [5:0] mio_outsel2_out11_wd;</pre>
<pre>  logic mio_outsel2_out11_we;</pre>
<pre>  logic [5:0] mio_outsel2_out12_qs;</pre>
<pre>  logic [5:0] mio_outsel2_out12_wd;</pre>
<pre>  logic mio_outsel2_out12_we;</pre>
<pre>  logic [5:0] mio_outsel2_out13_qs;</pre>
<pre>  logic [5:0] mio_outsel2_out13_wd;</pre>
<pre>  logic mio_outsel2_out13_we;</pre>
<pre>  logic [5:0] mio_outsel2_out14_qs;</pre>
<pre>  logic [5:0] mio_outsel2_out14_wd;</pre>
<pre>  logic mio_outsel2_out14_we;</pre>
<pre>  logic [5:0] mio_outsel3_out15_qs;</pre>
<pre>  logic [5:0] mio_outsel3_out15_wd;</pre>
<pre>  logic mio_outsel3_out15_we;</pre>
<pre>  logic [5:0] mio_outsel3_out16_qs;</pre>
<pre>  logic [5:0] mio_outsel3_out16_wd;</pre>
<pre>  logic mio_outsel3_out16_we;</pre>
<pre>  logic [5:0] mio_outsel3_out17_qs;</pre>
<pre>  logic [5:0] mio_outsel3_out17_wd;</pre>
<pre>  logic mio_outsel3_out17_we;</pre>
<pre>  logic [5:0] mio_outsel3_out18_qs;</pre>
<pre>  logic [5:0] mio_outsel3_out18_wd;</pre>
<pre>  logic mio_outsel3_out18_we;</pre>
<pre>  logic [5:0] mio_outsel3_out19_qs;</pre>
<pre>  logic [5:0] mio_outsel3_out19_wd;</pre>
<pre>  logic mio_outsel3_out19_we;</pre>
<pre>  logic [5:0] mio_outsel4_out20_qs;</pre>
<pre>  logic [5:0] mio_outsel4_out20_wd;</pre>
<pre>  logic mio_outsel4_out20_we;</pre>
<pre>  logic [5:0] mio_outsel4_out21_qs;</pre>
<pre>  logic [5:0] mio_outsel4_out21_wd;</pre>
<pre>  logic mio_outsel4_out21_we;</pre>
<pre>  logic [5:0] mio_outsel4_out22_qs;</pre>
<pre>  logic [5:0] mio_outsel4_out22_wd;</pre>
<pre>  logic mio_outsel4_out22_we;</pre>
<pre>  logic [5:0] mio_outsel4_out23_qs;</pre>
<pre>  logic [5:0] mio_outsel4_out23_wd;</pre>
<pre>  logic mio_outsel4_out23_we;</pre>
<pre>  logic [5:0] mio_outsel4_out24_qs;</pre>
<pre>  logic [5:0] mio_outsel4_out24_wd;</pre>
<pre>  logic mio_outsel4_out24_we;</pre>
<pre>  logic [5:0] mio_outsel5_out25_qs;</pre>
<pre>  logic [5:0] mio_outsel5_out25_wd;</pre>
<pre>  logic mio_outsel5_out25_we;</pre>
<pre>  logic [5:0] mio_outsel5_out26_qs;</pre>
<pre>  logic [5:0] mio_outsel5_out26_wd;</pre>
<pre>  logic mio_outsel5_out26_we;</pre>
<pre>  logic [5:0] mio_outsel5_out27_qs;</pre>
<pre>  logic [5:0] mio_outsel5_out27_wd;</pre>
<pre>  logic mio_outsel5_out27_we;</pre>
<pre>  logic [5:0] mio_outsel5_out28_qs;</pre>
<pre>  logic [5:0] mio_outsel5_out28_wd;</pre>
<pre>  logic mio_outsel5_out28_we;</pre>
<pre>  logic [5:0] mio_outsel5_out29_qs;</pre>
<pre>  logic [5:0] mio_outsel5_out29_wd;</pre>
<pre>  logic mio_outsel5_out29_we;</pre>
<pre>  logic [5:0] mio_outsel6_out30_qs;</pre>
<pre>  logic [5:0] mio_outsel6_out30_wd;</pre>
<pre>  logic mio_outsel6_out30_we;</pre>
<pre>  logic [5:0] mio_outsel6_out31_qs;</pre>
<pre>  logic [5:0] mio_outsel6_out31_wd;</pre>
<pre>  logic mio_outsel6_out31_we;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W0C"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_regen (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (regen_we),</pre>
<pre>    .wd     (regen_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (regen_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel0_in0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel0_in0_we & regen_qs),</pre>
<pre>    .wd     (periph_insel0_in0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[0].q ),</pre>
<pre>    .qs     (periph_insel0_in0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel0_in1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel0_in1_we & regen_qs),</pre>
<pre>    .wd     (periph_insel0_in1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[1].q ),</pre>
<pre>    .qs     (periph_insel0_in1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel0_in2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel0_in2_we & regen_qs),</pre>
<pre>    .wd     (periph_insel0_in2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[2].q ),</pre>
<pre>    .qs     (periph_insel0_in2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel0_in3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel0_in3_we & regen_qs),</pre>
<pre>    .wd     (periph_insel0_in3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[3].q ),</pre>
<pre>    .qs     (periph_insel0_in3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel0_in4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel0_in4_we & regen_qs),</pre>
<pre>    .wd     (periph_insel0_in4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[4].q ),</pre>
<pre>    .qs     (periph_insel0_in4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel1_in5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel1_in5_we & regen_qs),</pre>
<pre>    .wd     (periph_insel1_in5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[5].q ),</pre>
<pre>    .qs     (periph_insel1_in5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel1_in6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel1_in6_we & regen_qs),</pre>
<pre>    .wd     (periph_insel1_in6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[6].q ),</pre>
<pre>    .qs     (periph_insel1_in6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel1_in7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel1_in7_we & regen_qs),</pre>
<pre>    .wd     (periph_insel1_in7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[7].q ),</pre>
<pre>    .qs     (periph_insel1_in7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel1_in8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel1_in8_we & regen_qs),</pre>
<pre>    .wd     (periph_insel1_in8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[8].q ),</pre>
<pre>    .qs     (periph_insel1_in8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel1_in9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel1_in9_we & regen_qs),</pre>
<pre>    .wd     (periph_insel1_in9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[9].q ),</pre>
<pre>    .qs     (periph_insel1_in9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel2_in10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel2_in10_we & regen_qs),</pre>
<pre>    .wd     (periph_insel2_in10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[10].q ),</pre>
<pre>    .qs     (periph_insel2_in10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel2_in11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel2_in11_we & regen_qs),</pre>
<pre>    .wd     (periph_insel2_in11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[11].q ),</pre>
<pre>    .qs     (periph_insel2_in11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel2_in12 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel2_in12_we & regen_qs),</pre>
<pre>    .wd     (periph_insel2_in12_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[12].q ),</pre>
<pre>    .qs     (periph_insel2_in12_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel2_in13 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel2_in13_we & regen_qs),</pre>
<pre>    .wd     (periph_insel2_in13_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[13].q ),</pre>
<pre>    .qs     (periph_insel2_in13_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel2_in14 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel2_in14_we & regen_qs),</pre>
<pre>    .wd     (periph_insel2_in14_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[14].q ),</pre>
<pre>    .qs     (periph_insel2_in14_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel3_in15 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel3_in15_we & regen_qs),</pre>
<pre>    .wd     (periph_insel3_in15_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[15].q ),</pre>
<pre>    .qs     (periph_insel3_in15_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel3_in16 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel3_in16_we & regen_qs),</pre>
<pre>    .wd     (periph_insel3_in16_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[16].q ),</pre>
<pre>    .qs     (periph_insel3_in16_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel3_in17 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel3_in17_we & regen_qs),</pre>
<pre>    .wd     (periph_insel3_in17_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[17].q ),</pre>
<pre>    .qs     (periph_insel3_in17_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel3_in18 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel3_in18_we & regen_qs),</pre>
<pre>    .wd     (periph_insel3_in18_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[18].q ),</pre>
<pre>    .qs     (periph_insel3_in18_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel3_in19 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel3_in19_we & regen_qs),</pre>
<pre>    .wd     (periph_insel3_in19_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[19].q ),</pre>
<pre>    .qs     (periph_insel3_in19_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel4_in20 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel4_in20_we & regen_qs),</pre>
<pre>    .wd     (periph_insel4_in20_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[20].q ),</pre>
<pre>    .qs     (periph_insel4_in20_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel4_in21 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel4_in21_we & regen_qs),</pre>
<pre>    .wd     (periph_insel4_in21_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[21].q ),</pre>
<pre>    .qs     (periph_insel4_in21_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel4_in22 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel4_in22_we & regen_qs),</pre>
<pre>    .wd     (periph_insel4_in22_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[22].q ),</pre>
<pre>    .qs     (periph_insel4_in22_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel4_in23 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel4_in23_we & regen_qs),</pre>
<pre>    .wd     (periph_insel4_in23_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[23].q ),</pre>
<pre>    .qs     (periph_insel4_in23_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel4_in24 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel4_in24_we & regen_qs),</pre>
<pre>    .wd     (periph_insel4_in24_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[24].q ),</pre>
<pre>    .qs     (periph_insel4_in24_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel5_in25 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel5_in25_we & regen_qs),</pre>
<pre>    .wd     (periph_insel5_in25_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[25].q ),</pre>
<pre>    .qs     (periph_insel5_in25_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel5_in26 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel5_in26_we & regen_qs),</pre>
<pre>    .wd     (periph_insel5_in26_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[26].q ),</pre>
<pre>    .qs     (periph_insel5_in26_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel5_in27 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel5_in27_we & regen_qs),</pre>
<pre>    .wd     (periph_insel5_in27_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[27].q ),</pre>
<pre>    .qs     (periph_insel5_in27_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel5_in28 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel5_in28_we & regen_qs),</pre>
<pre>    .wd     (periph_insel5_in28_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[28].q ),</pre>
<pre>    .qs     (periph_insel5_in28_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel5_in29 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel5_in29_we & regen_qs),</pre>
<pre>    .wd     (periph_insel5_in29_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[29].q ),</pre>
<pre>    .qs     (periph_insel5_in29_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel6_in30 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel6_in30_we & regen_qs),</pre>
<pre>    .wd     (periph_insel6_in30_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[30].q ),</pre>
<pre>    .qs     (periph_insel6_in30_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_periph_insel6_in31 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (periph_insel6_in31_we & regen_qs),</pre>
<pre>    .wd     (periph_insel6_in31_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.periph_insel[31].q ),</pre>
<pre>    .qs     (periph_insel6_in31_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel0_out0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel0_out0_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel0_out0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[0].q ),</pre>
<pre>    .qs     (mio_outsel0_out0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel0_out1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel0_out1_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel0_out1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[1].q ),</pre>
<pre>    .qs     (mio_outsel0_out1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel0_out2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel0_out2_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel0_out2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[2].q ),</pre>
<pre>    .qs     (mio_outsel0_out2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel0_out3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel0_out3_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel0_out3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[3].q ),</pre>
<pre>    .qs     (mio_outsel0_out3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel0_out4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel0_out4_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel0_out4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[4].q ),</pre>
<pre>    .qs     (mio_outsel0_out4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel1_out5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel1_out5_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel1_out5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[5].q ),</pre>
<pre>    .qs     (mio_outsel1_out5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel1_out6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel1_out6_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel1_out6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[6].q ),</pre>
<pre>    .qs     (mio_outsel1_out6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel1_out7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel1_out7_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel1_out7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[7].q ),</pre>
<pre>    .qs     (mio_outsel1_out7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel1_out8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel1_out8_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel1_out8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[8].q ),</pre>
<pre>    .qs     (mio_outsel1_out8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel1_out9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel1_out9_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel1_out9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[9].q ),</pre>
<pre>    .qs     (mio_outsel1_out9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel2_out10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel2_out10_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel2_out10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[10].q ),</pre>
<pre>    .qs     (mio_outsel2_out10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel2_out11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel2_out11_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel2_out11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[11].q ),</pre>
<pre>    .qs     (mio_outsel2_out11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel2_out12 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel2_out12_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel2_out12_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[12].q ),</pre>
<pre>    .qs     (mio_outsel2_out12_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel2_out13 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel2_out13_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel2_out13_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[13].q ),</pre>
<pre>    .qs     (mio_outsel2_out13_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel2_out14 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel2_out14_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel2_out14_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[14].q ),</pre>
<pre>    .qs     (mio_outsel2_out14_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel3_out15 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel3_out15_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel3_out15_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[15].q ),</pre>
<pre>    .qs     (mio_outsel3_out15_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel3_out16 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel3_out16_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel3_out16_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[16].q ),</pre>
<pre>    .qs     (mio_outsel3_out16_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel3_out17 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel3_out17_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel3_out17_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[17].q ),</pre>
<pre>    .qs     (mio_outsel3_out17_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel3_out18 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel3_out18_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel3_out18_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[18].q ),</pre>
<pre>    .qs     (mio_outsel3_out18_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel3_out19 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel3_out19_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel3_out19_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[19].q ),</pre>
<pre>    .qs     (mio_outsel3_out19_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel4_out20 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel4_out20_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel4_out20_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[20].q ),</pre>
<pre>    .qs     (mio_outsel4_out20_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel4_out21 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel4_out21_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel4_out21_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[21].q ),</pre>
<pre>    .qs     (mio_outsel4_out21_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel4_out22 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel4_out22_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel4_out22_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[22].q ),</pre>
<pre>    .qs     (mio_outsel4_out22_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel4_out23 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel4_out23_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel4_out23_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[23].q ),</pre>
<pre>    .qs     (mio_outsel4_out23_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel4_out24 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel4_out24_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel4_out24_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[24].q ),</pre>
<pre>    .qs     (mio_outsel4_out24_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel5_out25 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel5_out25_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel5_out25_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[25].q ),</pre>
<pre>    .qs     (mio_outsel5_out25_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel5_out26 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel5_out26_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel5_out26_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[26].q ),</pre>
<pre>    .qs     (mio_outsel5_out26_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel5_out27 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel5_out27_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel5_out27_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[27].q ),</pre>
<pre>    .qs     (mio_outsel5_out27_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel5_out28 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel5_out28_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel5_out28_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[28].q ),</pre>
<pre>    .qs     (mio_outsel5_out28_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel5_out29 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel5_out29_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel5_out29_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[29].q ),</pre>
<pre>    .qs     (mio_outsel5_out29_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel6_out30 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel6_out30_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel6_out30_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[30].q ),</pre>
<pre>    .qs     (mio_outsel6_out30_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (6),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (6'h2)</pre>
<pre style="background-color: #FF0000;">  ) u_mio_outsel6_out31 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mio_outsel6_out31_we & regen_qs),</pre>
<pre>    .wd     (mio_outsel6_out31_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mio_outsel[31].q ),</pre>
<pre>    .qs     (mio_outsel6_out31_qs)</pre>
<pre>  logic [14:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[ 0] = (reg_addr == PINMUX_REGEN_OFFSET);</pre>
<pre>    addr_hit[ 1] = (reg_addr == PINMUX_PERIPH_INSEL0_OFFSET);</pre>
<pre>    addr_hit[ 2] = (reg_addr == PINMUX_PERIPH_INSEL1_OFFSET);</pre>
<pre>    addr_hit[ 3] = (reg_addr == PINMUX_PERIPH_INSEL2_OFFSET);</pre>
<pre>    addr_hit[ 4] = (reg_addr == PINMUX_PERIPH_INSEL3_OFFSET);</pre>
<pre>    addr_hit[ 5] = (reg_addr == PINMUX_PERIPH_INSEL4_OFFSET);</pre>
<pre>    addr_hit[ 6] = (reg_addr == PINMUX_PERIPH_INSEL5_OFFSET);</pre>
<pre>    addr_hit[ 7] = (reg_addr == PINMUX_PERIPH_INSEL6_OFFSET);</pre>
<pre>    addr_hit[ 8] = (reg_addr == PINMUX_MIO_OUTSEL0_OFFSET);</pre>
<pre>    addr_hit[ 9] = (reg_addr == PINMUX_MIO_OUTSEL1_OFFSET);</pre>
<pre>    addr_hit[10] = (reg_addr == PINMUX_MIO_OUTSEL2_OFFSET);</pre>
<pre>    addr_hit[11] = (reg_addr == PINMUX_MIO_OUTSEL3_OFFSET);</pre>
<pre>    addr_hit[12] = (reg_addr == PINMUX_MIO_OUTSEL4_OFFSET);</pre>
<pre>    addr_hit[13] = (reg_addr == PINMUX_MIO_OUTSEL5_OFFSET);</pre>
<pre>    addr_hit[14] = (reg_addr == PINMUX_MIO_OUTSEL6_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[ 0] && reg_we && (PINMUX_PERMIT[ 0] != (PINMUX_PERMIT[ 0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 1] && reg_we && (PINMUX_PERMIT[ 1] != (PINMUX_PERMIT[ 1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 2] && reg_we && (PINMUX_PERMIT[ 2] != (PINMUX_PERMIT[ 2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 3] && reg_we && (PINMUX_PERMIT[ 3] != (PINMUX_PERMIT[ 3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 4] && reg_we && (PINMUX_PERMIT[ 4] != (PINMUX_PERMIT[ 4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 5] && reg_we && (PINMUX_PERMIT[ 5] != (PINMUX_PERMIT[ 5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 6] && reg_we && (PINMUX_PERMIT[ 6] != (PINMUX_PERMIT[ 6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 7] && reg_we && (PINMUX_PERMIT[ 7] != (PINMUX_PERMIT[ 7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 8] && reg_we && (PINMUX_PERMIT[ 8] != (PINMUX_PERMIT[ 8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 9] && reg_we && (PINMUX_PERMIT[ 9] != (PINMUX_PERMIT[ 9] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[10] && reg_we && (PINMUX_PERMIT[10] != (PINMUX_PERMIT[10] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[11] && reg_we && (PINMUX_PERMIT[11] != (PINMUX_PERMIT[11] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[12] && reg_we && (PINMUX_PERMIT[12] != (PINMUX_PERMIT[12] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[13] && reg_we && (PINMUX_PERMIT[13] != (PINMUX_PERMIT[13] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[14] && reg_we && (PINMUX_PERMIT[14] != (PINMUX_PERMIT[14] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign regen_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign regen_wd = reg_wdata[0];</pre>
<pre>  assign periph_insel0_in0_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel0_in0_wd = reg_wdata[5:0];</pre>
<pre>  assign periph_insel0_in1_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel0_in1_wd = reg_wdata[11:6];</pre>
<pre>  assign periph_insel0_in2_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel0_in2_wd = reg_wdata[17:12];</pre>
<pre>  assign periph_insel0_in3_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel0_in3_wd = reg_wdata[23:18];</pre>
<pre>  assign periph_insel0_in4_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel0_in4_wd = reg_wdata[29:24];</pre>
<pre>  assign periph_insel1_in5_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel1_in5_wd = reg_wdata[5:0];</pre>
<pre>  assign periph_insel1_in6_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel1_in6_wd = reg_wdata[11:6];</pre>
<pre>  assign periph_insel1_in7_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel1_in7_wd = reg_wdata[17:12];</pre>
<pre>  assign periph_insel1_in8_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel1_in8_wd = reg_wdata[23:18];</pre>
<pre>  assign periph_insel1_in9_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel1_in9_wd = reg_wdata[29:24];</pre>
<pre>  assign periph_insel2_in10_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel2_in10_wd = reg_wdata[5:0];</pre>
<pre>  assign periph_insel2_in11_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel2_in11_wd = reg_wdata[11:6];</pre>
<pre>  assign periph_insel2_in12_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel2_in12_wd = reg_wdata[17:12];</pre>
<pre>  assign periph_insel2_in13_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel2_in13_wd = reg_wdata[23:18];</pre>
<pre>  assign periph_insel2_in14_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel2_in14_wd = reg_wdata[29:24];</pre>
<pre>  assign periph_insel3_in15_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel3_in15_wd = reg_wdata[5:0];</pre>
<pre>  assign periph_insel3_in16_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel3_in16_wd = reg_wdata[11:6];</pre>
<pre>  assign periph_insel3_in17_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel3_in17_wd = reg_wdata[17:12];</pre>
<pre>  assign periph_insel3_in18_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel3_in18_wd = reg_wdata[23:18];</pre>
<pre>  assign periph_insel3_in19_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel3_in19_wd = reg_wdata[29:24];</pre>
<pre>  assign periph_insel4_in20_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel4_in20_wd = reg_wdata[5:0];</pre>
<pre>  assign periph_insel4_in21_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel4_in21_wd = reg_wdata[11:6];</pre>
<pre>  assign periph_insel4_in22_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel4_in22_wd = reg_wdata[17:12];</pre>
<pre>  assign periph_insel4_in23_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel4_in23_wd = reg_wdata[23:18];</pre>
<pre>  assign periph_insel4_in24_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel4_in24_wd = reg_wdata[29:24];</pre>
<pre>  assign periph_insel5_in25_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel5_in25_wd = reg_wdata[5:0];</pre>
<pre>  assign periph_insel5_in26_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel5_in26_wd = reg_wdata[11:6];</pre>
<pre>  assign periph_insel5_in27_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel5_in27_wd = reg_wdata[17:12];</pre>
<pre>  assign periph_insel5_in28_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel5_in28_wd = reg_wdata[23:18];</pre>
<pre>  assign periph_insel5_in29_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel5_in29_wd = reg_wdata[29:24];</pre>
<pre>  assign periph_insel6_in30_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel6_in30_wd = reg_wdata[5:0];</pre>
<pre>  assign periph_insel6_in31_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign periph_insel6_in31_wd = reg_wdata[11:6];</pre>
<pre>  assign mio_outsel0_out0_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel0_out0_wd = reg_wdata[5:0];</pre>
<pre>  assign mio_outsel0_out1_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel0_out1_wd = reg_wdata[11:6];</pre>
<pre>  assign mio_outsel0_out2_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel0_out2_wd = reg_wdata[17:12];</pre>
<pre>  assign mio_outsel0_out3_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel0_out3_wd = reg_wdata[23:18];</pre>
<pre>  assign mio_outsel0_out4_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel0_out4_wd = reg_wdata[29:24];</pre>
<pre>  assign mio_outsel1_out5_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel1_out5_wd = reg_wdata[5:0];</pre>
<pre>  assign mio_outsel1_out6_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel1_out6_wd = reg_wdata[11:6];</pre>
<pre>  assign mio_outsel1_out7_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel1_out7_wd = reg_wdata[17:12];</pre>
<pre>  assign mio_outsel1_out8_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel1_out8_wd = reg_wdata[23:18];</pre>
<pre>  assign mio_outsel1_out9_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel1_out9_wd = reg_wdata[29:24];</pre>
<pre>  assign mio_outsel2_out10_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel2_out10_wd = reg_wdata[5:0];</pre>
<pre>  assign mio_outsel2_out11_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel2_out11_wd = reg_wdata[11:6];</pre>
<pre>  assign mio_outsel2_out12_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel2_out12_wd = reg_wdata[17:12];</pre>
<pre>  assign mio_outsel2_out13_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel2_out13_wd = reg_wdata[23:18];</pre>
<pre>  assign mio_outsel2_out14_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel2_out14_wd = reg_wdata[29:24];</pre>
<pre>  assign mio_outsel3_out15_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel3_out15_wd = reg_wdata[5:0];</pre>
<pre>  assign mio_outsel3_out16_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel3_out16_wd = reg_wdata[11:6];</pre>
<pre>  assign mio_outsel3_out17_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel3_out17_wd = reg_wdata[17:12];</pre>
<pre>  assign mio_outsel3_out18_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel3_out18_wd = reg_wdata[23:18];</pre>
<pre>  assign mio_outsel3_out19_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel3_out19_wd = reg_wdata[29:24];</pre>
<pre>  assign mio_outsel4_out20_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel4_out20_wd = reg_wdata[5:0];</pre>
<pre>  assign mio_outsel4_out21_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel4_out21_wd = reg_wdata[11:6];</pre>
<pre>  assign mio_outsel4_out22_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel4_out22_wd = reg_wdata[17:12];</pre>
<pre>  assign mio_outsel4_out23_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel4_out23_wd = reg_wdata[23:18];</pre>
<pre>  assign mio_outsel4_out24_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel4_out24_wd = reg_wdata[29:24];</pre>
<pre>  assign mio_outsel5_out25_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel5_out25_wd = reg_wdata[5:0];</pre>
<pre>  assign mio_outsel5_out26_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel5_out26_wd = reg_wdata[11:6];</pre>
<pre>  assign mio_outsel5_out27_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel5_out27_wd = reg_wdata[17:12];</pre>
<pre>  assign mio_outsel5_out28_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel5_out28_wd = reg_wdata[23:18];</pre>
<pre>  assign mio_outsel5_out29_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel5_out29_wd = reg_wdata[29:24];</pre>
<pre>  assign mio_outsel6_out30_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel6_out30_wd = reg_wdata[5:0];</pre>
<pre>  assign mio_outsel6_out31_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign mio_outsel6_out31_wd = reg_wdata[11:6];</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[0] = regen_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[5:0] = periph_insel0_in0_qs;</pre>
<pre>        reg_rdata_next[11:6] = periph_insel0_in1_qs;</pre>
<pre>        reg_rdata_next[17:12] = periph_insel0_in2_qs;</pre>
<pre>        reg_rdata_next[23:18] = periph_insel0_in3_qs;</pre>
<pre>        reg_rdata_next[29:24] = periph_insel0_in4_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[5:0] = periph_insel1_in5_qs;</pre>
<pre>        reg_rdata_next[11:6] = periph_insel1_in6_qs;</pre>
<pre>        reg_rdata_next[17:12] = periph_insel1_in7_qs;</pre>
<pre>        reg_rdata_next[23:18] = periph_insel1_in8_qs;</pre>
<pre>        reg_rdata_next[29:24] = periph_insel1_in9_qs;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[5:0] = periph_insel2_in10_qs;</pre>
<pre>        reg_rdata_next[11:6] = periph_insel2_in11_qs;</pre>
<pre>        reg_rdata_next[17:12] = periph_insel2_in12_qs;</pre>
<pre>        reg_rdata_next[23:18] = periph_insel2_in13_qs;</pre>
<pre>        reg_rdata_next[29:24] = periph_insel2_in14_qs;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[5:0] = periph_insel3_in15_qs;</pre>
<pre>        reg_rdata_next[11:6] = periph_insel3_in16_qs;</pre>
<pre>        reg_rdata_next[17:12] = periph_insel3_in17_qs;</pre>
<pre>        reg_rdata_next[23:18] = periph_insel3_in18_qs;</pre>
<pre>        reg_rdata_next[29:24] = periph_insel3_in19_qs;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[5:0] = periph_insel4_in20_qs;</pre>
<pre>        reg_rdata_next[11:6] = periph_insel4_in21_qs;</pre>
<pre>        reg_rdata_next[17:12] = periph_insel4_in22_qs;</pre>
<pre>        reg_rdata_next[23:18] = periph_insel4_in23_qs;</pre>
<pre>        reg_rdata_next[29:24] = periph_insel4_in24_qs;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[5:0] = periph_insel5_in25_qs;</pre>
<pre>        reg_rdata_next[11:6] = periph_insel5_in26_qs;</pre>
<pre>        reg_rdata_next[17:12] = periph_insel5_in27_qs;</pre>
<pre>        reg_rdata_next[23:18] = periph_insel5_in28_qs;</pre>
<pre>        reg_rdata_next[29:24] = periph_insel5_in29_qs;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[5:0] = periph_insel6_in30_qs;</pre>
<pre>        reg_rdata_next[11:6] = periph_insel6_in31_qs;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[5:0] = mio_outsel0_out0_qs;</pre>
<pre>        reg_rdata_next[11:6] = mio_outsel0_out1_qs;</pre>
<pre>        reg_rdata_next[17:12] = mio_outsel0_out2_qs;</pre>
<pre>        reg_rdata_next[23:18] = mio_outsel0_out3_qs;</pre>
<pre>        reg_rdata_next[29:24] = mio_outsel0_out4_qs;</pre>
<pre>      addr_hit[9]: begin</pre>
<pre>        reg_rdata_next[5:0] = mio_outsel1_out5_qs;</pre>
<pre>        reg_rdata_next[11:6] = mio_outsel1_out6_qs;</pre>
<pre>        reg_rdata_next[17:12] = mio_outsel1_out7_qs;</pre>
<pre>        reg_rdata_next[23:18] = mio_outsel1_out8_qs;</pre>
<pre>        reg_rdata_next[29:24] = mio_outsel1_out9_qs;</pre>
<pre>      addr_hit[10]: begin</pre>
<pre>        reg_rdata_next[5:0] = mio_outsel2_out10_qs;</pre>
<pre>        reg_rdata_next[11:6] = mio_outsel2_out11_qs;</pre>
<pre>        reg_rdata_next[17:12] = mio_outsel2_out12_qs;</pre>
<pre>        reg_rdata_next[23:18] = mio_outsel2_out13_qs;</pre>
<pre>        reg_rdata_next[29:24] = mio_outsel2_out14_qs;</pre>
<pre>      addr_hit[11]: begin</pre>
<pre>        reg_rdata_next[5:0] = mio_outsel3_out15_qs;</pre>
<pre>        reg_rdata_next[11:6] = mio_outsel3_out16_qs;</pre>
<pre>        reg_rdata_next[17:12] = mio_outsel3_out17_qs;</pre>
<pre>        reg_rdata_next[23:18] = mio_outsel3_out18_qs;</pre>
<pre>        reg_rdata_next[29:24] = mio_outsel3_out19_qs;</pre>
<pre>      addr_hit[12]: begin</pre>
<pre>        reg_rdata_next[5:0] = mio_outsel4_out20_qs;</pre>
<pre>        reg_rdata_next[11:6] = mio_outsel4_out21_qs;</pre>
<pre>        reg_rdata_next[17:12] = mio_outsel4_out22_qs;</pre>
<pre>        reg_rdata_next[23:18] = mio_outsel4_out23_qs;</pre>
<pre>        reg_rdata_next[29:24] = mio_outsel4_out24_qs;</pre>
<pre>      addr_hit[13]: begin</pre>
<pre>        reg_rdata_next[5:0] = mio_outsel5_out25_qs;</pre>
<pre>        reg_rdata_next[11:6] = mio_outsel5_out26_qs;</pre>
<pre>        reg_rdata_next[17:12] = mio_outsel5_out27_qs;</pre>
<pre>        reg_rdata_next[23:18] = mio_outsel5_out28_qs;</pre>
<pre>        reg_rdata_next[29:24] = mio_outsel5_out29_qs;</pre>
<pre>      addr_hit[14]: begin</pre>
<pre>        reg_rdata_next[5:0] = mio_outsel6_out30_qs;</pre>
<pre>        reg_rdata_next[11:6] = mio_outsel6_out31_qs;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/top_earlgrey/ip/xbar_peri/rtl/autogen/xbar_peri.sv</h3>
<pre>  input clk_peri_i,</pre>
<pre>  input rst_peri_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_main_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_main_o,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_uart_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_uart_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_gpio_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_gpio_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_spi_device_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_spi_device_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_rv_timer_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_rv_timer_i,</pre>
<pre>  input scanmode_i</pre>
<pre>  logic unused_scanmode;</pre>
<pre>  assign unused_scanmode = scanmode_i;</pre>
<pre>  tl_h2d_t tl_s1n_5_us_h2d ;</pre>
<pre>  tl_d2h_t tl_s1n_5_us_d2h ;</pre>
<pre>  tl_h2d_t tl_s1n_5_ds_h2d [4];</pre>
<pre>  tl_d2h_t tl_s1n_5_ds_d2h [4];</pre>
<pre>  logic [2:0] dev_sel_s1n_5;</pre>
<pre>  assign tl_uart_o = tl_s1n_5_ds_h2d[0];</pre>
<pre>  assign tl_s1n_5_ds_d2h[0] = tl_uart_i;</pre>
<pre>  assign tl_gpio_o = tl_s1n_5_ds_h2d[1];</pre>
<pre>  assign tl_s1n_5_ds_d2h[1] = tl_gpio_i;</pre>
<pre>  assign tl_spi_device_o = tl_s1n_5_ds_h2d[2];</pre>
<pre>  assign tl_s1n_5_ds_d2h[2] = tl_spi_device_i;</pre>
<pre>  assign tl_rv_timer_o = tl_s1n_5_ds_h2d[3];</pre>
<pre>  assign tl_s1n_5_ds_d2h[3] = tl_rv_timer_i;</pre>
<pre>  assign tl_s1n_5_us_h2d = tl_main_i;</pre>
<pre>  assign tl_main_o = tl_s1n_5_us_d2h;</pre>
<pre>  always_comb begin</pre>
<pre>    dev_sel_s1n_5 = 3'd4;</pre>
<pre>    if ((tl_s1n_5_us_h2d.a_address & ~(ADDR_MASK_UART)) == ADDR_SPACE_UART) begin</pre>
<pre>      dev_sel_s1n_5 = 3'd0;</pre>
<pre>    end else if ((tl_s1n_5_us_h2d.a_address & ~(ADDR_MASK_GPIO)) == ADDR_SPACE_GPIO) begin</pre>
<pre>      dev_sel_s1n_5 = 3'd1;</pre>
<pre>    end else if ((tl_s1n_5_us_h2d.a_address & ~(ADDR_MASK_SPI_DEVICE)) == ADDR_SPACE_SPI_DEVICE) begin</pre>
<pre>      dev_sel_s1n_5 = 3'd2;</pre>
<pre>    end else if ((tl_s1n_5_us_h2d.a_address & ~(ADDR_MASK_RV_TIMER)) == ADDR_SPACE_RV_TIMER) begin</pre>
<pre>      dev_sel_s1n_5 = 3'd3;</pre>
<pre>  tlul_socket_1n #(</pre>
<pre>    .HReqDepth (4'h0),</pre>
<pre>    .HRspDepth (4'h0),</pre>
<pre>    .DReqDepth ({4{4'h0}}),</pre>
<pre>    .DRspDepth ({4{4'h0}}),</pre>
<pre>    .N         (4)</pre>
<pre style="background-color: #FF0000;">  ) u_s1n_5 (</pre>
<pre>    .clk_i        (clk_peri_i),</pre>
<pre>    .rst_ni       (rst_peri_ni),</pre>
<pre>    .tl_h_i       (tl_s1n_5_us_h2d),</pre>
<pre>    .tl_h_o       (tl_s1n_5_us_d2h),</pre>
<pre>    .tl_d_o       (tl_s1n_5_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_s1n_5_ds_d2h),</pre>
<pre>    .dev_select   (dev_sel_s1n_5)</pre>
<h3>hw/top_earlgrey/ip/xbar_peri/rtl/autogen/tl_peri_pkg.sv</h3>
<pre>package tl_peri_pkg;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_UART       = 32'h 40000000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_GPIO       = 32'h 40010000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_SPI_DEVICE = 32'h 40020000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_RV_TIMER   = 32'h 40080000;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_UART       = 32'h 00000fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_GPIO       = 32'h 00000fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_SPI_DEVICE = 32'h 00000fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_RV_TIMER   = 32'h 00000fff;</pre>
<pre>  localparam int N_HOST   = 1;</pre>
<pre>  localparam int N_DEVICE = 4;</pre>
<pre>  typedef enum int {</pre>
<pre>    TlUart = 0,</pre>
<pre>    TlGpio = 1,</pre>
<pre>    TlSpiDevice = 2,</pre>
<pre>    TlRvTimer = 3</pre>
<pre>  } tl_device_e;</pre>
<pre>  typedef enum int {</pre>
<pre>    TlMain = 0</pre>
<pre>  } tl_host_e;</pre>
<h3>hw/top_earlgrey/ip/xbar_main/rtl/autogen/xbar_main.sv</h3>
<pre>  input clk_main_i,</pre>
<pre>  input clk_fixed_i,</pre>
<pre>  input rst_main_ni,</pre>
<pre>  input rst_fixed_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_corei_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_corei_o,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_cored_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_cored_o,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_dm_sba_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_dm_sba_o,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_rom_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_rom_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_debug_mem_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_debug_mem_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_ram_main_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_ram_main_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_eflash_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_eflash_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_peri_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_peri_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_flash_ctrl_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_flash_ctrl_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_hmac_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_hmac_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_aes_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_aes_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_rv_plic_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_rv_plic_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_pinmux_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_pinmux_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_alert_handler_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_alert_handler_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_nmi_gen_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_nmi_gen_i,</pre>
<pre>  input scanmode_i</pre>
<pre>  logic unused_scanmode;</pre>
<pre>  assign unused_scanmode = scanmode_i;</pre>
<pre>  tl_h2d_t tl_s1n_15_us_h2d ;</pre>
<pre>  tl_d2h_t tl_s1n_15_us_d2h ;</pre>
<pre>  tl_h2d_t tl_s1n_15_ds_h2d [4];</pre>
<pre>  tl_d2h_t tl_s1n_15_ds_d2h [4];</pre>
<pre>  logic [2:0] dev_sel_s1n_15;</pre>
<pre>  tl_h2d_t tl_sm1_16_us_h2d [3];</pre>
<pre>  tl_d2h_t tl_sm1_16_us_d2h [3];</pre>
<pre>  tl_h2d_t tl_sm1_16_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_16_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_17_us_h2d [2];</pre>
<pre>  tl_d2h_t tl_sm1_17_us_d2h [2];</pre>
<pre>  tl_h2d_t tl_sm1_17_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_17_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_18_us_h2d [3];</pre>
<pre>  tl_d2h_t tl_sm1_18_us_d2h [3];</pre>
<pre>  tl_h2d_t tl_sm1_18_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_18_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_19_us_h2d [3];</pre>
<pre>  tl_d2h_t tl_sm1_19_us_d2h [3];</pre>
<pre>  tl_h2d_t tl_sm1_19_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_19_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_s1n_20_us_h2d ;</pre>
<pre>  tl_d2h_t tl_s1n_20_us_d2h ;</pre>
<pre>  tl_h2d_t tl_s1n_20_ds_h2d [12];</pre>
<pre>  tl_d2h_t tl_s1n_20_ds_d2h [12];</pre>
<pre>  logic [3:0] dev_sel_s1n_20;</pre>
<pre>  tl_h2d_t tl_asf_21_us_h2d ;</pre>
<pre>  tl_d2h_t tl_asf_21_us_d2h ;</pre>
<pre>  tl_h2d_t tl_asf_21_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_asf_21_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_22_us_h2d [2];</pre>
<pre>  tl_d2h_t tl_sm1_22_us_d2h [2];</pre>
<pre>  tl_h2d_t tl_sm1_22_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_22_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_23_us_h2d [2];</pre>
<pre>  tl_d2h_t tl_sm1_23_us_d2h [2];</pre>
<pre>  tl_h2d_t tl_sm1_23_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_23_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_24_us_h2d [2];</pre>
<pre>  tl_d2h_t tl_sm1_24_us_d2h [2];</pre>
<pre>  tl_h2d_t tl_sm1_24_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_24_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_25_us_h2d [2];</pre>
<pre>  tl_d2h_t tl_sm1_25_us_d2h [2];</pre>
<pre>  tl_h2d_t tl_sm1_25_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_25_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_26_us_h2d [2];</pre>
<pre>  tl_d2h_t tl_sm1_26_us_d2h [2];</pre>
<pre>  tl_h2d_t tl_sm1_26_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_26_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_27_us_h2d [2];</pre>
<pre>  tl_d2h_t tl_sm1_27_us_d2h [2];</pre>
<pre>  tl_h2d_t tl_sm1_27_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_27_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_28_us_h2d [2];</pre>
<pre>  tl_d2h_t tl_sm1_28_us_d2h [2];</pre>
<pre>  tl_h2d_t tl_sm1_28_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_28_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_sm1_29_us_h2d [2];</pre>
<pre>  tl_d2h_t tl_sm1_29_us_d2h [2];</pre>
<pre>  tl_h2d_t tl_sm1_29_ds_h2d ;</pre>
<pre>  tl_d2h_t tl_sm1_29_ds_d2h ;</pre>
<pre>  tl_h2d_t tl_s1n_30_us_h2d ;</pre>
<pre>  tl_d2h_t tl_s1n_30_us_d2h ;</pre>
<pre>  tl_h2d_t tl_s1n_30_ds_h2d [11];</pre>
<pre>  tl_d2h_t tl_s1n_30_ds_d2h [11];</pre>
<pre>  logic [3:0] dev_sel_s1n_30;</pre>
<pre>  assign tl_sm1_16_us_h2d[0] = tl_s1n_15_ds_h2d[0];</pre>
<pre>  assign tl_s1n_15_ds_d2h[0] = tl_sm1_16_us_d2h[0];</pre>
<pre>  assign tl_sm1_17_us_h2d[0] = tl_s1n_15_ds_h2d[1];</pre>
<pre>  assign tl_s1n_15_ds_d2h[1] = tl_sm1_17_us_d2h[0];</pre>
<pre>  assign tl_sm1_18_us_h2d[0] = tl_s1n_15_ds_h2d[2];</pre>
<pre>  assign tl_s1n_15_ds_d2h[2] = tl_sm1_18_us_d2h[0];</pre>
<pre>  assign tl_sm1_19_us_h2d[0] = tl_s1n_15_ds_h2d[3];</pre>
<pre>  assign tl_s1n_15_ds_d2h[3] = tl_sm1_19_us_d2h[0];</pre>
<pre>  assign tl_sm1_16_us_h2d[1] = tl_s1n_20_ds_h2d[0];</pre>
<pre>  assign tl_s1n_20_ds_d2h[0] = tl_sm1_16_us_d2h[1];</pre>
<pre>  assign tl_sm1_17_us_h2d[1] = tl_s1n_20_ds_h2d[1];</pre>
<pre>  assign tl_s1n_20_ds_d2h[1] = tl_sm1_17_us_d2h[1];</pre>
<pre>  assign tl_sm1_18_us_h2d[1] = tl_s1n_20_ds_h2d[2];</pre>
<pre>  assign tl_s1n_20_ds_d2h[2] = tl_sm1_18_us_d2h[1];</pre>
<pre>  assign tl_sm1_19_us_h2d[1] = tl_s1n_20_ds_h2d[3];</pre>
<pre>  assign tl_s1n_20_ds_d2h[3] = tl_sm1_19_us_d2h[1];</pre>
<pre>  assign tl_sm1_22_us_h2d[0] = tl_s1n_20_ds_h2d[4];</pre>
<pre>  assign tl_s1n_20_ds_d2h[4] = tl_sm1_22_us_d2h[0];</pre>
<pre>  assign tl_sm1_23_us_h2d[0] = tl_s1n_20_ds_h2d[5];</pre>
<pre>  assign tl_s1n_20_ds_d2h[5] = tl_sm1_23_us_d2h[0];</pre>
<pre>  assign tl_sm1_24_us_h2d[0] = tl_s1n_20_ds_h2d[6];</pre>
<pre>  assign tl_s1n_20_ds_d2h[6] = tl_sm1_24_us_d2h[0];</pre>
<pre>  assign tl_sm1_25_us_h2d[0] = tl_s1n_20_ds_h2d[7];</pre>
<pre>  assign tl_s1n_20_ds_d2h[7] = tl_sm1_25_us_d2h[0];</pre>
<pre>  assign tl_sm1_26_us_h2d[0] = tl_s1n_20_ds_h2d[8];</pre>
<pre>  assign tl_s1n_20_ds_d2h[8] = tl_sm1_26_us_d2h[0];</pre>
<pre>  assign tl_sm1_27_us_h2d[0] = tl_s1n_20_ds_h2d[9];</pre>
<pre>  assign tl_s1n_20_ds_d2h[9] = tl_sm1_27_us_d2h[0];</pre>
<pre>  assign tl_sm1_28_us_h2d[0] = tl_s1n_20_ds_h2d[10];</pre>
<pre>  assign tl_s1n_20_ds_d2h[10] = tl_sm1_28_us_d2h[0];</pre>
<pre>  assign tl_sm1_29_us_h2d[0] = tl_s1n_20_ds_h2d[11];</pre>
<pre>  assign tl_s1n_20_ds_d2h[11] = tl_sm1_29_us_d2h[0];</pre>
<pre>  assign tl_sm1_16_us_h2d[2] = tl_s1n_30_ds_h2d[0];</pre>
<pre>  assign tl_s1n_30_ds_d2h[0] = tl_sm1_16_us_d2h[2];</pre>
<pre>  assign tl_sm1_18_us_h2d[2] = tl_s1n_30_ds_h2d[1];</pre>
<pre>  assign tl_s1n_30_ds_d2h[1] = tl_sm1_18_us_d2h[2];</pre>
<pre>  assign tl_sm1_19_us_h2d[2] = tl_s1n_30_ds_h2d[2];</pre>
<pre>  assign tl_s1n_30_ds_d2h[2] = tl_sm1_19_us_d2h[2];</pre>
<pre>  assign tl_sm1_22_us_h2d[1] = tl_s1n_30_ds_h2d[3];</pre>
<pre>  assign tl_s1n_30_ds_d2h[3] = tl_sm1_22_us_d2h[1];</pre>
<pre>  assign tl_sm1_23_us_h2d[1] = tl_s1n_30_ds_h2d[4];</pre>
<pre>  assign tl_s1n_30_ds_d2h[4] = tl_sm1_23_us_d2h[1];</pre>
<pre>  assign tl_sm1_24_us_h2d[1] = tl_s1n_30_ds_h2d[5];</pre>
<pre>  assign tl_s1n_30_ds_d2h[5] = tl_sm1_24_us_d2h[1];</pre>
<pre>  assign tl_sm1_25_us_h2d[1] = tl_s1n_30_ds_h2d[6];</pre>
<pre>  assign tl_s1n_30_ds_d2h[6] = tl_sm1_25_us_d2h[1];</pre>
<pre>  assign tl_sm1_26_us_h2d[1] = tl_s1n_30_ds_h2d[7];</pre>
<pre>  assign tl_s1n_30_ds_d2h[7] = tl_sm1_26_us_d2h[1];</pre>
<pre>  assign tl_sm1_27_us_h2d[1] = tl_s1n_30_ds_h2d[8];</pre>
<pre>  assign tl_s1n_30_ds_d2h[8] = tl_sm1_27_us_d2h[1];</pre>
<pre>  assign tl_sm1_28_us_h2d[1] = tl_s1n_30_ds_h2d[9];</pre>
<pre>  assign tl_s1n_30_ds_d2h[9] = tl_sm1_28_us_d2h[1];</pre>
<pre>  assign tl_sm1_29_us_h2d[1] = tl_s1n_30_ds_h2d[10];</pre>
<pre>  assign tl_s1n_30_ds_d2h[10] = tl_sm1_29_us_d2h[1];</pre>
<pre>  assign tl_s1n_15_us_h2d = tl_corei_i;</pre>
<pre>  assign tl_corei_o = tl_s1n_15_us_d2h;</pre>
<pre>  assign tl_rom_o = tl_sm1_16_ds_h2d;</pre>
<pre>  assign tl_sm1_16_ds_d2h = tl_rom_i;</pre>
<pre>  assign tl_debug_mem_o = tl_sm1_17_ds_h2d;</pre>
<pre>  assign tl_sm1_17_ds_d2h = tl_debug_mem_i;</pre>
<pre>  assign tl_ram_main_o = tl_sm1_18_ds_h2d;</pre>
<pre>  assign tl_sm1_18_ds_d2h = tl_ram_main_i;</pre>
<pre>  assign tl_eflash_o = tl_sm1_19_ds_h2d;</pre>
<pre>  assign tl_sm1_19_ds_d2h = tl_eflash_i;</pre>
<pre>  assign tl_s1n_20_us_h2d = tl_cored_i;</pre>
<pre>  assign tl_cored_o = tl_s1n_20_us_d2h;</pre>
<pre>  assign tl_peri_o = tl_asf_21_ds_h2d;</pre>
<pre>  assign tl_asf_21_ds_d2h = tl_peri_i;</pre>
<pre>  assign tl_asf_21_us_h2d = tl_sm1_22_ds_h2d;</pre>
<pre>  assign tl_sm1_22_ds_d2h = tl_asf_21_us_d2h;</pre>
<pre>  assign tl_flash_ctrl_o = tl_sm1_23_ds_h2d;</pre>
<pre>  assign tl_sm1_23_ds_d2h = tl_flash_ctrl_i;</pre>
<pre>  assign tl_aes_o = tl_sm1_24_ds_h2d;</pre>
<pre>  assign tl_sm1_24_ds_d2h = tl_aes_i;</pre>
<pre>  assign tl_hmac_o = tl_sm1_25_ds_h2d;</pre>
<pre>  assign tl_sm1_25_ds_d2h = tl_hmac_i;</pre>
<pre>  assign tl_rv_plic_o = tl_sm1_26_ds_h2d;</pre>
<pre>  assign tl_sm1_26_ds_d2h = tl_rv_plic_i;</pre>
<pre>  assign tl_pinmux_o = tl_sm1_27_ds_h2d;</pre>
<pre>  assign tl_sm1_27_ds_d2h = tl_pinmux_i;</pre>
<pre>  assign tl_alert_handler_o = tl_sm1_28_ds_h2d;</pre>
<pre>  assign tl_sm1_28_ds_d2h = tl_alert_handler_i;</pre>
<pre>  assign tl_nmi_gen_o = tl_sm1_29_ds_h2d;</pre>
<pre>  assign tl_sm1_29_ds_d2h = tl_nmi_gen_i;</pre>
<pre>  assign tl_s1n_30_us_h2d = tl_dm_sba_i;</pre>
<pre>  assign tl_dm_sba_o = tl_s1n_30_us_d2h;</pre>
<pre>  always_comb begin</pre>
<pre>    dev_sel_s1n_15 = 3'd4;</pre>
<pre>    if ((tl_s1n_15_us_h2d.a_address & ~(ADDR_MASK_ROM)) == ADDR_SPACE_ROM) begin</pre>
<pre>      dev_sel_s1n_15 = 3'd0;</pre>
<pre>    end else if ((tl_s1n_15_us_h2d.a_address & ~(ADDR_MASK_DEBUG_MEM)) == ADDR_SPACE_DEBUG_MEM) begin</pre>
<pre>      dev_sel_s1n_15 = 3'd1;</pre>
<pre>    end else if ((tl_s1n_15_us_h2d.a_address & ~(ADDR_MASK_RAM_MAIN)) == ADDR_SPACE_RAM_MAIN) begin</pre>
<pre>      dev_sel_s1n_15 = 3'd2;</pre>
<pre>    end else if ((tl_s1n_15_us_h2d.a_address & ~(ADDR_MASK_EFLASH)) == ADDR_SPACE_EFLASH) begin</pre>
<pre>      dev_sel_s1n_15 = 3'd3;</pre>
<pre>  always_comb begin</pre>
<pre>    dev_sel_s1n_20 = 4'd12;</pre>
<pre>    if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_ROM)) == ADDR_SPACE_ROM) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd0;</pre>
<pre>    end else if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_DEBUG_MEM)) == ADDR_SPACE_DEBUG_MEM) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd1;</pre>
<pre>    end else if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_RAM_MAIN)) == ADDR_SPACE_RAM_MAIN) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd2;</pre>
<pre>    end else if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_EFLASH)) == ADDR_SPACE_EFLASH) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd3;</pre>
<pre>      ((tl_s1n_20_us_h2d.a_address <= (ADDR_MASK_PERI[0] + ADDR_SPACE_PERI[0])) &&</pre>
<pre>       (tl_s1n_20_us_h2d.a_address >= ADDR_SPACE_PERI[0])) ||</pre>
<pre>      ((tl_s1n_20_us_h2d.a_address <= (ADDR_MASK_PERI[1] + ADDR_SPACE_PERI[1])) &&</pre>
<pre>       (tl_s1n_20_us_h2d.a_address >= ADDR_SPACE_PERI[1]))</pre>
<pre>    ) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd4;</pre>
<pre>    end else if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_FLASH_CTRL)) == ADDR_SPACE_FLASH_CTRL) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd5;</pre>
<pre>    end else if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_AES)) == ADDR_SPACE_AES) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd6;</pre>
<pre>    end else if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_HMAC)) == ADDR_SPACE_HMAC) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd7;</pre>
<pre>    end else if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_RV_PLIC)) == ADDR_SPACE_RV_PLIC) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd8;</pre>
<pre>    end else if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_PINMUX)) == ADDR_SPACE_PINMUX) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd9;</pre>
<pre>    end else if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_ALERT_HANDLER)) == ADDR_SPACE_ALERT_HANDLER) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd10;</pre>
<pre>    end else if ((tl_s1n_20_us_h2d.a_address & ~(ADDR_MASK_NMI_GEN)) == ADDR_SPACE_NMI_GEN) begin</pre>
<pre>      dev_sel_s1n_20 = 4'd11;</pre>
<pre>  always_comb begin</pre>
<pre>    dev_sel_s1n_30 = 4'd11;</pre>
<pre>    if ((tl_s1n_30_us_h2d.a_address & ~(ADDR_MASK_ROM)) == ADDR_SPACE_ROM) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd0;</pre>
<pre>    end else if ((tl_s1n_30_us_h2d.a_address & ~(ADDR_MASK_RAM_MAIN)) == ADDR_SPACE_RAM_MAIN) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd1;</pre>
<pre>    end else if ((tl_s1n_30_us_h2d.a_address & ~(ADDR_MASK_EFLASH)) == ADDR_SPACE_EFLASH) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd2;</pre>
<pre>      ((tl_s1n_30_us_h2d.a_address <= (ADDR_MASK_PERI[0] + ADDR_SPACE_PERI[0])) &&</pre>
<pre>       (tl_s1n_30_us_h2d.a_address >= ADDR_SPACE_PERI[0])) ||</pre>
<pre>      ((tl_s1n_30_us_h2d.a_address <= (ADDR_MASK_PERI[1] + ADDR_SPACE_PERI[1])) &&</pre>
<pre>       (tl_s1n_30_us_h2d.a_address >= ADDR_SPACE_PERI[1]))</pre>
<pre>    ) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd3;</pre>
<pre>    end else if ((tl_s1n_30_us_h2d.a_address & ~(ADDR_MASK_FLASH_CTRL)) == ADDR_SPACE_FLASH_CTRL) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd4;</pre>
<pre>    end else if ((tl_s1n_30_us_h2d.a_address & ~(ADDR_MASK_AES)) == ADDR_SPACE_AES) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd5;</pre>
<pre>    end else if ((tl_s1n_30_us_h2d.a_address & ~(ADDR_MASK_HMAC)) == ADDR_SPACE_HMAC) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd6;</pre>
<pre>    end else if ((tl_s1n_30_us_h2d.a_address & ~(ADDR_MASK_RV_PLIC)) == ADDR_SPACE_RV_PLIC) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd7;</pre>
<pre>    end else if ((tl_s1n_30_us_h2d.a_address & ~(ADDR_MASK_PINMUX)) == ADDR_SPACE_PINMUX) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd8;</pre>
<pre>    end else if ((tl_s1n_30_us_h2d.a_address & ~(ADDR_MASK_ALERT_HANDLER)) == ADDR_SPACE_ALERT_HANDLER) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd9;</pre>
<pre>    end else if ((tl_s1n_30_us_h2d.a_address & ~(ADDR_MASK_NMI_GEN)) == ADDR_SPACE_NMI_GEN) begin</pre>
<pre>      dev_sel_s1n_30 = 4'd10;</pre>
<pre>  tlul_socket_1n #(</pre>
<pre>    .HReqDepth (4'h0),</pre>
<pre>    .HRspDepth (4'h0),</pre>
<pre>    .DReqDepth ({4{4'h0}}),</pre>
<pre>    .DRspDepth ({4{4'h0}}),</pre>
<pre>    .N         (4)</pre>
<pre style="background-color: #FF0000;">  ) u_s1n_15 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_s1n_15_us_h2d),</pre>
<pre>    .tl_h_o       (tl_s1n_15_us_d2h),</pre>
<pre>    .tl_d_o       (tl_s1n_15_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_s1n_15_ds_d2h),</pre>
<pre>    .dev_select   (dev_sel_s1n_15)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqDepth ({3{4'h0}}),</pre>
<pre>    .HRspDepth ({3{4'h0}}),</pre>
<pre>    .DReqDepth (4'h0),</pre>
<pre>    .DRspDepth (4'h0),</pre>
<pre>    .M         (3)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_16 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_16_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_16_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_16_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_16_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqPass  (2'h0),</pre>
<pre>    .HRspPass  (2'h0),</pre>
<pre>    .DReqPass  (1'b0),</pre>
<pre>    .DRspPass  (1'b0),</pre>
<pre>    .M         (2)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_17 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_17_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_17_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_17_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_17_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqDepth ({3{4'h0}}),</pre>
<pre>    .HRspDepth ({3{4'h0}}),</pre>
<pre>    .DReqDepth (4'h0),</pre>
<pre>    .DRspDepth (4'h0),</pre>
<pre>    .M         (3)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_18 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_18_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_18_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_18_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_18_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqDepth ({3{4'h0}}),</pre>
<pre>    .HRspDepth ({3{4'h0}}),</pre>
<pre>    .DReqDepth (4'h0),</pre>
<pre>    .DRspDepth (4'h0),</pre>
<pre>    .M         (3)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_19 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_19_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_19_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_19_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_19_ds_d2h)</pre>
<pre>  tlul_socket_1n #(</pre>
<pre>    .HReqDepth (4'h0),</pre>
<pre>    .HRspDepth (4'h0),</pre>
<pre>    .DReqDepth ({12{4'h0}}),</pre>
<pre>    .DRspDepth ({12{4'h0}}),</pre>
<pre>    .N         (12)</pre>
<pre style="background-color: #FF0000;">  ) u_s1n_20 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_s1n_20_us_h2d),</pre>
<pre>    .tl_h_o       (tl_s1n_20_us_d2h),</pre>
<pre>    .tl_d_o       (tl_s1n_20_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_s1n_20_ds_d2h),</pre>
<pre>    .dev_select   (dev_sel_s1n_20)</pre>
<pre>  tlul_fifo_async #(</pre>
<pre>    .ReqDepth        (3),// At least 3 to make async work</pre>
<pre>    .RspDepth        (3) // At least 3 to make async work</pre>
<pre style="background-color: #FF0000;">  ) u_asf_21 (</pre>
<pre>    .clk_h_i      (clk_main_i),</pre>
<pre>    .rst_h_ni     (rst_main_ni),</pre>
<pre>    .clk_d_i      (clk_fixed_i),</pre>
<pre>    .rst_d_ni     (rst_fixed_ni),</pre>
<pre>    .tl_h_i       (tl_asf_21_us_h2d),</pre>
<pre>    .tl_h_o       (tl_asf_21_us_d2h),</pre>
<pre>    .tl_d_o       (tl_asf_21_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_asf_21_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .M         (2)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_22 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_22_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_22_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_22_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_22_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqPass  (2'h0),</pre>
<pre>    .HRspPass  (2'h0),</pre>
<pre>    .DReqPass  (1'b0),</pre>
<pre>    .DRspPass  (1'b0),</pre>
<pre>    .M         (2)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_23 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_23_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_23_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_23_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_23_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqPass  (2'h0),</pre>
<pre>    .HRspPass  (2'h0),</pre>
<pre>    .DReqPass  (1'b0),</pre>
<pre>    .DRspPass  (1'b0),</pre>
<pre>    .M         (2)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_24 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_24_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_24_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_24_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_24_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqPass  (2'h0),</pre>
<pre>    .HRspPass  (2'h0),</pre>
<pre>    .DReqPass  (1'b0),</pre>
<pre>    .DRspPass  (1'b0),</pre>
<pre>    .M         (2)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_25 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_25_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_25_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_25_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_25_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqPass  (2'h0),</pre>
<pre>    .HRspPass  (2'h0),</pre>
<pre>    .DReqPass  (1'b0),</pre>
<pre>    .DRspPass  (1'b0),</pre>
<pre>    .M         (2)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_26 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_26_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_26_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_26_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_26_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqPass  (2'h0),</pre>
<pre>    .HRspPass  (2'h0),</pre>
<pre>    .DReqPass  (1'b0),</pre>
<pre>    .DRspPass  (1'b0),</pre>
<pre>    .M         (2)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_27 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_27_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_27_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_27_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_27_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqPass  (2'h0),</pre>
<pre>    .HRspPass  (2'h0),</pre>
<pre>    .DReqPass  (1'b0),</pre>
<pre>    .DRspPass  (1'b0),</pre>
<pre>    .M         (2)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_28 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_28_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_28_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_28_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_28_ds_d2h)</pre>
<pre>  tlul_socket_m1 #(</pre>
<pre>    .HReqPass  (2'h0),</pre>
<pre>    .HRspPass  (2'h0),</pre>
<pre>    .DReqPass  (1'b0),</pre>
<pre>    .DRspPass  (1'b0),</pre>
<pre>    .M         (2)</pre>
<pre style="background-color: #FF0000;">  ) u_sm1_29 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_sm1_29_us_h2d),</pre>
<pre>    .tl_h_o       (tl_sm1_29_us_d2h),</pre>
<pre>    .tl_d_o       (tl_sm1_29_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_sm1_29_ds_d2h)</pre>
<pre>  tlul_socket_1n #(</pre>
<pre>    .HReqPass  (1'b0),</pre>
<pre>    .HRspPass  (1'b0),</pre>
<pre>    .DReqPass  (11'h0),</pre>
<pre>    .DRspPass  (11'h0),</pre>
<pre>    .N         (11)</pre>
<pre style="background-color: #FF0000;">  ) u_s1n_30 (</pre>
<pre>    .clk_i        (clk_main_i),</pre>
<pre>    .rst_ni       (rst_main_ni),</pre>
<pre>    .tl_h_i       (tl_s1n_30_us_h2d),</pre>
<pre>    .tl_h_o       (tl_s1n_30_us_d2h),</pre>
<pre>    .tl_d_o       (tl_s1n_30_ds_h2d),</pre>
<pre>    .tl_d_i       (tl_s1n_30_ds_d2h),</pre>
<pre>    .dev_select   (dev_sel_s1n_30)</pre>
<h3>hw/top_earlgrey/ip/xbar_main/rtl/autogen/tl_main_pkg.sv</h3>
<pre>package tl_main_pkg;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_ROM           = 32'h 00008000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_DEBUG_MEM     = 32'h 1a110000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_RAM_MAIN      = 32'h 10000000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_EFLASH        = 32'h 20000000;</pre>
<pre>  localparam logic [1:0][31:0] ADDR_SPACE_PERI          = {</pre>
<pre>    32'h 40000000,</pre>
<pre>    32'h 40080000</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_FLASH_CTRL    = 32'h 40030000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_HMAC          = 32'h 40120000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_AES           = 32'h 40110000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_RV_PLIC       = 32'h 40090000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_PINMUX        = 32'h 40070000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_ALERT_HANDLER = 32'h 40130000;</pre>
<pre>  localparam logic [31:0] ADDR_SPACE_NMI_GEN       = 32'h 40140000;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_ROM           = 32'h 00001fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_DEBUG_MEM     = 32'h 00000fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_RAM_MAIN      = 32'h 0000ffff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_EFLASH        = 32'h 0007ffff;</pre>
<pre>  localparam logic [1:0][31:0] ADDR_MASK_PERI          = {</pre>
<pre>    32'h 00020fff,</pre>
<pre>    32'h 00000fff</pre>
<pre>  localparam logic [31:0] ADDR_MASK_FLASH_CTRL    = 32'h 00000fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_HMAC          = 32'h 00000fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_AES           = 32'h 00000fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_RV_PLIC       = 32'h 00000fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_PINMUX        = 32'h 00000fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_ALERT_HANDLER = 32'h 00000fff;</pre>
<pre>  localparam logic [31:0] ADDR_MASK_NMI_GEN       = 32'h 00000fff;</pre>
<pre>  localparam int N_HOST   = 3;</pre>
<pre>  localparam int N_DEVICE = 12;</pre>
<pre>  typedef enum int {</pre>
<pre>    TlRom = 0,</pre>
<pre>    TlDebugMem = 1,</pre>
<pre>    TlRamMain = 2,</pre>
<pre>    TlEflash = 3,</pre>
<pre>    TlPeri = 4,</pre>
<pre>    TlFlashCtrl = 5,</pre>
<pre>    TlHmac = 6,</pre>
<pre>    TlAes = 7,</pre>
<pre>    TlRvPlic = 8,</pre>
<pre>    TlPinmux = 9,</pre>
<pre>    TlAlertHandler = 10,</pre>
<pre>    TlNmiGen = 11</pre>
<pre>  } tl_device_e;</pre>
<pre>  typedef enum int {</pre>
<pre>    TlCorei = 0,</pre>
<pre>    TlCored = 1,</pre>
<pre>    TlDmSba = 2</pre>
<pre>  } tl_host_e;</pre>
<h3>hw/top_earlgrey/rtl/autogen/top_earlgrey.sv</h3>
<pre>module top_earlgrey #(</pre>
<pre>  parameter bit IbexPipeLine = 0</pre>
<pre>  input               clk_i,</pre>
<pre>  input               rst_ni,</pre>
<pre>  input               jtag_tck_i,</pre>
<pre>  input               jtag_tms_i,</pre>
<pre>  input               jtag_trst_ni,</pre>
<pre>  input               jtag_td_i,</pre>
<pre>  output              jtag_td_o,</pre>
<pre>  input        [31:0] mio_in_i,</pre>
<pre>  output logic [31:0] mio_out_o,</pre>
<pre>  output logic [31:0] mio_oe_o,</pre>
<pre>  input               dio_spi_device_sck_i,</pre>
<pre>  input               dio_spi_device_csb_i,</pre>
<pre>  input               dio_spi_device_mosi_i,</pre>
<pre>  output logic        dio_spi_device_miso_o,</pre>
<pre>  output logic        dio_spi_device_miso_en_o,</pre>
<pre>  input               dio_uart_rx_i,</pre>
<pre>  output logic        dio_uart_tx_o,</pre>
<pre>  output logic        dio_uart_tx_en_o,</pre>
<pre>  input               scanmode_i  // 1 for Scan</pre>
<pre>  localparam JTAG_IDCODE = {</pre>
<pre>    4'h0,     // Version</pre>
<pre>    16'h4F54, // Part Number: "OT"</pre>
<pre>    11'h426,  // Manufacturer Identity: Google</pre>
<pre>    1'b1      // (fixed)</pre>
<pre>  tl_h2d_t  tl_corei_h_h2d;</pre>
<pre>  tl_d2h_t  tl_corei_h_d2h;</pre>
<pre>  tl_h2d_t  tl_cored_h_h2d;</pre>
<pre>  tl_d2h_t  tl_cored_h_d2h;</pre>
<pre>  tl_h2d_t  tl_dm_sba_h_h2d;</pre>
<pre>  tl_d2h_t  tl_dm_sba_h_d2h;</pre>
<pre>  tl_h2d_t  tl_debug_mem_d_h2d;</pre>
<pre>  tl_d2h_t  tl_debug_mem_d_d2h;</pre>
<pre>  tl_h2d_t  tl_uart_d_h2d;</pre>
<pre>  tl_d2h_t  tl_uart_d_d2h;</pre>
<pre>  tl_h2d_t  tl_gpio_d_h2d;</pre>
<pre>  tl_d2h_t  tl_gpio_d_d2h;</pre>
<pre>  tl_h2d_t  tl_spi_device_d_h2d;</pre>
<pre>  tl_d2h_t  tl_spi_device_d_d2h;</pre>
<pre>  tl_h2d_t  tl_flash_ctrl_d_h2d;</pre>
<pre>  tl_d2h_t  tl_flash_ctrl_d_d2h;</pre>
<pre>  tl_h2d_t  tl_rv_timer_d_h2d;</pre>
<pre>  tl_d2h_t  tl_rv_timer_d_d2h;</pre>
<pre>  tl_h2d_t  tl_aes_d_h2d;</pre>
<pre>  tl_d2h_t  tl_aes_d_d2h;</pre>
<pre>  tl_h2d_t  tl_hmac_d_h2d;</pre>
<pre>  tl_d2h_t  tl_hmac_d_d2h;</pre>
<pre>  tl_h2d_t  tl_rv_plic_d_h2d;</pre>
<pre>  tl_d2h_t  tl_rv_plic_d_d2h;</pre>
<pre>  tl_h2d_t  tl_pinmux_d_h2d;</pre>
<pre>  tl_d2h_t  tl_pinmux_d_d2h;</pre>
<pre>  tl_h2d_t  tl_alert_handler_d_h2d;</pre>
<pre>  tl_d2h_t  tl_alert_handler_d_d2h;</pre>
<pre>  tl_h2d_t  tl_nmi_gen_d_h2d;</pre>
<pre>  tl_d2h_t  tl_nmi_gen_d_d2h;</pre>
<pre>  tl_h2d_t tl_rom_d_h2d;</pre>
<pre>  tl_d2h_t tl_rom_d_d2h;</pre>
<pre>  tl_h2d_t tl_ram_main_d_h2d;</pre>
<pre>  tl_d2h_t tl_ram_main_d_d2h;</pre>
<pre>  tl_h2d_t tl_eflash_d_h2d;</pre>
<pre>  tl_d2h_t tl_eflash_d_d2h;</pre>
<pre>  tl_h2d_t tl_main_h_h2d;</pre>
<pre>  tl_d2h_t tl_main_h_d2h;</pre>
<pre>  tl_h2d_t tl_peri_d_h2d;</pre>
<pre>  tl_d2h_t tl_peri_d_d2h;</pre>
<pre>  assign tl_main_h_h2d = tl_peri_d_h2d;</pre>
<pre>  assign tl_peri_d_d2h = tl_main_h_d2h;</pre>
<pre>  logic lc_rst_n;</pre>
<pre>  logic sys_rst_n;</pre>
<pre>  logic sys_fixed_rst_n;</pre>
<pre>  logic spi_device_rst_n;</pre>
<pre>  logic main_clk;</pre>
<pre>  logic fixed_clk;</pre>
<pre>  logic [31:0] m2p;</pre>
<pre>  logic [31:0] p2m;</pre>
<pre>  logic [31:0] p2m_en;</pre>
<pre>  logic        cio_uart_rx_p2d;</pre>
<pre>  logic        cio_uart_tx_d2p;</pre>
<pre>  logic        cio_uart_tx_en_d2p;</pre>
<pre>  logic [31:0] cio_gpio_gpio_p2d;</pre>
<pre>  logic [31:0] cio_gpio_gpio_d2p;</pre>
<pre>  logic [31:0] cio_gpio_gpio_en_d2p;</pre>
<pre>  logic        cio_spi_device_sck_p2d;</pre>
<pre>  logic        cio_spi_device_csb_p2d;</pre>
<pre>  logic        cio_spi_device_mosi_p2d;</pre>
<pre>  logic        cio_spi_device_miso_d2p;</pre>
<pre>  logic        cio_spi_device_miso_en_d2p;</pre>
<pre>  logic [62:0]  intr_vector;</pre>
<pre>  logic intr_uart_tx_watermark;</pre>
<pre>  logic intr_uart_rx_watermark;</pre>
<pre>  logic intr_uart_tx_empty;</pre>
<pre>  logic intr_uart_rx_overflow;</pre>
<pre>  logic intr_uart_rx_frame_err;</pre>
<pre>  logic intr_uart_rx_break_err;</pre>
<pre>  logic intr_uart_rx_timeout;</pre>
<pre>  logic intr_uart_rx_parity_err;</pre>
<pre>  logic [31:0] intr_gpio_gpio;</pre>
<pre>  logic intr_spi_device_rxf;</pre>
<pre>  logic intr_spi_device_rxlvl;</pre>
<pre>  logic intr_spi_device_txlvl;</pre>
<pre>  logic intr_spi_device_rxerr;</pre>
<pre>  logic intr_spi_device_rxoverflow;</pre>
<pre>  logic intr_spi_device_txunderflow;</pre>
<pre>  logic intr_flash_ctrl_prog_empty;</pre>
<pre>  logic intr_flash_ctrl_prog_lvl;</pre>
<pre>  logic intr_flash_ctrl_rd_full;</pre>
<pre>  logic intr_flash_ctrl_rd_lvl;</pre>
<pre>  logic intr_flash_ctrl_op_done;</pre>
<pre>  logic intr_flash_ctrl_op_error;</pre>
<pre>  logic intr_rv_timer_timer_expired_0_0;</pre>
<pre>  logic intr_hmac_hmac_done;</pre>
<pre>  logic intr_hmac_fifo_full;</pre>
<pre>  logic intr_hmac_hmac_err;</pre>
<pre>  logic intr_alert_handler_classa;</pre>
<pre>  logic intr_alert_handler_classb;</pre>
<pre>  logic intr_alert_handler_classc;</pre>
<pre>  logic intr_alert_handler_classd;</pre>
<pre>  logic intr_nmi_gen_esc0;</pre>
<pre>  logic intr_nmi_gen_esc1;</pre>
<pre>  logic intr_nmi_gen_esc2;</pre>
<pre>  logic intr_nmi_gen_esc3;</pre>
<pre>  logic [0:0] irq_plic;</pre>
<pre>  logic [0:0] msip;</pre>
<pre>  logic [5:0] irq_id[1];</pre>
<pre>  logic [5:0] unused_irq_id[1];</pre>
<pre>  assign unused_irq_id = irq_id;</pre>
<pre>  prim_pkg::alert_tx_t [alert_pkg::NAlerts-1:0]  alert_tx;</pre>
<pre>  prim_pkg::alert_rx_t [alert_pkg::NAlerts-1:0]  alert_rx;</pre>
<pre>  prim_pkg::esc_tx_t [alert_pkg::N_ESC_SEV-1:0]  esc_tx;</pre>
<pre>  prim_pkg::esc_rx_t [alert_pkg::N_ESC_SEV-1:0]  esc_rx;</pre>
<pre>  assign main_clk = clk_i;</pre>
<pre>  assign fixed_clk = clk_i;</pre>
<pre>  logic ndmreset_req;</pre>
<pre>  assign lc_rst_n = rst_ni;</pre>
<pre>  assign sys_rst_n = (scanmode_i) ? lc_rst_n : ~ndmreset_req & lc_rst_n;</pre>
<pre>  assign sys_fixed_rst_n = sys_rst_n;</pre>
<pre>  assign spi_device_rst_n = sys_rst_n;</pre>
<pre>  logic debug_req;</pre>
<pre>  rv_core_ibex #(</pre>
<pre>    .PMPEnable           (0),</pre>
<pre>    .PMPGranularity      (0),</pre>
<pre>    .PMPNumRegions       (4),</pre>
<pre>    .MHPMCounterNum      (8),</pre>
<pre>    .MHPMCounterWidth    (40),</pre>
<pre>    .RV32E               (0),</pre>
<pre>    .RV32M               (1),</pre>
<pre>    .DmHaltAddr          (ADDR_SPACE_DEBUG_MEM + dm::HaltAddress),</pre>
<pre>    .DmExceptionAddr     (ADDR_SPACE_DEBUG_MEM + dm::ExceptionAddress),</pre>
<pre>    .PipeLine            (IbexPipeLine)</pre>
<pre style="background-color: #FF0000;">  ) core (</pre>
<pre>    .clk_i                (main_clk),</pre>
<pre>    .rst_ni               (sys_rst_n),</pre>
<pre>    .test_en_i            (1'b0),</pre>
<pre>    .hart_id_i            (32'b0),</pre>
<pre>    .boot_addr_i          (ADDR_SPACE_ROM),</pre>
<pre>    .tl_i_o               (tl_corei_h_h2d),</pre>
<pre>    .tl_i_i               (tl_corei_h_d2h),</pre>
<pre>    .tl_d_o               (tl_cored_h_h2d),</pre>
<pre>    .tl_d_i               (tl_cored_h_d2h),</pre>
<pre>    .irq_software_i       (msip),</pre>
<pre>    .irq_timer_i          (intr_rv_timer_timer_expired_0_0),</pre>
<pre>    .irq_external_i       (irq_plic),</pre>
<pre>    .irq_fast_i           (15'b0),// PLIC handles all peripheral interrupts</pre>
<pre>    .irq_nm_i             (1'b0),// TODO - add and connect alert responder</pre>
<pre>    .debug_req_i          (debug_req),</pre>
<pre>    .fetch_enable_i       (1'b1),</pre>
<pre>    .core_sleep_o         ()</pre>
<pre>  rv_dm #(</pre>
<pre>    .NrHarts     (1),</pre>
<pre>    .IdcodeValue (JTAG_IDCODE)</pre>
<pre>  ) u_dm_top (</pre>
<pre>    .clk_i         (main_clk),</pre>
<pre>    .rst_ni        (lc_rst_n),</pre>
<pre>    .testmode_i    (1'b0),</pre>
<pre>    .ndmreset_o    (ndmreset_req),</pre>
<pre>    .dmactive_o    (),</pre>
<pre>    .debug_req_o   (debug_req),</pre>
<pre>    .unavailable_i (1'b0),</pre>
<pre>    .tl_d_i        (tl_debug_mem_d_h2d),</pre>
<pre>    .tl_d_o        (tl_debug_mem_d_d2h),</pre>
<pre>    .tl_h_o        (tl_dm_sba_h_h2d),</pre>
<pre>    .tl_h_i        (tl_dm_sba_h_d2h),</pre>
<pre>    .tck_i            (jtag_tck_i),</pre>
<pre>    .tms_i            (jtag_tms_i),</pre>
<pre>    .trst_ni          (jtag_trst_ni),</pre>
<pre>    .td_i             (jtag_td_i),</pre>
<pre>    .td_o             (jtag_td_o),</pre>
<pre>    .tdo_oe_o         (       )</pre>
<pre>  logic        rom_req;</pre>
<pre>  logic [10:0] rom_addr;</pre>
<pre>  logic [31:0] rom_rdata;</pre>
<pre>  logic        rom_rvalid;</pre>
<pre>  tlul_adapter_sram #(</pre>
<pre>    .SramAw(11),</pre>
<pre>    .SramDw(32),</pre>
<pre>    .Outstanding(1),</pre>
<pre>    .ErrOnWrite(1)</pre>
<pre style="background-color: #FF0000;">  ) tl_adapter_rom (</pre>
<pre>    .clk_i   (main_clk),</pre>
<pre>    .rst_ni   (sys_rst_n),</pre>
<pre>    .tl_i     (tl_rom_d_h2d),</pre>
<pre>    .tl_o     (tl_rom_d_d2h),</pre>
<pre>    .req_o    (rom_req),</pre>
<pre>    .gnt_i    (1'b1), // Always grant as only one requester exists</pre>
<pre>    .we_o     (),</pre>
<pre>    .addr_o   (rom_addr),</pre>
<pre>    .wdata_o  (),</pre>
<pre>    .wmask_o  (),</pre>
<pre>    .rdata_i  (rom_rdata),</pre>
<pre>    .rvalid_i (rom_rvalid),</pre>
<pre>    .rerror_i (2'b00)</pre>
<pre>  prim_rom #(</pre>
<pre>    .Width(32),</pre>
<pre>    .Depth(2048)</pre>
<pre style="background-color: #FF0000;">  ) u_rom_rom (</pre>
<pre>    .clk_i   (main_clk),</pre>
<pre>    .rst_ni   (sys_rst_n),</pre>
<pre>    .cs_i     (rom_req),</pre>
<pre>    .addr_i   (rom_addr),</pre>
<pre>    .dout_o   (rom_rdata),</pre>
<pre>    .dvalid_o (rom_rvalid)</pre>
<pre>  logic        ram_main_req;</pre>
<pre>  logic        ram_main_we;</pre>
<pre>  logic [13:0] ram_main_addr;</pre>
<pre>  logic [31:0] ram_main_wdata;</pre>
<pre>  logic [31:0] ram_main_wmask;</pre>
<pre>  logic [31:0] ram_main_rdata;</pre>
<pre>  logic        ram_main_rvalid;</pre>
<pre>  tlul_adapter_sram #(</pre>
<pre>    .SramAw(14),</pre>
<pre>    .SramDw(32),</pre>
<pre>    .Outstanding(1)</pre>
<pre style="background-color: #FF0000;">  ) tl_adapter_ram_main (</pre>
<pre>    .clk_i   (main_clk),</pre>
<pre>    .rst_ni   (sys_rst_n),</pre>
<pre>    .tl_i     (tl_ram_main_d_h2d),</pre>
<pre>    .tl_o     (tl_ram_main_d_d2h),</pre>
<pre>    .req_o    (ram_main_req),</pre>
<pre>    .gnt_i    (1'b1), // Always grant as only one requester exists</pre>
<pre>    .we_o     (ram_main_we),</pre>
<pre>    .addr_o   (ram_main_addr),</pre>
<pre>    .wdata_o  (ram_main_wdata),</pre>
<pre>    .wmask_o  (ram_main_wmask),</pre>
<pre>    .rdata_i  (ram_main_rdata),</pre>
<pre>    .rvalid_i (ram_main_rvalid),</pre>
<pre>    .rerror_i (2'b00)</pre>
<pre>  prim_ram_1p #(</pre>
<pre>    .Width(32),</pre>
<pre>    .Depth(16384),</pre>
<pre>    .DataBitsPerMask(8)</pre>
<pre style="background-color: #FF0000;">  ) u_ram1p_ram_main (</pre>
<pre>    .clk_i   (main_clk),</pre>
<pre>    .rst_ni   (sys_rst_n),</pre>
<pre>    .req_i    (ram_main_req),</pre>
<pre>    .write_i  (ram_main_we),</pre>
<pre>    .addr_i   (ram_main_addr),</pre>
<pre>    .wdata_i  (ram_main_wdata),</pre>
<pre>    .wmask_i  (ram_main_wmask),</pre>
<pre>    .rvalid_o (ram_main_rvalid),</pre>
<pre>    .rdata_o  (ram_main_rdata)</pre>
<pre>  flash_c2m_t flash_c2m;</pre>
<pre>  flash_m2c_t flash_m2c;</pre>
<pre>  logic flash_host_req;</pre>
<pre>  logic flash_host_req_rdy;</pre>
<pre>  logic flash_host_req_done;</pre>
<pre>  logic [FLASH_DW-1:0] flash_host_rdata;</pre>
<pre>  logic [FLASH_AW-1:0] flash_host_addr;</pre>
<pre>  tlul_adapter_sram #(</pre>
<pre>    .SramAw(FLASH_AW),</pre>
<pre>    .SramDw(FLASH_DW),</pre>
<pre>    .Outstanding(1),</pre>
<pre>    .ByteAccess(0),</pre>
<pre>    .ErrOnWrite(1)</pre>
<pre>  ) tl_adapter_eflash (</pre>
<pre>    .clk_i   (main_clk),</pre>
<pre>    .rst_ni   (lc_rst_n),</pre>
<pre>    .tl_i       (tl_eflash_d_h2d),</pre>
<pre>    .tl_o       (tl_eflash_d_d2h),</pre>
<pre>    .req_o    (flash_host_req),</pre>
<pre>    .gnt_i    (flash_host_req_rdy),</pre>
<pre>    .we_o     (),</pre>
<pre>    .addr_o   (flash_host_addr),</pre>
<pre>    .wdata_o  (),</pre>
<pre>    .wmask_o  (),</pre>
<pre>    .rdata_i  (flash_host_rdata),</pre>
<pre>    .rvalid_i (flash_host_req_done),</pre>
<pre>    .rerror_i (2'b00)</pre>
<pre>  flash_phy #(</pre>
<pre>    .NumBanks(FLASH_BANKS),</pre>
<pre>    .PagesPerBank(FLASH_PAGES_PER_BANK),</pre>
<pre>    .WordsPerPage(FLASH_WORDS_PER_PAGE),</pre>
<pre>    .DataWidth(32)</pre>
<pre>  ) u_flash_eflash (</pre>
<pre>    .clk_i   (main_clk),</pre>
<pre>    .rst_ni   (lc_rst_n),</pre>
<pre>    .host_req_i      (flash_host_req),</pre>
<pre>    .host_addr_i     (flash_host_addr),</pre>
<pre>    .host_req_rdy_o  (flash_host_req_rdy),</pre>
<pre>    .host_req_done_o (flash_host_req_done),</pre>
<pre>    .host_rdata_o    (flash_host_rdata),</pre>
<pre>    .flash_ctrl_i    (flash_c2m),</pre>
<pre>    .flash_ctrl_o    (flash_m2c)</pre>
<pre>  uart uart (</pre>
<pre>      .tl_i (tl_uart_d_h2d),</pre>
<pre>      .tl_o (tl_uart_d_d2h),</pre>
<pre>      .cio_rx_i    (cio_uart_rx_p2d),</pre>
<pre>      .cio_tx_o    (cio_uart_tx_d2p),</pre>
<pre>      .cio_tx_en_o (cio_uart_tx_en_d2p),</pre>
<pre>      .intr_tx_watermark_o  (intr_uart_tx_watermark),</pre>
<pre>      .intr_rx_watermark_o  (intr_uart_rx_watermark),</pre>
<pre>      .intr_tx_empty_o      (intr_uart_tx_empty),</pre>
<pre>      .intr_rx_overflow_o   (intr_uart_rx_overflow),</pre>
<pre>      .intr_rx_frame_err_o  (intr_uart_rx_frame_err),</pre>
<pre>      .intr_rx_break_err_o  (intr_uart_rx_break_err),</pre>
<pre>      .intr_rx_timeout_o    (intr_uart_rx_timeout),</pre>
<pre>      .intr_rx_parity_err_o (intr_uart_rx_parity_err),</pre>
<pre>      .clk_i (fixed_clk),</pre>
<pre>      .rst_ni (sys_fixed_rst_n)</pre>
<pre>  gpio gpio (</pre>
<pre>      .tl_i (tl_gpio_d_h2d),</pre>
<pre>      .tl_o (tl_gpio_d_d2h),</pre>
<pre>      .cio_gpio_i    (cio_gpio_gpio_p2d),</pre>
<pre>      .cio_gpio_o    (cio_gpio_gpio_d2p),</pre>
<pre>      .cio_gpio_en_o (cio_gpio_gpio_en_d2p),</pre>
<pre>      .intr_gpio_o (intr_gpio_gpio),</pre>
<pre>      .clk_i (fixed_clk),</pre>
<pre>      .rst_ni (sys_fixed_rst_n)</pre>
<pre>  spi_device spi_device (</pre>
<pre>      .tl_i (tl_spi_device_d_h2d),</pre>
<pre>      .tl_o (tl_spi_device_d_d2h),</pre>
<pre>      .cio_sck_i     (cio_spi_device_sck_p2d),</pre>
<pre>      .cio_csb_i     (cio_spi_device_csb_p2d),</pre>
<pre>      .cio_mosi_i    (cio_spi_device_mosi_p2d),</pre>
<pre>      .cio_miso_o    (cio_spi_device_miso_d2p),</pre>
<pre>      .cio_miso_en_o (cio_spi_device_miso_en_d2p),</pre>
<pre>      .intr_rxf_o         (intr_spi_device_rxf),</pre>
<pre>      .intr_rxlvl_o       (intr_spi_device_rxlvl),</pre>
<pre>      .intr_txlvl_o       (intr_spi_device_txlvl),</pre>
<pre>      .intr_rxerr_o       (intr_spi_device_rxerr),</pre>
<pre>      .intr_rxoverflow_o  (intr_spi_device_rxoverflow),</pre>
<pre>      .intr_txunderflow_o (intr_spi_device_txunderflow),</pre>
<pre>      .scanmode_i   (scanmode_i),</pre>
<pre>      .clk_i (fixed_clk),</pre>
<pre>      .rst_ni (spi_device_rst_n)</pre>
<pre>  flash_ctrl flash_ctrl (</pre>
<pre>      .tl_i (tl_flash_ctrl_d_h2d),</pre>
<pre>      .tl_o (tl_flash_ctrl_d_d2h),</pre>
<pre>      .intr_prog_empty_o (intr_flash_ctrl_prog_empty),</pre>
<pre>      .intr_prog_lvl_o   (intr_flash_ctrl_prog_lvl),</pre>
<pre>      .intr_rd_full_o    (intr_flash_ctrl_rd_full),</pre>
<pre>      .intr_rd_lvl_o     (intr_flash_ctrl_rd_lvl),</pre>
<pre>      .intr_op_done_o    (intr_flash_ctrl_op_done),</pre>
<pre>      .intr_op_error_o   (intr_flash_ctrl_op_error),</pre>
<pre>      .flash_o(flash_c2m),</pre>
<pre>      .flash_i(flash_m2c),</pre>
<pre>      .clk_i (main_clk),</pre>
<pre>      .rst_ni (lc_rst_n)</pre>
<pre>  rv_timer rv_timer (</pre>
<pre>      .tl_i (tl_rv_timer_d_h2d),</pre>
<pre>      .tl_o (tl_rv_timer_d_d2h),</pre>
<pre>      .intr_timer_expired_0_0_o (intr_rv_timer_timer_expired_0_0),</pre>
<pre>      .clk_i (fixed_clk),</pre>
<pre>      .rst_ni (sys_fixed_rst_n)</pre>
<pre>  aes aes (</pre>
<pre>      .tl_i (tl_aes_d_h2d),</pre>
<pre>      .tl_o (tl_aes_d_d2h),</pre>
<pre>      .clk_i (main_clk),</pre>
<pre>      .rst_ni (sys_rst_n)</pre>
<pre>  hmac hmac (</pre>
<pre>      .tl_i (tl_hmac_d_h2d),</pre>
<pre>      .tl_o (tl_hmac_d_d2h),</pre>
<pre>      .intr_hmac_done_o (intr_hmac_hmac_done),</pre>
<pre>      .intr_fifo_full_o (intr_hmac_fifo_full),</pre>
<pre>      .intr_hmac_err_o  (intr_hmac_hmac_err),</pre>
<pre>      .alert_tx_o  ( alert_tx[0:0] ),</pre>
<pre>      .alert_rx_i  ( alert_rx[0:0] ),</pre>
<pre>      .clk_i (main_clk),</pre>
<pre>      .rst_ni (sys_rst_n)</pre>
<pre>  rv_plic rv_plic (</pre>
<pre>      .tl_i (tl_rv_plic_d_h2d),</pre>
<pre>      .tl_o (tl_rv_plic_d_d2h),</pre>
<pre>      .intr_src_i (intr_vector),</pre>
<pre>      .irq_o      (irq_plic),</pre>
<pre>      .irq_id_o   (irq_id),</pre>
<pre>      .msip_o     (msip),</pre>
<pre>      .clk_i (main_clk),</pre>
<pre>      .rst_ni (sys_rst_n)</pre>
<pre>  pinmux pinmux (</pre>
<pre>      .tl_i (tl_pinmux_d_h2d),</pre>
<pre>      .tl_o (tl_pinmux_d_d2h),</pre>
<pre>      .periph_to_mio_i      (p2m    ),</pre>
<pre>      .periph_to_mio_oe_i   (p2m_en ),</pre>
<pre>      .mio_to_periph_o      (m2p    ),</pre>
<pre>      .mio_out_o            (mio_out_o),</pre>
<pre>      .mio_oe_o             (mio_oe_o ),</pre>
<pre>      .mio_in_i             (mio_in_i ),</pre>
<pre>      .clk_i (main_clk),</pre>
<pre>      .rst_ni (sys_rst_n)</pre>
<pre>  alert_handler alert_handler (</pre>
<pre>      .tl_i (tl_alert_handler_d_h2d),</pre>
<pre>      .tl_o (tl_alert_handler_d_d2h),</pre>
<pre>      .intr_classa_o (intr_alert_handler_classa),</pre>
<pre>      .intr_classb_o (intr_alert_handler_classb),</pre>
<pre>      .intr_classc_o (intr_alert_handler_classc),</pre>
<pre>      .intr_classd_o (intr_alert_handler_classd),</pre>
<pre>      .crashdump_o (          ),</pre>
<pre>      .entropy_i   ( 1'b0     ),</pre>
<pre>      .alert_rx_o  ( alert_rx ),</pre>
<pre>      .alert_tx_i  ( alert_tx ),</pre>
<pre>      .esc_rx_i    ( esc_rx   ),</pre>
<pre>      .esc_tx_o    ( esc_tx   ),</pre>
<pre>      .clk_i (main_clk),</pre>
<pre>      .rst_ni (sys_rst_n)</pre>
<pre>  nmi_gen nmi_gen (</pre>
<pre>      .tl_i (tl_nmi_gen_d_h2d),</pre>
<pre>      .tl_o (tl_nmi_gen_d_d2h),</pre>
<pre>      .intr_esc0_o (intr_nmi_gen_esc0),</pre>
<pre>      .intr_esc1_o (intr_nmi_gen_esc1),</pre>
<pre>      .intr_esc2_o (intr_nmi_gen_esc2),</pre>
<pre>      .intr_esc3_o (intr_nmi_gen_esc3),</pre>
<pre>      .esc_rx_o    ( esc_rx   ),</pre>
<pre>      .esc_tx_i    ( esc_tx   ),</pre>
<pre>      .clk_i (main_clk),</pre>
<pre>      .rst_ni (sys_rst_n)</pre>
<pre>  assign intr_vector = {</pre>
<pre>      intr_nmi_gen_esc3,</pre>
<pre>      intr_nmi_gen_esc2,</pre>
<pre>      intr_nmi_gen_esc1,</pre>
<pre>      intr_nmi_gen_esc0,</pre>
<pre>      intr_alert_handler_classd,</pre>
<pre>      intr_alert_handler_classc,</pre>
<pre>      intr_alert_handler_classb,</pre>
<pre>      intr_alert_handler_classa,</pre>
<pre>      intr_hmac_hmac_err,</pre>
<pre>      intr_hmac_fifo_full,</pre>
<pre>      intr_hmac_hmac_done,</pre>
<pre>      intr_flash_ctrl_op_error,</pre>
<pre>      intr_flash_ctrl_op_done,</pre>
<pre>      intr_flash_ctrl_rd_lvl,</pre>
<pre>      intr_flash_ctrl_rd_full,</pre>
<pre>      intr_flash_ctrl_prog_lvl,</pre>
<pre>      intr_flash_ctrl_prog_empty,</pre>
<pre>      intr_spi_device_txunderflow,</pre>
<pre>      intr_spi_device_rxoverflow,</pre>
<pre>      intr_spi_device_rxerr,</pre>
<pre>      intr_spi_device_txlvl,</pre>
<pre>      intr_spi_device_rxlvl,</pre>
<pre>      intr_spi_device_rxf,</pre>
<pre>      intr_uart_rx_parity_err,</pre>
<pre>      intr_uart_rx_timeout,</pre>
<pre>      intr_uart_rx_break_err,</pre>
<pre>      intr_uart_rx_frame_err,</pre>
<pre>      intr_uart_rx_overflow,</pre>
<pre>      intr_uart_tx_empty,</pre>
<pre>      intr_uart_rx_watermark,</pre>
<pre>      intr_uart_tx_watermark,</pre>
<pre>      intr_gpio_gpio</pre>
<pre>  xbar_main u_xbar_main (</pre>
<pre>    .clk_main_i (main_clk),</pre>
<pre>    .clk_fixed_i (fixed_clk),</pre>
<pre>    .rst_main_ni (sys_rst_n),</pre>
<pre>    .rst_fixed_ni (sys_fixed_rst_n),</pre>
<pre>    .tl_corei_i         (tl_corei_h_h2d),</pre>
<pre>    .tl_corei_o         (tl_corei_h_d2h),</pre>
<pre>    .tl_cored_i         (tl_cored_h_h2d),</pre>
<pre>    .tl_cored_o         (tl_cored_h_d2h),</pre>
<pre>    .tl_dm_sba_i        (tl_dm_sba_h_h2d),</pre>
<pre>    .tl_dm_sba_o        (tl_dm_sba_h_d2h),</pre>
<pre>    .tl_rom_o           (tl_rom_d_h2d),</pre>
<pre>    .tl_rom_i           (tl_rom_d_d2h),</pre>
<pre>    .tl_debug_mem_o     (tl_debug_mem_d_h2d),</pre>
<pre>    .tl_debug_mem_i     (tl_debug_mem_d_d2h),</pre>
<pre>    .tl_ram_main_o      (tl_ram_main_d_h2d),</pre>
<pre>    .tl_ram_main_i      (tl_ram_main_d_d2h),</pre>
<pre>    .tl_eflash_o        (tl_eflash_d_h2d),</pre>
<pre>    .tl_eflash_i        (tl_eflash_d_d2h),</pre>
<pre>    .tl_peri_o          (tl_peri_d_h2d),</pre>
<pre>    .tl_peri_i          (tl_peri_d_d2h),</pre>
<pre>    .tl_flash_ctrl_o    (tl_flash_ctrl_d_h2d),</pre>
<pre>    .tl_flash_ctrl_i    (tl_flash_ctrl_d_d2h),</pre>
<pre>    .tl_hmac_o          (tl_hmac_d_h2d),</pre>
<pre>    .tl_hmac_i          (tl_hmac_d_d2h),</pre>
<pre>    .tl_aes_o           (tl_aes_d_h2d),</pre>
<pre>    .tl_aes_i           (tl_aes_d_d2h),</pre>
<pre>    .tl_rv_plic_o       (tl_rv_plic_d_h2d),</pre>
<pre>    .tl_rv_plic_i       (tl_rv_plic_d_d2h),</pre>
<pre>    .tl_pinmux_o        (tl_pinmux_d_h2d),</pre>
<pre>    .tl_pinmux_i        (tl_pinmux_d_d2h),</pre>
<pre>    .tl_alert_handler_o (tl_alert_handler_d_h2d),</pre>
<pre>    .tl_alert_handler_i (tl_alert_handler_d_d2h),</pre>
<pre>    .tl_nmi_gen_o       (tl_nmi_gen_d_h2d),</pre>
<pre>    .tl_nmi_gen_i       (tl_nmi_gen_d_d2h),</pre>
<pre>    .scanmode_i</pre>
<pre>  xbar_peri u_xbar_peri (</pre>
<pre>    .clk_peri_i (fixed_clk),</pre>
<pre>    .rst_peri_ni (sys_fixed_rst_n),</pre>
<pre>    .tl_main_i       (tl_main_h_h2d),</pre>
<pre>    .tl_main_o       (tl_main_h_d2h),</pre>
<pre>    .tl_uart_o       (tl_uart_d_h2d),</pre>
<pre>    .tl_uart_i       (tl_uart_d_d2h),</pre>
<pre>    .tl_gpio_o       (tl_gpio_d_h2d),</pre>
<pre>    .tl_gpio_i       (tl_gpio_d_d2h),</pre>
<pre>    .tl_spi_device_o (tl_spi_device_d_h2d),</pre>
<pre>    .tl_spi_device_i (tl_spi_device_d_d2h),</pre>
<pre>    .tl_rv_timer_o   (tl_rv_timer_d_h2d),</pre>
<pre>    .tl_rv_timer_i   (tl_rv_timer_d_d2h),</pre>
<pre>    .scanmode_i</pre>
<pre>  assign p2m = {</pre>
<pre>    cio_gpio_gpio_d2p</pre>
<pre>  assign p2m_en = {</pre>
<pre>    cio_gpio_gpio_en_d2p</pre>
<pre>  assign {</pre>
<pre>    cio_gpio_gpio_p2d</pre>
<pre>  } = m2p;</pre>
<pre>  assign cio_spi_device_sck_p2d   = dio_spi_device_sck_i;</pre>
<pre>  assign cio_spi_device_csb_p2d   = dio_spi_device_csb_i;</pre>
<pre>  assign cio_spi_device_mosi_p2d  = dio_spi_device_mosi_i;</pre>
<pre>  assign dio_spi_device_miso_o    = cio_spi_device_miso_d2p;</pre>
<pre>  assign dio_spi_device_miso_en_o = cio_spi_device_miso_en_d2p;</pre>
<pre>  assign cio_uart_rx_p2d          = dio_uart_rx_i;</pre>
<pre>  assign dio_uart_tx_o            = cio_uart_tx_d2p;</pre>
<pre>  assign dio_uart_tx_en_o         = cio_uart_tx_en_d2p;</pre>
<h3>hw/top_earlgrey/rtl/padctl.sv</h3>
<pre>  input   cio_uart_tx_d2p,</pre>
<pre>  input   cio_uart_tx_en_d2p,</pre>
<pre>  output  cio_uart_rx_p2d,</pre>
<pre>  input   IO_URX,</pre>
<pre>  output  IO_UTX,</pre>
<pre>  input   [31:0] cio_gpio_d2p,</pre>
<pre>  input   [31:0] cio_gpio_en_d2p,</pre>
<pre>  output  [31:0] cio_gpio_p2d,</pre>
<pre>  inout   IO_GP0,</pre>
<pre>  inout   IO_GP1,</pre>
<pre>  inout   IO_GP2,</pre>
<pre>  inout   IO_GP3,</pre>
<pre>  inout   IO_GP4,</pre>
<pre>  inout   IO_GP5,</pre>
<pre>  inout   IO_GP6,</pre>
<pre>  inout   IO_GP7,</pre>
<pre>  inout   IO_GP8,</pre>
<pre>  inout   IO_GP9,</pre>
<pre>  inout   IO_GP10,</pre>
<pre>  inout   IO_GP11,</pre>
<pre>  inout   IO_GP12,</pre>
<pre>  inout   IO_GP13,</pre>
<pre>  inout   IO_GP14,</pre>
<pre>  inout   IO_GP15,</pre>
<pre>  output cio_spi_device_sck_p2d,</pre>
<pre>  output cio_spi_device_csb_p2d,</pre>
<pre>  output cio_spi_device_mosi_p2d,</pre>
<pre>  input  cio_spi_device_miso_d2p,</pre>
<pre>  input  cio_spi_device_miso_en_d2p,</pre>
<pre>  output cio_jtag_tck_p2d,</pre>
<pre>  output cio_jtag_tms_p2d,</pre>
<pre>  output cio_jtag_trst_n_p2d,</pre>
<pre>  output cio_jtag_srst_n_p2d,</pre>
<pre>  output cio_jtag_tdi_p2d,</pre>
<pre>  input  cio_jtag_tdo_d2p,</pre>
<pre>  input  IO_DPS0,</pre>
<pre>  input  IO_DPS1,</pre>
<pre>  output IO_DPS2,</pre>
<pre>  input  IO_DPS3,</pre>
<pre>  input  IO_DPS4,</pre>
<pre>  input  IO_DPS5,</pre>
<pre>  input  IO_DPS6,</pre>
<pre>  input  IO_DPS7</pre>
<pre>  logic    jtag_spi_n, dps2, dps2_en;</pre>
<pre>  logic    boot_strap;</pre>
<pre>  assign  cio_uart_rx_p2d = IO_URX;</pre>
<pre>  assign  IO_UTX = cio_uart_tx_en_d2p ? cio_uart_tx_d2p : 1'bz;</pre>
<pre>  assign  cio_gpio_p2d = {</pre>
<pre>      14'h0,      // unpopulated</pre>
<pre>      boot_strap, // Use GPIO17 to pass rom boot_strap indication</pre>
<pre>      jtag_spi_n, // Use GPIO16 to pass SPI/JTAG control flag</pre>
<pre>      IO_GP15,</pre>
<pre>      IO_GP14,</pre>
<pre>      IO_GP13,</pre>
<pre>      IO_GP12,</pre>
<pre>      IO_GP11,</pre>
<pre>      IO_GP10,</pre>
<pre>      IO_GP9,</pre>
<pre>      IO_GP8,</pre>
<pre>      IO_GP7,</pre>
<pre>      IO_GP6,</pre>
<pre>      IO_GP5,</pre>
<pre>      IO_GP4,</pre>
<pre>      IO_GP3,</pre>
<pre>      IO_GP2,</pre>
<pre>      IO_GP1,</pre>
<pre>      IO_GP0</pre>
<pre>  assign  IO_GP0  = cio_gpio_en_d2p[0]  ? cio_gpio_d2p[0]  : 1'bz;</pre>
<pre>  assign  IO_GP1  = cio_gpio_en_d2p[1]  ? cio_gpio_d2p[1]  : 1'bz;</pre>
<pre>  assign  IO_GP2  = cio_gpio_en_d2p[2]  ? cio_gpio_d2p[2]  : 1'bz;</pre>
<pre>  assign  IO_GP3  = cio_gpio_en_d2p[3]  ? cio_gpio_d2p[3]  : 1'bz;</pre>
<pre>  assign  IO_GP4  = cio_gpio_en_d2p[4]  ? cio_gpio_d2p[4]  : 1'bz;</pre>
<pre>  assign  IO_GP5  = cio_gpio_en_d2p[5]  ? cio_gpio_d2p[5]  : 1'bz;</pre>
<pre>  assign  IO_GP6  = cio_gpio_en_d2p[6]  ? cio_gpio_d2p[6]  : 1'bz;</pre>
<pre>  assign  IO_GP7  = cio_gpio_en_d2p[7]  ? cio_gpio_d2p[7]  : 1'bz;</pre>
<pre>  assign  IO_GP8  = cio_gpio_en_d2p[8]  ? cio_gpio_d2p[8]  : 1'bz;</pre>
<pre>  assign  IO_GP9  = cio_gpio_en_d2p[9]  ? cio_gpio_d2p[9]  : 1'bz;</pre>
<pre>  assign  IO_GP10 = cio_gpio_en_d2p[10] ? cio_gpio_d2p[10] : 1'bz;</pre>
<pre>  assign  IO_GP11 = cio_gpio_en_d2p[11] ? cio_gpio_d2p[11] : 1'bz;</pre>
<pre>  assign  IO_GP12 = cio_gpio_en_d2p[12] ? cio_gpio_d2p[12] : 1'bz;</pre>
<pre>  assign  IO_GP13 = cio_gpio_en_d2p[13] ? cio_gpio_d2p[13] : 1'bz;</pre>
<pre>  assign  IO_GP14 = cio_gpio_en_d2p[14] ? cio_gpio_d2p[14] : 1'bz;</pre>
<pre>  assign  IO_GP15 = cio_gpio_en_d2p[15] ? cio_gpio_d2p[15] : 1'bz;</pre>
<pre>  assign jtag_spi_n = IO_DPS6;</pre>
<pre>  assign boot_strap = IO_DPS7;</pre>
<pre>  assign cio_spi_device_sck_p2d  = jtag_spi_n ?  0         : IO_DPS0;</pre>
<pre>  assign cio_jtag_tck_p2d        = jtag_spi_n ?  IO_DPS0   : 0;</pre>
<pre>  assign cio_spi_device_mosi_p2d = jtag_spi_n ?  0         : IO_DPS1;</pre>
<pre>  assign cio_jtag_tdi_p2d        = jtag_spi_n ?  IO_DPS1   : 0;</pre>
<pre>  assign dps2    = jtag_spi_n ?    cio_jtag_tdo_d2p : cio_spi_device_miso_d2p;</pre>
<pre>  assign dps2_en = jtag_spi_n ?    1                : cio_spi_device_miso_en_d2p;</pre>
<pre>  assign IO_DPS2 = dps2_en ? dps2 : 1'bz;</pre>
<pre>  assign cio_spi_device_csb_p2d  = jtag_spi_n ?  1         : IO_DPS3;</pre>
<pre>  assign cio_jtag_tms_p2d        = jtag_spi_n ?  IO_DPS3   : 0;</pre>
<pre>  assign cio_jtag_trst_n_p2d     = jtag_spi_n ?  IO_DPS4   : 1;</pre>
<pre>  assign cio_jtag_srst_n_p2d     = jtag_spi_n ?  IO_DPS5   : 1;</pre>
<h3>hw/ip/rv_timer/rtl/timer_core.sv</h3>
<pre>module timer_core #(</pre>
<pre>  parameter int N = 1</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input        active,</pre>
<pre>  input [11:0] prescaler,</pre>
<pre>  input [ 7:0] step,</pre>
<pre>  output logic        tick,</pre>
<pre>  output logic [63:0] mtime_d,</pre>
<pre>  input        [63:0] mtime,</pre>
<pre>  input        [63:0] mtimecmp [N],</pre>
<pre>  output logic [N-1:0] intr</pre>
<pre>  logic [11:0] tick_count;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : generate_tick</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      tick_count <= 12'h0;</pre>
<pre>    end else if (!active) begin</pre>
<pre>      tick_count <= 12'h0;</pre>
<pre>    end else if (tick_count == prescaler) begin</pre>
<pre>      tick_count <= 12'h0;</pre>
<pre>    end else begin</pre>
<pre>      tick_count <= tick_count + 1'b1;</pre>
<pre>  assign tick = active & (tick_count >= prescaler);</pre>
<pre>  assign mtime_d = mtime + 64'(step);</pre>
<pre>  for (genvar t = 0 ; t < N ; t++) begin : gen_intr</pre>
<pre>    assign intr[t] = active & (mtime >= mtimecmp[t]);</pre>
<pre style="background-color: #FF0000;">endmodule : timer_core</pre>
<h3>hw/ip/rv_timer/rtl/rv_timer_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output rv_timer_reg_pkg::rv_timer_reg2hw_t reg2hw, // Write</pre>
<pre>  input  rv_timer_reg_pkg::rv_timer_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam int AW = 9;</pre>
<pre>  localparam int DW = 32;</pre>
<pre>  localparam int DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  assign tl_reg_h2d = tl_i;</pre>
<pre>  assign tl_o       = tl_reg_d2h;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic ctrl_qs;</pre>
<pre>  logic ctrl_wd;</pre>
<pre>  logic ctrl_we;</pre>
<pre>  logic [11:0] cfg0_prescale_qs;</pre>
<pre>  logic [11:0] cfg0_prescale_wd;</pre>
<pre>  logic cfg0_prescale_we;</pre>
<pre>  logic [7:0] cfg0_step_qs;</pre>
<pre>  logic [7:0] cfg0_step_wd;</pre>
<pre>  logic cfg0_step_we;</pre>
<pre>  logic [31:0] timer_v_lower0_qs;</pre>
<pre>  logic [31:0] timer_v_lower0_wd;</pre>
<pre>  logic timer_v_lower0_we;</pre>
<pre>  logic [31:0] timer_v_upper0_qs;</pre>
<pre>  logic [31:0] timer_v_upper0_wd;</pre>
<pre>  logic timer_v_upper0_we;</pre>
<pre>  logic [31:0] compare_lower0_0_qs;</pre>
<pre>  logic [31:0] compare_lower0_0_wd;</pre>
<pre>  logic compare_lower0_0_we;</pre>
<pre>  logic [31:0] compare_upper0_0_qs;</pre>
<pre>  logic [31:0] compare_upper0_0_wd;</pre>
<pre>  logic compare_upper0_0_we;</pre>
<pre>  logic intr_enable0_qs;</pre>
<pre>  logic intr_enable0_wd;</pre>
<pre>  logic intr_enable0_we;</pre>
<pre>  logic intr_state0_qs;</pre>
<pre>  logic intr_state0_wd;</pre>
<pre>  logic intr_state0_we;</pre>
<pre>  logic intr_test0_wd;</pre>
<pre>  logic intr_test0_we;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_we),</pre>
<pre>    .wd     (ctrl_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl[0].q ),</pre>
<pre>    .qs     (ctrl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (12),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (12'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg0_prescale (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (cfg0_prescale_we),</pre>
<pre>    .wd     (cfg0_prescale_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.cfg0.prescale.q ),</pre>
<pre>    .qs     (cfg0_prescale_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (8),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (8'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg0_step (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (cfg0_step_we),</pre>
<pre>    .wd     (cfg0_step_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.cfg0.step.q ),</pre>
<pre>    .qs     (cfg0_step_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_timer_v_lower0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (timer_v_lower0_we),</pre>
<pre>    .wd     (timer_v_lower0_wd),</pre>
<pre>    .de     (hw2reg.timer_v_lower0.de),</pre>
<pre>    .d      (hw2reg.timer_v_lower0.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.timer_v_lower0.q ),</pre>
<pre>    .qs     (timer_v_lower0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_timer_v_upper0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (timer_v_upper0_we),</pre>
<pre>    .wd     (timer_v_upper0_wd),</pre>
<pre>    .de     (hw2reg.timer_v_upper0.de),</pre>
<pre>    .d      (hw2reg.timer_v_upper0.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.timer_v_upper0.q ),</pre>
<pre>    .qs     (timer_v_upper0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'hffffffff)</pre>
<pre style="background-color: #FF0000;">  ) u_compare_lower0_0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (compare_lower0_0_we),</pre>
<pre>    .wd     (compare_lower0_0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.compare_lower0_0.q ),</pre>
<pre>    .qs     (compare_lower0_0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'hffffffff)</pre>
<pre style="background-color: #FF0000;">  ) u_compare_upper0_0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (compare_upper0_0_we),</pre>
<pre>    .wd     (compare_upper0_0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.compare_upper0_0.q ),</pre>
<pre>    .qs     (compare_upper0_0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable0_we),</pre>
<pre>    .wd     (intr_enable0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable0[0].q ),</pre>
<pre>    .qs     (intr_enable0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state0_we),</pre>
<pre>    .wd     (intr_state0_wd),</pre>
<pre>    .de     (hw2reg.intr_state0[0].de),</pre>
<pre>    .d      (hw2reg.intr_state0[0].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state0[0].q ),</pre>
<pre>    .qs     (intr_state0_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test0 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test0_we),</pre>
<pre>    .wd     (intr_test0_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test0[0].qe),</pre>
<pre>    .q      (reg2hw.intr_test0[0].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  logic [8:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[0] = (reg_addr == RV_TIMER_CTRL_OFFSET);</pre>
<pre>    addr_hit[1] = (reg_addr == RV_TIMER_CFG0_OFFSET);</pre>
<pre>    addr_hit[2] = (reg_addr == RV_TIMER_TIMER_V_LOWER0_OFFSET);</pre>
<pre>    addr_hit[3] = (reg_addr == RV_TIMER_TIMER_V_UPPER0_OFFSET);</pre>
<pre>    addr_hit[4] = (reg_addr == RV_TIMER_COMPARE_LOWER0_0_OFFSET);</pre>
<pre>    addr_hit[5] = (reg_addr == RV_TIMER_COMPARE_UPPER0_0_OFFSET);</pre>
<pre>    addr_hit[6] = (reg_addr == RV_TIMER_INTR_ENABLE0_OFFSET);</pre>
<pre>    addr_hit[7] = (reg_addr == RV_TIMER_INTR_STATE0_OFFSET);</pre>
<pre>    addr_hit[8] = (reg_addr == RV_TIMER_INTR_TEST0_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[0] && reg_we && (RV_TIMER_PERMIT[0] != (RV_TIMER_PERMIT[0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[1] && reg_we && (RV_TIMER_PERMIT[1] != (RV_TIMER_PERMIT[1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[2] && reg_we && (RV_TIMER_PERMIT[2] != (RV_TIMER_PERMIT[2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[3] && reg_we && (RV_TIMER_PERMIT[3] != (RV_TIMER_PERMIT[3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[4] && reg_we && (RV_TIMER_PERMIT[4] != (RV_TIMER_PERMIT[4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[5] && reg_we && (RV_TIMER_PERMIT[5] != (RV_TIMER_PERMIT[5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[6] && reg_we && (RV_TIMER_PERMIT[6] != (RV_TIMER_PERMIT[6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[7] && reg_we && (RV_TIMER_PERMIT[7] != (RV_TIMER_PERMIT[7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[8] && reg_we && (RV_TIMER_PERMIT[8] != (RV_TIMER_PERMIT[8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign ctrl_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_wd = reg_wdata[0];</pre>
<pre>  assign cfg0_prescale_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign cfg0_prescale_wd = reg_wdata[11:0];</pre>
<pre>  assign cfg0_step_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign cfg0_step_wd = reg_wdata[23:16];</pre>
<pre>  assign timer_v_lower0_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign timer_v_lower0_wd = reg_wdata[31:0];</pre>
<pre>  assign timer_v_upper0_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign timer_v_upper0_wd = reg_wdata[31:0];</pre>
<pre>  assign compare_lower0_0_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign compare_lower0_0_wd = reg_wdata[31:0];</pre>
<pre>  assign compare_upper0_0_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign compare_upper0_0_wd = reg_wdata[31:0];</pre>
<pre>  assign intr_enable0_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable0_wd = reg_wdata[0];</pre>
<pre>  assign intr_state0_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state0_wd = reg_wdata[0];</pre>
<pre>  assign intr_test0_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test0_wd = reg_wdata[0];</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[0] = ctrl_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[11:0] = cfg0_prescale_qs;</pre>
<pre>        reg_rdata_next[23:16] = cfg0_step_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[31:0] = timer_v_lower0_qs;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[31:0] = timer_v_upper0_qs;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[31:0] = compare_lower0_0_qs;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[31:0] = compare_upper0_0_qs;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[0] = intr_enable0_qs;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[0] = intr_state0_qs;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/ip/rv_timer/rtl/rv_timer_reg_pkg.sv</h3>
<pre>package rv_timer_reg_pkg;</pre>
<pre>  parameter int N_HARTS = 1;</pre>
<pre>  parameter int N_TIMERS = 1;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_reg2hw_ctrl_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [11:0] q;</pre>
<pre>    } prescale;</pre>
<pre>    struct packed {</pre>
<pre>      logic [7:0]  q;</pre>
<pre>    } step;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_reg2hw_cfg0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_reg2hw_timer_v_lower0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_reg2hw_timer_v_upper0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_reg2hw_compare_lower0_0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_reg2hw_compare_upper0_0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_reg2hw_intr_enable0_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_reg2hw_intr_state0_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_reg2hw_intr_test0_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_hw2reg_timer_v_lower0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_hw2reg_timer_v_upper0_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } rv_timer_hw2reg_intr_state0_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    rv_timer_reg2hw_ctrl_mreg_t [0:0] ctrl; // [152:152]</pre>
<pre>    rv_timer_reg2hw_cfg0_reg_t cfg0; // [151:132]</pre>
<pre>    rv_timer_reg2hw_timer_v_lower0_reg_t timer_v_lower0; // [131:100]</pre>
<pre>    rv_timer_reg2hw_timer_v_upper0_reg_t timer_v_upper0; // [99:68]</pre>
<pre>    rv_timer_reg2hw_compare_lower0_0_reg_t compare_lower0_0; // [67:36]</pre>
<pre>    rv_timer_reg2hw_compare_upper0_0_reg_t compare_upper0_0; // [35:4]</pre>
<pre>    rv_timer_reg2hw_intr_enable0_mreg_t [0:0] intr_enable0; // [3:3]</pre>
<pre>    rv_timer_reg2hw_intr_state0_mreg_t [0:0] intr_state0; // [2:2]</pre>
<pre>    rv_timer_reg2hw_intr_test0_mreg_t [0:0] intr_test0; // [1:0]</pre>
<pre style="background-color: #FF0000;">  } rv_timer_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    rv_timer_hw2reg_timer_v_lower0_reg_t timer_v_lower0; // [67:36]</pre>
<pre>    rv_timer_hw2reg_timer_v_upper0_reg_t timer_v_upper0; // [35:4]</pre>
<pre>    rv_timer_hw2reg_intr_state0_mreg_t [0:0] intr_state0; // [3:2]</pre>
<pre style="background-color: #FF0000;">  } rv_timer_hw2reg_t;</pre>
<pre>  parameter logic [8:0] RV_TIMER_CTRL_OFFSET = 9'h 0;</pre>
<pre>  parameter logic [8:0] RV_TIMER_CFG0_OFFSET = 9'h 100;</pre>
<pre>  parameter logic [8:0] RV_TIMER_TIMER_V_LOWER0_OFFSET = 9'h 104;</pre>
<pre>  parameter logic [8:0] RV_TIMER_TIMER_V_UPPER0_OFFSET = 9'h 108;</pre>
<pre>  parameter logic [8:0] RV_TIMER_COMPARE_LOWER0_0_OFFSET = 9'h 10c;</pre>
<pre>  parameter logic [8:0] RV_TIMER_COMPARE_UPPER0_0_OFFSET = 9'h 110;</pre>
<pre>  parameter logic [8:0] RV_TIMER_INTR_ENABLE0_OFFSET = 9'h 114;</pre>
<pre>  parameter logic [8:0] RV_TIMER_INTR_STATE0_OFFSET = 9'h 118;</pre>
<pre>  parameter logic [8:0] RV_TIMER_INTR_TEST0_OFFSET = 9'h 11c;</pre>
<pre>  typedef enum int {</pre>
<pre>    RV_TIMER_CTRL,</pre>
<pre>    RV_TIMER_CFG0,</pre>
<pre>    RV_TIMER_TIMER_V_LOWER0,</pre>
<pre>    RV_TIMER_TIMER_V_UPPER0,</pre>
<pre>    RV_TIMER_COMPARE_LOWER0_0,</pre>
<pre>    RV_TIMER_COMPARE_UPPER0_0,</pre>
<pre>    RV_TIMER_INTR_ENABLE0,</pre>
<pre>    RV_TIMER_INTR_STATE0,</pre>
<pre>    RV_TIMER_INTR_TEST0</pre>
<pre>  } rv_timer_id_e;</pre>
<pre>  parameter logic [3:0] RV_TIMER_PERMIT [9] = '{</pre>
<pre>    4'b 0001, // index[0] RV_TIMER_CTRL</pre>
<pre>    4'b 0111, // index[1] RV_TIMER_CFG0</pre>
<pre>    4'b 1111, // index[2] RV_TIMER_TIMER_V_LOWER0</pre>
<pre>    4'b 1111, // index[3] RV_TIMER_TIMER_V_UPPER0</pre>
<pre>    4'b 1111, // index[4] RV_TIMER_COMPARE_LOWER0_0</pre>
<pre>    4'b 1111, // index[5] RV_TIMER_COMPARE_UPPER0_0</pre>
<pre>    4'b 0001, // index[6] RV_TIMER_INTR_ENABLE0</pre>
<pre>    4'b 0001, // index[7] RV_TIMER_INTR_STATE0</pre>
<pre>    4'b 0001  // index[8] RV_TIMER_INTR_TEST0</pre>
<h3>hw/ip/rv_timer/rtl/rv_timer.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output logic intr_timer_expired_0_0_o</pre>
<pre>  localparam int N_HARTS  = 1;</pre>
<pre>  localparam int N_TIMERS = 1;</pre>
<pre>  rv_timer_reg2hw_t reg2hw;</pre>
<pre>  rv_timer_hw2reg_t hw2reg;</pre>
<pre>  logic [N_HARTS-1:0] active;</pre>
<pre>  logic [11:0] prescaler [N_HARTS];</pre>
<pre>  logic [7:0]  step      [N_HARTS];</pre>
<pre>  logic [N_HARTS-1:0] tick;</pre>
<pre>  logic [63:0] mtime_d  [N_HARTS];</pre>
<pre>  logic [63:0] mtime    [N_HARTS];</pre>
<pre>  logic [63:0] mtimecmp [N_HARTS][N_TIMERS]; // Only [harts][0] is connected to mtimecmp CSRs</pre>
<pre>  logic [N_HARTS*N_TIMERS-1:0] intr_timer_set;</pre>
<pre>  logic [N_HARTS*N_TIMERS-1:0] intr_timer_en;</pre>
<pre>  logic [N_HARTS*N_TIMERS-1:0] intr_timer_test_q;</pre>
<pre>  logic [N_HARTS-1:0]          intr_timer_test_qe;</pre>
<pre>  logic [N_HARTS*N_TIMERS-1:0] intr_timer_state_q;</pre>
<pre>  logic [N_HARTS-1:0]          intr_timer_state_de;</pre>
<pre>  logic [N_HARTS*N_TIMERS-1:0] intr_timer_state_d;</pre>
<pre>  logic [N_HARTS*N_TIMERS-1:0] intr_out;</pre>
<pre>  assign active[0]  = reg2hw.ctrl[0].q;</pre>
<pre>  assign prescaler = '{reg2hw.cfg0.prescale.q};</pre>
<pre>  assign step      = '{reg2hw.cfg0.step.q};</pre>
<pre>  assign hw2reg.timer_v_upper0.de = tick[0];</pre>
<pre>  assign hw2reg.timer_v_lower0.de = tick[0];</pre>
<pre>  assign hw2reg.timer_v_upper0.d = mtime_d[0][63:32];</pre>
<pre>  assign hw2reg.timer_v_lower0.d = mtime_d[0][31: 0];</pre>
<pre>  assign mtime[0] = {reg2hw.timer_v_upper0.q, reg2hw.timer_v_lower0.q};</pre>
<pre>  assign mtimecmp = '{'{{reg2hw.compare_upper0_0,reg2hw.compare_lower0_0}}};</pre>
<pre>  assign intr_timer_expired_0_0_o = intr_out[0];</pre>
<pre>  assign intr_timer_en            = reg2hw.intr_enable0[0].q;</pre>
<pre>  assign intr_timer_state_q       = reg2hw.intr_state0[0].q;</pre>
<pre>  assign intr_timer_test_q        = reg2hw.intr_test0[0].q;</pre>
<pre>  assign intr_timer_test_qe       = reg2hw.intr_test0[0].qe;</pre>
<pre>  assign hw2reg.intr_state0[0].de = intr_timer_state_de;</pre>
<pre>  assign hw2reg.intr_state0[0].d  = intr_timer_state_d;</pre>
<pre>  for (genvar h = 0 ; h < N_HARTS ; h++) begin : gen_harts</pre>
<pre>    prim_intr_hw #(</pre>
<pre>      .Width(N_TIMERS)</pre>
<pre style="background-color: #FF0000;">    ) u_intr_hw (</pre>
<pre>      .event_intr_i           (intr_timer_set),</pre>
<pre>      .reg2hw_intr_enable_q_i (intr_timer_en[h*N_TIMERS+:N_TIMERS]),</pre>
<pre>      .reg2hw_intr_test_q_i   (intr_timer_test_q[h*N_TIMERS+:N_TIMERS]),</pre>
<pre>      .reg2hw_intr_test_qe_i  (intr_timer_test_qe[h]),</pre>
<pre>      .reg2hw_intr_state_q_i  (intr_timer_state_q[h*N_TIMERS+:N_TIMERS]),</pre>
<pre>      .hw2reg_intr_state_de_o (intr_timer_state_de),</pre>
<pre>      .hw2reg_intr_state_d_o  (intr_timer_state_d[h*N_TIMERS+:N_TIMERS]),</pre>
<pre>      .intr_o                 (intr_out[h*N_TIMERS+:N_TIMERS])</pre>
<pre>    timer_core #(</pre>
<pre>      .N (N_TIMERS)</pre>
<pre style="background-color: #FF0000;">    ) u_core (</pre>
<pre>      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .active    (active[h]),</pre>
<pre>      .prescaler (prescaler[h]),</pre>
<pre>      .step      (step[h]),</pre>
<pre>      .tick      (tick[h]),</pre>
<pre>      .mtime_d   (mtime_d[h]),</pre>
<pre>      .mtime     (mtime[h]),</pre>
<pre>      .mtimecmp  (mtimecmp[h]),</pre>
<pre>      .intr      (intr_timer_set[h*N_TIMERS+:N_TIMERS])</pre>
<pre>  end : gen_harts</pre>
<pre>  rv_timer_reg_top u_reg (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .tl_o,</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .devmode_i  (1'b1)</pre>
<h3>hw/ip/nmi_gen/rtl/nmi_gen_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output nmi_gen_reg_pkg::nmi_gen_reg2hw_t reg2hw, // Write</pre>
<pre>  input  nmi_gen_reg_pkg::nmi_gen_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam int AW = 4;</pre>
<pre>  localparam int DW = 32;</pre>
<pre>  localparam int DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  assign tl_reg_h2d = tl_i;</pre>
<pre>  assign tl_o       = tl_reg_d2h;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic intr_state_esc0_qs;</pre>
<pre>  logic intr_state_esc0_wd;</pre>
<pre>  logic intr_state_esc0_we;</pre>
<pre>  logic intr_state_esc1_qs;</pre>
<pre>  logic intr_state_esc1_wd;</pre>
<pre>  logic intr_state_esc1_we;</pre>
<pre>  logic intr_state_esc2_qs;</pre>
<pre>  logic intr_state_esc2_wd;</pre>
<pre>  logic intr_state_esc2_we;</pre>
<pre>  logic intr_state_esc3_qs;</pre>
<pre>  logic intr_state_esc3_wd;</pre>
<pre>  logic intr_state_esc3_we;</pre>
<pre>  logic intr_enable_esc0_qs;</pre>
<pre>  logic intr_enable_esc0_wd;</pre>
<pre>  logic intr_enable_esc0_we;</pre>
<pre>  logic intr_enable_esc1_qs;</pre>
<pre>  logic intr_enable_esc1_wd;</pre>
<pre>  logic intr_enable_esc1_we;</pre>
<pre>  logic intr_enable_esc2_qs;</pre>
<pre>  logic intr_enable_esc2_wd;</pre>
<pre>  logic intr_enable_esc2_we;</pre>
<pre>  logic intr_enable_esc3_qs;</pre>
<pre>  logic intr_enable_esc3_wd;</pre>
<pre>  logic intr_enable_esc3_we;</pre>
<pre>  logic intr_test_esc0_wd;</pre>
<pre>  logic intr_test_esc0_we;</pre>
<pre>  logic intr_test_esc1_wd;</pre>
<pre>  logic intr_test_esc1_we;</pre>
<pre>  logic intr_test_esc2_wd;</pre>
<pre>  logic intr_test_esc2_we;</pre>
<pre>  logic intr_test_esc3_wd;</pre>
<pre>  logic intr_test_esc3_we;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_esc0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_esc0_we),</pre>
<pre>    .wd     (intr_state_esc0_wd),</pre>
<pre>    .de     (hw2reg.intr_state.esc0.de),</pre>
<pre>    .d      (hw2reg.intr_state.esc0.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.esc0.q ),</pre>
<pre>    .qs     (intr_state_esc0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_esc1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_esc1_we),</pre>
<pre>    .wd     (intr_state_esc1_wd),</pre>
<pre>    .de     (hw2reg.intr_state.esc1.de),</pre>
<pre>    .d      (hw2reg.intr_state.esc1.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.esc1.q ),</pre>
<pre>    .qs     (intr_state_esc1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_esc2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_esc2_we),</pre>
<pre>    .wd     (intr_state_esc2_wd),</pre>
<pre>    .de     (hw2reg.intr_state.esc2.de),</pre>
<pre>    .d      (hw2reg.intr_state.esc2.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.esc2.q ),</pre>
<pre>    .qs     (intr_state_esc2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_esc3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_esc3_we),</pre>
<pre>    .wd     (intr_state_esc3_wd),</pre>
<pre>    .de     (hw2reg.intr_state.esc3.de),</pre>
<pre>    .d      (hw2reg.intr_state.esc3.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.esc3.q ),</pre>
<pre>    .qs     (intr_state_esc3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_esc0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_esc0_we),</pre>
<pre>    .wd     (intr_enable_esc0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.esc0.q ),</pre>
<pre>    .qs     (intr_enable_esc0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_esc1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_esc1_we),</pre>
<pre>    .wd     (intr_enable_esc1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.esc1.q ),</pre>
<pre>    .qs     (intr_enable_esc1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_esc2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_esc2_we),</pre>
<pre>    .wd     (intr_enable_esc2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.esc2.q ),</pre>
<pre>    .qs     (intr_enable_esc2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_esc3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_esc3_we),</pre>
<pre>    .wd     (intr_enable_esc3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.esc3.q ),</pre>
<pre>    .qs     (intr_enable_esc3_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_esc0 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_esc0_we),</pre>
<pre>    .wd     (intr_test_esc0_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.esc0.qe),</pre>
<pre>    .q      (reg2hw.intr_test.esc0.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_esc1 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_esc1_we),</pre>
<pre>    .wd     (intr_test_esc1_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.esc1.qe),</pre>
<pre>    .q      (reg2hw.intr_test.esc1.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_esc2 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_esc2_we),</pre>
<pre>    .wd     (intr_test_esc2_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.esc2.qe),</pre>
<pre>    .q      (reg2hw.intr_test.esc2.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_esc3 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_esc3_we),</pre>
<pre>    .wd     (intr_test_esc3_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.esc3.qe),</pre>
<pre>    .q      (reg2hw.intr_test.esc3.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  logic [2:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[0] = (reg_addr == NMI_GEN_INTR_STATE_OFFSET);</pre>
<pre>    addr_hit[1] = (reg_addr == NMI_GEN_INTR_ENABLE_OFFSET);</pre>
<pre>    addr_hit[2] = (reg_addr == NMI_GEN_INTR_TEST_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[0] && reg_we && (NMI_GEN_PERMIT[0] != (NMI_GEN_PERMIT[0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[1] && reg_we && (NMI_GEN_PERMIT[1] != (NMI_GEN_PERMIT[1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[2] && reg_we && (NMI_GEN_PERMIT[2] != (NMI_GEN_PERMIT[2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign intr_state_esc0_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_esc0_wd = reg_wdata[0];</pre>
<pre>  assign intr_state_esc1_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_esc1_wd = reg_wdata[1];</pre>
<pre>  assign intr_state_esc2_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_esc2_wd = reg_wdata[2];</pre>
<pre>  assign intr_state_esc3_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_esc3_wd = reg_wdata[3];</pre>
<pre>  assign intr_enable_esc0_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_esc0_wd = reg_wdata[0];</pre>
<pre>  assign intr_enable_esc1_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_esc1_wd = reg_wdata[1];</pre>
<pre>  assign intr_enable_esc2_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_esc2_wd = reg_wdata[2];</pre>
<pre>  assign intr_enable_esc3_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_esc3_wd = reg_wdata[3];</pre>
<pre>  assign intr_test_esc0_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_esc0_wd = reg_wdata[0];</pre>
<pre>  assign intr_test_esc1_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_esc1_wd = reg_wdata[1];</pre>
<pre>  assign intr_test_esc2_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_esc2_wd = reg_wdata[2];</pre>
<pre>  assign intr_test_esc3_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_esc3_wd = reg_wdata[3];</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[0] = intr_state_esc0_qs;</pre>
<pre>        reg_rdata_next[1] = intr_state_esc1_qs;</pre>
<pre>        reg_rdata_next[2] = intr_state_esc2_qs;</pre>
<pre>        reg_rdata_next[3] = intr_state_esc3_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[0] = intr_enable_esc0_qs;</pre>
<pre>        reg_rdata_next[1] = intr_enable_esc1_qs;</pre>
<pre>        reg_rdata_next[2] = intr_enable_esc2_qs;</pre>
<pre>        reg_rdata_next[3] = intr_enable_esc3_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>        reg_rdata_next[2] = '0;</pre>
<pre>        reg_rdata_next[3] = '0;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/ip/nmi_gen/rtl/nmi_gen_reg_pkg.sv</h3>
<pre>package nmi_gen_reg_pkg;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } esc0;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } esc1;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } esc2;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } esc3;</pre>
<pre style="background-color: #FF0000;">  } nmi_gen_reg2hw_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } esc0;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } esc1;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } esc2;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } esc3;</pre>
<pre style="background-color: #FF0000;">  } nmi_gen_reg2hw_intr_enable_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } esc0;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } esc1;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } esc2;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } esc3;</pre>
<pre style="background-color: #FF0000;">  } nmi_gen_reg2hw_intr_test_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } esc0;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } esc1;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } esc2;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } esc3;</pre>
<pre style="background-color: #FF0000;">  } nmi_gen_hw2reg_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    nmi_gen_reg2hw_intr_state_reg_t intr_state; // [15:12]</pre>
<pre>    nmi_gen_reg2hw_intr_enable_reg_t intr_enable; // [11:8]</pre>
<pre>    nmi_gen_reg2hw_intr_test_reg_t intr_test; // [7:0]</pre>
<pre style="background-color: #FF0000;">  } nmi_gen_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    nmi_gen_hw2reg_intr_state_reg_t intr_state; // [7:4]</pre>
<pre style="background-color: #FF0000;">  } nmi_gen_hw2reg_t;</pre>
<pre>  parameter logic [3:0] NMI_GEN_INTR_STATE_OFFSET = 4'h 0;</pre>
<pre>  parameter logic [3:0] NMI_GEN_INTR_ENABLE_OFFSET = 4'h 4;</pre>
<pre>  parameter logic [3:0] NMI_GEN_INTR_TEST_OFFSET = 4'h 8;</pre>
<pre>  typedef enum int {</pre>
<pre>    NMI_GEN_INTR_STATE,</pre>
<pre>    NMI_GEN_INTR_ENABLE,</pre>
<pre>    NMI_GEN_INTR_TEST</pre>
<pre>  } nmi_gen_id_e;</pre>
<pre>  parameter logic [3:0] NMI_GEN_PERMIT [3] = '{</pre>
<pre>    4'b 0001, // index[0] NMI_GEN_INTR_STATE</pre>
<pre>    4'b 0001, // index[1] NMI_GEN_INTR_ENABLE</pre>
<pre>    4'b 0001  // index[2] NMI_GEN_INTR_TEST</pre>
<h3>hw/ip/nmi_gen/rtl/nmi_gen.sv</h3>
<pre>module nmi_gen import prim_pkg::*; #(</pre>
<pre>  localparam int unsigned N_ESC_SEV = 4</pre>
<pre>  input                           clk_i,</pre>
<pre>  input                           rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t       tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t       tl_o,</pre>
<pre>  output logic                    intr_esc0_o,</pre>
<pre>  output logic                    intr_esc1_o,</pre>
<pre>  output logic                    intr_esc2_o,</pre>
<pre>  output logic                    intr_esc3_o,</pre>
<pre>  input  esc_tx_t [N_ESC_SEV-1:0] esc_tx_i,</pre>
<pre>  output esc_rx_t [N_ESC_SEV-1:0] esc_rx_o</pre>
<pre>  logic [N_ESC_SEV-1:0] esc_en;</pre>
<pre>  nmi_gen_reg_pkg::nmi_gen_reg2hw_t reg2hw;</pre>
<pre>  nmi_gen_reg_pkg::nmi_gen_hw2reg_t hw2reg;</pre>
<pre>  nmi_gen_reg_top i_reg (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .tl_o,</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .devmode_i(1'b1)</pre>
<pre>  prim_intr_hw #(</pre>
<pre>    .Width(1)</pre>
<pre style="background-color: #FF0000;">  ) i_intr_esc0 (</pre>
<pre>    .event_intr_i           ( esc_en[0]                  ),</pre>
<pre>    .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.esc0.q  ),</pre>
<pre>    .reg2hw_intr_test_q_i   ( reg2hw.intr_test.esc0.q    ),</pre>
<pre>    .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.esc0.qe   ),</pre>
<pre>    .reg2hw_intr_state_q_i  ( reg2hw.intr_state.esc0.q   ),</pre>
<pre>    .hw2reg_intr_state_de_o ( hw2reg.intr_state.esc0.de  ),</pre>
<pre>    .hw2reg_intr_state_d_o  ( hw2reg.intr_state.esc0.d   ),</pre>
<pre>    .intr_o                 ( intr_esc0_o                )</pre>
<pre>  prim_intr_hw #(</pre>
<pre>    .Width(1)</pre>
<pre style="background-color: #FF0000;">  ) i_intr_esc1 (</pre>
<pre>    .event_intr_i           ( esc_en[1]                  ),</pre>
<pre>    .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.esc1.q  ),</pre>
<pre>    .reg2hw_intr_test_q_i   ( reg2hw.intr_test.esc1.q    ),</pre>
<pre>    .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.esc1.qe   ),</pre>
<pre>    .reg2hw_intr_state_q_i  ( reg2hw.intr_state.esc1.q   ),</pre>
<pre>    .hw2reg_intr_state_de_o ( hw2reg.intr_state.esc1.de  ),</pre>
<pre>    .hw2reg_intr_state_d_o  ( hw2reg.intr_state.esc1.d   ),</pre>
<pre>    .intr_o                 ( intr_esc1_o                )</pre>
<pre>  prim_intr_hw #(</pre>
<pre>    .Width(1)</pre>
<pre style="background-color: #FF0000;">  ) i_intr_esc2 (</pre>
<pre>    .event_intr_i           ( esc_en[2]                  ),</pre>
<pre>    .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.esc2.q  ),</pre>
<pre>    .reg2hw_intr_test_q_i   ( reg2hw.intr_test.esc2.q    ),</pre>
<pre>    .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.esc2.qe   ),</pre>
<pre>    .reg2hw_intr_state_q_i  ( reg2hw.intr_state.esc2.q   ),</pre>
<pre>    .hw2reg_intr_state_de_o ( hw2reg.intr_state.esc2.de  ),</pre>
<pre>    .hw2reg_intr_state_d_o  ( hw2reg.intr_state.esc2.d   ),</pre>
<pre>    .intr_o                 ( intr_esc2_o                )</pre>
<pre>  prim_intr_hw #(</pre>
<pre>    .Width(1)</pre>
<pre style="background-color: #FF0000;">  ) i_intr_esc3 (</pre>
<pre>    .event_intr_i           ( esc_en[3]                  ),</pre>
<pre>    .reg2hw_intr_enable_q_i ( reg2hw.intr_enable.esc3.q  ),</pre>
<pre>    .reg2hw_intr_test_q_i   ( reg2hw.intr_test.esc3.q    ),</pre>
<pre>    .reg2hw_intr_test_qe_i  ( reg2hw.intr_test.esc3.qe   ),</pre>
<pre>    .reg2hw_intr_state_q_i  ( reg2hw.intr_state.esc3.q   ),</pre>
<pre>    .hw2reg_intr_state_de_o ( hw2reg.intr_state.esc3.de  ),</pre>
<pre>    .hw2reg_intr_state_d_o  ( hw2reg.intr_state.esc3.d   ),</pre>
<pre>    .intr_o                 ( intr_esc3_o                )</pre>
<pre>  for (genvar k = 0; k < N_ESC_SEV; k++) begin : gen_esc_sev</pre>
<pre>    prim_esc_receiver i_prim_esc_receiver (</pre>
<pre>      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .esc_en_o ( esc_en[k]   ),</pre>
<pre>      .esc_rx_o ( esc_rx_o[k] ),</pre>
<pre>      .esc_tx_i ( esc_tx_i[k] )</pre>
<pre style="background-color: #FF0000;">  end : gen_esc_sev</pre>
<pre style="background-color: #FF0000;">endmodule : nmi_gen</pre>
<h3>hw/ip/prim/abstract/prim_clock_mux2.sv</h3>
<pre>  parameter prim_pkg::impl_e Impl = `PRIM_DEFAULT_IMPL</pre>
<pre>) (</pre>
<pre>  input        clk1_i,</pre>
<pre>  input        sel_i,</pre>
<pre>  output logic clk_o</pre>
<pre>);</pre>
<pre>    prim_generic_clock_mux2 u_impl_generic (</pre>
<pre>      .clk0_i,</pre>
<pre>      .clk1_i,</pre>
<pre>      .sel_i,</pre>
<pre>      .clk_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">    prim_xilinx_clock_mux2 u_impl_xilinx (</pre>
<pre style="background-color: #FF0000;">      .clk0_i,</pre>
<pre style="background-color: #FF0000;">      .clk1_i,</pre>
<pre style="background-color: #FF0000;">      .sel_i,</pre>
<pre style="background-color: #FF0000;">      .clk_o</pre>
<pre style="background-color: #FF0000;">    );</pre>
<pre style="background-color: #FF0000;">    // TODO: Find code that works across tools and causes a compile failure</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>hw/ip/rv_dm/rtl/tlul_adapter_host.sv</h3>
<pre>module tlul_adapter_host #(</pre>
<pre>  parameter int unsigned AW = 32,</pre>
<pre>  parameter int unsigned DW = 32</pre>
<pre>  input clk_i   ,</pre>
<pre>  input rst_ni  ,</pre>
<pre>  input                   req_i   ,</pre>
<pre>  output logic            gnt_o   ,</pre>
<pre>  input        [AW-1:0]   addr_i  ,</pre>
<pre>  input                   we_i    ,</pre>
<pre>  input        [DW-1:0]   wdata_i ,</pre>
<pre>  input        [DW/8-1:0] be_i    ,</pre>
<pre>  input        [1:0]      size_i  , // 2**(size_i)</pre>
<pre>  output logic            valid_o ,</pre>
<pre>  output logic [DW-1:0]   rdata_o ,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_o ,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_i</pre>
<pre>  tlul_pkg::tl_a_op_e req_op;</pre>
<pre>  assign req_op = (we_i) ? tlul_pkg::PutFullData : tlul_pkg::Get ;</pre>
<pre>  assign tl_o = '{</pre>
<pre>    a_valid:      req_i       ,</pre>
<pre>    a_opcode:     req_op      ,</pre>
<pre>    a_param:      '0          ,</pre>
<pre>    a_size:       size_i      ,</pre>
<pre>    a_source:     '0          ,</pre>
<pre>    a_address:    addr_i      ,</pre>
<pre>    a_mask:       be_i        ,</pre>
<pre>    a_data:       wdata_i     ,</pre>
<pre>    a_user:       '0          ,</pre>
<pre>    d_ready:      1'b1          // Ready to accept</pre>
<pre>  assign gnt_o   = tl_i.a_ready; // Do we need to and with req_i? then registers are required</pre>
<pre>  assign valid_o = tl_i.d_valid;</pre>
<pre>  assign rdata_o = tl_i.d_data;</pre>
<h3>hw/ip/rv_dm/rtl/rv_dm.sv</h3>
<pre>module rv_dm #(</pre>
<pre>  parameter int                 NrHarts = 1,</pre>
<pre>  parameter logic [31:0]        IdcodeValue = 32'h 0000_0001</pre>
<pre>  input  logic                  clk_i,       // clock</pre>
<pre>  input  logic                  rst_ni,      // asynchronous reset active low, connect PoR</pre>
<pre>  input  logic                  testmode_i,</pre>
<pre>  output logic                  ndmreset_o,  // non-debug module reset</pre>
<pre>  output logic                  dmactive_o,  // debug module is active</pre>
<pre>  output logic [NrHarts-1:0]    debug_req_o, // async debug request</pre>
<pre>  input  logic [NrHarts-1:0]    unavailable_i, // communicate whether the hart is unavailable</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_d_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_d_o,</pre>
<pre>  output tlul_pkg::tl_h2d_t  tl_h_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t  tl_h_i,</pre>
<pre>  input  logic               tck_i,           // JTAG test clock pad</pre>
<pre>  input  logic               tms_i,           // JTAG test mode select pad</pre>
<pre>  input  logic               trst_ni,         // JTAG test reset pad</pre>
<pre>  input  logic               td_i,            // JTAG test data input pad</pre>
<pre>  output logic               td_o,            // JTAG test data output pad</pre>
<pre>  output logic               tdo_oe_o         // Data out output enable</pre>
<pre>  // all harts have contiguous IDs</pre>
<pre></pre>
<pre>  logic [NrHarts-1:0]               halted;</pre>
<pre>  // logic [NrHarts-1:0]               running;</pre>
<pre>  logic [NrHarts-1:0]               haltreq;</pre>
<pre>  logic [NrHarts-1:0]               resumereq;</pre>
<pre>  logic                             clear_resumeack;</pre>
<pre>  logic                             cmd_valid;</pre>
<pre>  dm::command_t                     cmd;</pre>
<pre></pre>
<pre>  dm::cmderr_e                      cmderror;</pre>
<pre>  logic                             cmdbusy;</pre>
<pre>  logic [dm::ProgBufSize-1:0][31:0] progbuf;</pre>
<pre>  logic [dm::DataCount-1:0][31:0]   data_csrs_mem;</pre>
<pre>  logic [dm::DataCount-1:0][31:0]   data_mem_csrs;</pre>
<pre>  logic                             data_valid;</pre>
<pre>  logic [19:0]                      hartsel;</pre>
<pre>  // System Bus Access Module</pre>
<pre>  logic [BusWidth-1:0]              sbaddress_sba_csrs;</pre>
<pre>  logic                             sbaddress_write_valid;</pre>
<pre>  logic                             sbreadonaddr;</pre>
<pre>  logic                             sbautoincrement;</pre>
<pre>  logic [2:0]                       sbaccess;</pre>
<pre>  logic                             sbreadondata;</pre>
<pre>  logic [BusWidth-1:0]              sbdata_write;</pre>
<pre>  logic                             sbdata_read_valid;</pre>
<pre>  logic                             sbdata_write_valid;</pre>
<pre>  logic [BusWidth-1:0]              sbdata_read;</pre>
<pre>  logic                             sbdata_valid;</pre>
<pre>  logic                             sbbusy;</pre>
<pre>  logic                             sberror_valid;</pre>
<pre>  logic [2:0]                       sberror;</pre>
<pre></pre>
<pre>  dm::dmi_resp_t dmi_rsp;</pre>
<pre>  logic dmi_req_valid, dmi_req_ready;</pre>
<pre>  logic dmi_rsp_valid, dmi_rsp_ready;</pre>
<pre>  logic dmi_rst_n;</pre>
<pre></pre>
<pre>    zero1:      '0,</pre>
<pre>    nscratch:   2, // Debug module needs at least two scratch regs</pre>
<pre>    zero0:      0,</pre>
<pre>    dataaccess: 1'b1, // data registers are memory mapped in the debugger</pre>
<pre>    datasize:   dm::DataCount,</pre>
<pre>    dataaddr:   dm::DataAddr</pre>
<pre>  };</pre>
<pre style="background-color: #FF0000;">  for (genvar i = 0; i < NrHarts; i++) begin : gen_dm_hart_ctrl</pre>
<pre>    assign hartinfo[i] = DebugHartInfo;</pre>
<pre>  end</pre>
<pre>    .NrHarts(NrHarts),</pre>
<pre>    .BusWidth(BusWidth),</pre>
<pre>    .SelectableHarts(SelectableHarts)</pre>
<pre>  ) i_dm_csrs (</pre>
<pre style="background-color: #FF0000;">    .clk_i                   ( clk_i                 ),</pre>
<pre>    .rst_ni                  ( rst_ni                ),</pre>
<pre>    .testmode_i              ( testmode_i            ),</pre>
<pre>    .dmi_rst_ni              ( dmi_rst_n             ),</pre>
<pre>    .dmi_req_valid_i         ( dmi_req_valid         ),</pre>
<pre>    .dmi_req_ready_o         ( dmi_req_ready         ),</pre>
<pre>    .dmi_req_i               ( dmi_req               ),</pre>
<pre>    .dmi_resp_valid_o        ( dmi_rsp_valid         ),</pre>
<pre>    .dmi_resp_ready_i        ( dmi_rsp_ready         ),</pre>
<pre>    .dmi_resp_o              ( dmi_rsp               ),</pre>
<pre>    .ndmreset_o              ( ndmreset_o            ),</pre>
<pre>    .dmactive_o              ( dmactive_o            ),</pre>
<pre>    .hartsel_o               ( hartsel               ),</pre>
<pre>    .hartinfo_i              ( hartinfo              ),</pre>
<pre>    .halted_i                ( halted                ),</pre>
<pre>    .unavailable_i,</pre>
<pre>    .resumeack_i             ( resumeack             ),</pre>
<pre>    .haltreq_o               ( haltreq               ),</pre>
<pre>    .resumereq_o             ( resumereq             ),</pre>
<pre>    .clear_resumeack_o       ( clear_resumeack       ),</pre>
<pre>    .cmd_valid_o             ( cmd_valid             ),</pre>
<pre>    .cmd_o                   ( cmd                   ),</pre>
<pre>    .cmderror_valid_i        ( cmderror_valid        ),</pre>
<pre>    .cmderror_i              ( cmderror              ),</pre>
<pre>    .cmdbusy_i               ( cmdbusy               ),</pre>
<pre>    .progbuf_o               ( progbuf               ),</pre>
<pre>    .data_i                  ( data_mem_csrs         ),</pre>
<pre>    .data_valid_i            ( data_valid            ),</pre>
<pre>    .data_o                  ( data_csrs_mem         ),</pre>
<pre>    .sbaddress_o             ( sbaddress_csrs_sba    ),</pre>
<pre>    .sbaddress_i             ( sbaddress_sba_csrs    ),</pre>
<pre>    .sbaddress_write_valid_o ( sbaddress_write_valid ),</pre>
<pre>    .sbreadonaddr_o          ( sbreadonaddr          ),</pre>
<pre>    .sbautoincrement_o       ( sbautoincrement       ),</pre>
<pre>    .sbaccess_o              ( sbaccess              ),</pre>
<pre>    .sbreadondata_o          ( sbreadondata          ),</pre>
<pre>    .sbdata_o                ( sbdata_write          ),</pre>
<pre>    .sbdata_read_valid_o     ( sbdata_read_valid     ),</pre>
<pre>    .sbdata_write_valid_o    ( sbdata_write_valid    ),</pre>
<pre>    .sbdata_i                ( sbdata_read           ),</pre>
<pre>    .sbdata_valid_i          ( sbdata_valid          ),</pre>
<pre>    .sbbusy_i                ( sbbusy                ),</pre>
<pre>    .sberror_valid_i         ( sberror_valid         ),</pre>
<pre>    .sberror_i               ( sberror               )</pre>
<pre>  );</pre>
<pre>  logic   [BusWidth-1:0]  master_add;</pre>
<pre>  logic                   master_we;</pre>
<pre>  logic   [BusWidth-1:0]  master_wdata;</pre>
<pre>  logic [BusWidth/8-1:0]  master_be;</pre>
<pre>  logic                   master_gnt;</pre>
<pre>  logic                   master_r_valid;</pre>
<pre>  logic   [BusWidth-1:0]  master_r_rdata;</pre>
<pre></pre>
<pre>    .BusWidth(BusWidth)</pre>
<pre>  ) i_dm_sba (</pre>
<pre style="background-color: #FF0000;">    .clk_i                   ( clk_i                 ),</pre>
<pre>    .rst_ni                  ( rst_ni                ),</pre>
<pre>    .master_req_o            ( master_req            ),</pre>
<pre>    .master_add_o            ( master_add            ),</pre>
<pre>    .master_we_o             ( master_we             ),</pre>
<pre>    .master_wdata_o          ( master_wdata          ),</pre>
<pre>    .master_be_o             ( master_be             ),</pre>
<pre>    .master_gnt_i            ( master_gnt            ),</pre>
<pre>    .master_r_valid_i        ( master_r_valid        ),</pre>
<pre>    .master_r_rdata_i        ( master_r_rdata        ),</pre>
<pre>    .dmactive_i              ( dmactive_o            ),</pre>
<pre>    .sbaddress_i             ( sbaddress_csrs_sba    ),</pre>
<pre>    .sbaddress_o             ( sbaddress_sba_csrs    ),</pre>
<pre>    .sbaddress_write_valid_i ( sbaddress_write_valid ),</pre>
<pre>    .sbreadonaddr_i          ( sbreadonaddr          ),</pre>
<pre>    .sbautoincrement_i       ( sbautoincrement       ),</pre>
<pre>    .sbaccess_i              ( sbaccess              ),</pre>
<pre>    .sbreadondata_i          ( sbreadondata          ),</pre>
<pre>    .sbdata_i                ( sbdata_write          ),</pre>
<pre>    .sbdata_read_valid_i     ( sbdata_read_valid     ),</pre>
<pre>    .sbdata_write_valid_i    ( sbdata_write_valid    ),</pre>
<pre>    .sbdata_o                ( sbdata_read           ),</pre>
<pre>    .sbdata_valid_o          ( sbdata_valid          ),</pre>
<pre>    .sbbusy_o                ( sbbusy                ),</pre>
<pre>    .sberror_valid_o         ( sberror_valid         ),</pre>
<pre>    .sberror_o               ( sberror               )</pre>
<pre>  );</pre>
<pre>    .AW(BusWidth),</pre>
<pre>    .DW(BusWidth)</pre>
<pre>  ) tl_adapter_host_sba (</pre>
<pre style="background-color: #FF0000;">    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .req_i        (master_req),</pre>
<pre>    .gnt_o        (master_gnt),</pre>
<pre>    .addr_i       (master_add),</pre>
<pre>    .we_i         (master_we),</pre>
<pre>    .wdata_i      (master_wdata),</pre>
<pre>    .be_i         (master_be),</pre>
<pre>    .size_i       (sbaccess[1:0]),</pre>
<pre>    .valid_o      (master_r_valid),</pre>
<pre>    .rdata_o      (master_r_rdata),</pre>
<pre>    .tl_o         (tl_h_o),</pre>
<pre>    .tl_i         (tl_h_i)</pre>
<pre>  );</pre>
<pre></pre>
<pre>  logic                         we;</pre>
<pre>  logic [BusWidth/8-1:0]        be;</pre>
<pre>  logic   [BusWidth-1:0]        wdata;</pre>
<pre>  logic   [BusWidth-1:0]        rdata;</pre>
<pre>  logic                         rvalid;</pre>
<pre></pre>
<pre>  logic [AddressWidthWords-1:0] addr_w;</pre>
<pre></pre>
<pre></pre>
<pre></pre>
<pre>    .NrHarts(NrHarts),</pre>
<pre>    .BusWidth(BusWidth),</pre>
<pre>    .SelectableHarts(SelectableHarts)</pre>
<pre>  ) i_dm_mem (</pre>
<pre style="background-color: #FF0000;">    .clk_i                   ( clk_i                 ),</pre>
<pre>    .rst_ni                  ( rst_ni                ),</pre>
<pre>    .debug_req_o             ( debug_req_o           ),</pre>
<pre>    .hartsel_i               ( hartsel               ),</pre>
<pre>    .haltreq_i               ( haltreq               ),</pre>
<pre>    .resumereq_i             ( resumereq             ),</pre>
<pre>    .clear_resumeack_i       ( clear_resumeack       ),</pre>
<pre>    .halted_o                ( halted                ),</pre>
<pre>    .resuming_o              ( resumeack             ),</pre>
<pre>    .cmd_valid_i             ( cmd_valid             ),</pre>
<pre>    .cmd_i                   ( cmd                   ),</pre>
<pre>    .cmderror_valid_o        ( cmderror_valid        ),</pre>
<pre>    .cmderror_o              ( cmderror              ),</pre>
<pre>    .cmdbusy_o               ( cmdbusy               ),</pre>
<pre>    .progbuf_i               ( progbuf               ),</pre>
<pre>    .data_i                  ( data_csrs_mem         ),</pre>
<pre>    .data_o                  ( data_mem_csrs         ),</pre>
<pre>    .data_valid_o            ( data_valid            ),</pre>
<pre>    .req_i                   ( req                   ),</pre>
<pre>    .we_i                    ( we                    ),</pre>
<pre>    .addr_i                  ( addr_b                ),</pre>
<pre>    .wdata_i                 ( wdata                 ),</pre>
<pre>    .be_i                    ( be                    ),</pre>
<pre>    .rdata_o                 ( rdata                 )</pre>
<pre>  );</pre>
<pre>    .IdcodeValue    (IdcodeValue)</pre>
<pre>  ) dap (</pre>
<pre style="background-color: #FF0000;">    .clk_i            (clk_i),</pre>
<pre>    .rst_ni           (rst_ni),</pre>
<pre>    .testmode_i       (testmode_i),</pre>
<pre></pre>
<pre>    .dmi_req_o        (dmi_req),</pre>
<pre>    .dmi_req_valid_o  (dmi_req_valid),</pre>
<pre>    .dmi_req_ready_i  (dmi_req_ready),</pre>
<pre></pre>
<pre>    .dmi_resp_ready_o (dmi_rsp_ready),</pre>
<pre>    .dmi_resp_valid_i (dmi_rsp_valid),</pre>
<pre></pre>
<pre>    .tms_i,</pre>
<pre>    .trst_ni,</pre>
<pre>    .td_i,</pre>
<pre>    .td_o,</pre>
<pre>    .tdo_oe_o</pre>
<pre>  );</pre>
<pre>    .SramAw(AddressWidthWords),</pre>
<pre>    .SramDw(BusWidth),</pre>
<pre>    .Outstanding(1),</pre>
<pre>    .ByteAccess(0)</pre>
<pre>  ) tl_adapter_device_mem (</pre>
<pre style="background-color: #FF0000;">    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre></pre>
<pre>    .gnt_i    (1'b1),</pre>
<pre>    .we_o     (we),</pre>
<pre>    .addr_o   (addr_w),</pre>
<pre>    .wdata_o  (wdata),</pre>
<pre>    .wmask_o  (),</pre>
<pre>    .rdata_i  (rdata),</pre>
<pre>    .rvalid_i (rvalid),</pre>
<pre>    .rerror_i (2'b00),</pre>
<pre></pre>
<pre>    .tl_i     (tl_d_i)</pre>
<pre>  );</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rvalid <= '0;</pre>
<pre>    end else begin</pre>
<pre>      rvalid <= req & ~we;</pre>
<pre>    end</pre>
<h3>hw/top_earlgrey/rtl/top_pkg.sv</h3>
<pre>package top_pkg;</pre>
<pre>localparam TL_AW=32;</pre>
<pre>localparam TL_DW=32;    // = TL_DBW * 8; TL_DBW must be a power-of-two</pre>
<pre>localparam TL_AIW=8;    // a_source, d_source</pre>
<pre>localparam TL_DIW=1;    // d_sink</pre>
<pre>localparam TL_DUW=16;   // d_user</pre>
<pre>localparam TL_DBW=(TL_DW>>3);</pre>
<pre>localparam TL_SZW=$clog2($clog2(TL_DBW)+1);</pre>
<pre>localparam FLASH_BANKS=2;</pre>
<pre>localparam FLASH_PAGES_PER_BANK=256;</pre>
<pre>localparam FLASH_WORDS_PER_PAGE=256;</pre>
<pre>localparam FLASH_BYTES_PER_WORD=4;</pre>
<pre>localparam FLASH_BKW = $clog2(FLASH_BANKS);</pre>
<pre>localparam FLASH_PGW = $clog2(FLASH_PAGES_PER_BANK);</pre>
<pre>localparam FLASH_WDW = $clog2(FLASH_WORDS_PER_PAGE);</pre>
<pre>localparam FLASH_AW = FLASH_BKW + FLASH_PGW + FLASH_WDW;</pre>
<pre>localparam FLASH_DW = FLASH_BYTES_PER_WORD * 8;</pre>
<h3>hw/ip/flash_ctrl/rtl/flash_mp.sv</h3>
<pre>module flash_mp #(</pre>
<pre>  parameter int MpRegions = 8,</pre>
<pre>  parameter int NumBanks = 2,</pre>
<pre>  parameter int AllPagesW = 16,</pre>
<pre>  localparam int TotalRegions = MpRegions+1,</pre>
<pre>  localparam int BankW = $clog2(NumBanks)</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input flash_ctrl_reg_pkg::flash_ctrl_reg2hw_mp_region_cfg_mreg_t [TotalRegions-1:0] region_cfgs_i,</pre>
<pre>  input flash_ctrl_reg_pkg::flash_ctrl_reg2hw_mp_bank_cfg_mreg_t [NumBanks-1:0] bank_cfgs_i,</pre>
<pre>  input req_i,</pre>
<pre>  input [AllPagesW-1:0] req_addr_i,</pre>
<pre>  input addr_ovfl_i,</pre>
<pre>  input [BankW-1:0] req_bk_i,</pre>
<pre>  input rd_i,</pre>
<pre>  input prog_i,</pre>
<pre>  input pg_erase_i,</pre>
<pre>  input bk_erase_i,</pre>
<pre>  output logic rd_done_o,</pre>
<pre>  output logic prog_done_o,</pre>
<pre>  output logic erase_done_o,</pre>
<pre>  output logic error_o,</pre>
<pre>  output logic [AllPagesW-1:0] err_addr_o,</pre>
<pre>  output logic [BankW-1:0] err_bank_o,</pre>
<pre>  output logic req_o,</pre>
<pre>  output logic rd_o,</pre>
<pre>  output logic prog_o,</pre>
<pre>  output logic pg_erase_o,</pre>
<pre>  output logic bk_erase_o,</pre>
<pre>  input rd_done_i,</pre>
<pre>  input prog_done_i,</pre>
<pre>  input erase_done_i</pre>
<pre>  logic [AllPagesW-1:0] region_end[TotalRegions];</pre>
<pre>  logic [TotalRegions-1:0] region_match;</pre>
<pre>  logic [TotalRegions-1:0] region_sel;</pre>
<pre>  logic [TotalRegions-1:0] rd_en;</pre>
<pre>  logic [TotalRegions-1:0] prog_en;</pre>
<pre>  logic [TotalRegions-1:0] pg_erase_en;</pre>
<pre>  logic [NumBanks-1:0] bk_erase_en;</pre>
<pre>  logic final_rd_en;</pre>
<pre>  logic final_prog_en;</pre>
<pre>  logic final_pg_erase_en;</pre>
<pre>  logic final_bk_erase_en;</pre>
<pre>  assign region_sel[0] = region_match[0];</pre>
<pre>  for (genvar i = 1; i < TotalRegions; i++) begin: gen_region_priority</pre>
<pre>    assign region_sel[i] = region_match[i] & ~|region_match[i-1:0];</pre>
<pre>  always_comb begin</pre>
<pre>    for (int unsigned i = 0; i < TotalRegions; i++) begin: region_comps</pre>
<pre>      region_end[i] = region_cfgs_i[i].base.q + region_cfgs_i[i].size.q;</pre>
<pre>      region_match[i] = req_addr_i >= region_cfgs_i[i].base.q &</pre>
<pre>                        req_addr_i <  region_end[i] &</pre>
<pre>                        req_i;</pre>
<pre>      rd_en[i] = region_cfgs_i[i].en.q & region_cfgs_i[i].rd_en.q & region_sel[i];</pre>
<pre>      prog_en[i] = region_cfgs_i[i].en.q & region_cfgs_i[i].prog_en.q & region_sel[i];</pre>
<pre>      pg_erase_en[i] = region_cfgs_i[i].en.q & region_cfgs_i[i].erase_en.q & region_sel[i];</pre>
<pre>  always_comb begin</pre>
<pre>    for (int unsigned i = 0; i < NumBanks; i++) begin: bank_comps</pre>
<pre>      bk_erase_en[i] = (req_bk_i == i) & bank_cfgs_i[i].q;</pre>
<pre>  assign final_rd_en = rd_i & |rd_en;</pre>
<pre>  assign final_prog_en = prog_i & |prog_en;</pre>
<pre>  assign final_pg_erase_en = pg_erase_i & |pg_erase_en;</pre>
<pre>  assign final_bk_erase_en = bk_erase_i & |bk_erase_en;</pre>
<pre>  assign rd_o = req_i & final_rd_en;</pre>
<pre>  assign prog_o = req_i & final_prog_en;</pre>
<pre>  assign pg_erase_o = req_i & final_pg_erase_en;</pre>
<pre>  assign bk_erase_o = req_i & final_bk_erase_en;</pre>
<pre>  assign req_o = rd_o | prog_o | pg_erase_o | bk_erase_o;</pre>
<pre>  logic txn_err;</pre>
<pre>  logic txn_ens;</pre>
<pre>  logic no_allowed_txn;</pre>
<pre>  assign txn_ens = final_rd_en | final_prog_en | final_pg_erase_en | final_bk_erase_en;</pre>
<pre>  assign no_allowed_txn = req_i & (addr_ovfl_i | ~txn_ens);</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      txn_err <= 1'b0;</pre>
<pre>      err_addr_o <= '0;</pre>
<pre>      err_bank_o <= '0;</pre>
<pre>    end else if (txn_err) begin</pre>
<pre>      txn_err <= 1'b0;</pre>
<pre>    end else if (no_allowed_txn) begin</pre>
<pre>      txn_err <= 1'b1;</pre>
<pre>      err_addr_o <= req_addr_i;</pre>
<pre>      err_bank_o <= req_bk_i;</pre>
<pre>  assign rd_done_o = rd_done_i | txn_err;</pre>
<pre>  assign prog_done_o = prog_done_i | txn_err;</pre>
<pre>  assign erase_done_o = erase_done_i | txn_err;</pre>
<pre>  assign error_o = txn_err;</pre>
<h3>hw/ip/flash_ctrl/rtl/flash_phy.sv</h3>
<pre>module flash_phy #(</pre>
<pre>  parameter int NumBanks = 2,</pre>
<pre>  parameter int PagesPerBank = 256, // pages per bank</pre>
<pre>  parameter int WordsPerPage = 256, // words per page</pre>
<pre>  parameter int DataWidth   = 32, // bits per word</pre>
<pre>  localparam int BankW = $clog2(NumBanks),</pre>
<pre>  localparam int PageW = $clog2(PagesPerBank),</pre>
<pre>  localparam int WordW = $clog2(WordsPerPage),</pre>
<pre>  localparam int AddrW = BankW + PageW + WordW</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input host_req_i,</pre>
<pre>  input [AddrW-1:0] host_addr_i,</pre>
<pre>  output logic host_req_rdy_o,</pre>
<pre>  output logic host_req_done_o,</pre>
<pre>  output logic [DataWidth-1:0] host_rdata_o,</pre>
<pre>  input flash_ctrl_pkg::flash_c2m_t flash_ctrl_i,</pre>
<pre>  output flash_ctrl_pkg::flash_m2c_t flash_ctrl_o</pre>
<pre>  localparam int FlashMacroOustanding = 1;</pre>
<pre>  localparam int SeqFifoDepth = FlashMacroOustanding * NumBanks;</pre>
<pre>  logic [BankW-1:0]     host_bank_sel;</pre>
<pre>  logic [BankW-1:0]     rsp_bank_sel;</pre>
<pre>  logic [NumBanks-1:0]  host_req_rdy;</pre>
<pre>  logic [NumBanks-1:0]  host_req_done;</pre>
<pre>  logic [NumBanks-1:0]  host_rsp_avail;</pre>
<pre>  logic [NumBanks-1:0]  host_rsp_vld;</pre>
<pre>  logic [NumBanks-1:0]  host_rsp_ack;</pre>
<pre>  logic [DataWidth-1:0] host_rsp_data [NumBanks];</pre>
<pre>  logic                 seq_fifo_rdy;</pre>
<pre>  logic                 seq_fifo_pending;</pre>
<pre>  logic [BankW-1:0]     ctrl_bank_sel;</pre>
<pre>  logic [NumBanks-1:0]  rd_done;</pre>
<pre>  logic [NumBanks-1:0]  prog_done;</pre>
<pre>  logic [NumBanks-1:0]  erase_done;</pre>
<pre>  logic [NumBanks-1:0]  init_busy;</pre>
<pre>  logic [DataWidth-1:0] rd_data [NumBanks];</pre>
<pre>  assign host_bank_sel = host_req_i ? host_addr_i[PageW + WordW +: BankW] : '0;</pre>
<pre>  assign ctrl_bank_sel = flash_ctrl_i.addr[PageW + WordW +: BankW];</pre>
<pre>  assign host_req_rdy_o = host_req_rdy[host_bank_sel] & host_rsp_avail[host_bank_sel] &</pre>
<pre>                          seq_fifo_rdy;</pre>
<pre>  assign host_req_done_o = seq_fifo_pending & host_rsp_vld[rsp_bank_sel];</pre>
<pre>  assign host_rdata_o = host_rsp_data[rsp_bank_sel];</pre>
<pre>  assign flash_ctrl_o.rd_done = rd_done[ctrl_bank_sel];</pre>
<pre>  assign flash_ctrl_o.prog_done = prog_done[ctrl_bank_sel];</pre>
<pre>  assign flash_ctrl_o.erase_done = erase_done[ctrl_bank_sel];</pre>
<pre>  assign flash_ctrl_o.rd_data = rd_data[ctrl_bank_sel];</pre>
<pre>  assign flash_ctrl_o.init_busy = |init_busy;</pre>
<pre>  prim_fifo_sync #(</pre>
<pre>      .Width  (BankW),</pre>
<pre>      .Pass   (0),</pre>
<pre>      .Depth  (SeqFifoDepth)</pre>
<pre style="background-color: #FF0000;">    ) bank_sequence_fifo (</pre>
<pre>      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .clr_i  (1'b0),</pre>
<pre>      .wvalid (host_req_i & host_req_rdy_o),</pre>
<pre>      .wready (seq_fifo_rdy),</pre>
<pre>      .wdata  (host_bank_sel),</pre>
<pre>      .depth  (),</pre>
<pre>      .rvalid (seq_fifo_pending),</pre>
<pre>      .rready (host_req_done_o),</pre>
<pre>      .rdata  (rsp_bank_sel)</pre>
<pre>  for (genvar bank = 0; bank < NumBanks; bank++) begin : gen_flash_banks</pre>
<pre>    assign host_rsp_ack[bank] = host_req_done_o & (rsp_bank_sel == bank);</pre>
<pre>    prim_fifo_sync #(</pre>
<pre>      .Width  (DataWidth),</pre>
<pre>      .Pass   (1'b1),</pre>
<pre>      .Depth  (FlashMacroOustanding)</pre>
<pre style="background-color: #FF0000;">    ) host_rsp_fifo (</pre>
<pre>      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .clr_i  (1'b0),</pre>
<pre>      .wvalid (host_req_done[bank]),</pre>
<pre>      .wready (host_rsp_avail[bank]),</pre>
<pre>      .wdata  (rd_data[bank]),</pre>
<pre>      .depth  (),</pre>
<pre>      .rvalid (host_rsp_vld[bank]),</pre>
<pre>      .rready (host_rsp_ack[bank]),</pre>
<pre>      .rdata  (host_rsp_data[bank])</pre>
<pre>    prim_flash #(</pre>
<pre>      .PagesPerBank(PagesPerBank),</pre>
<pre>      .WordsPerPage(WordsPerPage),</pre>
<pre>      .DataWidth(DataWidth)</pre>
<pre style="background-color: #FF0000;">    ) u_flash (</pre>
<pre>      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .req_i(flash_ctrl_i.req & (ctrl_bank_sel == bank)),</pre>
<pre>      .host_req_i(host_req_i & host_req_rdy_o & (host_bank_sel == bank)),</pre>
<pre>      .host_addr_i(host_addr_i[0 +: PageW + WordW]),</pre>
<pre>      .rd_i(flash_ctrl_i.rd),</pre>
<pre>      .prog_i(flash_ctrl_i.prog),</pre>
<pre>      .pg_erase_i(flash_ctrl_i.pg_erase),</pre>
<pre>      .bk_erase_i(flash_ctrl_i.bk_erase),</pre>
<pre>      .addr_i(flash_ctrl_i.addr[0 +: PageW + WordW]),</pre>
<pre>      .prog_data_i(flash_ctrl_i.prog_data),</pre>
<pre>      .host_req_rdy_o(host_req_rdy[bank]),</pre>
<pre>      .host_req_done_o(host_req_done[bank]),</pre>
<pre>      .rd_done_o(rd_done[bank]),</pre>
<pre>      .prog_done_o(prog_done[bank]),</pre>
<pre>      .erase_done_o(erase_done[bank]),</pre>
<pre>      .rd_data_o(rd_data[bank]),</pre>
<pre>      .init_busy_o(init_busy[bank])</pre>
<h3>hw/ip/flash_ctrl/rtl/flash_ctrl.sv</h3>
<pre>  input        clk_i,</pre>
<pre>  input        rst_ni,</pre>
<pre>  input        tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output       tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  input        flash_ctrl_pkg::flash_m2c_t flash_i,</pre>
<pre>  output       flash_ctrl_pkg::flash_c2m_t flash_o,</pre>
<pre>  output logic intr_prog_empty_o, // Program fifo is empty</pre>
<pre>  output logic intr_prog_lvl_o,   // Program fifo is empty</pre>
<pre>  output logic intr_rd_full_o,    // Read fifo is full</pre>
<pre>  output logic intr_rd_lvl_o,     // Read fifo is full</pre>
<pre>  output logic intr_op_done_o,    // Requested flash operation (wr/erase) done</pre>
<pre>  output logic intr_op_error_o    // Requested flash operation (wr/erase) done</pre>
<pre>  localparam int NumBanks = top_pkg::FLASH_BANKS;</pre>
<pre>  localparam int PagesPerBank = top_pkg::FLASH_PAGES_PER_BANK;</pre>
<pre>  localparam int WordsPerPage = top_pkg::FLASH_WORDS_PER_PAGE;</pre>
<pre>  localparam int BankW = top_pkg::FLASH_BKW;</pre>
<pre>  localparam int PageW = top_pkg::FLASH_PGW;</pre>
<pre>  localparam int WordW = top_pkg::FLASH_WDW;</pre>
<pre>  localparam int AllPagesW = BankW + PageW;</pre>
<pre>  localparam int AddrW = top_pkg::FLASH_AW;</pre>
<pre>  localparam int DataWidth = top_pkg::FLASH_DW;</pre>
<pre>  localparam int DataBitWidth = $clog2(DataWidth/8);</pre>
<pre>  localparam int EraseBitWidth = $bits(flash_erase_op_e);</pre>
<pre>  localparam int FifoDepth = 16;</pre>
<pre>  localparam int FifoDepthW = $clog2(FifoDepth+1);</pre>
<pre>  localparam int MpRegions = 8;</pre>
<pre>  flash_ctrl_reg2hw_t reg2hw;</pre>
<pre>  flash_ctrl_hw2reg_t hw2reg;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_fifo_h2d [2];</pre>
<pre>  tlul_pkg::tl_d2h_t tl_fifo_d2h [2];</pre>
<pre>  flash_ctrl_reg_top u_reg (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .tl_o,</pre>
<pre>    .tl_win_o (tl_fifo_h2d),</pre>
<pre>    .tl_win_i (tl_fifo_d2h),</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .devmode_i  (1'b1)</pre>
<pre>  logic                 prog_fifo_wready;</pre>
<pre>  logic                 prog_fifo_rvalid;</pre>
<pre>  logic                 prog_fifo_req;</pre>
<pre>  logic                 prog_fifo_wen;</pre>
<pre>  logic                 prog_fifo_ren;</pre>
<pre>  logic [DataWidth-1:0] prog_fifo_wdata;</pre>
<pre>  logic [DataWidth-1:0] prog_fifo_rdata;</pre>
<pre>  logic [FifoDepthW-1:0] prog_fifo_depth;</pre>
<pre>  logic                 rd_fifo_wready;</pre>
<pre>  logic                 rd_fifo_rvalid;</pre>
<pre>  logic                 rd_fifo_wen;</pre>
<pre>  logic                 rd_fifo_ren;</pre>
<pre>  logic [DataWidth-1:0] rd_fifo_wdata;</pre>
<pre>  logic [DataWidth-1:0] rd_fifo_rdata;</pre>
<pre>  logic [FifoDepthW-1:0] rd_fifo_depth;</pre>
<pre>  logic prog_flash_req;</pre>
<pre>  logic prog_flash_ovfl;</pre>
<pre>  logic [AddrW-1:0] prog_flash_addr;</pre>
<pre>  logic rd_flash_req;</pre>
<pre>  logic rd_flash_ovfl;</pre>
<pre>  logic [AddrW-1:0] rd_flash_addr;</pre>
<pre>  logic erase_flash_req;</pre>
<pre>  logic [AddrW-1:0] erase_flash_addr;</pre>
<pre>  logic [EraseBitWidth-1:0] erase_flash_type;</pre>
<pre>  logic [2:0] ctrl_done, ctrl_err;</pre>
<pre>  logic flash_req;</pre>
<pre>  logic flash_rd_done, flash_prog_done, flash_erase_done;</pre>
<pre>  logic flash_error;</pre>
<pre>  logic [AddrW-1:0] flash_addr;</pre>
<pre>  logic [DataWidth-1:0] flash_prog_data;</pre>
<pre>  logic [DataWidth-1:0] flash_rd_data;</pre>
<pre>  logic init_busy;</pre>
<pre>  logic rd_op;</pre>
<pre>  logic prog_op;</pre>
<pre>  logic erase_op;</pre>
<pre>  logic [AllPagesW-1:0] err_page;</pre>
<pre>  logic [BankW-1:0] err_bank;</pre>
<pre>  assign rd_op = reg2hw.control.op.q == FlashRead;</pre>
<pre>  assign prog_op = reg2hw.control.op.q == FlashProg;</pre>
<pre>  assign erase_op = reg2hw.control.op.q == FlashErase;</pre>
<pre>  tlul_adapter_sram #(</pre>
<pre>    .SramAw(1),         //address unused</pre>
<pre>    .SramDw(DataWidth),</pre>
<pre>    .ByteAccess(0),     //flash may not support byte access</pre>
<pre>    .ErrOnRead(1)       //reads not supported</pre>
<pre style="background-color: #FF0000;">  ) u_to_prog_fifo (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i       (tl_fifo_h2d[0]),</pre>
<pre>    .tl_o       (tl_fifo_d2h[0]),</pre>
<pre>    .req_o      (prog_fifo_req),</pre>
<pre>    .gnt_i      (prog_fifo_wready),</pre>
<pre>    .we_o       (prog_fifo_wen),</pre>
<pre>    .addr_o     (),</pre>
<pre>    .wmask_o    (),</pre>
<pre>    .wdata_o    (prog_fifo_wdata),</pre>
<pre>    .rdata_i    (DataWidth'(0)),</pre>
<pre>    .rvalid_i   (1'b0),</pre>
<pre>    .rerror_i   (2'b0)</pre>
<pre>  prim_fifo_sync #(</pre>
<pre>    .Width(DataWidth),</pre>
<pre>    .Depth(FifoDepth)</pre>
<pre style="background-color: #FF0000;">  ) u_prog_fifo (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni (rst_ni),</pre>
<pre>    .clr_i  (reg2hw.control.fifo_rst.q),</pre>
<pre>    .wvalid (prog_fifo_req & prog_fifo_wen),</pre>
<pre>    .wready (prog_fifo_wready),</pre>
<pre>    .wdata  (prog_fifo_wdata),</pre>
<pre>    .depth  (prog_fifo_depth),</pre>
<pre>    .rvalid (prog_fifo_rvalid),</pre>
<pre>    .rready (prog_fifo_ren),</pre>
<pre>    .rdata  (prog_fifo_rdata)</pre>
<pre>  flash_prog_ctrl #(</pre>
<pre>    .DataW(DataWidth),</pre>
<pre>    .AddrW(AddrW)</pre>
<pre style="background-color: #FF0000;">  ) u_flash_prog_ctrl (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .op_start_i     (reg2hw.control.start.q & prog_op),</pre>
<pre>    .op_num_words_i (reg2hw.control.num.q),</pre>
<pre>    .op_done_o      (ctrl_done[0]),</pre>
<pre>    .op_err_o       (ctrl_err[0]),</pre>
<pre>    .op_addr_i      (reg2hw.addr.q[DataBitWidth +: AddrW]),</pre>
<pre>    .data_i         (prog_fifo_rdata),</pre>
<pre>    .data_rdy_i     (prog_fifo_rvalid),</pre>
<pre>    .data_rd_o      (prog_fifo_ren),</pre>
<pre>    .flash_req_o    (prog_flash_req),</pre>
<pre>    .flash_addr_o   (prog_flash_addr),</pre>
<pre>    .flash_ovfl_o   (prog_flash_ovfl),</pre>
<pre>    .flash_data_o   (flash_prog_data),</pre>
<pre>    .flash_done_i   (flash_prog_done),</pre>
<pre>    .flash_error_i  (flash_error)</pre>
<pre>  logic adapter_rvalid;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      adapter_rvalid <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      adapter_rvalid <= rd_fifo_ren && rd_fifo_rvalid;</pre>
<pre>  tlul_adapter_sram #(</pre>
<pre>    .SramAw(1),         //address unused</pre>
<pre>    .SramDw(DataWidth),</pre>
<pre>    .ByteAccess(0),     //flash may not support byte access</pre>
<pre>    .ErrOnWrite(1)      //writes not supported</pre>
<pre style="background-color: #FF0000;">  ) u_to_rd_fifo (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i       (tl_fifo_h2d[1]),</pre>
<pre>    .tl_o       (tl_fifo_d2h[1]),</pre>
<pre>    .req_o      (rd_fifo_ren),</pre>
<pre>    .gnt_i      (rd_fifo_rvalid),</pre>
<pre>    .we_o       (),</pre>
<pre>    .addr_o     (),</pre>
<pre>    .wmask_o    (),</pre>
<pre>    .wdata_o    (),</pre>
<pre>    .rdata_i    (rd_fifo_rdata),</pre>
<pre>    .rvalid_i   (adapter_rvalid),</pre>
<pre>    .rerror_i   (2'b0)</pre>
<pre>  prim_fifo_sync #(</pre>
<pre>    .Width(DataWidth),</pre>
<pre>    .Depth(FifoDepth)</pre>
<pre style="background-color: #FF0000;">  ) u_rd_fifo (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni (rst_ni),</pre>
<pre>    .clr_i  (reg2hw.control.fifo_rst.q),</pre>
<pre>    .wvalid (rd_fifo_wen),</pre>
<pre>    .wready (rd_fifo_wready),</pre>
<pre>    .wdata  (rd_fifo_wdata),</pre>
<pre>    .depth  (rd_fifo_depth),</pre>
<pre>    .rvalid (rd_fifo_rvalid),</pre>
<pre>    .rready (adapter_rvalid),</pre>
<pre>    .rdata  (rd_fifo_rdata)</pre>
<pre>  flash_rd_ctrl #(</pre>
<pre>    .DataW(DataWidth),</pre>
<pre>    .AddrW(AddrW)</pre>
<pre style="background-color: #FF0000;">  ) u_flash_rd_ctrl (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .op_start_i     (reg2hw.control.start.q & rd_op),</pre>
<pre>    .op_num_words_i (reg2hw.control.num.q),</pre>
<pre>    .op_done_o      (ctrl_done[1]),</pre>
<pre>    .op_err_o       (ctrl_err[1]),</pre>
<pre>    .op_addr_i      (reg2hw.addr.q[DataBitWidth +: AddrW]),</pre>
<pre>    .data_rdy_i     (rd_fifo_wready),</pre>
<pre>    .data_o         (rd_fifo_wdata),</pre>
<pre>    .data_wr_o      (rd_fifo_wen),</pre>
<pre>    .flash_req_o    (rd_flash_req),</pre>
<pre>    .flash_addr_o   (rd_flash_addr),</pre>
<pre>    .flash_ovfl_o   (rd_flash_ovfl),</pre>
<pre>    .flash_data_i   (flash_rd_data),</pre>
<pre>    .flash_done_i   (flash_rd_done),</pre>
<pre>    .flash_error_i  (flash_error)</pre>
<pre>  flash_erase_ctrl #(</pre>
<pre>    .AddrW(AddrW),</pre>
<pre>    .PagesPerBank(PagesPerBank),</pre>
<pre>    .WordsPerPage(WordsPerPage),</pre>
<pre>    .EraseBitWidth(EraseBitWidth)</pre>
<pre>  ) u_flash_erase_ctrl (</pre>
<pre>    .op_start_i     (reg2hw.control.start.q & erase_op),</pre>
<pre>    .op_type_i      (reg2hw.control.erase_sel.q),</pre>
<pre>    .op_done_o      (ctrl_done[2]),</pre>
<pre>    .op_err_o       (ctrl_err[2]),</pre>
<pre>    .op_addr_i      (reg2hw.addr.q[DataBitWidth +: AddrW]),</pre>
<pre>    .flash_req_o    (erase_flash_req),</pre>
<pre>    .flash_addr_o   (erase_flash_addr),</pre>
<pre>    .flash_op_o     (erase_flash_type),</pre>
<pre>    .flash_done_i   (flash_erase_done),</pre>
<pre>    .flash_error_i  (flash_error)</pre>
<pre>  always_comb begin</pre>
<pre>    unique case (reg2hw.control.op.q)</pre>
<pre>      FlashRead: begin</pre>
<pre>        flash_req = rd_flash_req;</pre>
<pre>        flash_addr = rd_flash_addr;</pre>
<pre>      FlashProg: begin</pre>
<pre>        flash_req = prog_flash_req;</pre>
<pre>        flash_addr = prog_flash_addr;</pre>
<pre>      FlashErase: begin</pre>
<pre>        flash_req = erase_flash_req;</pre>
<pre>        flash_addr = erase_flash_addr;</pre>
<pre>      default: begin</pre>
<pre>        flash_req = 1'b0;</pre>
<pre>        flash_addr  = '0;</pre>
<pre>  flash_ctrl_reg2hw_mp_region_cfg_mreg_t [MpRegions:0] region_cfgs;</pre>
<pre>  assign region_cfgs[MpRegions-1:0] = reg2hw.mp_region_cfg[MpRegions-1:0];</pre>
<pre>  assign region_cfgs[MpRegions].base.q = '0;</pre>
<pre>  assign region_cfgs[MpRegions].size.q = {AllPagesW{1'b1}};</pre>
<pre>  assign region_cfgs[MpRegions].en.q = 1'b1;</pre>
<pre>  assign region_cfgs[MpRegions].rd_en.q = reg2hw.default_region.rd_en.q;</pre>
<pre>  assign region_cfgs[MpRegions].prog_en.q = reg2hw.default_region.prog_en.q;</pre>
<pre>  assign region_cfgs[MpRegions].erase_en.q = reg2hw.default_region.erase_en.q;</pre>
<pre>  flash_mp #(</pre>
<pre>    .MpRegions(MpRegions),</pre>
<pre>    .NumBanks(NumBanks),</pre>
<pre>    .AllPagesW(AllPagesW)</pre>
<pre style="background-color: #FF0000;">  ) u_flash_mp (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .region_cfgs_i(region_cfgs),</pre>
<pre>    .bank_cfgs_i(reg2hw.mp_bank_cfg),</pre>
<pre>    .req_i(flash_req),</pre>
<pre>    .req_addr_i(flash_addr[WordW +: AllPagesW]),</pre>
<pre>    .addr_ovfl_i(rd_flash_ovfl | prog_flash_ovfl),</pre>
<pre>    .req_bk_i(flash_addr[WordW + PageW +: BankW]),</pre>
<pre>    .rd_i(rd_op),</pre>
<pre>    .prog_i(prog_op),</pre>
<pre>    .pg_erase_i(erase_op & (erase_flash_type == PageErase)),</pre>
<pre>    .bk_erase_i(erase_op & (erase_flash_type == BankErase)),</pre>
<pre>    .rd_done_o(flash_rd_done),</pre>
<pre>    .prog_done_o(flash_prog_done),</pre>
<pre>    .erase_done_o(flash_erase_done),</pre>
<pre>    .error_o(flash_error),</pre>
<pre>    .err_addr_o(err_page),</pre>
<pre>    .err_bank_o(err_bank),</pre>
<pre>    .req_o(flash_o.req),</pre>
<pre>    .rd_o(flash_o.rd),</pre>
<pre>    .prog_o(flash_o.prog),</pre>
<pre>    .pg_erase_o(flash_o.pg_erase),</pre>
<pre>    .bk_erase_o(flash_o.bk_erase),</pre>
<pre>    .rd_done_i(flash_i.rd_done),</pre>
<pre>    .prog_done_i(flash_i.prog_done),</pre>
<pre>    .erase_done_i(flash_i.erase_done)</pre>
<pre>  assign hw2reg.op_status.done.d = 1'b1;</pre>
<pre>  assign hw2reg.op_status.done.de = |ctrl_done;</pre>
<pre>  assign hw2reg.op_status.err.d = 1'b1;</pre>
<pre>  assign hw2reg.op_status.err.de = |ctrl_err;</pre>
<pre>  assign hw2reg.status.rd_full.d = ~rd_fifo_wready;</pre>
<pre>  assign hw2reg.status.rd_empty.d = ~rd_fifo_rvalid;</pre>
<pre>  assign hw2reg.status.prog_full.d = ~prog_fifo_wready;</pre>
<pre>  assign hw2reg.status.prog_empty.d = ~prog_fifo_rvalid;</pre>
<pre>  assign hw2reg.status.init_wip.d = init_busy;</pre>
<pre>  assign hw2reg.status.error_page.d = err_page;</pre>
<pre>  assign hw2reg.status.error_bank.d = err_bank;</pre>
<pre>  assign hw2reg.control.start.d = 1'b0;</pre>
<pre>  assign hw2reg.control.start.de = |ctrl_done;</pre>
<pre>  assign flash_o.addr = flash_addr;</pre>
<pre>  assign flash_o.prog_data = flash_prog_data;</pre>
<pre>  assign flash_rd_data = flash_i.rd_data;</pre>
<pre>  assign init_busy = flash_i.init_busy;</pre>
<pre>  logic [3:0] intr_src;</pre>
<pre>  logic [3:0] intr_src_q;</pre>
<pre>  logic [3:0] intr_assert;</pre>
<pre>  assign intr_src = { ~prog_fifo_rvalid,</pre>
<pre>                      reg2hw.fifo_lvl.prog.q == prog_fifo_depth,</pre>
<pre>                      ~rd_fifo_wready,</pre>
<pre>                      reg2hw.fifo_lvl.rd.q == rd_fifo_depth</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      intr_src_q <= 'h0;</pre>
<pre>    end else begin</pre>
<pre>      intr_src_q <= intr_src;</pre>
<pre>  assign intr_assert = ~intr_src_q & intr_src;</pre>
<pre>  assign intr_prog_empty_o = reg2hw.intr_enable.prog_empty.q & reg2hw.intr_state.prog_empty.q;</pre>
<pre>  assign intr_prog_lvl_o = reg2hw.intr_enable.prog_lvl.q & reg2hw.intr_state.prog_lvl.q;</pre>
<pre>  assign intr_rd_full_o = reg2hw.intr_enable.rd_full.q & reg2hw.intr_state.rd_full.q;</pre>
<pre>  assign intr_rd_lvl_o = reg2hw.intr_enable.rd_lvl.q & reg2hw.intr_state.rd_lvl.q;</pre>
<pre>  assign intr_op_done_o = reg2hw.intr_enable.op_done.q & reg2hw.intr_state.op_done.q;</pre>
<pre>  assign intr_op_error_o = reg2hw.intr_enable.op_error.q & reg2hw.intr_state.op_error.q;</pre>
<pre>  assign hw2reg.intr_state.prog_empty.d  = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.prog_empty.de = intr_assert[3]  |</pre>
<pre>                                           (reg2hw.intr_test.prog_empty.qe  &</pre>
<pre>                                           reg2hw.intr_test.prog_empty.q);</pre>
<pre>  assign hw2reg.intr_state.prog_lvl.d  = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.prog_lvl.de = intr_assert[2]  |</pre>
<pre>                                         (reg2hw.intr_test.prog_lvl.qe  &</pre>
<pre>                                         reg2hw.intr_test.prog_lvl.q);</pre>
<pre>  assign hw2reg.intr_state.rd_full.d  = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.rd_full.de = intr_assert[1] |</pre>
<pre>                                        (reg2hw.intr_test.rd_full.qe  &</pre>
<pre>                                        reg2hw.intr_test.rd_full.q);</pre>
<pre>  assign hw2reg.intr_state.rd_lvl.d  = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.rd_lvl.de =  intr_assert[0] |</pre>
<pre>                                       (reg2hw.intr_test.rd_lvl.qe  &</pre>
<pre>                                       reg2hw.intr_test.rd_lvl.q);</pre>
<pre>  assign hw2reg.intr_state.op_done.d  = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.op_done.de = |ctrl_done  |</pre>
<pre>                                        (reg2hw.intr_test.op_done.qe  &</pre>
<pre>                                        reg2hw.intr_test.op_done.q);</pre>
<pre>  assign hw2reg.intr_state.op_error.d  = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.op_error.de = |ctrl_err  |</pre>
<pre>                                        (reg2hw.intr_test.op_error.qe  &</pre>
<pre>                                        reg2hw.intr_test.op_error.q);</pre>
<pre>  logic [DataBitWidth-1:0] unused_byte_sel;</pre>
<pre>  logic [31-AddrW:0] unused_higher_addr_bits;</pre>
<pre>  logic [31:0] unused_scratch;</pre>
<pre>  assign unused_byte_sel = reg2hw.addr.q[DataBitWidth-1:0];</pre>
<pre>  assign unused_higher_addr_bits = reg2hw.addr.q[31:AddrW];</pre>
<pre>  assign unused_scratch = reg2hw.scratch;</pre>
<h3>hw/ip/flash_ctrl/rtl/flash_ctrl_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_win_o  [2],</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_win_i  [2],</pre>
<pre>  output flash_ctrl_reg_pkg::flash_ctrl_reg2hw_t reg2hw, // Write</pre>
<pre>  input  flash_ctrl_reg_pkg::flash_ctrl_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam int AW = 7;</pre>
<pre>  localparam int DW = 32;</pre>
<pre>  localparam int DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_socket_h2d [3];</pre>
<pre>  tlul_pkg::tl_d2h_t tl_socket_d2h [3];</pre>
<pre>  logic [1:0] reg_steer;</pre>
<pre>  assign tl_reg_h2d = tl_socket_h2d[2];</pre>
<pre>  assign tl_socket_d2h[2] = tl_reg_d2h;</pre>
<pre>  assign tl_win_o[0] = tl_socket_h2d[0];</pre>
<pre>  assign tl_socket_d2h[0] = tl_win_i[0];</pre>
<pre>  assign tl_win_o[1] = tl_socket_h2d[1];</pre>
<pre>  assign tl_socket_d2h[1] = tl_win_i[1];</pre>
<pre>  tlul_socket_1n #(</pre>
<pre>    .N          (3),</pre>
<pre>    .HReqPass   (1'b1),</pre>
<pre>    .HRspPass   (1'b1),</pre>
<pre>    .DReqPass   ({3{1'b1}}),</pre>
<pre>    .DRspPass   ({3{1'b1}}),</pre>
<pre>    .HReqDepth  (4'h0),</pre>
<pre>    .HRspDepth  (4'h0),</pre>
<pre>    .DReqDepth  ({3{4'h0}}),</pre>
<pre>    .DRspDepth  ({3{4'h0}})</pre>
<pre style="background-color: #FF0000;">  ) u_socket (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_h_i (tl_i),</pre>
<pre>    .tl_h_o (tl_o),</pre>
<pre>    .tl_d_o (tl_socket_h2d),</pre>
<pre>    .tl_d_i (tl_socket_d2h),</pre>
<pre>    .dev_select (reg_steer)</pre>
<pre>  always_comb begin</pre>
<pre>    reg_steer = 2;       // Default set to register</pre>
<pre>    if (tl_i.a_address[AW-1:0] >= 84 && tl_i.a_address[AW-1:0] < 88) begin</pre>
<pre>      reg_steer = 0;</pre>
<pre>    if (tl_i.a_address[AW-1:0] >= 88 && tl_i.a_address[AW-1:0] < 92) begin</pre>
<pre>      reg_steer = 1;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic intr_state_prog_empty_qs;</pre>
<pre>  logic intr_state_prog_empty_wd;</pre>
<pre>  logic intr_state_prog_empty_we;</pre>
<pre>  logic intr_state_prog_lvl_qs;</pre>
<pre>  logic intr_state_prog_lvl_wd;</pre>
<pre>  logic intr_state_prog_lvl_we;</pre>
<pre>  logic intr_state_rd_full_qs;</pre>
<pre>  logic intr_state_rd_full_wd;</pre>
<pre>  logic intr_state_rd_full_we;</pre>
<pre>  logic intr_state_rd_lvl_qs;</pre>
<pre>  logic intr_state_rd_lvl_wd;</pre>
<pre>  logic intr_state_rd_lvl_we;</pre>
<pre>  logic intr_state_op_done_qs;</pre>
<pre>  logic intr_state_op_done_wd;</pre>
<pre>  logic intr_state_op_done_we;</pre>
<pre>  logic intr_state_op_error_qs;</pre>
<pre>  logic intr_state_op_error_wd;</pre>
<pre>  logic intr_state_op_error_we;</pre>
<pre>  logic intr_enable_prog_empty_qs;</pre>
<pre>  logic intr_enable_prog_empty_wd;</pre>
<pre>  logic intr_enable_prog_empty_we;</pre>
<pre>  logic intr_enable_prog_lvl_qs;</pre>
<pre>  logic intr_enable_prog_lvl_wd;</pre>
<pre>  logic intr_enable_prog_lvl_we;</pre>
<pre>  logic intr_enable_rd_full_qs;</pre>
<pre>  logic intr_enable_rd_full_wd;</pre>
<pre>  logic intr_enable_rd_full_we;</pre>
<pre>  logic intr_enable_rd_lvl_qs;</pre>
<pre>  logic intr_enable_rd_lvl_wd;</pre>
<pre>  logic intr_enable_rd_lvl_we;</pre>
<pre>  logic intr_enable_op_done_qs;</pre>
<pre>  logic intr_enable_op_done_wd;</pre>
<pre>  logic intr_enable_op_done_we;</pre>
<pre>  logic intr_enable_op_error_qs;</pre>
<pre>  logic intr_enable_op_error_wd;</pre>
<pre>  logic intr_enable_op_error_we;</pre>
<pre>  logic intr_test_prog_empty_wd;</pre>
<pre>  logic intr_test_prog_empty_we;</pre>
<pre>  logic intr_test_prog_lvl_wd;</pre>
<pre>  logic intr_test_prog_lvl_we;</pre>
<pre>  logic intr_test_rd_full_wd;</pre>
<pre>  logic intr_test_rd_full_we;</pre>
<pre>  logic intr_test_rd_lvl_wd;</pre>
<pre>  logic intr_test_rd_lvl_we;</pre>
<pre>  logic intr_test_op_done_wd;</pre>
<pre>  logic intr_test_op_done_we;</pre>
<pre>  logic intr_test_op_error_wd;</pre>
<pre>  logic intr_test_op_error_we;</pre>
<pre>  logic control_start_qs;</pre>
<pre>  logic control_start_wd;</pre>
<pre>  logic control_start_we;</pre>
<pre>  logic [1:0] control_op_qs;</pre>
<pre>  logic [1:0] control_op_wd;</pre>
<pre>  logic control_op_we;</pre>
<pre>  logic control_erase_sel_qs;</pre>
<pre>  logic control_erase_sel_wd;</pre>
<pre>  logic control_erase_sel_we;</pre>
<pre>  logic control_fifo_rst_qs;</pre>
<pre>  logic control_fifo_rst_wd;</pre>
<pre>  logic control_fifo_rst_we;</pre>
<pre>  logic [11:0] control_num_qs;</pre>
<pre>  logic [11:0] control_num_wd;</pre>
<pre>  logic control_num_we;</pre>
<pre>  logic [31:0] addr_qs;</pre>
<pre>  logic [31:0] addr_wd;</pre>
<pre>  logic addr_we;</pre>
<pre>  logic region_cfg_regwen_qs;</pre>
<pre>  logic region_cfg_regwen_wd;</pre>
<pre>  logic region_cfg_regwen_we;</pre>
<pre>  logic mp_region_cfg0_en0_qs;</pre>
<pre>  logic mp_region_cfg0_en0_wd;</pre>
<pre>  logic mp_region_cfg0_en0_we;</pre>
<pre>  logic mp_region_cfg0_rd_en0_qs;</pre>
<pre>  logic mp_region_cfg0_rd_en0_wd;</pre>
<pre>  logic mp_region_cfg0_rd_en0_we;</pre>
<pre>  logic mp_region_cfg0_prog_en0_qs;</pre>
<pre>  logic mp_region_cfg0_prog_en0_wd;</pre>
<pre>  logic mp_region_cfg0_prog_en0_we;</pre>
<pre>  logic mp_region_cfg0_erase_en0_qs;</pre>
<pre>  logic mp_region_cfg0_erase_en0_wd;</pre>
<pre>  logic mp_region_cfg0_erase_en0_we;</pre>
<pre>  logic [8:0] mp_region_cfg0_base0_qs;</pre>
<pre>  logic [8:0] mp_region_cfg0_base0_wd;</pre>
<pre>  logic mp_region_cfg0_base0_we;</pre>
<pre>  logic [8:0] mp_region_cfg0_size0_qs;</pre>
<pre>  logic [8:0] mp_region_cfg0_size0_wd;</pre>
<pre>  logic mp_region_cfg0_size0_we;</pre>
<pre>  logic mp_region_cfg1_en1_qs;</pre>
<pre>  logic mp_region_cfg1_en1_wd;</pre>
<pre>  logic mp_region_cfg1_en1_we;</pre>
<pre>  logic mp_region_cfg1_rd_en1_qs;</pre>
<pre>  logic mp_region_cfg1_rd_en1_wd;</pre>
<pre>  logic mp_region_cfg1_rd_en1_we;</pre>
<pre>  logic mp_region_cfg1_prog_en1_qs;</pre>
<pre>  logic mp_region_cfg1_prog_en1_wd;</pre>
<pre>  logic mp_region_cfg1_prog_en1_we;</pre>
<pre>  logic mp_region_cfg1_erase_en1_qs;</pre>
<pre>  logic mp_region_cfg1_erase_en1_wd;</pre>
<pre>  logic mp_region_cfg1_erase_en1_we;</pre>
<pre>  logic [8:0] mp_region_cfg1_base1_qs;</pre>
<pre>  logic [8:0] mp_region_cfg1_base1_wd;</pre>
<pre>  logic mp_region_cfg1_base1_we;</pre>
<pre>  logic [8:0] mp_region_cfg1_size1_qs;</pre>
<pre>  logic [8:0] mp_region_cfg1_size1_wd;</pre>
<pre>  logic mp_region_cfg1_size1_we;</pre>
<pre>  logic mp_region_cfg2_en2_qs;</pre>
<pre>  logic mp_region_cfg2_en2_wd;</pre>
<pre>  logic mp_region_cfg2_en2_we;</pre>
<pre>  logic mp_region_cfg2_rd_en2_qs;</pre>
<pre>  logic mp_region_cfg2_rd_en2_wd;</pre>
<pre>  logic mp_region_cfg2_rd_en2_we;</pre>
<pre>  logic mp_region_cfg2_prog_en2_qs;</pre>
<pre>  logic mp_region_cfg2_prog_en2_wd;</pre>
<pre>  logic mp_region_cfg2_prog_en2_we;</pre>
<pre>  logic mp_region_cfg2_erase_en2_qs;</pre>
<pre>  logic mp_region_cfg2_erase_en2_wd;</pre>
<pre>  logic mp_region_cfg2_erase_en2_we;</pre>
<pre>  logic [8:0] mp_region_cfg2_base2_qs;</pre>
<pre>  logic [8:0] mp_region_cfg2_base2_wd;</pre>
<pre>  logic mp_region_cfg2_base2_we;</pre>
<pre>  logic [8:0] mp_region_cfg2_size2_qs;</pre>
<pre>  logic [8:0] mp_region_cfg2_size2_wd;</pre>
<pre>  logic mp_region_cfg2_size2_we;</pre>
<pre>  logic mp_region_cfg3_en3_qs;</pre>
<pre>  logic mp_region_cfg3_en3_wd;</pre>
<pre>  logic mp_region_cfg3_en3_we;</pre>
<pre>  logic mp_region_cfg3_rd_en3_qs;</pre>
<pre>  logic mp_region_cfg3_rd_en3_wd;</pre>
<pre>  logic mp_region_cfg3_rd_en3_we;</pre>
<pre>  logic mp_region_cfg3_prog_en3_qs;</pre>
<pre>  logic mp_region_cfg3_prog_en3_wd;</pre>
<pre>  logic mp_region_cfg3_prog_en3_we;</pre>
<pre>  logic mp_region_cfg3_erase_en3_qs;</pre>
<pre>  logic mp_region_cfg3_erase_en3_wd;</pre>
<pre>  logic mp_region_cfg3_erase_en3_we;</pre>
<pre>  logic [8:0] mp_region_cfg3_base3_qs;</pre>
<pre>  logic [8:0] mp_region_cfg3_base3_wd;</pre>
<pre>  logic mp_region_cfg3_base3_we;</pre>
<pre>  logic [8:0] mp_region_cfg3_size3_qs;</pre>
<pre>  logic [8:0] mp_region_cfg3_size3_wd;</pre>
<pre>  logic mp_region_cfg3_size3_we;</pre>
<pre>  logic mp_region_cfg4_en4_qs;</pre>
<pre>  logic mp_region_cfg4_en4_wd;</pre>
<pre>  logic mp_region_cfg4_en4_we;</pre>
<pre>  logic mp_region_cfg4_rd_en4_qs;</pre>
<pre>  logic mp_region_cfg4_rd_en4_wd;</pre>
<pre>  logic mp_region_cfg4_rd_en4_we;</pre>
<pre>  logic mp_region_cfg4_prog_en4_qs;</pre>
<pre>  logic mp_region_cfg4_prog_en4_wd;</pre>
<pre>  logic mp_region_cfg4_prog_en4_we;</pre>
<pre>  logic mp_region_cfg4_erase_en4_qs;</pre>
<pre>  logic mp_region_cfg4_erase_en4_wd;</pre>
<pre>  logic mp_region_cfg4_erase_en4_we;</pre>
<pre>  logic [8:0] mp_region_cfg4_base4_qs;</pre>
<pre>  logic [8:0] mp_region_cfg4_base4_wd;</pre>
<pre>  logic mp_region_cfg4_base4_we;</pre>
<pre>  logic [8:0] mp_region_cfg4_size4_qs;</pre>
<pre>  logic [8:0] mp_region_cfg4_size4_wd;</pre>
<pre>  logic mp_region_cfg4_size4_we;</pre>
<pre>  logic mp_region_cfg5_en5_qs;</pre>
<pre>  logic mp_region_cfg5_en5_wd;</pre>
<pre>  logic mp_region_cfg5_en5_we;</pre>
<pre>  logic mp_region_cfg5_rd_en5_qs;</pre>
<pre>  logic mp_region_cfg5_rd_en5_wd;</pre>
<pre>  logic mp_region_cfg5_rd_en5_we;</pre>
<pre>  logic mp_region_cfg5_prog_en5_qs;</pre>
<pre>  logic mp_region_cfg5_prog_en5_wd;</pre>
<pre>  logic mp_region_cfg5_prog_en5_we;</pre>
<pre>  logic mp_region_cfg5_erase_en5_qs;</pre>
<pre>  logic mp_region_cfg5_erase_en5_wd;</pre>
<pre>  logic mp_region_cfg5_erase_en5_we;</pre>
<pre>  logic [8:0] mp_region_cfg5_base5_qs;</pre>
<pre>  logic [8:0] mp_region_cfg5_base5_wd;</pre>
<pre>  logic mp_region_cfg5_base5_we;</pre>
<pre>  logic [8:0] mp_region_cfg5_size5_qs;</pre>
<pre>  logic [8:0] mp_region_cfg5_size5_wd;</pre>
<pre>  logic mp_region_cfg5_size5_we;</pre>
<pre>  logic mp_region_cfg6_en6_qs;</pre>
<pre>  logic mp_region_cfg6_en6_wd;</pre>
<pre>  logic mp_region_cfg6_en6_we;</pre>
<pre>  logic mp_region_cfg6_rd_en6_qs;</pre>
<pre>  logic mp_region_cfg6_rd_en6_wd;</pre>
<pre>  logic mp_region_cfg6_rd_en6_we;</pre>
<pre>  logic mp_region_cfg6_prog_en6_qs;</pre>
<pre>  logic mp_region_cfg6_prog_en6_wd;</pre>
<pre>  logic mp_region_cfg6_prog_en6_we;</pre>
<pre>  logic mp_region_cfg6_erase_en6_qs;</pre>
<pre>  logic mp_region_cfg6_erase_en6_wd;</pre>
<pre>  logic mp_region_cfg6_erase_en6_we;</pre>
<pre>  logic [8:0] mp_region_cfg6_base6_qs;</pre>
<pre>  logic [8:0] mp_region_cfg6_base6_wd;</pre>
<pre>  logic mp_region_cfg6_base6_we;</pre>
<pre>  logic [8:0] mp_region_cfg6_size6_qs;</pre>
<pre>  logic [8:0] mp_region_cfg6_size6_wd;</pre>
<pre>  logic mp_region_cfg6_size6_we;</pre>
<pre>  logic mp_region_cfg7_en7_qs;</pre>
<pre>  logic mp_region_cfg7_en7_wd;</pre>
<pre>  logic mp_region_cfg7_en7_we;</pre>
<pre>  logic mp_region_cfg7_rd_en7_qs;</pre>
<pre>  logic mp_region_cfg7_rd_en7_wd;</pre>
<pre>  logic mp_region_cfg7_rd_en7_we;</pre>
<pre>  logic mp_region_cfg7_prog_en7_qs;</pre>
<pre>  logic mp_region_cfg7_prog_en7_wd;</pre>
<pre>  logic mp_region_cfg7_prog_en7_we;</pre>
<pre>  logic mp_region_cfg7_erase_en7_qs;</pre>
<pre>  logic mp_region_cfg7_erase_en7_wd;</pre>
<pre>  logic mp_region_cfg7_erase_en7_we;</pre>
<pre>  logic [8:0] mp_region_cfg7_base7_qs;</pre>
<pre>  logic [8:0] mp_region_cfg7_base7_wd;</pre>
<pre>  logic mp_region_cfg7_base7_we;</pre>
<pre>  logic [8:0] mp_region_cfg7_size7_qs;</pre>
<pre>  logic [8:0] mp_region_cfg7_size7_wd;</pre>
<pre>  logic mp_region_cfg7_size7_we;</pre>
<pre>  logic default_region_rd_en_qs;</pre>
<pre>  logic default_region_rd_en_wd;</pre>
<pre>  logic default_region_rd_en_we;</pre>
<pre>  logic default_region_prog_en_qs;</pre>
<pre>  logic default_region_prog_en_wd;</pre>
<pre>  logic default_region_prog_en_we;</pre>
<pre>  logic default_region_erase_en_qs;</pre>
<pre>  logic default_region_erase_en_wd;</pre>
<pre>  logic default_region_erase_en_we;</pre>
<pre>  logic bank_cfg_regwen_qs;</pre>
<pre>  logic bank_cfg_regwen_wd;</pre>
<pre>  logic bank_cfg_regwen_we;</pre>
<pre>  logic mp_bank_cfg_erase_en0_qs;</pre>
<pre>  logic mp_bank_cfg_erase_en0_wd;</pre>
<pre>  logic mp_bank_cfg_erase_en0_we;</pre>
<pre>  logic mp_bank_cfg_erase_en1_qs;</pre>
<pre>  logic mp_bank_cfg_erase_en1_wd;</pre>
<pre>  logic mp_bank_cfg_erase_en1_we;</pre>
<pre>  logic op_status_done_qs;</pre>
<pre>  logic op_status_done_wd;</pre>
<pre>  logic op_status_done_we;</pre>
<pre>  logic op_status_err_qs;</pre>
<pre>  logic op_status_err_wd;</pre>
<pre>  logic op_status_err_we;</pre>
<pre>  logic status_rd_full_qs;</pre>
<pre>  logic status_rd_full_re;</pre>
<pre>  logic status_rd_empty_qs;</pre>
<pre>  logic status_rd_empty_re;</pre>
<pre>  logic status_prog_full_qs;</pre>
<pre>  logic status_prog_full_re;</pre>
<pre>  logic status_prog_empty_qs;</pre>
<pre>  logic status_prog_empty_re;</pre>
<pre>  logic status_init_wip_qs;</pre>
<pre>  logic status_init_wip_re;</pre>
<pre>  logic [8:0] status_error_page_qs;</pre>
<pre>  logic status_error_page_re;</pre>
<pre>  logic status_error_bank_qs;</pre>
<pre>  logic status_error_bank_re;</pre>
<pre>  logic [31:0] scratch_qs;</pre>
<pre>  logic [31:0] scratch_wd;</pre>
<pre>  logic scratch_we;</pre>
<pre>  logic [4:0] fifo_lvl_prog_qs;</pre>
<pre>  logic [4:0] fifo_lvl_prog_wd;</pre>
<pre>  logic fifo_lvl_prog_we;</pre>
<pre>  logic [4:0] fifo_lvl_rd_qs;</pre>
<pre>  logic [4:0] fifo_lvl_rd_wd;</pre>
<pre>  logic fifo_lvl_rd_we;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_prog_empty (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_prog_empty_we),</pre>
<pre>    .wd     (intr_state_prog_empty_wd),</pre>
<pre>    .de     (hw2reg.intr_state.prog_empty.de),</pre>
<pre>    .d      (hw2reg.intr_state.prog_empty.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.prog_empty.q ),</pre>
<pre>    .qs     (intr_state_prog_empty_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_prog_lvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_prog_lvl_we),</pre>
<pre>    .wd     (intr_state_prog_lvl_wd),</pre>
<pre>    .de     (hw2reg.intr_state.prog_lvl.de),</pre>
<pre>    .d      (hw2reg.intr_state.prog_lvl.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.prog_lvl.q ),</pre>
<pre>    .qs     (intr_state_prog_lvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rd_full (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rd_full_we),</pre>
<pre>    .wd     (intr_state_rd_full_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rd_full.de),</pre>
<pre>    .d      (hw2reg.intr_state.rd_full.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rd_full.q ),</pre>
<pre>    .qs     (intr_state_rd_full_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rd_lvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rd_lvl_we),</pre>
<pre>    .wd     (intr_state_rd_lvl_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rd_lvl.de),</pre>
<pre>    .d      (hw2reg.intr_state.rd_lvl.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rd_lvl.q ),</pre>
<pre>    .qs     (intr_state_rd_lvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_op_done (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_op_done_we),</pre>
<pre>    .wd     (intr_state_op_done_wd),</pre>
<pre>    .de     (hw2reg.intr_state.op_done.de),</pre>
<pre>    .d      (hw2reg.intr_state.op_done.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.op_done.q ),</pre>
<pre>    .qs     (intr_state_op_done_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_op_error (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_op_error_we),</pre>
<pre>    .wd     (intr_state_op_error_wd),</pre>
<pre>    .de     (hw2reg.intr_state.op_error.de),</pre>
<pre>    .d      (hw2reg.intr_state.op_error.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.op_error.q ),</pre>
<pre>    .qs     (intr_state_op_error_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_prog_empty (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_prog_empty_we),</pre>
<pre>    .wd     (intr_enable_prog_empty_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.prog_empty.q ),</pre>
<pre>    .qs     (intr_enable_prog_empty_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_prog_lvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_prog_lvl_we),</pre>
<pre>    .wd     (intr_enable_prog_lvl_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.prog_lvl.q ),</pre>
<pre>    .qs     (intr_enable_prog_lvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rd_full (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rd_full_we),</pre>
<pre>    .wd     (intr_enable_rd_full_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rd_full.q ),</pre>
<pre>    .qs     (intr_enable_rd_full_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rd_lvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rd_lvl_we),</pre>
<pre>    .wd     (intr_enable_rd_lvl_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rd_lvl.q ),</pre>
<pre>    .qs     (intr_enable_rd_lvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_op_done (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_op_done_we),</pre>
<pre>    .wd     (intr_enable_op_done_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.op_done.q ),</pre>
<pre>    .qs     (intr_enable_op_done_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_op_error (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_op_error_we),</pre>
<pre>    .wd     (intr_enable_op_error_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.op_error.q ),</pre>
<pre>    .qs     (intr_enable_op_error_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_prog_empty (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_prog_empty_we),</pre>
<pre>    .wd     (intr_test_prog_empty_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.prog_empty.qe),</pre>
<pre>    .q      (reg2hw.intr_test.prog_empty.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_prog_lvl (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_prog_lvl_we),</pre>
<pre>    .wd     (intr_test_prog_lvl_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.prog_lvl.qe),</pre>
<pre>    .q      (reg2hw.intr_test.prog_lvl.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rd_full (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rd_full_we),</pre>
<pre>    .wd     (intr_test_rd_full_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rd_full.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rd_full.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rd_lvl (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rd_lvl_we),</pre>
<pre>    .wd     (intr_test_rd_lvl_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rd_lvl.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rd_lvl.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_op_done (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_op_done_we),</pre>
<pre>    .wd     (intr_test_op_done_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.op_done.qe),</pre>
<pre>    .q      (reg2hw.intr_test.op_done.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_op_error (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_op_error_we),</pre>
<pre>    .wd     (intr_test_op_error_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.op_error.qe),</pre>
<pre>    .q      (reg2hw.intr_test.op_error.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_control_start (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (control_start_we),</pre>
<pre>    .wd     (control_start_wd),</pre>
<pre>    .de     (hw2reg.control.start.de),</pre>
<pre>    .d      (hw2reg.control.start.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.control.start.q ),</pre>
<pre>    .qs     (control_start_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_control_op (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (control_op_we),</pre>
<pre>    .wd     (control_op_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.control.op.q ),</pre>
<pre>    .qs     (control_op_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_control_erase_sel (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (control_erase_sel_we),</pre>
<pre>    .wd     (control_erase_sel_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.control.erase_sel.q ),</pre>
<pre>    .qs     (control_erase_sel_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_control_fifo_rst (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (control_fifo_rst_we),</pre>
<pre>    .wd     (control_fifo_rst_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.control.fifo_rst.q ),</pre>
<pre>    .qs     (control_fifo_rst_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (12),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (12'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_control_num (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (control_num_we),</pre>
<pre>    .wd     (control_num_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.control.num.q ),</pre>
<pre>    .qs     (control_num_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_addr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (addr_we),</pre>
<pre>    .wd     (addr_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.addr.q ),</pre>
<pre>    .qs     (addr_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W0C"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_region_cfg_regwen (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (region_cfg_regwen_we),</pre>
<pre>    .wd     (region_cfg_regwen_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (region_cfg_regwen_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg0_en0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg0_en0_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg0_en0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[0].en.q ),</pre>
<pre>    .qs     (mp_region_cfg0_en0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg0_rd_en0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg0_rd_en0_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg0_rd_en0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[0].rd_en.q ),</pre>
<pre>    .qs     (mp_region_cfg0_rd_en0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg0_prog_en0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg0_prog_en0_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg0_prog_en0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[0].prog_en.q ),</pre>
<pre>    .qs     (mp_region_cfg0_prog_en0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg0_erase_en0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg0_erase_en0_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg0_erase_en0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[0].erase_en.q ),</pre>
<pre>    .qs     (mp_region_cfg0_erase_en0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg0_base0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg0_base0_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg0_base0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[0].base.q ),</pre>
<pre>    .qs     (mp_region_cfg0_base0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg0_size0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg0_size0_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg0_size0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[0].size.q ),</pre>
<pre>    .qs     (mp_region_cfg0_size0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg1_en1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg1_en1_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg1_en1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[1].en.q ),</pre>
<pre>    .qs     (mp_region_cfg1_en1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg1_rd_en1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg1_rd_en1_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg1_rd_en1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[1].rd_en.q ),</pre>
<pre>    .qs     (mp_region_cfg1_rd_en1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg1_prog_en1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg1_prog_en1_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg1_prog_en1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[1].prog_en.q ),</pre>
<pre>    .qs     (mp_region_cfg1_prog_en1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg1_erase_en1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg1_erase_en1_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg1_erase_en1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[1].erase_en.q ),</pre>
<pre>    .qs     (mp_region_cfg1_erase_en1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg1_base1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg1_base1_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg1_base1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[1].base.q ),</pre>
<pre>    .qs     (mp_region_cfg1_base1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg1_size1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg1_size1_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg1_size1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[1].size.q ),</pre>
<pre>    .qs     (mp_region_cfg1_size1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg2_en2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg2_en2_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg2_en2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[2].en.q ),</pre>
<pre>    .qs     (mp_region_cfg2_en2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg2_rd_en2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg2_rd_en2_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg2_rd_en2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[2].rd_en.q ),</pre>
<pre>    .qs     (mp_region_cfg2_rd_en2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg2_prog_en2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg2_prog_en2_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg2_prog_en2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[2].prog_en.q ),</pre>
<pre>    .qs     (mp_region_cfg2_prog_en2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg2_erase_en2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg2_erase_en2_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg2_erase_en2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[2].erase_en.q ),</pre>
<pre>    .qs     (mp_region_cfg2_erase_en2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg2_base2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg2_base2_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg2_base2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[2].base.q ),</pre>
<pre>    .qs     (mp_region_cfg2_base2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg2_size2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg2_size2_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg2_size2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[2].size.q ),</pre>
<pre>    .qs     (mp_region_cfg2_size2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg3_en3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg3_en3_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg3_en3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[3].en.q ),</pre>
<pre>    .qs     (mp_region_cfg3_en3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg3_rd_en3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg3_rd_en3_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg3_rd_en3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[3].rd_en.q ),</pre>
<pre>    .qs     (mp_region_cfg3_rd_en3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg3_prog_en3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg3_prog_en3_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg3_prog_en3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[3].prog_en.q ),</pre>
<pre>    .qs     (mp_region_cfg3_prog_en3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg3_erase_en3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg3_erase_en3_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg3_erase_en3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[3].erase_en.q ),</pre>
<pre>    .qs     (mp_region_cfg3_erase_en3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg3_base3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg3_base3_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg3_base3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[3].base.q ),</pre>
<pre>    .qs     (mp_region_cfg3_base3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg3_size3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg3_size3_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg3_size3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[3].size.q ),</pre>
<pre>    .qs     (mp_region_cfg3_size3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg4_en4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg4_en4_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg4_en4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[4].en.q ),</pre>
<pre>    .qs     (mp_region_cfg4_en4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg4_rd_en4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg4_rd_en4_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg4_rd_en4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[4].rd_en.q ),</pre>
<pre>    .qs     (mp_region_cfg4_rd_en4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg4_prog_en4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg4_prog_en4_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg4_prog_en4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[4].prog_en.q ),</pre>
<pre>    .qs     (mp_region_cfg4_prog_en4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg4_erase_en4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg4_erase_en4_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg4_erase_en4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[4].erase_en.q ),</pre>
<pre>    .qs     (mp_region_cfg4_erase_en4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg4_base4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg4_base4_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg4_base4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[4].base.q ),</pre>
<pre>    .qs     (mp_region_cfg4_base4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg4_size4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg4_size4_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg4_size4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[4].size.q ),</pre>
<pre>    .qs     (mp_region_cfg4_size4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg5_en5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg5_en5_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg5_en5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[5].en.q ),</pre>
<pre>    .qs     (mp_region_cfg5_en5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg5_rd_en5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg5_rd_en5_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg5_rd_en5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[5].rd_en.q ),</pre>
<pre>    .qs     (mp_region_cfg5_rd_en5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg5_prog_en5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg5_prog_en5_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg5_prog_en5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[5].prog_en.q ),</pre>
<pre>    .qs     (mp_region_cfg5_prog_en5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg5_erase_en5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg5_erase_en5_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg5_erase_en5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[5].erase_en.q ),</pre>
<pre>    .qs     (mp_region_cfg5_erase_en5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg5_base5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg5_base5_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg5_base5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[5].base.q ),</pre>
<pre>    .qs     (mp_region_cfg5_base5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg5_size5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg5_size5_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg5_size5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[5].size.q ),</pre>
<pre>    .qs     (mp_region_cfg5_size5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg6_en6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg6_en6_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg6_en6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[6].en.q ),</pre>
<pre>    .qs     (mp_region_cfg6_en6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg6_rd_en6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg6_rd_en6_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg6_rd_en6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[6].rd_en.q ),</pre>
<pre>    .qs     (mp_region_cfg6_rd_en6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg6_prog_en6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg6_prog_en6_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg6_prog_en6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[6].prog_en.q ),</pre>
<pre>    .qs     (mp_region_cfg6_prog_en6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg6_erase_en6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg6_erase_en6_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg6_erase_en6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[6].erase_en.q ),</pre>
<pre>    .qs     (mp_region_cfg6_erase_en6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg6_base6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg6_base6_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg6_base6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[6].base.q ),</pre>
<pre>    .qs     (mp_region_cfg6_base6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg6_size6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg6_size6_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg6_size6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[6].size.q ),</pre>
<pre>    .qs     (mp_region_cfg6_size6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg7_en7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg7_en7_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg7_en7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[7].en.q ),</pre>
<pre>    .qs     (mp_region_cfg7_en7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg7_rd_en7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg7_rd_en7_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg7_rd_en7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[7].rd_en.q ),</pre>
<pre>    .qs     (mp_region_cfg7_rd_en7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg7_prog_en7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg7_prog_en7_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg7_prog_en7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[7].prog_en.q ),</pre>
<pre>    .qs     (mp_region_cfg7_prog_en7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg7_erase_en7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg7_erase_en7_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg7_erase_en7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[7].erase_en.q ),</pre>
<pre>    .qs     (mp_region_cfg7_erase_en7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg7_base7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg7_base7_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg7_base7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[7].base.q ),</pre>
<pre>    .qs     (mp_region_cfg7_base7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (9),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (9'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_region_cfg7_size7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_region_cfg7_size7_we & region_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_region_cfg7_size7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_region_cfg[7].size.q ),</pre>
<pre>    .qs     (mp_region_cfg7_size7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_default_region_rd_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (default_region_rd_en_we),</pre>
<pre>    .wd     (default_region_rd_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.default_region.rd_en.q ),</pre>
<pre>    .qs     (default_region_rd_en_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_default_region_prog_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (default_region_prog_en_we),</pre>
<pre>    .wd     (default_region_prog_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.default_region.prog_en.q ),</pre>
<pre>    .qs     (default_region_prog_en_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_default_region_erase_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (default_region_erase_en_we),</pre>
<pre>    .wd     (default_region_erase_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.default_region.erase_en.q ),</pre>
<pre>    .qs     (default_region_erase_en_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W0C"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_bank_cfg_regwen (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (bank_cfg_regwen_we),</pre>
<pre>    .wd     (bank_cfg_regwen_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (bank_cfg_regwen_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_bank_cfg_erase_en0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_bank_cfg_erase_en0_we & bank_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_bank_cfg_erase_en0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_bank_cfg[0].q ),</pre>
<pre>    .qs     (mp_bank_cfg_erase_en0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_mp_bank_cfg_erase_en1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (mp_bank_cfg_erase_en1_we & bank_cfg_regwen_qs),</pre>
<pre>    .wd     (mp_bank_cfg_erase_en1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.mp_bank_cfg[1].q ),</pre>
<pre>    .qs     (mp_bank_cfg_erase_en1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_op_status_done (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (op_status_done_we),</pre>
<pre>    .wd     (op_status_done_wd),</pre>
<pre>    .de     (hw2reg.op_status.done.de),</pre>
<pre>    .d      (hw2reg.op_status.done.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (op_status_done_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_op_status_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (op_status_err_we),</pre>
<pre>    .wd     (op_status_err_wd),</pre>
<pre>    .de     (hw2reg.op_status.err.de),</pre>
<pre>    .d      (hw2reg.op_status.err.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (op_status_err_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_rd_full (</pre>
<pre>    .re     (status_rd_full_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.rd_full.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_rd_full_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_rd_empty (</pre>
<pre>    .re     (status_rd_empty_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.rd_empty.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_rd_empty_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_prog_full (</pre>
<pre>    .re     (status_prog_full_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.prog_full.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_prog_full_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_prog_empty (</pre>
<pre>    .re     (status_prog_empty_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.prog_empty.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_prog_empty_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_init_wip (</pre>
<pre>    .re     (status_init_wip_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.init_wip.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_init_wip_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (9)</pre>
<pre style="background-color: #FF0000;">  ) u_status_error_page (</pre>
<pre>    .re     (status_error_page_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.error_page.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_error_page_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_error_bank (</pre>
<pre>    .re     (status_error_bank_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.error_bank.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_error_bank_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_scratch (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (scratch_we),</pre>
<pre>    .wd     (scratch_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.scratch.q ),</pre>
<pre>    .qs     (scratch_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'hf)</pre>
<pre style="background-color: #FF0000;">  ) u_fifo_lvl_prog (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (fifo_lvl_prog_we),</pre>
<pre>    .wd     (fifo_lvl_prog_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.fifo_lvl.prog.q ),</pre>
<pre>    .qs     (fifo_lvl_prog_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'hf)</pre>
<pre style="background-color: #FF0000;">  ) u_fifo_lvl_rd (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (fifo_lvl_rd_we),</pre>
<pre>    .wd     (fifo_lvl_rd_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.fifo_lvl.rd.q ),</pre>
<pre>    .qs     (fifo_lvl_rd_qs)</pre>
<pre>  logic [20:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[ 0] = (reg_addr == FLASH_CTRL_INTR_STATE_OFFSET);</pre>
<pre>    addr_hit[ 1] = (reg_addr == FLASH_CTRL_INTR_ENABLE_OFFSET);</pre>
<pre>    addr_hit[ 2] = (reg_addr == FLASH_CTRL_INTR_TEST_OFFSET);</pre>
<pre>    addr_hit[ 3] = (reg_addr == FLASH_CTRL_CONTROL_OFFSET);</pre>
<pre>    addr_hit[ 4] = (reg_addr == FLASH_CTRL_ADDR_OFFSET);</pre>
<pre>    addr_hit[ 5] = (reg_addr == FLASH_CTRL_REGION_CFG_REGWEN_OFFSET);</pre>
<pre>    addr_hit[ 6] = (reg_addr == FLASH_CTRL_MP_REGION_CFG0_OFFSET);</pre>
<pre>    addr_hit[ 7] = (reg_addr == FLASH_CTRL_MP_REGION_CFG1_OFFSET);</pre>
<pre>    addr_hit[ 8] = (reg_addr == FLASH_CTRL_MP_REGION_CFG2_OFFSET);</pre>
<pre>    addr_hit[ 9] = (reg_addr == FLASH_CTRL_MP_REGION_CFG3_OFFSET);</pre>
<pre>    addr_hit[10] = (reg_addr == FLASH_CTRL_MP_REGION_CFG4_OFFSET);</pre>
<pre>    addr_hit[11] = (reg_addr == FLASH_CTRL_MP_REGION_CFG5_OFFSET);</pre>
<pre>    addr_hit[12] = (reg_addr == FLASH_CTRL_MP_REGION_CFG6_OFFSET);</pre>
<pre>    addr_hit[13] = (reg_addr == FLASH_CTRL_MP_REGION_CFG7_OFFSET);</pre>
<pre>    addr_hit[14] = (reg_addr == FLASH_CTRL_DEFAULT_REGION_OFFSET);</pre>
<pre>    addr_hit[15] = (reg_addr == FLASH_CTRL_BANK_CFG_REGWEN_OFFSET);</pre>
<pre>    addr_hit[16] = (reg_addr == FLASH_CTRL_MP_BANK_CFG_OFFSET);</pre>
<pre>    addr_hit[17] = (reg_addr == FLASH_CTRL_OP_STATUS_OFFSET);</pre>
<pre>    addr_hit[18] = (reg_addr == FLASH_CTRL_STATUS_OFFSET);</pre>
<pre>    addr_hit[19] = (reg_addr == FLASH_CTRL_SCRATCH_OFFSET);</pre>
<pre>    addr_hit[20] = (reg_addr == FLASH_CTRL_FIFO_LVL_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[ 0] && reg_we && (FLASH_CTRL_PERMIT[ 0] != (FLASH_CTRL_PERMIT[ 0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 1] && reg_we && (FLASH_CTRL_PERMIT[ 1] != (FLASH_CTRL_PERMIT[ 1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 2] && reg_we && (FLASH_CTRL_PERMIT[ 2] != (FLASH_CTRL_PERMIT[ 2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 3] && reg_we && (FLASH_CTRL_PERMIT[ 3] != (FLASH_CTRL_PERMIT[ 3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 4] && reg_we && (FLASH_CTRL_PERMIT[ 4] != (FLASH_CTRL_PERMIT[ 4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 5] && reg_we && (FLASH_CTRL_PERMIT[ 5] != (FLASH_CTRL_PERMIT[ 5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 6] && reg_we && (FLASH_CTRL_PERMIT[ 6] != (FLASH_CTRL_PERMIT[ 6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 7] && reg_we && (FLASH_CTRL_PERMIT[ 7] != (FLASH_CTRL_PERMIT[ 7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 8] && reg_we && (FLASH_CTRL_PERMIT[ 8] != (FLASH_CTRL_PERMIT[ 8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 9] && reg_we && (FLASH_CTRL_PERMIT[ 9] != (FLASH_CTRL_PERMIT[ 9] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[10] && reg_we && (FLASH_CTRL_PERMIT[10] != (FLASH_CTRL_PERMIT[10] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[11] && reg_we && (FLASH_CTRL_PERMIT[11] != (FLASH_CTRL_PERMIT[11] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[12] && reg_we && (FLASH_CTRL_PERMIT[12] != (FLASH_CTRL_PERMIT[12] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[13] && reg_we && (FLASH_CTRL_PERMIT[13] != (FLASH_CTRL_PERMIT[13] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[14] && reg_we && (FLASH_CTRL_PERMIT[14] != (FLASH_CTRL_PERMIT[14] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[15] && reg_we && (FLASH_CTRL_PERMIT[15] != (FLASH_CTRL_PERMIT[15] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[16] && reg_we && (FLASH_CTRL_PERMIT[16] != (FLASH_CTRL_PERMIT[16] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[17] && reg_we && (FLASH_CTRL_PERMIT[17] != (FLASH_CTRL_PERMIT[17] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[18] && reg_we && (FLASH_CTRL_PERMIT[18] != (FLASH_CTRL_PERMIT[18] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[19] && reg_we && (FLASH_CTRL_PERMIT[19] != (FLASH_CTRL_PERMIT[19] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[20] && reg_we && (FLASH_CTRL_PERMIT[20] != (FLASH_CTRL_PERMIT[20] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign intr_state_prog_empty_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_prog_empty_wd = reg_wdata[0];</pre>
<pre>  assign intr_state_prog_lvl_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_prog_lvl_wd = reg_wdata[1];</pre>
<pre>  assign intr_state_rd_full_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rd_full_wd = reg_wdata[2];</pre>
<pre>  assign intr_state_rd_lvl_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rd_lvl_wd = reg_wdata[3];</pre>
<pre>  assign intr_state_op_done_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_op_done_wd = reg_wdata[4];</pre>
<pre>  assign intr_state_op_error_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_op_error_wd = reg_wdata[5];</pre>
<pre>  assign intr_enable_prog_empty_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_prog_empty_wd = reg_wdata[0];</pre>
<pre>  assign intr_enable_prog_lvl_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_prog_lvl_wd = reg_wdata[1];</pre>
<pre>  assign intr_enable_rd_full_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rd_full_wd = reg_wdata[2];</pre>
<pre>  assign intr_enable_rd_lvl_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rd_lvl_wd = reg_wdata[3];</pre>
<pre>  assign intr_enable_op_done_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_op_done_wd = reg_wdata[4];</pre>
<pre>  assign intr_enable_op_error_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_op_error_wd = reg_wdata[5];</pre>
<pre>  assign intr_test_prog_empty_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_prog_empty_wd = reg_wdata[0];</pre>
<pre>  assign intr_test_prog_lvl_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_prog_lvl_wd = reg_wdata[1];</pre>
<pre>  assign intr_test_rd_full_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rd_full_wd = reg_wdata[2];</pre>
<pre>  assign intr_test_rd_lvl_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rd_lvl_wd = reg_wdata[3];</pre>
<pre>  assign intr_test_op_done_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_op_done_wd = reg_wdata[4];</pre>
<pre>  assign intr_test_op_error_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_op_error_wd = reg_wdata[5];</pre>
<pre>  assign control_start_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign control_start_wd = reg_wdata[0];</pre>
<pre>  assign control_op_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign control_op_wd = reg_wdata[5:4];</pre>
<pre>  assign control_erase_sel_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign control_erase_sel_wd = reg_wdata[6];</pre>
<pre>  assign control_fifo_rst_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign control_fifo_rst_wd = reg_wdata[7];</pre>
<pre>  assign control_num_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign control_num_wd = reg_wdata[27:16];</pre>
<pre>  assign addr_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign addr_wd = reg_wdata[31:0];</pre>
<pre>  assign region_cfg_regwen_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign region_cfg_regwen_wd = reg_wdata[0];</pre>
<pre>  assign mp_region_cfg0_en0_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg0_en0_wd = reg_wdata[0];</pre>
<pre>  assign mp_region_cfg0_rd_en0_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg0_rd_en0_wd = reg_wdata[1];</pre>
<pre>  assign mp_region_cfg0_prog_en0_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg0_prog_en0_wd = reg_wdata[2];</pre>
<pre>  assign mp_region_cfg0_erase_en0_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg0_erase_en0_wd = reg_wdata[3];</pre>
<pre>  assign mp_region_cfg0_base0_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg0_base0_wd = reg_wdata[12:4];</pre>
<pre>  assign mp_region_cfg0_size0_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg0_size0_wd = reg_wdata[24:16];</pre>
<pre>  assign mp_region_cfg1_en1_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg1_en1_wd = reg_wdata[0];</pre>
<pre>  assign mp_region_cfg1_rd_en1_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg1_rd_en1_wd = reg_wdata[1];</pre>
<pre>  assign mp_region_cfg1_prog_en1_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg1_prog_en1_wd = reg_wdata[2];</pre>
<pre>  assign mp_region_cfg1_erase_en1_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg1_erase_en1_wd = reg_wdata[3];</pre>
<pre>  assign mp_region_cfg1_base1_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg1_base1_wd = reg_wdata[12:4];</pre>
<pre>  assign mp_region_cfg1_size1_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg1_size1_wd = reg_wdata[24:16];</pre>
<pre>  assign mp_region_cfg2_en2_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg2_en2_wd = reg_wdata[0];</pre>
<pre>  assign mp_region_cfg2_rd_en2_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg2_rd_en2_wd = reg_wdata[1];</pre>
<pre>  assign mp_region_cfg2_prog_en2_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg2_prog_en2_wd = reg_wdata[2];</pre>
<pre>  assign mp_region_cfg2_erase_en2_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg2_erase_en2_wd = reg_wdata[3];</pre>
<pre>  assign mp_region_cfg2_base2_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg2_base2_wd = reg_wdata[12:4];</pre>
<pre>  assign mp_region_cfg2_size2_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg2_size2_wd = reg_wdata[24:16];</pre>
<pre>  assign mp_region_cfg3_en3_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg3_en3_wd = reg_wdata[0];</pre>
<pre>  assign mp_region_cfg3_rd_en3_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg3_rd_en3_wd = reg_wdata[1];</pre>
<pre>  assign mp_region_cfg3_prog_en3_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg3_prog_en3_wd = reg_wdata[2];</pre>
<pre>  assign mp_region_cfg3_erase_en3_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg3_erase_en3_wd = reg_wdata[3];</pre>
<pre>  assign mp_region_cfg3_base3_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg3_base3_wd = reg_wdata[12:4];</pre>
<pre>  assign mp_region_cfg3_size3_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg3_size3_wd = reg_wdata[24:16];</pre>
<pre>  assign mp_region_cfg4_en4_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg4_en4_wd = reg_wdata[0];</pre>
<pre>  assign mp_region_cfg4_rd_en4_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg4_rd_en4_wd = reg_wdata[1];</pre>
<pre>  assign mp_region_cfg4_prog_en4_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg4_prog_en4_wd = reg_wdata[2];</pre>
<pre>  assign mp_region_cfg4_erase_en4_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg4_erase_en4_wd = reg_wdata[3];</pre>
<pre>  assign mp_region_cfg4_base4_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg4_base4_wd = reg_wdata[12:4];</pre>
<pre>  assign mp_region_cfg4_size4_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg4_size4_wd = reg_wdata[24:16];</pre>
<pre>  assign mp_region_cfg5_en5_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg5_en5_wd = reg_wdata[0];</pre>
<pre>  assign mp_region_cfg5_rd_en5_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg5_rd_en5_wd = reg_wdata[1];</pre>
<pre>  assign mp_region_cfg5_prog_en5_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg5_prog_en5_wd = reg_wdata[2];</pre>
<pre>  assign mp_region_cfg5_erase_en5_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg5_erase_en5_wd = reg_wdata[3];</pre>
<pre>  assign mp_region_cfg5_base5_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg5_base5_wd = reg_wdata[12:4];</pre>
<pre>  assign mp_region_cfg5_size5_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg5_size5_wd = reg_wdata[24:16];</pre>
<pre>  assign mp_region_cfg6_en6_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg6_en6_wd = reg_wdata[0];</pre>
<pre>  assign mp_region_cfg6_rd_en6_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg6_rd_en6_wd = reg_wdata[1];</pre>
<pre>  assign mp_region_cfg6_prog_en6_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg6_prog_en6_wd = reg_wdata[2];</pre>
<pre>  assign mp_region_cfg6_erase_en6_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg6_erase_en6_wd = reg_wdata[3];</pre>
<pre>  assign mp_region_cfg6_base6_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg6_base6_wd = reg_wdata[12:4];</pre>
<pre>  assign mp_region_cfg6_size6_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg6_size6_wd = reg_wdata[24:16];</pre>
<pre>  assign mp_region_cfg7_en7_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg7_en7_wd = reg_wdata[0];</pre>
<pre>  assign mp_region_cfg7_rd_en7_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg7_rd_en7_wd = reg_wdata[1];</pre>
<pre>  assign mp_region_cfg7_prog_en7_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg7_prog_en7_wd = reg_wdata[2];</pre>
<pre>  assign mp_region_cfg7_erase_en7_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg7_erase_en7_wd = reg_wdata[3];</pre>
<pre>  assign mp_region_cfg7_base7_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg7_base7_wd = reg_wdata[12:4];</pre>
<pre>  assign mp_region_cfg7_size7_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign mp_region_cfg7_size7_wd = reg_wdata[24:16];</pre>
<pre>  assign default_region_rd_en_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign default_region_rd_en_wd = reg_wdata[0];</pre>
<pre>  assign default_region_prog_en_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign default_region_prog_en_wd = reg_wdata[1];</pre>
<pre>  assign default_region_erase_en_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign default_region_erase_en_wd = reg_wdata[2];</pre>
<pre>  assign bank_cfg_regwen_we = addr_hit[15] & reg_we & ~wr_err;</pre>
<pre>  assign bank_cfg_regwen_wd = reg_wdata[0];</pre>
<pre>  assign mp_bank_cfg_erase_en0_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign mp_bank_cfg_erase_en0_wd = reg_wdata[0];</pre>
<pre>  assign mp_bank_cfg_erase_en1_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign mp_bank_cfg_erase_en1_wd = reg_wdata[1];</pre>
<pre>  assign op_status_done_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign op_status_done_wd = reg_wdata[0];</pre>
<pre>  assign op_status_err_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign op_status_err_wd = reg_wdata[1];</pre>
<pre>  assign status_rd_full_re = addr_hit[18] && reg_re;</pre>
<pre>  assign status_rd_empty_re = addr_hit[18] && reg_re;</pre>
<pre>  assign status_prog_full_re = addr_hit[18] && reg_re;</pre>
<pre>  assign status_prog_empty_re = addr_hit[18] && reg_re;</pre>
<pre>  assign status_init_wip_re = addr_hit[18] && reg_re;</pre>
<pre>  assign status_error_page_re = addr_hit[18] && reg_re;</pre>
<pre>  assign status_error_bank_re = addr_hit[18] && reg_re;</pre>
<pre>  assign scratch_we = addr_hit[19] & reg_we & ~wr_err;</pre>
<pre>  assign scratch_wd = reg_wdata[31:0];</pre>
<pre>  assign fifo_lvl_prog_we = addr_hit[20] & reg_we & ~wr_err;</pre>
<pre>  assign fifo_lvl_prog_wd = reg_wdata[4:0];</pre>
<pre>  assign fifo_lvl_rd_we = addr_hit[20] & reg_we & ~wr_err;</pre>
<pre>  assign fifo_lvl_rd_wd = reg_wdata[12:8];</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[0] = intr_state_prog_empty_qs;</pre>
<pre>        reg_rdata_next[1] = intr_state_prog_lvl_qs;</pre>
<pre>        reg_rdata_next[2] = intr_state_rd_full_qs;</pre>
<pre>        reg_rdata_next[3] = intr_state_rd_lvl_qs;</pre>
<pre>        reg_rdata_next[4] = intr_state_op_done_qs;</pre>
<pre>        reg_rdata_next[5] = intr_state_op_error_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[0] = intr_enable_prog_empty_qs;</pre>
<pre>        reg_rdata_next[1] = intr_enable_prog_lvl_qs;</pre>
<pre>        reg_rdata_next[2] = intr_enable_rd_full_qs;</pre>
<pre>        reg_rdata_next[3] = intr_enable_rd_lvl_qs;</pre>
<pre>        reg_rdata_next[4] = intr_enable_op_done_qs;</pre>
<pre>        reg_rdata_next[5] = intr_enable_op_error_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>        reg_rdata_next[2] = '0;</pre>
<pre>        reg_rdata_next[3] = '0;</pre>
<pre>        reg_rdata_next[4] = '0;</pre>
<pre>        reg_rdata_next[5] = '0;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[0] = control_start_qs;</pre>
<pre>        reg_rdata_next[5:4] = control_op_qs;</pre>
<pre>        reg_rdata_next[6] = control_erase_sel_qs;</pre>
<pre>        reg_rdata_next[7] = control_fifo_rst_qs;</pre>
<pre>        reg_rdata_next[27:16] = control_num_qs;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[31:0] = addr_qs;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[0] = region_cfg_regwen_qs;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[0] = mp_region_cfg0_en0_qs;</pre>
<pre>        reg_rdata_next[1] = mp_region_cfg0_rd_en0_qs;</pre>
<pre>        reg_rdata_next[2] = mp_region_cfg0_prog_en0_qs;</pre>
<pre>        reg_rdata_next[3] = mp_region_cfg0_erase_en0_qs;</pre>
<pre>        reg_rdata_next[12:4] = mp_region_cfg0_base0_qs;</pre>
<pre>        reg_rdata_next[24:16] = mp_region_cfg0_size0_qs;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[0] = mp_region_cfg1_en1_qs;</pre>
<pre>        reg_rdata_next[1] = mp_region_cfg1_rd_en1_qs;</pre>
<pre>        reg_rdata_next[2] = mp_region_cfg1_prog_en1_qs;</pre>
<pre>        reg_rdata_next[3] = mp_region_cfg1_erase_en1_qs;</pre>
<pre>        reg_rdata_next[12:4] = mp_region_cfg1_base1_qs;</pre>
<pre>        reg_rdata_next[24:16] = mp_region_cfg1_size1_qs;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[0] = mp_region_cfg2_en2_qs;</pre>
<pre>        reg_rdata_next[1] = mp_region_cfg2_rd_en2_qs;</pre>
<pre>        reg_rdata_next[2] = mp_region_cfg2_prog_en2_qs;</pre>
<pre>        reg_rdata_next[3] = mp_region_cfg2_erase_en2_qs;</pre>
<pre>        reg_rdata_next[12:4] = mp_region_cfg2_base2_qs;</pre>
<pre>        reg_rdata_next[24:16] = mp_region_cfg2_size2_qs;</pre>
<pre>      addr_hit[9]: begin</pre>
<pre>        reg_rdata_next[0] = mp_region_cfg3_en3_qs;</pre>
<pre>        reg_rdata_next[1] = mp_region_cfg3_rd_en3_qs;</pre>
<pre>        reg_rdata_next[2] = mp_region_cfg3_prog_en3_qs;</pre>
<pre>        reg_rdata_next[3] = mp_region_cfg3_erase_en3_qs;</pre>
<pre>        reg_rdata_next[12:4] = mp_region_cfg3_base3_qs;</pre>
<pre>        reg_rdata_next[24:16] = mp_region_cfg3_size3_qs;</pre>
<pre>      addr_hit[10]: begin</pre>
<pre>        reg_rdata_next[0] = mp_region_cfg4_en4_qs;</pre>
<pre>        reg_rdata_next[1] = mp_region_cfg4_rd_en4_qs;</pre>
<pre>        reg_rdata_next[2] = mp_region_cfg4_prog_en4_qs;</pre>
<pre>        reg_rdata_next[3] = mp_region_cfg4_erase_en4_qs;</pre>
<pre>        reg_rdata_next[12:4] = mp_region_cfg4_base4_qs;</pre>
<pre>        reg_rdata_next[24:16] = mp_region_cfg4_size4_qs;</pre>
<pre>      addr_hit[11]: begin</pre>
<pre>        reg_rdata_next[0] = mp_region_cfg5_en5_qs;</pre>
<pre>        reg_rdata_next[1] = mp_region_cfg5_rd_en5_qs;</pre>
<pre>        reg_rdata_next[2] = mp_region_cfg5_prog_en5_qs;</pre>
<pre>        reg_rdata_next[3] = mp_region_cfg5_erase_en5_qs;</pre>
<pre>        reg_rdata_next[12:4] = mp_region_cfg5_base5_qs;</pre>
<pre>        reg_rdata_next[24:16] = mp_region_cfg5_size5_qs;</pre>
<pre>      addr_hit[12]: begin</pre>
<pre>        reg_rdata_next[0] = mp_region_cfg6_en6_qs;</pre>
<pre>        reg_rdata_next[1] = mp_region_cfg6_rd_en6_qs;</pre>
<pre>        reg_rdata_next[2] = mp_region_cfg6_prog_en6_qs;</pre>
<pre>        reg_rdata_next[3] = mp_region_cfg6_erase_en6_qs;</pre>
<pre>        reg_rdata_next[12:4] = mp_region_cfg6_base6_qs;</pre>
<pre>        reg_rdata_next[24:16] = mp_region_cfg6_size6_qs;</pre>
<pre>      addr_hit[13]: begin</pre>
<pre>        reg_rdata_next[0] = mp_region_cfg7_en7_qs;</pre>
<pre>        reg_rdata_next[1] = mp_region_cfg7_rd_en7_qs;</pre>
<pre>        reg_rdata_next[2] = mp_region_cfg7_prog_en7_qs;</pre>
<pre>        reg_rdata_next[3] = mp_region_cfg7_erase_en7_qs;</pre>
<pre>        reg_rdata_next[12:4] = mp_region_cfg7_base7_qs;</pre>
<pre>        reg_rdata_next[24:16] = mp_region_cfg7_size7_qs;</pre>
<pre>      addr_hit[14]: begin</pre>
<pre>        reg_rdata_next[0] = default_region_rd_en_qs;</pre>
<pre>        reg_rdata_next[1] = default_region_prog_en_qs;</pre>
<pre>        reg_rdata_next[2] = default_region_erase_en_qs;</pre>
<pre>      addr_hit[15]: begin</pre>
<pre>        reg_rdata_next[0] = bank_cfg_regwen_qs;</pre>
<pre>      addr_hit[16]: begin</pre>
<pre>        reg_rdata_next[0] = mp_bank_cfg_erase_en0_qs;</pre>
<pre>        reg_rdata_next[1] = mp_bank_cfg_erase_en1_qs;</pre>
<pre>      addr_hit[17]: begin</pre>
<pre>        reg_rdata_next[0] = op_status_done_qs;</pre>
<pre>        reg_rdata_next[1] = op_status_err_qs;</pre>
<pre>      addr_hit[18]: begin</pre>
<pre>        reg_rdata_next[0] = status_rd_full_qs;</pre>
<pre>        reg_rdata_next[1] = status_rd_empty_qs;</pre>
<pre>        reg_rdata_next[2] = status_prog_full_qs;</pre>
<pre>        reg_rdata_next[3] = status_prog_empty_qs;</pre>
<pre>        reg_rdata_next[4] = status_init_wip_qs;</pre>
<pre>        reg_rdata_next[16:8] = status_error_page_qs;</pre>
<pre>        reg_rdata_next[17] = status_error_bank_qs;</pre>
<pre>      addr_hit[19]: begin</pre>
<pre>        reg_rdata_next[31:0] = scratch_qs;</pre>
<pre>      addr_hit[20]: begin</pre>
<pre>        reg_rdata_next[4:0] = fifo_lvl_prog_qs;</pre>
<pre>        reg_rdata_next[12:8] = fifo_lvl_rd_qs;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/ip/flash_ctrl/rtl/flash_prog_ctrl.sv</h3>
<pre>module flash_prog_ctrl #(</pre>
<pre>  parameter int AddrW = 10,</pre>
<pre>  parameter int DataW = 32</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input                    op_start_i,</pre>
<pre>  input  [11:0]            op_num_words_i,</pre>
<pre>  output logic             op_done_o,</pre>
<pre>  output logic             op_err_o,</pre>
<pre>  input [AddrW-1:0]        op_addr_i,</pre>
<pre>  input                    data_rdy_i,</pre>
<pre>  input  [DataW-1:0]       data_i,</pre>
<pre>  output logic             data_rd_o,</pre>
<pre>  output logic             flash_req_o,</pre>
<pre>  output logic [AddrW-1:0] flash_addr_o,</pre>
<pre>  output logic             flash_ovfl_o,</pre>
<pre>  output logic [DataW-1:0] flash_data_o,</pre>
<pre>  input                    flash_done_i,</pre>
<pre>  input                    flash_error_i</pre>
<pre>  typedef enum logic {</pre>
<pre>    StNorm  = 'h0,</pre>
<pre>    StErr   = 'h1</pre>
<pre>  } state_e;</pre>
<pre>  state_e st, st_nxt;</pre>
<pre>  logic [11:0] cnt, cnt_nxt;</pre>
<pre>  logic cnt_hit;</pre>
<pre>  logic [AddrW:0] int_addr;</pre>
<pre>  logic txn_done;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      cnt <= '0;</pre>
<pre>      st <= StNorm;</pre>
<pre>    end else begin</pre>
<pre>      cnt <= cnt_nxt;</pre>
<pre>      st <= st_nxt;</pre>
<pre>  assign txn_done = flash_req_o && flash_done_i;</pre>
<pre>  assign cnt_hit = (cnt == op_num_words_i);</pre>
<pre>  always_comb begin</pre>
<pre>    st_nxt = st;</pre>
<pre>    cnt_nxt = cnt;</pre>
<pre>    flash_req_o = 1'b0;</pre>
<pre>    data_rd_o = 1'b0;</pre>
<pre>    op_done_o = 1'b0;</pre>
<pre>    op_err_o = 1'b0;</pre>
<pre>    unique case (st)</pre>
<pre>      StNorm: begin</pre>
<pre>        flash_req_o = op_start_i & data_rdy_i;</pre>
<pre>        if(txn_done && cnt_hit) begin</pre>
<pre>          cnt_nxt = '0;</pre>
<pre>          data_rd_o = 1'b1;</pre>
<pre>          op_done_o = 1'b1;</pre>
<pre>          op_err_o = flash_error_i;</pre>
<pre>        end else if(txn_done) begin</pre>
<pre>          cnt_nxt = cnt + 1'b1;</pre>
<pre>          data_rd_o = 1'b1;</pre>
<pre>          st_nxt = flash_error_i ? StErr : StNorm;</pre>
<pre>      StErr: begin</pre>
<pre>        data_rd_o = data_rdy_i;</pre>
<pre>        if (data_rdy_i && cnt_hit) begin</pre>
<pre>          st_nxt = StNorm;</pre>
<pre>          cnt_nxt = '0;</pre>
<pre>          op_done_o = 1'b1;</pre>
<pre>          op_err_o = 1'b1;</pre>
<pre>        end else if (data_rdy_i) begin</pre>
<pre>          cnt_nxt = cnt + 1'b1;</pre>
<pre>      default:;</pre>
<pre>  assign flash_data_o = data_i;</pre>
<pre>  assign int_addr = op_addr_i + AddrW'(cnt);</pre>
<pre>  assign flash_addr_o = int_addr[0 +: AddrW];</pre>
<pre>  assign flash_ovfl_o = int_addr[AddrW];</pre>
<h3>hw/ip/flash_ctrl/rtl/flash_erase_ctrl.sv</h3>
<pre>module flash_erase_ctrl #(</pre>
<pre>  parameter int AddrW = 10,</pre>
<pre>  parameter int WordsPerPage = 256,</pre>
<pre>  parameter int PagesPerBank = 256,</pre>
<pre>  parameter int EraseBitWidth = 1</pre>
<pre>  input                     op_start_i,</pre>
<pre>  input [EraseBitWidth-1:0] op_type_i,</pre>
<pre>  input [AddrW-1:0]         op_addr_i,</pre>
<pre>  output logic              op_done_o,</pre>
<pre>  output logic              op_err_o,</pre>
<pre>  output logic             flash_req_o,</pre>
<pre>  output logic [AddrW-1:0] flash_addr_o,</pre>
<pre>  output logic [EraseBitWidth-1:0] flash_op_o,</pre>
<pre>  input                    flash_done_i,</pre>
<pre>  input                    flash_error_i</pre>
<pre>  localparam int WordsBitWidth = $clog2(WordsPerPage);</pre>
<pre>  localparam int PagesBitWidth = $clog2(PagesPerBank);</pre>
<pre>  localparam logic[AddrW-1:0] PageAddrMask = ~(('h1 << WordsBitWidth) - 1'b1);</pre>
<pre>  localparam logic[AddrW-1:0] BankAddrMask = ~(('h1 << (PagesBitWidth + WordsBitWidth)) - 1'b1);</pre>
<pre>  assign op_done_o = flash_req_o & flash_done_i;</pre>
<pre>  assign op_err_o = flash_req_o & flash_error_i;</pre>
<pre>  assign flash_req_o = op_start_i;</pre>
<pre>  assign flash_op_o = op_type_i;</pre>
<pre>  assign flash_addr_o = (op_type_i == PageErase) ?</pre>
<pre>                        op_addr_i & PageAddrMask :</pre>
<pre>                        op_addr_i & BankAddrMask;</pre>
<pre>  logic [WordsBitWidth-1:0] unused_addr_i;</pre>
<pre>  assign unused_addr_i = op_addr_i[WordsBitWidth-1:0];</pre>
<h3>hw/ip/flash_ctrl/rtl/flash_ctrl_reg_pkg.sv</h3>
<pre>package flash_ctrl_reg_pkg;</pre>
<pre>  parameter int NumBanks = 2;</pre>
<pre>  parameter int NumRegions = 8;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } prog_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } prog_lvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rd_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rd_lvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } op_done;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } op_error;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } prog_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } prog_lvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rd_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rd_lvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } op_done;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } op_error;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_intr_enable_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } prog_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } prog_lvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rd_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rd_lvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } op_done;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } op_error;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_intr_test_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } start;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } op;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } erase_sel;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } fifo_rst;</pre>
<pre>    struct packed {</pre>
<pre>      logic [11:0] q;</pre>
<pre>    } num;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_control_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_addr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rd_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } prog_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } erase_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic [8:0]  q;</pre>
<pre>    } base;</pre>
<pre>    struct packed {</pre>
<pre>      logic [8:0]  q;</pre>
<pre>    } size;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_mp_region_cfg_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rd_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } prog_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } erase_en;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_default_region_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_mp_bank_cfg_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_scratch_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [4:0]  q;</pre>
<pre>    } prog;</pre>
<pre>    struct packed {</pre>
<pre>      logic [4:0]  q;</pre>
<pre>    } rd;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_fifo_lvl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } prog_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } prog_lvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rd_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rd_lvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } op_done;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } op_error;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_hw2reg_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } start;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_hw2reg_control_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } done;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } err;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_hw2reg_op_status_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } rd_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } rd_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } prog_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } prog_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } init_wip;</pre>
<pre>    struct packed {</pre>
<pre>      logic [8:0]  d;</pre>
<pre>    } error_page;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } error_bank;</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_hw2reg_status_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    flash_ctrl_reg2hw_intr_state_reg_t intr_state; // [295:290]</pre>
<pre>    flash_ctrl_reg2hw_intr_enable_reg_t intr_enable; // [289:284]</pre>
<pre>    flash_ctrl_reg2hw_intr_test_reg_t intr_test; // [283:272]</pre>
<pre>    flash_ctrl_reg2hw_control_reg_t control; // [271:255]</pre>
<pre>    flash_ctrl_reg2hw_addr_reg_t addr; // [254:223]</pre>
<pre>    flash_ctrl_reg2hw_mp_region_cfg_mreg_t [7:0] mp_region_cfg; // [222:47]</pre>
<pre>    flash_ctrl_reg2hw_default_region_reg_t default_region; // [46:44]</pre>
<pre>    flash_ctrl_reg2hw_mp_bank_cfg_mreg_t [1:0] mp_bank_cfg; // [43:42]</pre>
<pre>    flash_ctrl_reg2hw_scratch_reg_t scratch; // [41:10]</pre>
<pre>    flash_ctrl_reg2hw_fifo_lvl_reg_t fifo_lvl; // [9:0]</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    flash_ctrl_hw2reg_intr_state_reg_t intr_state; // [32:27]</pre>
<pre>    flash_ctrl_hw2reg_control_reg_t control; // [26:10]</pre>
<pre>    flash_ctrl_hw2reg_op_status_reg_t op_status; // [9:10]</pre>
<pre>    flash_ctrl_hw2reg_status_reg_t status; // [9:10]</pre>
<pre style="background-color: #FF0000;">  } flash_ctrl_hw2reg_t;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_INTR_STATE_OFFSET = 7'h 0;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_INTR_ENABLE_OFFSET = 7'h 4;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_INTR_TEST_OFFSET = 7'h 8;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_CONTROL_OFFSET = 7'h c;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_ADDR_OFFSET = 7'h 10;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_REGION_CFG_REGWEN_OFFSET = 7'h 14;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_MP_REGION_CFG0_OFFSET = 7'h 18;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_MP_REGION_CFG1_OFFSET = 7'h 1c;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_MP_REGION_CFG2_OFFSET = 7'h 20;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_MP_REGION_CFG3_OFFSET = 7'h 24;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_MP_REGION_CFG4_OFFSET = 7'h 28;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_MP_REGION_CFG5_OFFSET = 7'h 2c;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_MP_REGION_CFG6_OFFSET = 7'h 30;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_MP_REGION_CFG7_OFFSET = 7'h 34;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_DEFAULT_REGION_OFFSET = 7'h 38;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_BANK_CFG_REGWEN_OFFSET = 7'h 3c;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_MP_BANK_CFG_OFFSET = 7'h 40;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_OP_STATUS_OFFSET = 7'h 44;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_STATUS_OFFSET = 7'h 48;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_SCRATCH_OFFSET = 7'h 4c;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_FIFO_LVL_OFFSET = 7'h 50;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_PROG_FIFO_OFFSET = 7'h 54;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_PROG_FIFO_SIZE   = 7'h 4;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_RD_FIFO_OFFSET = 7'h 58;</pre>
<pre>  parameter logic [6:0] FLASH_CTRL_RD_FIFO_SIZE   = 7'h 4;</pre>
<pre>  typedef enum int {</pre>
<pre>    FLASH_CTRL_INTR_STATE,</pre>
<pre>    FLASH_CTRL_INTR_ENABLE,</pre>
<pre>    FLASH_CTRL_INTR_TEST,</pre>
<pre>    FLASH_CTRL_CONTROL,</pre>
<pre>    FLASH_CTRL_ADDR,</pre>
<pre>    FLASH_CTRL_REGION_CFG_REGWEN,</pre>
<pre>    FLASH_CTRL_MP_REGION_CFG0,</pre>
<pre>    FLASH_CTRL_MP_REGION_CFG1,</pre>
<pre>    FLASH_CTRL_MP_REGION_CFG2,</pre>
<pre>    FLASH_CTRL_MP_REGION_CFG3,</pre>
<pre>    FLASH_CTRL_MP_REGION_CFG4,</pre>
<pre>    FLASH_CTRL_MP_REGION_CFG5,</pre>
<pre>    FLASH_CTRL_MP_REGION_CFG6,</pre>
<pre>    FLASH_CTRL_MP_REGION_CFG7,</pre>
<pre>    FLASH_CTRL_DEFAULT_REGION,</pre>
<pre>    FLASH_CTRL_BANK_CFG_REGWEN,</pre>
<pre>    FLASH_CTRL_MP_BANK_CFG,</pre>
<pre>    FLASH_CTRL_OP_STATUS,</pre>
<pre>    FLASH_CTRL_STATUS,</pre>
<pre>    FLASH_CTRL_SCRATCH,</pre>
<pre>    FLASH_CTRL_FIFO_LVL</pre>
<pre>  } flash_ctrl_id_e;</pre>
<pre>  parameter logic [3:0] FLASH_CTRL_PERMIT [21] = '{</pre>
<pre>    4'b 0001, // index[ 0] FLASH_CTRL_INTR_STATE</pre>
<pre>    4'b 0001, // index[ 1] FLASH_CTRL_INTR_ENABLE</pre>
<pre>    4'b 0001, // index[ 2] FLASH_CTRL_INTR_TEST</pre>
<pre>    4'b 1111, // index[ 3] FLASH_CTRL_CONTROL</pre>
<pre>    4'b 1111, // index[ 4] FLASH_CTRL_ADDR</pre>
<pre>    4'b 0001, // index[ 5] FLASH_CTRL_REGION_CFG_REGWEN</pre>
<pre>    4'b 1111, // index[ 6] FLASH_CTRL_MP_REGION_CFG0</pre>
<pre>    4'b 1111, // index[ 7] FLASH_CTRL_MP_REGION_CFG1</pre>
<pre>    4'b 1111, // index[ 8] FLASH_CTRL_MP_REGION_CFG2</pre>
<pre>    4'b 1111, // index[ 9] FLASH_CTRL_MP_REGION_CFG3</pre>
<pre>    4'b 1111, // index[10] FLASH_CTRL_MP_REGION_CFG4</pre>
<pre>    4'b 1111, // index[11] FLASH_CTRL_MP_REGION_CFG5</pre>
<pre>    4'b 1111, // index[12] FLASH_CTRL_MP_REGION_CFG6</pre>
<pre>    4'b 1111, // index[13] FLASH_CTRL_MP_REGION_CFG7</pre>
<pre>    4'b 0001, // index[14] FLASH_CTRL_DEFAULT_REGION</pre>
<pre>    4'b 0001, // index[15] FLASH_CTRL_BANK_CFG_REGWEN</pre>
<pre>    4'b 0001, // index[16] FLASH_CTRL_MP_BANK_CFG</pre>
<pre>    4'b 0001, // index[17] FLASH_CTRL_OP_STATUS</pre>
<pre>    4'b 0111, // index[18] FLASH_CTRL_STATUS</pre>
<pre>    4'b 1111, // index[19] FLASH_CTRL_SCRATCH</pre>
<pre>    4'b 0011  // index[20] FLASH_CTRL_FIFO_LVL</pre>
<h3>hw/ip/flash_ctrl/rtl/flash_rd_ctrl.sv</h3>
<pre>module flash_rd_ctrl #(</pre>
<pre>  parameter int AddrW = 10,</pre>
<pre>  parameter int DataW = 32</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input                    op_start_i,</pre>
<pre>  input  [11:0]            op_num_words_i,</pre>
<pre>  output logic             op_done_o,</pre>
<pre>  output logic             op_err_o,</pre>
<pre>  input [AddrW-1:0]        op_addr_i,</pre>
<pre>  input                    data_rdy_i,</pre>
<pre>  output logic [DataW-1:0] data_o,</pre>
<pre>  output logic             data_wr_o,</pre>
<pre>  output logic             flash_req_o,</pre>
<pre>  output logic [AddrW-1:0] flash_addr_o,</pre>
<pre>  output logic             flash_ovfl_o,</pre>
<pre>  input [DataW-1:0]        flash_data_i,</pre>
<pre>  input                    flash_done_i,</pre>
<pre>  input                    flash_error_i</pre>
<pre>  typedef enum logic {</pre>
<pre>    StNorm  = 'h0,</pre>
<pre>    StErr   = 'h1</pre>
<pre>  } state_e;</pre>
<pre>  state_e st, st_nxt;</pre>
<pre>  logic [11:0] cnt, cnt_nxt;</pre>
<pre>  logic cnt_hit;</pre>
<pre>  logic [AddrW:0] int_addr;</pre>
<pre>  logic txn_done;</pre>
<pre>  logic err_sel; //1 selects error data, 0 selects normal data</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      cnt <= '0;</pre>
<pre>      st <= StNorm;</pre>
<pre>    end else begin</pre>
<pre>      cnt <= cnt_nxt;</pre>
<pre>      st <= st_nxt;</pre>
<pre>  assign txn_done = flash_req_o & flash_done_i;</pre>
<pre>  assign cnt_hit = (cnt == op_num_words_i);</pre>
<pre>  always_comb begin</pre>
<pre>    st_nxt = st;</pre>
<pre>    cnt_nxt = cnt;</pre>
<pre>    flash_req_o = 1'b0;</pre>
<pre>    data_wr_o = 1'b0;</pre>
<pre>    op_done_o = 1'b0;</pre>
<pre>    op_err_o = 1'b0;</pre>
<pre>    err_sel = 1'b0;</pre>
<pre>    unique case (st)</pre>
<pre>      StNorm: begin</pre>
<pre>        flash_req_o = op_start_i & data_rdy_i;</pre>
<pre>        if (txn_done && cnt_hit) begin</pre>
<pre>          cnt_nxt = '0;</pre>
<pre>          data_wr_o = 1'b1;</pre>
<pre>          op_done_o = 1'b1;</pre>
<pre>          op_err_o = flash_error_i;</pre>
<pre>        end else if (txn_done) begin</pre>
<pre>          cnt_nxt = cnt + 1'b1;</pre>
<pre>          data_wr_o = 1'b1;</pre>
<pre>          err_sel = flash_error_i;</pre>
<pre>          st_nxt = flash_error_i ? StErr : StNorm;</pre>
<pre>      StErr: begin</pre>
<pre>        data_wr_o = data_rdy_i;</pre>
<pre>        err_sel = 1'b1;</pre>
<pre>        if (data_rdy_i && cnt_hit) begin</pre>
<pre>          st_nxt = StNorm;</pre>
<pre>          cnt_nxt = '0;</pre>
<pre>          op_done_o = 1'b1;</pre>
<pre>          op_err_o = 1'b1;</pre>
<pre>        end else if (data_rdy_i) begin</pre>
<pre>          cnt_nxt = cnt + 1'b1;</pre>
<pre>      default:;</pre>
<pre>  assign int_addr = op_addr_i + AddrW'(cnt);</pre>
<pre>  assign flash_addr_o = int_addr[0 +: AddrW];</pre>
<pre>  assign flash_ovfl_o = int_addr[AddrW];</pre>
<pre>  assign data_o = err_sel ? {DataW{1'b1}} : flash_data_i;</pre>
<h3>hw/ip/prim/abstract/prim_rom.sv</h3>
<pre>  parameter prim_pkg::impl_e Impl = `PRIM_DEFAULT_IMPL,</pre>
<pre>  parameter int Width = 32,</pre>
<pre>  parameter int Depth = 2048, // 8kB default</pre>
<pre>  parameter int Aw    = $clog2(Depth)</pre>
<pre>) (</pre>
<pre>  input                        rst_ni,</pre>
<pre>  input        [Aw-1:0]        addr_i,</pre>
<pre>  input                        cs_i,</pre>
<pre>  output logic [Width-1:0]     dout_o,</pre>
<pre>  output logic                 dvalid_o</pre>
<pre>);</pre>
<pre>    prim_generic_rom #(</pre>
<pre>      .Width(Width),</pre>
<pre>      .Depth(Depth)</pre>
<pre>    ) u_impl_generic (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .addr_i,</pre>
<pre>      .cs_i,</pre>
<pre>      .dout_o,</pre>
<pre>      .dvalid_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">    prim_xilinx_rom #(</pre>
<pre style="background-color: #FF0000;">      .Width(Width),</pre>
<pre style="background-color: #FF0000;">      .Depth(Depth)</pre>
<pre style="background-color: #FF0000;">    ) u_impl_generic (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre style="background-color: #FF0000;">      .addr_i,</pre>
<pre style="background-color: #FF0000;">      .cs_i,</pre>
<pre style="background-color: #FF0000;">      .dout_o,</pre>
<pre style="background-color: #FF0000;">      .dvalid_o</pre>
<pre style="background-color: #FF0000;">    );</pre>
<pre style="background-color: #FF0000;">    // TODO: Find code that works across tools and causes a compile failure</pre>
<h3>hw/ip/prim_xilinx/rtl/prim_xilinx_ram_2p.sv</h3>
<pre>module prim_xilinx_ram_2p #(</pre>
<pre>  parameter  int Width = 32, // bit</pre>
<pre>  parameter  int Depth = 128,</pre>
<pre>  localparam int Aw    = $clog2(Depth)  // derived parameter</pre>
<pre>  input clk_a_i,</pre>
<pre>  input clk_b_i,</pre>
<pre>  input                    a_req_i,</pre>
<pre>  input                    a_write_i,</pre>
<pre>  input        [Aw-1:0]    a_addr_i,</pre>
<pre>  input        [Width-1:0] a_wdata_i,</pre>
<pre>  output logic [Width-1:0] a_rdata_o,</pre>
<pre>  input                    b_req_i,</pre>
<pre>  input                    b_write_i,</pre>
<pre>  input        [Aw-1:0]    b_addr_i,</pre>
<pre>  input        [Width-1:0] b_wdata_i,</pre>
<pre>  output logic [Width-1:0] b_rdata_o</pre>
<pre>  logic [Width-1:0] storage [Depth];</pre>
<pre>  always_ff @(posedge clk_a_i) begin</pre>
<pre>    if (a_req_i) begin</pre>
<pre>      if (a_write_i) begin</pre>
<pre>        storage[a_addr_i] <= a_wdata_i;</pre>
<pre>      a_rdata_o <= storage[a_addr_i];</pre>
<pre>  always_ff @(posedge clk_b_i) begin</pre>
<pre>    if (b_req_i) begin</pre>
<pre>      if (b_write_i) begin</pre>
<pre>        storage[b_addr_i] <= b_wdata_i;</pre>
<pre>      b_rdata_o <= storage[b_addr_i];</pre>
<h3>hw/vendor/pulp_riscv_dbg/src/dm_mem.sv</h3>
<pre>module dm_mem #(</pre>
<pre>  parameter int unsigned        NrHarts          =  1,</pre>
<pre>  parameter int unsigned        BusWidth         = 32,</pre>
<pre>  parameter logic [NrHarts-1:0] SelectableHarts  = {NrHarts{1'b1}}</pre>
<pre>  input  logic                             clk_i,       // Clock</pre>
<pre>  input  logic                             rst_ni,      // debug module reset</pre>
<pre>  output logic [NrHarts-1:0]               debug_req_o,</pre>
<pre>  input  logic [19:0]                      hartsel_i,</pre>
<pre>  input  logic [NrHarts-1:0]               haltreq_i,</pre>
<pre>  input  logic [NrHarts-1:0]               resumereq_i,</pre>
<pre>  input  logic                             clear_resumeack_i,</pre>
<pre>  output logic [NrHarts-1:0]               halted_o,    // hart acknowledge halt</pre>
<pre>  output logic [NrHarts-1:0]               resuming_o,  // hart is resuming</pre>
<pre>  input  logic [dm::ProgBufSize-1:0][31:0] progbuf_i,    // program buffer to expose</pre>
<pre>  input  logic [dm::DataCount-1:0][31:0]   data_i,       // data in</pre>
<pre>  output logic [dm::DataCount-1:0][31:0]   data_o,       // data out</pre>
<pre>  output logic                             data_valid_o, // data out is valid</pre>
<pre>  input  logic                             cmd_valid_i,</pre>
<pre>  input  dm::command_t                     cmd_i,</pre>
<pre>  output logic                             cmderror_valid_o,</pre>
<pre>  output dm::cmderr_e                      cmderror_o,</pre>
<pre>  output logic                             cmdbusy_o,</pre>
<pre>  input  logic                             req_i,</pre>
<pre>  input  logic                             we_i,</pre>
<pre>  input  logic [BusWidth-1:0]              addr_i,</pre>
<pre>  input  logic [BusWidth-1:0]              wdata_i,</pre>
<pre>  input  logic [BusWidth/8-1:0]            be_i,</pre>
<pre>  output logic [BusWidth-1:0]              rdata_o</pre>
<pre>  localparam int unsigned DbgAddressBits = 12;</pre>
<pre>  localparam int unsigned HartSelLen     = (NrHarts == 1) ? 1 : $clog2(NrHarts);</pre>
<pre>  localparam int unsigned NrHartsAligned = 2**HartSelLen;</pre>
<pre>  localparam int unsigned MaxAar         = (BusWidth == 64) ? 4 : 3;</pre>
<pre>  localparam logic [DbgAddressBits-1:0] DataBaseAddr        = (dm::DataAddr);</pre>
<pre>  localparam logic [DbgAddressBits-1:0] DataEndAddr         = (dm::DataAddr + 4*dm::DataCount);</pre>
<pre>  localparam logic [DbgAddressBits-1:0] ProgBufBaseAddr     = (dm::DataAddr - 4*dm::ProgBufSize);</pre>
<pre>  localparam logic [DbgAddressBits-1:0] ProgBufEndAddr      = (dm::DataAddr - 1);</pre>
<pre>  localparam logic [DbgAddressBits-1:0] AbstractCmdBaseAddr = (ProgBufBaseAddr - 4*10);</pre>
<pre>  localparam logic [DbgAddressBits-1:0] AbstractCmdEndAddr  = (ProgBufBaseAddr - 1);</pre>
<pre>  localparam logic [DbgAddressBits-1:0] WhereToAddr   = 'h300;</pre>
<pre>  localparam logic [DbgAddressBits-1:0] FlagsBaseAddr = 'h400;</pre>
<pre>  localparam logic [DbgAddressBits-1:0] FlagsEndAddr  = 'h7FF;</pre>
<pre>  localparam logic [DbgAddressBits-1:0] HaltedAddr    = 'h100;</pre>
<pre>  localparam logic [DbgAddressBits-1:0] GoingAddr     = 'h104;</pre>
<pre>  localparam logic [DbgAddressBits-1:0] ResumingAddr  = 'h108;</pre>
<pre>  localparam logic [DbgAddressBits-1:0] ExceptionAddr = 'h10C;</pre>
<pre>  logic [dm::ProgBufSize/2-1:0][63:0]   progbuf;</pre>
<pre>  logic [7:0][63:0]   abstract_cmd;</pre>
<pre>  logic [NrHarts-1:0] halted_d, halted_q;</pre>
<pre>  logic [NrHarts-1:0] resuming_d, resuming_q;</pre>
<pre>  logic               resume, go, going;</pre>
<pre>  logic exception;</pre>
<pre>  logic unsupported_command;</pre>
<pre>  logic [63:0] rom_rdata;</pre>
<pre>  logic [63:0] rdata_d, rdata_q;</pre>
<pre>  logic        word_enable32_q;</pre>
<pre>  logic [HartSelLen-1:0] hartsel, wdata_hartsel;</pre>
<pre>  assign hartsel       = hartsel_i[HartSelLen-1:0];</pre>
<pre>  assign wdata_hartsel = wdata_i[HartSelLen-1:0];</pre>
<pre>  logic [NrHartsAligned-1:0] resumereq_aligned, haltreq_aligned,</pre>
<pre>                             halted_d_aligned, halted_q_aligned,</pre>
<pre>                             halted_aligned, resumereq_wdata_aligned,</pre>
<pre>                             resuming_d_aligned, resuming_q_aligned;</pre>
<pre>  assign resumereq_aligned       = NrHartsAligned'(resumereq_i);</pre>
<pre>  assign haltreq_aligned         = NrHartsAligned'(haltreq_i);</pre>
<pre>  assign resumereq_wdata_aligned = NrHartsAligned'(resumereq_i);</pre>
<pre>  assign halted_q_aligned        = NrHartsAligned'(halted_q);</pre>
<pre>  assign halted_d                = NrHarts'(halted_d_aligned);</pre>
<pre>  assign resuming_q_aligned      = NrHartsAligned'(resuming_q);</pre>
<pre>  assign resuming_d              = NrHarts'(resuming_d_aligned);</pre>
<pre>  logic fwd_rom_d, fwd_rom_q;</pre>
<pre>  dm::ac_ar_cmd_t ac_ar;</pre>
<pre>  assign ac_ar       = dm::ac_ar_cmd_t'(cmd_i.control);</pre>
<pre>  assign debug_req_o = haltreq_i;</pre>
<pre>  assign halted_o    = halted_q;</pre>
<pre>  assign resuming_o  = resuming_q;</pre>
<pre>  assign progbuf = progbuf_i;</pre>
<pre>  typedef enum logic [1:0] { Idle, Go, Resume, CmdExecuting } state_e;</pre>
<pre>  state_e state_d, state_q;</pre>
<pre>  always_comb begin : p_hart_ctrl_queue</pre>
<pre>    cmderror_valid_o = 1'b0;</pre>
<pre>    cmderror_o       = dm::CmdErrNone;</pre>
<pre>    state_d          = state_q;</pre>
<pre>    go               = 1'b0;</pre>
<pre>    resume           = 1'b0;</pre>
<pre>    cmdbusy_o        = 1'b1;</pre>
<pre>    unique case (state_q)</pre>
<pre>      Idle: begin</pre>
<pre>        cmdbusy_o = 1'b0;</pre>
<pre>        if (cmd_valid_i && halted_q_aligned[hartsel] && !unsupported_command) begin</pre>
<pre>          state_d = Go;</pre>
<pre>        end else if (cmd_valid_i) begin</pre>
<pre>          cmderror_valid_o = 1'b1;</pre>
<pre>          cmderror_o = dm::CmdErrorHaltResume;</pre>
<pre>        if (resumereq_aligned[hartsel] && !resuming_q_aligned[hartsel] &&</pre>
<pre>            !haltreq_aligned[hartsel] && halted_q_aligned[hartsel]) begin</pre>
<pre>          state_d = Resume;</pre>
<pre>      Go: begin</pre>
<pre>        cmdbusy_o = 1'b1;</pre>
<pre>        go        = 1'b1;</pre>
<pre>        if (going) begin</pre>
<pre>            state_d = CmdExecuting;</pre>
<pre>      Resume: begin</pre>
<pre>        cmdbusy_o = 1'b1;</pre>
<pre>        resume = 1'b1;</pre>
<pre>        if (resuming_q_aligned[hartsel]) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>      CmdExecuting: begin</pre>
<pre>        cmdbusy_o = 1'b1;</pre>
<pre>        go        = 1'b0;</pre>
<pre>        if (halted_aligned[hartsel]) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>      default: ;</pre>
<pre>    if (unsupported_command && cmd_valid_i) begin</pre>
<pre>      cmderror_valid_o = 1'b1;</pre>
<pre>      cmderror_o = dm::CmdErrNotSupported;</pre>
<pre>    if (exception) begin</pre>
<pre>      cmderror_valid_o = 1'b1;</pre>
<pre>      cmderror_o = dm::CmdErrorException;</pre>
<pre>  logic [63:0] word_mux;</pre>
<pre>  assign word_mux = (fwd_rom_q) ? rom_rdata : rdata_q;</pre>
<pre style="background-color: #FF0000;">  if (BusWidth == 64) begin : gen_word_mux64</pre>
<pre style="background-color: #FF0000;">    assign rdata_o = word_mux;</pre>
<pre>  end else begin : gen_word_mux32</pre>
<pre>    assign rdata_o = (word_enable32_q) ? word_mux[32 +: 32] : word_mux[0 +: 32];</pre>
<pre>  logic [63:0] data_bits;</pre>
<pre>  logic [7:0][7:0] rdata;</pre>
<pre>  always_comb begin : p_rw_logic</pre>
<pre>    halted_d_aligned   = NrHartsAligned'(halted_q);</pre>
<pre>    resuming_d_aligned = NrHartsAligned'(resuming_q);</pre>
<pre>    rdata_d        = rdata_q;</pre>
<pre>    data_bits      = data_i;</pre>
<pre>    rdata          = '0;</pre>
<pre>    data_valid_o   = 1'b0;</pre>
<pre>    exception      = 1'b0;</pre>
<pre>    halted_aligned     = '0;</pre>
<pre>    going          = 1'b0;</pre>
<pre>    if (clear_resumeack_i) begin</pre>
<pre>      resuming_d_aligned[hartsel] = 1'b0;</pre>
<pre>    if (req_i) begin</pre>
<pre>      if (we_i) begin</pre>
<pre>        unique case (addr_i[DbgAddressBits-1:0]) inside</pre>
<pre>          HaltedAddr: begin</pre>
<pre>            halted_aligned[wdata_hartsel] = 1'b1;</pre>
<pre>            halted_d_aligned[wdata_hartsel] = 1'b1;</pre>
<pre>          GoingAddr: begin</pre>
<pre>            going = 1'b1;</pre>
<pre>          ResumingAddr: begin</pre>
<pre>            halted_d_aligned[wdata_hartsel] = 1'b0;</pre>
<pre>            resuming_d_aligned[wdata_hartsel] = 1'b1;</pre>
<pre>          ExceptionAddr: exception = 1'b1;</pre>
<pre>          [(dm::DataAddr):DataEndAddr]: begin</pre>
<pre>            data_valid_o = 1'b1;</pre>
<pre>            for (int i = 0; i < $bits(be_i); i++) begin</pre>
<pre>              if (be_i[i]) begin</pre>
<pre>                data_bits[i*8+:8] = wdata_i[i*8+:8];</pre>
<pre>          default ;</pre>
<pre>      end else begin</pre>
<pre>        unique case (addr_i[DbgAddressBits-1:0]) inside</pre>
<pre>          WhereToAddr: begin</pre>
<pre>            if (resumereq_wdata_aligned[wdata_hartsel]) begin</pre>
<pre>              rdata_d = {32'b0, dm::jal('0, 21'(dm::ResumeAddress[11:0])-21'(WhereToAddr))};</pre>
<pre>            if (cmdbusy_o) begin</pre>
<pre>              if (cmd_i.cmdtype == dm::AccessRegister &&</pre>
<pre>                  !ac_ar.transfer && ac_ar.postexec) begin</pre>
<pre>                rdata_d = {32'b0, dm::jal('0, 21'(ProgBufBaseAddr)-21'(WhereToAddr))};</pre>
<pre>              end else begin</pre>
<pre>                rdata_d = {32'b0, dm::jal('0, 21'(AbstractCmdBaseAddr)-21'(WhereToAddr))};</pre>
<pre>          [DataBaseAddr:DataEndAddr]: begin</pre>
<pre>            rdata_d = {</pre>
<pre>                      data_i[$clog2(dm::ProgBufSize)'(addr_i[DbgAddressBits-1:3] -</pre>
<pre>                          DataBaseAddr[DbgAddressBits-1:3] + 1'b1)],</pre>
<pre>                      data_i[$clog2(dm::ProgBufSize)'(addr_i[DbgAddressBits-1:3] -</pre>
<pre>                          DataBaseAddr[DbgAddressBits-1:3])]</pre>
<pre>          [ProgBufBaseAddr:ProgBufEndAddr]: begin</pre>
<pre>            rdata_d = progbuf[$clog2(dm::ProgBufSize)'(addr_i[DbgAddressBits-1:3] -</pre>
<pre>                          ProgBufBaseAddr[DbgAddressBits-1:3])];</pre>
<pre>          [AbstractCmdBaseAddr:AbstractCmdEndAddr]: begin</pre>
<pre>            rdata_d = abstract_cmd[3'(addr_i[DbgAddressBits-1:3] -</pre>
<pre>                           AbstractCmdBaseAddr[DbgAddressBits-1:3])];</pre>
<pre>          [FlagsBaseAddr:FlagsEndAddr]: begin</pre>
<pre>            if (({addr_i[DbgAddressBits-1:3], 3'b0} - FlagsBaseAddr[DbgAddressBits-1:0]) ==</pre>
<pre>              (DbgAddressBits'(hartsel) & {{(DbgAddressBits-3){1'b1}}, 3'b0})) begin</pre>
<pre>              rdata[DbgAddressBits'(hartsel) & DbgAddressBits'(3'b111)] = {6'b0, resume, go};</pre>
<pre>            rdata_d = rdata;</pre>
<pre>          default: ;</pre>
<pre>    data_o = data_bits;</pre>
<pre>  always_comb begin : p_abstract_cmd_rom</pre>
<pre>    unsupported_command = 1'b0;</pre>
<pre>    abstract_cmd[0][31:0]  = dm::illegal();</pre>
<pre>    abstract_cmd[0][63:32] = dm::auipc(5'd10, '0);</pre>
<pre>    abstract_cmd[1][31:0]  = dm::srli(5'd10, 5'd10, 6'd12); // clr lowest 12b -> DM base offset</pre>
<pre>    abstract_cmd[1][63:32] = dm::slli(5'd10, 5'd10, 6'd12);</pre>
<pre>    abstract_cmd[2][31:0]  = dm::nop();</pre>
<pre>    abstract_cmd[2][63:32] = dm::nop();</pre>
<pre>    abstract_cmd[3][31:0]  = dm::nop();</pre>
<pre>    abstract_cmd[3][63:32] = dm::nop();</pre>
<pre>    abstract_cmd[4][31:0]  = dm::csrr(dm::CSR_DSCRATCH1, 5'd10);</pre>
<pre>    abstract_cmd[4][63:32] = dm::ebreak();</pre>
<pre>    abstract_cmd[7:5]      = '0;</pre>
<pre>    unique case (cmd_i.cmdtype)</pre>
<pre>      dm::AccessRegister: begin</pre>
<pre>        if (32'(ac_ar.aarsize) < MaxAar && ac_ar.transfer && ac_ar.write) begin</pre>
<pre>          abstract_cmd[0][31:0] = dm::csrw(dm::CSR_DSCRATCH1, 5'd10);</pre>
<pre>          if (ac_ar.regno[15:14] != '0) begin</pre>
<pre>            abstract_cmd[0][31:0] = dm::ebreak(); // we leave asap</pre>
<pre>            unsupported_command = 1'b1;</pre>
<pre>          end else if (ac_ar.regno[12] && (!ac_ar.regno[5]) &&</pre>
<pre>                      (ac_ar.regno[4:0] == 5'd10)) begin</pre>
<pre>            abstract_cmd[2][31:0]  = dm::csrw(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre>            abstract_cmd[2][63:32] = dm::load(ac_ar.aarsize, 5'd8, 5'd10, dm::DataAddr);</pre>
<pre>            abstract_cmd[3][31:0]  = dm::csrw(dm::CSR_DSCRATCH1, 5'd8);</pre>
<pre>            abstract_cmd[3][63:32] = dm::csrr(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre>          end else if (ac_ar.regno[12]) begin</pre>
<pre>            if (ac_ar.regno[5]) begin</pre>
<pre>              abstract_cmd[2][31:0] =</pre>
<pre>                  dm::float_load(ac_ar.aarsize, ac_ar.regno[4:0], 5'd10, dm::DataAddr);</pre>
<pre>            end else begin</pre>
<pre>              abstract_cmd[2][31:0] =</pre>
<pre>                  dm::load(ac_ar.aarsize, ac_ar.regno[4:0], 5'd10, dm::DataAddr);</pre>
<pre>          end else begin</pre>
<pre>            abstract_cmd[2][31:0]  = dm::csrw(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre>            abstract_cmd[2][63:32] = dm::load(ac_ar.aarsize, 5'd8, 5'd10, dm::DataAddr);</pre>
<pre>            abstract_cmd[3][31:0]  = dm::csrw(dm::csr_reg_t'(ac_ar.regno[11:0]), 5'd8);</pre>
<pre>            abstract_cmd[3][63:32] = dm::csrr(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre>        end else if (32'(ac_ar.aarsize) < MaxAar && ac_ar.transfer && !ac_ar.write) begin</pre>
<pre>          abstract_cmd[0][31:0]  = dm::csrw(dm::CSR_DSCRATCH1, 5'd10);</pre>
<pre>          if (ac_ar.regno[15:14] != '0) begin</pre>
<pre>              abstract_cmd[0][31:0] = dm::ebreak(); // we leave asap</pre>
<pre>              unsupported_command = 1'b1;</pre>
<pre>          end else if (ac_ar.regno[12] && (!ac_ar.regno[5]) &&</pre>
<pre>                      (ac_ar.regno[4:0] == 5'd10)) begin</pre>
<pre>            abstract_cmd[2][31:0]  = dm::csrw(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre>            abstract_cmd[2][63:32] = dm::csrr(dm::CSR_DSCRATCH1, 5'd8);</pre>
<pre>            abstract_cmd[3][31:0]  = dm::store(ac_ar.aarsize, 5'd8, 5'd10, dm::DataAddr);</pre>
<pre>            abstract_cmd[3][63:32] = dm::csrr(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre>          end else if (ac_ar.regno[12]) begin</pre>
<pre>            if (ac_ar.regno[5]) begin</pre>
<pre>              abstract_cmd[2][31:0] =</pre>
<pre>                  dm::float_store(ac_ar.aarsize, ac_ar.regno[4:0], 5'd10, dm::DataAddr);</pre>
<pre>            end else begin</pre>
<pre>              abstract_cmd[2][31:0] =</pre>
<pre>                  dm::store(ac_ar.aarsize, ac_ar.regno[4:0], 5'd10, dm::DataAddr);</pre>
<pre>          end else begin</pre>
<pre>            abstract_cmd[2][31:0]  = dm::csrw(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre>            abstract_cmd[2][63:32] = dm::csrr(dm::csr_reg_t'(ac_ar.regno[11:0]), 5'd8);</pre>
<pre>            abstract_cmd[3][31:0]  = dm::store(ac_ar.aarsize, 5'd8, 5'd10, dm::DataAddr);</pre>
<pre>            abstract_cmd[3][63:32] = dm::csrr(dm::CSR_DSCRATCH0, 5'd8);</pre>
<pre>        end else if (32'(ac_ar.aarsize) >= MaxAar || ac_ar.aarpostincrement == 1'b1) begin</pre>
<pre>          abstract_cmd[0][31:0] = dm::ebreak(); // we leave asap</pre>
<pre>          unsupported_command = 1'b1;</pre>
<pre>        if (ac_ar.postexec && !unsupported_command) begin</pre>
<pre>          abstract_cmd[4][63:32] = dm::nop();</pre>
<pre>      default: begin</pre>
<pre>        abstract_cmd[0][31:0] = dm::ebreak();</pre>
<pre>        unsupported_command = 1'b1;</pre>
<pre>  logic [63:0] rom_addr;</pre>
<pre>  assign rom_addr = 64'(addr_i);</pre>
<pre>  debug_rom i_debug_rom (</pre>
<pre>    .clk_i,</pre>
<pre>    .req_i,</pre>
<pre>    .addr_i  ( rom_addr  ),</pre>
<pre>    .rdata_o ( rom_rdata )</pre>
<pre>  assign fwd_rom_d = logic'(addr_i[DbgAddressBits-1:0] >= dm::HaltAddress[DbgAddressBits-1:0]);</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      fwd_rom_q       <= 1'b0;</pre>
<pre>      rdata_q         <= '0;</pre>
<pre>      state_q         <= Idle;</pre>
<pre>      word_enable32_q <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      fwd_rom_q       <= fwd_rom_d;</pre>
<pre>      rdata_q         <= rdata_d;</pre>
<pre>      state_q         <= state_d;</pre>
<pre>      word_enable32_q <= addr_i[2];</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      halted_q   <= 1'b0;</pre>
<pre>      resuming_q <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      halted_q   <= SelectableHarts & halted_d;</pre>
<pre>      resuming_q <= SelectableHarts & resuming_d;</pre>
<pre style="background-color: #FF0000;">endmodule : dm_mem</pre>
<h3>hw/vendor/pulp_riscv_dbg/src/dm_pkg.sv</h3>
<pre>package dm;</pre>
<pre>  localparam logic [3:0] DbgVersion013 = 4'h2;</pre>
<pre>  localparam logic [4:0] ProgBufSize   = 5'h8;</pre>
<pre>  localparam logic [3:0] DataCount     = 4'h2;</pre>
<pre>  localparam logic [63:0] HaltAddress = 64'h800;</pre>
<pre>  localparam logic [63:0] ResumeAddress = HaltAddress + 4;</pre>
<pre>  localparam logic [63:0] ExceptionAddress = HaltAddress + 8;</pre>
<pre>  localparam logic [11:0] DataAddr = 12'h380; // we are aligned with Rocket here</pre>
<pre>  typedef enum logic [7:0] {</pre>
<pre>    Data0        = 8'h04,</pre>
<pre>    Data1        = 8'h05,</pre>
<pre>    Data2        = 8'h06,</pre>
<pre>    Data3        = 8'h07,</pre>
<pre>    Data4        = 8'h08,</pre>
<pre>    Data5        = 8'h09,</pre>
<pre>    Data6        = 8'h0A,</pre>
<pre>    Data7        = 8'h0B,</pre>
<pre>    Data8        = 8'h0C,</pre>
<pre>    Data9        = 8'h0D,</pre>
<pre>    Data10       = 8'h0E,</pre>
<pre>    Data11       = 8'h0F,</pre>
<pre>    DMControl    = 8'h10,</pre>
<pre>    DMStatus     = 8'h11, // r/o</pre>
<pre>    Hartinfo     = 8'h12,</pre>
<pre>    HaltSum1     = 8'h13,</pre>
<pre>    HAWindowSel  = 8'h14,</pre>
<pre>    HAWindow     = 8'h15,</pre>
<pre>    AbstractCS   = 8'h16,</pre>
<pre>    Command      = 8'h17,</pre>
<pre>    AbstractAuto = 8'h18,</pre>
<pre>    DevTreeAddr0 = 8'h19,</pre>
<pre>    DevTreeAddr1 = 8'h1A,</pre>
<pre>    DevTreeAddr2 = 8'h1B,</pre>
<pre>    DevTreeAddr3 = 8'h1C,</pre>
<pre>    NextDM       = 8'h1D,</pre>
<pre>    ProgBuf0     = 8'h20,</pre>
<pre>    ProgBuf15    = 8'h2F,</pre>
<pre>    AuthData     = 8'h30,</pre>
<pre>    HaltSum2     = 8'h34,</pre>
<pre>    HaltSum3     = 8'h35,</pre>
<pre>    SBAddress3   = 8'h37,</pre>
<pre>    SBCS         = 8'h38,</pre>
<pre>    SBAddress0   = 8'h39,</pre>
<pre>    SBAddress1   = 8'h3A,</pre>
<pre>    SBAddress2   = 8'h3B,</pre>
<pre>    SBData0      = 8'h3C,</pre>
<pre>    SBData1      = 8'h3D,</pre>
<pre>    SBData2      = 8'h3E,</pre>
<pre>    SBData3      = 8'h3F,</pre>
<pre>    HaltSum0     = 8'h40</pre>
<pre>  } dm_csr_e;</pre>
<pre>  localparam logic [2:0] CauseBreakpoint = 3'h1;</pre>
<pre>  localparam logic [2:0] CauseTrigger    = 3'h2;</pre>
<pre>  localparam logic [2:0] CauseRequest    = 3'h3;</pre>
<pre>  localparam logic [2:0] CauseSingleStep = 3'h4;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:23] zero1;</pre>
<pre>    logic         impebreak;</pre>
<pre>    logic [21:20] zero0;</pre>
<pre>    logic         allhavereset;</pre>
<pre>    logic         anyhavereset;</pre>
<pre>    logic         allresumeack;</pre>
<pre>    logic         anyresumeack;</pre>
<pre>    logic         allnonexistent;</pre>
<pre>    logic         anynonexistent;</pre>
<pre>    logic         allunavail;</pre>
<pre>    logic         anyunavail;</pre>
<pre>    logic         allrunning;</pre>
<pre>    logic         anyrunning;</pre>
<pre>    logic         allhalted;</pre>
<pre>    logic         anyhalted;</pre>
<pre>    logic         authenticated;</pre>
<pre>    logic         authbusy;</pre>
<pre>    logic         hasresethaltreq;</pre>
<pre>    logic         devtreevalid;</pre>
<pre>    logic [3:0]   version;</pre>
<pre style="background-color: #FF0000;">  } dmstatus_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic         haltreq;</pre>
<pre>    logic         resumereq;</pre>
<pre>    logic         hartreset;</pre>
<pre>    logic         ackhavereset;</pre>
<pre>    logic         zero1;</pre>
<pre>    logic         hasel;</pre>
<pre>    logic [25:16] hartsello;</pre>
<pre>    logic [15:6]  hartselhi;</pre>
<pre>    logic [5:4]   zero0;</pre>
<pre>    logic         setresethaltreq;</pre>
<pre>    logic         clrresethaltreq;</pre>
<pre>    logic         ndmreset;</pre>
<pre>    logic         dmactive;</pre>
<pre style="background-color: #FF0000;">  } dmcontrol_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:24] zero1;</pre>
<pre>    logic [23:20] nscratch;</pre>
<pre>    logic [19:17] zero0;</pre>
<pre>    logic         dataaccess;</pre>
<pre>    logic [15:12] datasize;</pre>
<pre>    logic [11:0]  dataaddr;</pre>
<pre style="background-color: #FF0000;">  } hartinfo_t;</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    CmdErrNone, CmdErrBusy, CmdErrNotSupported,</pre>
<pre>    CmdErrorException, CmdErrorHaltResume,</pre>
<pre>    CmdErrorBus, CmdErrorOther = 7</pre>
<pre>  } cmderr_e;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:29] zero3;</pre>
<pre>    logic [28:24] progbufsize;</pre>
<pre>    logic [23:13] zero2;</pre>
<pre>    logic         busy;</pre>
<pre>    logic         zero1;</pre>
<pre>    cmderr_e      cmderr;</pre>
<pre>    logic [7:4]   zero0;</pre>
<pre>    logic [3:0]   datacount;</pre>
<pre style="background-color: #FF0000;">  } abstractcs_t;</pre>
<pre>  typedef enum logic [7:0] {</pre>
<pre>    AccessRegister = 8'h0,</pre>
<pre>    QuickAccess    = 8'h1,</pre>
<pre>    AccessMemory   = 8'h2</pre>
<pre>  } cmd_e;</pre>
<pre>  typedef struct packed {</pre>
<pre>    cmd_e        cmdtype;</pre>
<pre>    logic [23:0] control;</pre>
<pre style="background-color: #FF0000;">  } command_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:16] autoexecprogbuf;</pre>
<pre>    logic [15:12] zero0;</pre>
<pre>    logic [11:0]  autoexecdata;</pre>
<pre style="background-color: #FF0000;">  } abstractauto_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic         zero1;</pre>
<pre>    logic [22:20] aarsize;</pre>
<pre>    logic         aarpostincrement;</pre>
<pre>    logic         postexec;</pre>
<pre>    logic         transfer;</pre>
<pre>    logic         write;</pre>
<pre>    logic [15:0]  regno;</pre>
<pre style="background-color: #FF0000;">  } ac_ar_cmd_t;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    DTM_NOP   = 2'h0,</pre>
<pre>    DTM_READ  = 2'h1,</pre>
<pre>    DTM_WRITE = 2'h2</pre>
<pre>  } dtm_op_e;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:29] sbversion;</pre>
<pre>    logic [28:23] zero0;</pre>
<pre>    logic         sbbusyerror;</pre>
<pre>    logic         sbbusy;</pre>
<pre>    logic         sbreadonaddr;</pre>
<pre>    logic [19:17] sbaccess;</pre>
<pre>    logic         sbautoincrement;</pre>
<pre>    logic         sbreadondata;</pre>
<pre>    logic [14:12] sberror;</pre>
<pre>    logic [11:5]  sbasize;</pre>
<pre>    logic         sbaccess128;</pre>
<pre>    logic         sbaccess64;</pre>
<pre>    logic         sbaccess32;</pre>
<pre>    logic         sbaccess16;</pre>
<pre>    logic         sbaccess8;</pre>
<pre style="background-color: #FF0000;">  } sbcs_t;</pre>
<pre>  localparam logic[1:0] DTM_SUCCESS = 2'h0;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [6:0]  addr;</pre>
<pre>    dtm_op_e     op;</pre>
<pre>    logic [31:0] data;</pre>
<pre style="background-color: #FF0000;">  } dmi_req_t;</pre>
<pre>  typedef struct packed  {</pre>
<pre>    logic [31:0] data;</pre>
<pre>    logic [1:0]  resp;</pre>
<pre style="background-color: #FF0000;">  } dmi_resp_t;</pre>
<pre>  typedef enum logic[1:0] {</pre>
<pre>    PRIV_LVL_M = 2'b11,</pre>
<pre>    PRIV_LVL_S = 2'b01,</pre>
<pre>    PRIV_LVL_U = 2'b00</pre>
<pre>  } priv_lvl_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:28]     xdebugver;</pre>
<pre>    logic [27:16]     zero2;</pre>
<pre>    logic             ebreakm;</pre>
<pre>    logic             zero1;</pre>
<pre>    logic             ebreaks;</pre>
<pre>    logic             ebreaku;</pre>
<pre>    logic             stepie;</pre>
<pre>    logic             stopcount;</pre>
<pre>    logic             stoptime;</pre>
<pre>    logic [8:6]       cause;</pre>
<pre>    logic             zero0;</pre>
<pre>    logic             mprven;</pre>
<pre>    logic             nmip;</pre>
<pre>    logic             step;</pre>
<pre>    priv_lvl_t        prv;</pre>
<pre style="background-color: #FF0000;">  } dcsr_t;</pre>
<pre>  typedef enum logic [11:0] {</pre>
<pre>    CSR_FFLAGS         = 12'h001,</pre>
<pre>    CSR_FRM            = 12'h002,</pre>
<pre>    CSR_FCSR           = 12'h003,</pre>
<pre>    CSR_FTRAN          = 12'h800,</pre>
<pre>    CSR_SSTATUS        = 12'h100,</pre>
<pre>    CSR_SIE            = 12'h104,</pre>
<pre>    CSR_STVEC          = 12'h105,</pre>
<pre>    CSR_SCOUNTEREN     = 12'h106,</pre>
<pre>    CSR_SSCRATCH       = 12'h140,</pre>
<pre>    CSR_SEPC           = 12'h141,</pre>
<pre>    CSR_SCAUSE         = 12'h142,</pre>
<pre>    CSR_STVAL          = 12'h143,</pre>
<pre>    CSR_SIP            = 12'h144,</pre>
<pre>    CSR_SATP           = 12'h180,</pre>
<pre>    CSR_MSTATUS        = 12'h300,</pre>
<pre>    CSR_MISA           = 12'h301,</pre>
<pre>    CSR_MEDELEG        = 12'h302,</pre>
<pre>    CSR_MIDELEG        = 12'h303,</pre>
<pre>    CSR_MIE            = 12'h304,</pre>
<pre>    CSR_MTVEC          = 12'h305,</pre>
<pre>    CSR_MCOUNTEREN     = 12'h306,</pre>
<pre>    CSR_MSCRATCH       = 12'h340,</pre>
<pre>    CSR_MEPC           = 12'h341,</pre>
<pre>    CSR_MCAUSE         = 12'h342,</pre>
<pre>    CSR_MTVAL          = 12'h343,</pre>
<pre>    CSR_MIP            = 12'h344,</pre>
<pre>    CSR_PMPCFG0        = 12'h3A0,</pre>
<pre>    CSR_PMPADDR0       = 12'h3B0,</pre>
<pre>    CSR_MVENDORID      = 12'hF11,</pre>
<pre>    CSR_MARCHID        = 12'hF12,</pre>
<pre>    CSR_MIMPID         = 12'hF13,</pre>
<pre>    CSR_MHARTID        = 12'hF14,</pre>
<pre>    CSR_MCYCLE         = 12'hB00,</pre>
<pre>    CSR_MINSTRET       = 12'hB02,</pre>
<pre>    CSR_DCACHE         = 12'h701,</pre>
<pre>    CSR_ICACHE         = 12'h700,</pre>
<pre>    CSR_TSELECT        = 12'h7A0,</pre>
<pre>    CSR_TDATA1         = 12'h7A1,</pre>
<pre>    CSR_TDATA2         = 12'h7A2,</pre>
<pre>    CSR_TDATA3         = 12'h7A3,</pre>
<pre>    CSR_TINFO          = 12'h7A4,</pre>
<pre>    CSR_DCSR           = 12'h7b0,</pre>
<pre>    CSR_DPC            = 12'h7b1,</pre>
<pre>    CSR_DSCRATCH0      = 12'h7b2, // optional</pre>
<pre>    CSR_DSCRATCH1      = 12'h7b3, // optional</pre>
<pre>    CSR_CYCLE          = 12'hC00,</pre>
<pre>    CSR_TIME           = 12'hC01,</pre>
<pre>    CSR_INSTRET        = 12'hC02</pre>
<pre>  } csr_reg_t;</pre>
<pre>  function automatic logic [31:0] jal (logic [4:0]  rd,</pre>
<pre>                                       logic [20:0] imm);</pre>
<pre>    return {imm[20], imm[10:1], imm[11], imm[19:12], rd, 7'h6f};</pre>
<pre>  function automatic logic [31:0] jalr (logic [4:0]  rd,</pre>
<pre>                                        logic [4:0]  rs1,</pre>
<pre>                                        logic [11:0] offset);</pre>
<pre>    return {offset[11:0], rs1, 3'b0, rd, 7'h67};</pre>
<pre>  function automatic logic [31:0] andi (logic [4:0]  rd,</pre>
<pre>                                        logic [4:0]  rs1,</pre>
<pre>                                        logic [11:0] imm);</pre>
<pre>    return {imm[11:0], rs1, 3'h7, rd, 7'h13};</pre>
<pre>  function automatic logic [31:0] slli (logic [4:0] rd,</pre>
<pre>                                        logic [4:0] rs1,</pre>
<pre>                                        logic [5:0] shamt);</pre>
<pre>    return {6'b0, shamt[5:0], rs1, 3'h1, rd, 7'h13};</pre>
<pre>  function automatic logic [31:0] srli (logic [4:0] rd,</pre>
<pre>                                        logic [4:0] rs1,</pre>
<pre>                                        logic [5:0] shamt);</pre>
<pre>    return {6'b0, shamt[5:0], rs1, 3'h5, rd, 7'h13};</pre>
<pre>  function automatic logic [31:0] load (logic [2:0]  size,</pre>
<pre>                                        logic [4:0]  dest,</pre>
<pre>                                        logic [4:0]  base,</pre>
<pre>                                        logic [11:0] offset);</pre>
<pre>    return {offset[11:0], base, size, dest, 7'h03};</pre>
<pre>  function automatic logic [31:0] auipc (logic [4:0]  rd,</pre>
<pre>                                         logic [20:0] imm);</pre>
<pre>    return {imm[20], imm[10:1], imm[11], imm[19:12], rd, 7'h17};</pre>
<pre>  function automatic logic [31:0] store (logic [2:0]  size,</pre>
<pre>                                         logic [4:0]  src,</pre>
<pre>                                         logic [4:0]  base,</pre>
<pre>                                         logic [11:0] offset);</pre>
<pre>    return {offset[11:5], src, base, size, offset[4:0], 7'h23};</pre>
<pre>  function automatic logic [31:0] float_load (logic [2:0]  size,</pre>
<pre>                                              logic [4:0]  dest,</pre>
<pre>                                              logic [4:0]  base,</pre>
<pre>                                              logic [11:0] offset);</pre>
<pre>    return {offset[11:0], base, size, dest, 7'b00_001_11};</pre>
<pre>  function automatic logic [31:0] float_store (logic [2:0]  size,</pre>
<pre>                                               logic [4:0]  src,</pre>
<pre>                                               logic [4:0]  base,</pre>
<pre>                                               logic [11:0] offset);</pre>
<pre>    return {offset[11:5], src, base, size, offset[4:0], 7'b01_001_11};</pre>
<pre>  function automatic logic [31:0] csrw (csr_reg_t   csr,</pre>
<pre>                                        logic [4:0] rs1);</pre>
<pre>    return {csr, rs1, 3'h1, 5'h0, 7'h73};</pre>
<pre>  function automatic logic [31:0] csrr (csr_reg_t   csr,</pre>
<pre>                                        logic [4:0] dest);</pre>
<pre>    return {csr, 5'h0, 3'h2, dest, 7'h73};</pre>
<pre>  function automatic logic [31:0] branch(logic [4:0]  src2,</pre>
<pre>                                         logic [4:0]  src1,</pre>
<pre>                                         logic [2:0]  funct3,</pre>
<pre>                                         logic [11:0] offset);</pre>
<pre>    return {offset[11], offset[9:4], src2, src1, funct3,</pre>
<pre>        offset[3:0], offset[10], 7'b11_000_11};</pre>
<pre>  function automatic logic [31:0] ebreak ();</pre>
<pre>    return 32'h00100073;</pre>
<pre>  function automatic logic [31:0] wfi ();</pre>
<pre>    return 32'h10500073;</pre>
<pre>  function automatic logic [31:0] nop ();</pre>
<pre>    return 32'h00000013;</pre>
<pre>  function automatic logic [31:0] illegal ();</pre>
<pre>    return 32'h00000000;</pre>
<pre style="background-color: #FF0000;">endpackage : dm</pre>
<h3>hw/vendor/pulp_riscv_dbg/src/dmi_jtag.sv</h3>
<pre>module dmi_jtag #(</pre>
<pre>  parameter logic [31:0] IdcodeValue = 32'h00000001</pre>
<pre>  input  logic         clk_i,      // DMI Clock</pre>
<pre>  input  logic         rst_ni,     // Asynchronous reset active low</pre>
<pre>  input  logic         testmode_i,</pre>
<pre>  output logic         dmi_rst_no, // hard reset</pre>
<pre>  output dm::dmi_req_t dmi_req_o,</pre>
<pre>  output logic         dmi_req_valid_o,</pre>
<pre>  input  logic         dmi_req_ready_i,</pre>
<pre>  input dm::dmi_resp_t dmi_resp_i,</pre>
<pre>  output logic         dmi_resp_ready_o,</pre>
<pre>  input  logic         dmi_resp_valid_i,</pre>
<pre>  input  logic         tck_i,    // JTAG test clock pad</pre>
<pre>  input  logic         tms_i,    // JTAG test mode select pad</pre>
<pre>  input  logic         trst_ni,  // JTAG test reset pad</pre>
<pre>  input  logic         td_i,     // JTAG test data input pad</pre>
<pre>  output logic         td_o,     // JTAG test data output pad</pre>
<pre>  output logic         tdo_oe_o  // Data out output enable</pre>
<pre>  assign       dmi_rst_no = rst_ni;</pre>
<pre>  logic        test_logic_reset;</pre>
<pre>  logic        shift_dr;</pre>
<pre>  logic        update_dr;</pre>
<pre>  logic        capture_dr;</pre>
<pre>  logic        dmi_access;</pre>
<pre>  logic        dtmcs_select;</pre>
<pre>  logic        dmi_reset;</pre>
<pre>  logic        dmi_tdi;</pre>
<pre>  logic        dmi_tdo;</pre>
<pre>  dm::dmi_req_t  dmi_req;</pre>
<pre>  logic          dmi_req_ready;</pre>
<pre>  logic          dmi_req_valid;</pre>
<pre>  dm::dmi_resp_t dmi_resp;</pre>
<pre>  logic          dmi_resp_valid;</pre>
<pre>  logic          dmi_resp_ready;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [6:0]  address;</pre>
<pre>    logic [31:0] data;</pre>
<pre>    logic [1:0]  op;</pre>
<pre style="background-color: #FF0000;">  } dmi_t;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    DMINoError = 2'h0, DMIReservedError = 2'h1,</pre>
<pre>    DMIOPFailed = 2'h2, DMIBusy = 2'h3</pre>
<pre>  } dmi_error_e;</pre>
<pre>  typedef enum logic [2:0] { Idle, Read, WaitReadValid, Write, WaitWriteValid } state_e;</pre>
<pre>  state_e state_d, state_q;</pre>
<pre>  logic [$bits(dmi_t)-1:0] dr_d, dr_q;</pre>
<pre>  logic [6:0] address_d, address_q;</pre>
<pre>  logic [31:0] data_d, data_q;</pre>
<pre>  dmi_t  dmi;</pre>
<pre>  assign dmi          = dmi_t'(dr_q);</pre>
<pre>  assign dmi_req.addr = address_q;</pre>
<pre>  assign dmi_req.data = data_q;</pre>
<pre>  assign dmi_req.op   = (state_q == Write) ? dm::DTM_WRITE : dm::DTM_READ;</pre>
<pre>  assign dmi_resp_ready = 1'b1;</pre>
<pre>  logic error_dmi_busy;</pre>
<pre>  dmi_error_e error_d, error_q;</pre>
<pre>  always_comb begin : p_fsm</pre>
<pre>    error_dmi_busy = 1'b0;</pre>
<pre>    state_d   = state_q;</pre>
<pre>    address_d = address_q;</pre>
<pre>    data_d    = data_q;</pre>
<pre>    error_d   = error_q;</pre>
<pre>    dmi_req_valid = 1'b0;</pre>
<pre>    unique case (state_q)</pre>
<pre>      Idle: begin</pre>
<pre>        if (dmi_access && update_dr && (error_q == DMINoError)) begin</pre>
<pre>          address_d = dmi.address;</pre>
<pre>          data_d = dmi.data;</pre>
<pre>          if (dm::dtm_op_e'(dmi.op) == dm::DTM_READ) begin</pre>
<pre>            state_d = Read;</pre>
<pre>          end else if (dm::dtm_op_e'(dmi.op) == dm::DTM_WRITE) begin</pre>
<pre>            state_d = Write;</pre>
<pre>      Read: begin</pre>
<pre>        dmi_req_valid = 1'b1;</pre>
<pre>        if (dmi_req_ready) begin</pre>
<pre>          state_d = WaitReadValid;</pre>
<pre>      WaitReadValid: begin</pre>
<pre>        if (dmi_resp_valid) begin</pre>
<pre>          data_d = dmi_resp.data;</pre>
<pre>          state_d = Idle;</pre>
<pre>      Write: begin</pre>
<pre>        dmi_req_valid = 1'b1;</pre>
<pre>        if (dmi_req_ready) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>      default: begin</pre>
<pre>        if (dmi_resp_valid) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>    if (update_dr && state_q != Idle) begin</pre>
<pre>      error_dmi_busy = 1'b1;</pre>
<pre>    if (capture_dr && state_q inside {Read, WaitReadValid}) begin</pre>
<pre>      error_dmi_busy = 1'b1;</pre>
<pre>    if (error_dmi_busy) begin</pre>
<pre>      error_d = DMIBusy;</pre>
<pre>    if (dmi_reset && dtmcs_select) begin</pre>
<pre>      error_d = DMINoError;</pre>
<pre>  assign dmi_tdo = dr_q[0];</pre>
<pre>  always_comb begin : p_shift</pre>
<pre>    dr_d    = dr_q;</pre>
<pre>    if (capture_dr) begin</pre>
<pre>      if (dmi_access) begin</pre>
<pre>        if (error_q == DMINoError && !error_dmi_busy) begin</pre>
<pre>          dr_d = {address_q, data_q, DMINoError};</pre>
<pre>        end else if (error_q == DMIBusy || error_dmi_busy) begin</pre>
<pre>          dr_d = {address_q, data_q, DMIBusy};</pre>
<pre>    if (shift_dr) begin</pre>
<pre>      if (dmi_access) begin</pre>
<pre>        dr_d = {dmi_tdi, dr_q[$bits(dr_q)-1:1]};</pre>
<pre>    if (test_logic_reset) begin</pre>
<pre>      dr_d = '0;</pre>
<pre>  always_ff @(posedge tck_i or negedge trst_ni) begin : p_regs</pre>
<pre>    if (!trst_ni) begin</pre>
<pre>      dr_q      <= '0;</pre>
<pre>      state_q   <= Idle;</pre>
<pre>      address_q <= '0;</pre>
<pre>      data_q    <= '0;</pre>
<pre>      error_q   <= DMINoError;</pre>
<pre>    end else begin</pre>
<pre>      dr_q      <= dr_d;</pre>
<pre>      state_q   <= state_d;</pre>
<pre>      address_q <= address_d;</pre>
<pre>      data_q    <= data_d;</pre>
<pre>      error_q   <= error_d;</pre>
<pre>  dmi_jtag_tap #(</pre>
<pre>    .IrLength (5),</pre>
<pre>    .IdcodeValue(IdcodeValue)</pre>
<pre style="background-color: #FF0000;">  ) i_dmi_jtag_tap (</pre>
<pre>    .tck_i,</pre>
<pre>    .tms_i,</pre>
<pre>    .trst_ni,</pre>
<pre>    .td_i,</pre>
<pre>    .td_o,</pre>
<pre>    .tdo_oe_o,</pre>
<pre>    .testmode_i,</pre>
<pre>    .test_logic_reset_o ( test_logic_reset ),</pre>
<pre>    .shift_dr_o         ( shift_dr         ),</pre>
<pre>    .update_dr_o        ( update_dr        ),</pre>
<pre>    .capture_dr_o       ( capture_dr       ),</pre>
<pre>    .dmi_access_o       ( dmi_access       ),</pre>
<pre>    .dtmcs_select_o     ( dtmcs_select     ),</pre>
<pre>    .dmi_reset_o        ( dmi_reset        ),</pre>
<pre>    .dmi_error_i        ( error_q          ),</pre>
<pre>    .dmi_tdi_o          ( dmi_tdi          ),</pre>
<pre>    .dmi_tdo_i          ( dmi_tdo          )</pre>
<pre>  dmi_cdc i_dmi_cdc (</pre>
<pre>    .tck_i,</pre>
<pre>    .trst_ni,</pre>
<pre>    .jtag_dmi_req_i    ( dmi_req          ),</pre>
<pre>    .jtag_dmi_ready_o  ( dmi_req_ready    ),</pre>
<pre>    .jtag_dmi_valid_i  ( dmi_req_valid    ),</pre>
<pre>    .jtag_dmi_resp_o   ( dmi_resp         ),</pre>
<pre>    .jtag_dmi_valid_o  ( dmi_resp_valid   ),</pre>
<pre>    .jtag_dmi_ready_i  ( dmi_resp_ready   ),</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .core_dmi_req_o    ( dmi_req_o        ),</pre>
<pre>    .core_dmi_valid_o  ( dmi_req_valid_o  ),</pre>
<pre>    .core_dmi_ready_i  ( dmi_req_ready_i  ),</pre>
<pre>    .core_dmi_resp_i   ( dmi_resp_i       ),</pre>
<pre>    .core_dmi_ready_o  ( dmi_resp_ready_o ),</pre>
<pre>    .core_dmi_valid_i  ( dmi_resp_valid_i )</pre>
<pre style="background-color: #FF0000;">endmodule : dmi_jtag</pre>
<h3>hw/vendor/pulp_riscv_dbg/src/dmi_cdc.sv</h3>
<pre>  input  logic             tck_i,</pre>
<pre>  input  logic             trst_ni,</pre>
<pre>  input  dm::dmi_req_t     jtag_dmi_req_i,</pre>
<pre>  output logic             jtag_dmi_ready_o,</pre>
<pre>  input  logic             jtag_dmi_valid_i,</pre>
<pre>  output dm::dmi_resp_t    jtag_dmi_resp_o,</pre>
<pre>  output logic             jtag_dmi_valid_o,</pre>
<pre>  input  logic             jtag_dmi_ready_i,</pre>
<pre>  input  logic             clk_i,</pre>
<pre>  input  logic             rst_ni,</pre>
<pre>  output dm::dmi_req_t     core_dmi_req_o,</pre>
<pre>  output logic             core_dmi_valid_o,</pre>
<pre>  input  logic             core_dmi_ready_i,</pre>
<pre>  input dm::dmi_resp_t     core_dmi_resp_i,</pre>
<pre>  output logic             core_dmi_ready_o,</pre>
<pre>  input  logic             core_dmi_valid_i</pre>
<pre>  prim_fifo_async #(</pre>
<pre>    .Width( $bits(dm::dmi_req_t) ),</pre>
<pre>    .Depth( 4 )</pre>
<pre style="background-color: #FF0000;">  ) i_cdc_req (</pre>
<pre>    .clk_wr_i    ( tck_i            ),</pre>
<pre>    .rst_wr_ni   ( trst_ni          ),</pre>
<pre>    .wvalid      ( jtag_dmi_valid_i ),</pre>
<pre>    .wready      ( jtag_dmi_ready_o ), // wrclk</pre>
<pre>    .wdata       ( jtag_dmi_req_i   ),</pre>
<pre>    .wdepth      (                  ),</pre>
<pre>    .clk_rd_i    ( clk_i            ),</pre>
<pre>    .rst_rd_ni   ( rst_ni           ),</pre>
<pre>    .rvalid      ( core_dmi_valid_o ),</pre>
<pre>    .rready      ( core_dmi_ready_i ),</pre>
<pre>    .rdata       ( core_dmi_req_o   ),</pre>
<pre>    .rdepth      (                  )</pre>
<pre>  prim_fifo_async #(</pre>
<pre>    .Width( $bits(dm::dmi_resp_t) ),</pre>
<pre>    .Depth( 4 )</pre>
<pre style="background-color: #FF0000;">  ) i_cdc_resp (</pre>
<pre>    .clk_wr_i    ( clk_i            ),</pre>
<pre>    .rst_wr_ni   ( rst_ni           ),</pre>
<pre>    .wvalid      ( core_dmi_valid_i ),</pre>
<pre>    .wready      ( core_dmi_ready_o ), // wrclk</pre>
<pre>    .wdata       ( core_dmi_resp_i  ),</pre>
<pre>    .wdepth      (                  ),</pre>
<pre>    .clk_rd_i    ( tck_i            ),</pre>
<pre>    .rst_rd_ni   ( trst_ni          ),</pre>
<pre>    .rvalid      ( jtag_dmi_valid_o ),</pre>
<pre>    .rready      ( jtag_dmi_ready_i ),</pre>
<pre>    .rdata       ( jtag_dmi_resp_o  ),</pre>
<pre>    .rdepth      (                  )</pre>
<pre style="background-color: #FF0000;">endmodule : dmi_cdc</pre>
<h3>hw/vendor/pulp_riscv_dbg/src/dm_sba.sv</h3>
<pre>module dm_sba #(</pre>
<pre>  parameter int unsigned BusWidth = 32</pre>
<pre>  input  logic                   clk_i,       // Clock</pre>
<pre>  input  logic                   rst_ni,</pre>
<pre>  input  logic                   dmactive_i,  // synchronous reset active low</pre>
<pre>  output logic                   master_req_o,</pre>
<pre>  output logic [BusWidth-1:0]    master_add_o,</pre>
<pre>  output logic                   master_we_o,</pre>
<pre>  output logic [BusWidth-1:0]    master_wdata_o,</pre>
<pre>  output logic [BusWidth/8-1:0]  master_be_o,</pre>
<pre>  input  logic                   master_gnt_i,</pre>
<pre>  input  logic                   master_r_valid_i,</pre>
<pre>  input  logic [BusWidth-1:0]    master_r_rdata_i,</pre>
<pre>  input  logic [BusWidth-1:0]    sbaddress_i,</pre>
<pre>  input  logic                   sbaddress_write_valid_i,</pre>
<pre>  input  logic                   sbreadonaddr_i,</pre>
<pre>  output logic [BusWidth-1:0]    sbaddress_o,</pre>
<pre>  input  logic                   sbautoincrement_i,</pre>
<pre>  input  logic [2:0]             sbaccess_i,</pre>
<pre>  input  logic                   sbreadondata_i,</pre>
<pre>  input  logic [BusWidth-1:0]    sbdata_i,</pre>
<pre>  input  logic                   sbdata_read_valid_i,</pre>
<pre>  input  logic                   sbdata_write_valid_i,</pre>
<pre>  output logic [BusWidth-1:0]    sbdata_o,</pre>
<pre>  output logic                   sbdata_valid_o,</pre>
<pre>  output logic                   sbbusy_o,</pre>
<pre>  output logic                   sberror_valid_o, // bus error occurred</pre>
<pre>  output logic [2:0]             sberror_o // bus error occurred</pre>
<pre>  typedef enum logic [2:0] { Idle, Read, Write, WaitRead, WaitWrite } state_e;</pre>
<pre>  state_e state_d, state_q;</pre>
<pre>  logic [BusWidth-1:0]           address;</pre>
<pre>  logic                          req;</pre>
<pre>  logic                          gnt;</pre>
<pre>  logic                          we;</pre>
<pre>  logic [BusWidth/8-1:0]         be;</pre>
<pre>  logic [$clog2(BusWidth/8)-1:0] be_idx;</pre>
<pre>  assign sbbusy_o = logic'(state_q != Idle);</pre>
<pre>  always_comb begin : p_fsm</pre>
<pre>    req     = 1'b0;</pre>
<pre>    address = sbaddress_i;</pre>
<pre>    we      = 1'b0;</pre>
<pre>    be      = '0;</pre>
<pre>    be_idx  = sbaddress_i[$clog2(BusWidth/8)-1:0];</pre>
<pre>    sberror_o       = '0;</pre>
<pre>    sberror_valid_o = 1'b0;</pre>
<pre>    sbaddress_o     = sbaddress_i;</pre>
<pre>    state_d = state_q;</pre>
<pre>    unique case (state_q)</pre>
<pre>      Idle: begin</pre>
<pre>        if (sbaddress_write_valid_i && sbreadonaddr_i)  state_d = Read;</pre>
<pre>        if (sbdata_write_valid_i) state_d = Write;</pre>
<pre>        if (sbdata_read_valid_i && sbreadondata_i) state_d = Read;</pre>
<pre>      Read: begin</pre>
<pre>        req = 1'b1;</pre>
<pre>        if (gnt) state_d = WaitRead;</pre>
<pre>      Write: begin</pre>
<pre>        req = 1'b1;</pre>
<pre>        we  = 1'b1;</pre>
<pre>        unique case (sbaccess_i)</pre>
<pre>          3'b000: begin</pre>
<pre>            be[be_idx] = '1;</pre>
<pre>          3'b001: begin</pre>
<pre>            be[int'({be_idx[$high(be_idx):1], 1'b0}) +: 2] = '1;</pre>
<pre>          3'b010: begin</pre>
<pre>            if (BusWidth == 32'd64) be[int'({be_idx[$high(be_idx)], 2'b0}) +: 4] = '1;</pre>
<pre>            else                    be = '1;</pre>
<pre>          3'b011: be = '1;</pre>
<pre>          default: ;</pre>
<pre>        if (gnt) state_d = WaitWrite;</pre>
<pre>      WaitRead: begin</pre>
<pre>        if (sbdata_valid_o) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          if (sbautoincrement_i) sbaddress_o = sbaddress_i + (32'b1 << sbaccess_i);</pre>
<pre>      WaitWrite: begin</pre>
<pre>        if (sbdata_valid_o) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          if (sbautoincrement_i) sbaddress_o = sbaddress_i + (32'b1 << sbaccess_i);</pre>
<pre>      default: state_d = Idle; // catch parasitic state</pre>
<pre>    if (sbaccess_i > 3 && state_q != Idle) begin</pre>
<pre>      req             = 1'b0;</pre>
<pre>      state_d         = Idle;</pre>
<pre>      sberror_valid_o = 1'b1;</pre>
<pre>      sberror_o       = 3'd3;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      state_q <= Idle;</pre>
<pre>    end else begin</pre>
<pre>      state_q <= state_d;</pre>
<pre>  assign master_req_o    = req;</pre>
<pre>  assign master_add_o    = address[BusWidth-1:0];</pre>
<pre>  assign master_we_o     = we;</pre>
<pre>  assign master_wdata_o  = sbdata_i[BusWidth-1:0];</pre>
<pre>  assign master_be_o     = be[BusWidth/8-1:0];</pre>
<pre>  assign gnt             = master_gnt_i;</pre>
<pre>  assign sbdata_valid_o  = master_r_valid_i;</pre>
<pre>  assign sbdata_o        = master_r_rdata_i[BusWidth-1:0];</pre>
<pre style="background-color: #FF0000;">    dm_sba_access_size: assert property(@(posedge clk_i) disable iff (dmactive_i !== 1'b0)</pre>
<pre style="background-color: #FF0000;">        (state_d != Idle) |-> (sbaccess_i < 4))</pre>
<pre style="background-color: #FF0000;">            else $warning ("accesses > 8 byte not supported at the moment");</pre>
<pre style="background-color: #FF0000;">endmodule : dm_sba</pre>
<h3>hw/vendor/pulp_riscv_dbg/src/dm_csrs.sv</h3>
<pre>module dm_csrs #(</pre>
<pre>  parameter int unsigned        NrHarts          = 1,</pre>
<pre>  parameter int unsigned        BusWidth         = 32,</pre>
<pre>  parameter logic [NrHarts-1:0] SelectableHarts  = {NrHarts{1'b1}}</pre>
<pre>  input  logic                              clk_i,           // Clock</pre>
<pre>  input  logic                              rst_ni,          // Asynchronous reset active low</pre>
<pre>  input  logic                              testmode_i,</pre>
<pre>  input  logic                              dmi_rst_ni,      // Debug Module Intf reset active-low</pre>
<pre>  input  logic                              dmi_req_valid_i,</pre>
<pre>  output logic                              dmi_req_ready_o,</pre>
<pre>  input  dm::dmi_req_t                      dmi_req_i,</pre>
<pre>  output logic                              dmi_resp_valid_o,</pre>
<pre>  input  logic                              dmi_resp_ready_i,</pre>
<pre>  output dm::dmi_resp_t                     dmi_resp_o,</pre>
<pre>  output logic                              ndmreset_o,      // non-debug module reset active-high</pre>
<pre>  output logic                              dmactive_o,      // 1 -> debug-module is active,</pre>
<pre>  input  dm::hartinfo_t [NrHarts-1:0]       hartinfo_i,      // static hartinfo</pre>
<pre>  input  logic [NrHarts-1:0]                halted_i,        // hart is halted</pre>
<pre>  input  logic [NrHarts-1:0]                unavailable_i,   // e.g.: powered down</pre>
<pre>  input  logic [NrHarts-1:0]                resumeack_i,     // hart acknowledged resume request</pre>
<pre>  output logic [19:0]                       hartsel_o,       // hartselect to ctrl module</pre>
<pre>  output logic [NrHarts-1:0]                haltreq_o,       // request to halt a hart</pre>
<pre>  output logic [NrHarts-1:0]                resumereq_o,     // request hart to resume</pre>
<pre>  output logic                              clear_resumeack_o,</pre>
<pre>  output logic                              cmd_valid_o,       // debugger writing to cmd field</pre>
<pre>  output dm::command_t                      cmd_o,             // abstract command</pre>
<pre>  input  logic                              cmderror_valid_i,  // an error occured</pre>
<pre>  input  dm::cmderr_e                       cmderror_i,        // this error occured</pre>
<pre>  input  logic                              cmdbusy_i,         // cmd is currently busy executing</pre>
<pre>  output logic [dm::ProgBufSize-1:0][31:0]  progbuf_o, // to system bus</pre>
<pre>  output logic [dm::DataCount-1:0][31:0]    data_o,</pre>
<pre>  input  logic [dm::DataCount-1:0][31:0]    data_i,</pre>
<pre>  input  logic                              data_valid_i,</pre>
<pre>  output logic [BusWidth-1:0]               sbaddress_o,</pre>
<pre>  input  logic [BusWidth-1:0]               sbaddress_i,</pre>
<pre>  output logic                              sbaddress_write_valid_o,</pre>
<pre>  output logic                              sbreadonaddr_o,</pre>
<pre>  output logic                              sbautoincrement_o,</pre>
<pre>  output logic [2:0]                        sbaccess_o,</pre>
<pre>  output logic                              sbreadondata_o,</pre>
<pre>  output logic [BusWidth-1:0]               sbdata_o,</pre>
<pre>  output logic                              sbdata_read_valid_o,</pre>
<pre>  output logic                              sbdata_write_valid_o,</pre>
<pre>  input  logic [BusWidth-1:0]               sbdata_i,</pre>
<pre>  input  logic                              sbdata_valid_i,</pre>
<pre>  input  logic                              sbbusy_i,</pre>
<pre>  input  logic                              sberror_valid_i, // bus error occurred</pre>
<pre>  input  logic [2:0]                        sberror_i // bus error occurred</pre>
<pre>  localparam int unsigned HartSelLen = (NrHarts == 1) ? 1 : $clog2(NrHarts);</pre>
<pre>  localparam int unsigned NrHartsAligned = 2**HartSelLen;</pre>
<pre>  dm::dtm_op_e dtm_op;</pre>
<pre>  assign dtm_op = dm::dtm_op_e'(dmi_req_i.op);</pre>
<pre>  logic [31:0] resp_queue_data;</pre>
<pre>  localparam dm::dm_csr_e DataEnd = dm::dm_csr_e'((dm::Data0 + {4'b0, dm::DataCount}));</pre>
<pre>  localparam dm::dm_csr_e ProgBufEnd = dm::dm_csr_e'((dm::ProgBuf0 + {4'b0, dm::ProgBufSize}));</pre>
<pre>  logic [31:0] haltsum0, haltsum1, haltsum2, haltsum3;</pre>
<pre>  logic [((NrHarts-1)/2**5 + 1) * 32 - 1 : 0] halted;</pre>
<pre>  logic [(NrHarts-1)/2**5:0][31:0] halted_reshaped0;</pre>
<pre>  logic [NrHarts/2**10:0][31:0] halted_reshaped1;</pre>
<pre>  logic [NrHarts/2**15:0][31:0] halted_reshaped2;</pre>
<pre>  logic [(NrHarts/2**10+1)*32-1:0] halted_flat1;</pre>
<pre>  logic [(NrHarts/2**15+1)*32-1:0] halted_flat2;</pre>
<pre>  logic [32-1:0] halted_flat3;</pre>
<pre>  logic [14:0] hartsel_idx0;</pre>
<pre>  always_comb begin : p_haltsum0</pre>
<pre>    halted              = '0;</pre>
<pre>    haltsum0            = '0;</pre>
<pre>    hartsel_idx0        = hartsel_o[19:5];</pre>
<pre>    halted[NrHarts-1:0] = halted_i;</pre>
<pre>    halted_reshaped0    = halted;</pre>
<pre>    if (hartsel_idx0 < 15'((NrHarts-1)/2**5+1)) begin</pre>
<pre>      haltsum0 = halted_reshaped0[hartsel_idx0];</pre>
<pre>  logic [9:0] hartsel_idx1;</pre>
<pre>  always_comb begin : p_reduction1</pre>
<pre>    halted_flat1 = '0;</pre>
<pre>    haltsum1     = '0;</pre>
<pre>    hartsel_idx1 = hartsel_o[19:10];</pre>
<pre>    for (int unsigned k = 0; k < NrHarts/2**5+1; k++) begin</pre>
<pre>      halted_flat1[k] = |halted_reshaped0[k];</pre>
<pre>    halted_reshaped1 = halted_flat1;</pre>
<pre>    if (hartsel_idx1 < 10'((NrHarts/2**10+1))) begin</pre>
<pre>      haltsum1 = halted_reshaped1[hartsel_idx1];</pre>
<pre>  logic [4:0] hartsel_idx2;</pre>
<pre>  always_comb begin : p_reduction2</pre>
<pre>    halted_flat2 = '0;</pre>
<pre>    haltsum2     = '0;</pre>
<pre>    hartsel_idx2 = hartsel_o[19:15];</pre>
<pre>    for (int unsigned k = 0; k < NrHarts/2**10+1; k++) begin</pre>
<pre>      halted_flat2[k] = |halted_reshaped1[k];</pre>
<pre>    halted_reshaped2 = halted_flat2;</pre>
<pre>    if (hartsel_idx2 < 5'((NrHarts/2**15+1))) begin</pre>
<pre>      haltsum2         = halted_reshaped2[hartsel_idx2];</pre>
<pre>  always_comb begin : p_reduction3</pre>
<pre>    halted_flat3 = '0;</pre>
<pre>    for (int unsigned k = 0; k < NrHarts/2**15+1; k++) begin</pre>
<pre>      halted_flat3[k] = |halted_reshaped2[k];</pre>
<pre>    haltsum3 = halted_flat3;</pre>
<pre>  dm::dmstatus_t      dmstatus;</pre>
<pre>  dm::dmcontrol_t     dmcontrol_d, dmcontrol_q;</pre>
<pre>  dm::abstractcs_t    abstractcs;</pre>
<pre>  dm::cmderr_e        cmderr_d, cmderr_q;</pre>
<pre>  dm::command_t       command_d, command_q;</pre>
<pre>  logic               cmd_valid_d, cmd_valid_q;</pre>
<pre>  dm::abstractauto_t  abstractauto_d, abstractauto_q;</pre>
<pre>  dm::sbcs_t          sbcs_d, sbcs_q;</pre>
<pre>  logic [63:0]        sbaddr_d, sbaddr_q;</pre>
<pre>  logic [63:0]        sbdata_d, sbdata_q;</pre>
<pre>  logic [NrHarts-1:0] havereset_d, havereset_q;</pre>
<pre>  logic [dm::ProgBufSize-1:0][31:0] progbuf_d, progbuf_q;</pre>
<pre>  logic [dm::DataCount-1:0][31:0] data_d, data_q;</pre>
<pre>  logic [HartSelLen-1:0] selected_hart;</pre>
<pre>  assign dmi_resp_o.resp = dm::DTM_SUCCESS;</pre>
<pre>  assign sbautoincrement_o = sbcs_q.sbautoincrement;</pre>
<pre>  assign sbreadonaddr_o    = sbcs_q.sbreadonaddr;</pre>
<pre>  assign sbreadondata_o    = sbcs_q.sbreadondata;</pre>
<pre>  assign sbaccess_o        = sbcs_q.sbaccess;</pre>
<pre>  assign sbdata_o          = sbdata_q[BusWidth-1:0];</pre>
<pre>  assign sbaddress_o       = sbaddr_q[BusWidth-1:0];</pre>
<pre>  assign hartsel_o         = {dmcontrol_q.hartselhi, dmcontrol_q.hartsello};</pre>
<pre>  logic [NrHartsAligned-1:0] havereset_d_aligned, havereset_q_aligned,</pre>
<pre>                             resumeack_aligned, unavailable_aligned,</pre>
<pre>                             halted_aligned;</pre>
<pre>  assign resumeack_aligned   = NrHartsAligned'(resumeack_i);</pre>
<pre>  assign unavailable_aligned = NrHartsAligned'(unavailable_i);</pre>
<pre>  assign halted_aligned      = NrHartsAligned'(halted_i);</pre>
<pre>  assign havereset_d         = NrHarts'(havereset_d_aligned);</pre>
<pre>  assign havereset_q_aligned = NrHartsAligned'(havereset_q);</pre>
<pre>  dm::hartinfo_t [NrHartsAligned-1:0] hartinfo_aligned;</pre>
<pre>  always_comb begin : p_hartinfo_align</pre>
<pre>    hartinfo_aligned = '0;</pre>
<pre>    hartinfo_aligned[NrHarts-1:0] = hartinfo_i;</pre>
<pre>  dm::sbcs_t sbcs;</pre>
<pre>  dm::dmcontrol_t dmcontrol;</pre>
<pre>  dm::abstractcs_t a_abstractcs;</pre>
<pre>  logic [4:0] autoexecdata_idx;</pre>
<pre>  always_comb begin : csr_read_write</pre>
<pre>    dmstatus    = '0;</pre>
<pre>    dmstatus.version = dm::DbgVersion013;</pre>
<pre>    dmstatus.authenticated = 1'b1;</pre>
<pre>    dmstatus.hasresethaltreq = 1'b0;</pre>
<pre>    dmstatus.allhavereset = havereset_q_aligned[selected_hart];</pre>
<pre>    dmstatus.anyhavereset = havereset_q_aligned[selected_hart];</pre>
<pre>    dmstatus.allresumeack = resumeack_aligned[selected_hart];</pre>
<pre>    dmstatus.anyresumeack = resumeack_aligned[selected_hart];</pre>
<pre>    dmstatus.allunavail   = unavailable_aligned[selected_hart];</pre>
<pre>    dmstatus.anyunavail   = unavailable_aligned[selected_hart];</pre>
<pre>    dmstatus.allnonexistent = logic'(32'(hartsel_o) > (NrHarts - 1));</pre>
<pre>    dmstatus.anynonexistent = logic'(32'(hartsel_o) > (NrHarts - 1));</pre>
<pre>    dmstatus.allhalted    = halted_aligned[selected_hart] & ~unavailable_aligned[selected_hart];</pre>
<pre>    dmstatus.anyhalted    = halted_aligned[selected_hart] & ~unavailable_aligned[selected_hart];</pre>
<pre>    dmstatus.allrunning   = ~halted_aligned[selected_hart] & ~unavailable_aligned[selected_hart];</pre>
<pre>    dmstatus.anyrunning   = ~halted_aligned[selected_hart] & ~unavailable_aligned[selected_hart];</pre>
<pre>    abstractcs = '0;</pre>
<pre>    abstractcs.datacount = dm::DataCount;</pre>
<pre>    abstractcs.progbufsize = dm::ProgBufSize;</pre>
<pre>    abstractcs.busy = cmdbusy_i;</pre>
<pre>    abstractcs.cmderr = cmderr_q;</pre>
<pre>    abstractauto_d = abstractauto_q;</pre>
<pre>    abstractauto_d.zero0 = '0;</pre>
<pre>    havereset_d_aligned = NrHartsAligned'(havereset_q);</pre>
<pre>    dmcontrol_d         = dmcontrol_q;</pre>
<pre>    cmderr_d            = cmderr_q;</pre>
<pre>    command_d           = command_q;</pre>
<pre>    progbuf_d           = progbuf_q;</pre>
<pre>    data_d              = data_q;</pre>
<pre>    sbcs_d              = sbcs_q;</pre>
<pre>    sbaddr_d            = 64'(sbaddress_i);</pre>
<pre>    sbdata_d            = sbdata_q;</pre>
<pre>    resp_queue_data         = 32'b0;</pre>
<pre>    cmd_valid_d             = 1'b0;</pre>
<pre>    sbaddress_write_valid_o = 1'b0;</pre>
<pre>    sbdata_read_valid_o     = 1'b0;</pre>
<pre>    sbdata_write_valid_o    = 1'b0;</pre>
<pre>    clear_resumeack_o       = 1'b0;</pre>
<pre>    sbcs         = '0;</pre>
<pre>    dmcontrol    = '0;</pre>
<pre>    a_abstractcs = '0;</pre>
<pre>    autoexecdata_idx    = dmi_req_i.addr[4:0] - 5'(dm::Data0);</pre>
<pre>    if (dmi_req_ready_o && dmi_req_valid_i && dtm_op == dm::DTM_READ) begin</pre>
<pre>      unique case ({1'b0, dmi_req_i.addr}) inside</pre>
<pre>        [(dm::Data0):DataEnd]: begin</pre>
<pre>          resp_queue_data = data_q[$clog2(dm::DataCount)'(autoexecdata_idx)];</pre>
<pre>          if (!cmdbusy_i) begin</pre>
<pre>            if (autoexecdata_idx < $bits(abstractauto_q.autoexecdata)) begin</pre>
<pre>              cmd_valid_d = abstractauto_q.autoexecdata[autoexecdata_idx];</pre>
<pre>        dm::DMControl:    resp_queue_data = dmcontrol_q;</pre>
<pre>        dm::DMStatus:     resp_queue_data = dmstatus;</pre>
<pre>        dm::Hartinfo:     resp_queue_data = hartinfo_aligned[selected_hart];</pre>
<pre>        dm::AbstractCS:   resp_queue_data = abstractcs;</pre>
<pre>        dm::AbstractAuto: resp_queue_data = abstractauto_q;</pre>
<pre>        dm::Command:    resp_queue_data = '0;</pre>
<pre>        [(dm::ProgBuf0):ProgBufEnd]: begin</pre>
<pre>          resp_queue_data = progbuf_q[dmi_req_i.addr[$clog2(dm::ProgBufSize)-1:0]];</pre>
<pre>          if (!cmdbusy_i) begin</pre>
<pre>            cmd_valid_d = abstractauto_q.autoexecprogbuf[{1'b1, dmi_req_i.addr[3:0]}];</pre>
<pre>        dm::HaltSum0: resp_queue_data = haltsum0;</pre>
<pre>        dm::HaltSum1: resp_queue_data = haltsum1;</pre>
<pre>        dm::HaltSum2: resp_queue_data = haltsum2;</pre>
<pre>        dm::HaltSum3: resp_queue_data = haltsum3;</pre>
<pre>        dm::SBCS: begin</pre>
<pre>          resp_queue_data = sbcs_q;</pre>
<pre>        dm::SBAddress0: begin</pre>
<pre>          if (sbbusy_i) begin</pre>
<pre>            sbcs_d.sbbusyerror = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            resp_queue_data = sbaddr_q[31:0];</pre>
<pre>        dm::SBAddress1: begin</pre>
<pre>          if (sbbusy_i) begin</pre>
<pre>            sbcs_d.sbbusyerror = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            resp_queue_data = sbaddr_q[63:32];</pre>
<pre>        dm::SBData0: begin</pre>
<pre>          if (sbbusy_i) begin</pre>
<pre>            sbcs_d.sbbusyerror = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            sbdata_read_valid_o = (sbcs_q.sberror == '0);</pre>
<pre>            resp_queue_data = sbdata_q[31:0];</pre>
<pre>        dm::SBData1: begin</pre>
<pre>          if (sbbusy_i) begin</pre>
<pre>            sbcs_d.sbbusyerror = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            resp_queue_data = sbdata_q[63:32];</pre>
<pre>        default:;</pre>
<pre>    if (dmi_req_ready_o && dmi_req_valid_i && dtm_op == dm::DTM_WRITE) begin</pre>
<pre>      unique case (dm::dm_csr_e'({1'b0, dmi_req_i.addr})) inside</pre>
<pre>        [(dm::Data0):DataEnd]: begin</pre>
<pre>          if (!cmdbusy_i && dm::DataCount > 0) begin</pre>
<pre>            data_d[dmi_req_i.addr[$clog2(dm::DataCount)-1:0]] = dmi_req_i.data;</pre>
<pre>            if (autoexecdata_idx < $bits(abstractauto_q.autoexecdata)) begin</pre>
<pre>              cmd_valid_d = abstractauto_q.autoexecdata[autoexecdata_idx];</pre>
<pre>        dm::DMControl: begin</pre>
<pre>          dmcontrol = dm::dmcontrol_t'(dmi_req_i.data);</pre>
<pre>          if (dmcontrol.ackhavereset) begin</pre>
<pre>            havereset_d_aligned[selected_hart] = 1'b0;</pre>
<pre>          dmcontrol_d = dmi_req_i.data;</pre>
<pre>        dm::DMStatus:; // write are ignored to R/O register</pre>
<pre>        dm::Hartinfo:; // hartinfo is R/O</pre>
<pre>        dm::AbstractCS: begin // W1C</pre>
<pre>          a_abstractcs = dm::abstractcs_t'(dmi_req_i.data);</pre>
<pre>          if (!cmdbusy_i) begin</pre>
<pre>            cmderr_d = dm::cmderr_e'(~a_abstractcs.cmderr & cmderr_q);</pre>
<pre>          end else if (cmderr_q == dm::CmdErrNone) begin</pre>
<pre>            cmderr_d = dm::CmdErrBusy;</pre>
<pre>        dm::Command: begin</pre>
<pre>          if (!cmdbusy_i) begin</pre>
<pre>            cmd_valid_d = 1'b1;</pre>
<pre>            command_d = dm::command_t'(dmi_req_i.data);</pre>
<pre>          end else if (cmderr_q == dm::CmdErrNone) begin</pre>
<pre>            cmderr_d = dm::CmdErrBusy;</pre>
<pre>        dm::AbstractAuto: begin</pre>
<pre>          if (!cmdbusy_i) begin</pre>
<pre>            abstractauto_d                 = 32'b0;</pre>
<pre>            abstractauto_d.autoexecdata    = 12'(dmi_req_i.data[dm::DataCount-1:0]);</pre>
<pre>            abstractauto_d.autoexecprogbuf = 16'(dmi_req_i.data[dm::ProgBufSize-1+16:16]);</pre>
<pre>          end else if (cmderr_q == dm::CmdErrNone) begin</pre>
<pre>            cmderr_d = dm::CmdErrBusy;</pre>
<pre>        [(dm::ProgBuf0):ProgBufEnd]: begin</pre>
<pre>          if (!cmdbusy_i) begin</pre>
<pre>            progbuf_d[dmi_req_i.addr[$clog2(dm::ProgBufSize)-1:0]] = dmi_req_i.data;</pre>
<pre>            cmd_valid_d = abstractauto_q.autoexecprogbuf[{1'b1, dmi_req_i.addr[3:0]}];</pre>
<pre>        dm::SBCS: begin</pre>
<pre>          if (sbbusy_i) begin</pre>
<pre>            sbcs_d.sbbusyerror = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            sbcs = dm::sbcs_t'(dmi_req_i.data);</pre>
<pre>            sbcs_d = sbcs;</pre>
<pre>            sbcs_d.sbbusyerror = sbcs_q.sbbusyerror & (~sbcs.sbbusyerror);</pre>
<pre>            sbcs_d.sberror     = sbcs_q.sberror     & (~sbcs.sberror);</pre>
<pre>        dm::SBAddress0: begin</pre>
<pre>          if (sbbusy_i) begin</pre>
<pre>            sbcs_d.sbbusyerror = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            sbaddr_d[31:0] = dmi_req_i.data;</pre>
<pre>            sbaddress_write_valid_o = (sbcs_q.sberror == '0);</pre>
<pre>        dm::SBAddress1: begin</pre>
<pre>          if (sbbusy_i) begin</pre>
<pre>            sbcs_d.sbbusyerror = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            sbaddr_d[63:32] = dmi_req_i.data;</pre>
<pre>        dm::SBData0: begin</pre>
<pre>          if (sbbusy_i) begin</pre>
<pre>           sbcs_d.sbbusyerror = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            sbdata_d[31:0] = dmi_req_i.data;</pre>
<pre>            sbdata_write_valid_o = (sbcs_q.sberror == '0);</pre>
<pre>        dm::SBData1: begin</pre>
<pre>          if (sbbusy_i) begin</pre>
<pre>           sbcs_d.sbbusyerror = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            sbdata_d[63:32] = dmi_req_i.data;</pre>
<pre>        default:;</pre>
<pre>    if (cmderror_valid_i) begin</pre>
<pre>      cmderr_d = cmderror_i;</pre>
<pre>    if (data_valid_i) begin</pre>
<pre>      data_d = data_i;</pre>
<pre>    if (ndmreset_o) begin</pre>
<pre>      havereset_d_aligned[NrHarts-1:0] = '1;</pre>
<pre>    if (sberror_valid_i) begin</pre>
<pre>      sbcs_d.sberror = sberror_i;</pre>
<pre>    if (sbdata_valid_i) begin</pre>
<pre>      sbdata_d = 64'(sbdata_i);</pre>
<pre>    dmcontrol_d.hasel           = 1'b0;</pre>
<pre>    dmcontrol_d.hartreset       = 1'b0;</pre>
<pre>    dmcontrol_d.setresethaltreq = 1'b0;</pre>
<pre>    dmcontrol_d.clrresethaltreq = 1'b0;</pre>
<pre>    dmcontrol_d.zero1           = '0;</pre>
<pre>    dmcontrol_d.zero0           = '0;</pre>
<pre>    dmcontrol_d.ackhavereset    = 1'b0;</pre>
<pre>    if (!dmcontrol_q.resumereq && dmcontrol_d.resumereq) begin</pre>
<pre>      clear_resumeack_o = 1'b1;</pre>
<pre>    if (dmcontrol_q.resumereq && resumeack_i) begin</pre>
<pre>      dmcontrol_d.resumereq = 1'b0;</pre>
<pre>    sbcs_d.sbversion            = 3'b1;</pre>
<pre>    sbcs_d.sbbusy               = sbbusy_i;</pre>
<pre>    sbcs_d.sbasize              = $bits(sbcs_d.sbasize)'(BusWidth);</pre>
<pre>    sbcs_d.sbaccess128          = 1'b0;</pre>
<pre>    sbcs_d.sbaccess64           = logic'(BusWidth == 32'd64);</pre>
<pre>    sbcs_d.sbaccess32           = logic'(BusWidth == 32'd32);</pre>
<pre>    sbcs_d.sbaccess16           = 1'b0;</pre>
<pre>    sbcs_d.sbaccess8            = 1'b0;</pre>
<pre>    sbcs_d.sbaccess             = (BusWidth == 32'd64) ? 3'd3 : 3'd2;</pre>
<pre>  always_comb begin : p_outmux</pre>
<pre>    selected_hart = hartsel_o[HartSelLen-1:0];</pre>
<pre>    haltreq_o = '0;</pre>
<pre>    resumereq_o = '0;</pre>
<pre>    if (selected_hart < (HartSelLen+1)'(NrHarts)) begin</pre>
<pre>      haltreq_o[selected_hart]   = dmcontrol_q.haltreq;</pre>
<pre>      resumereq_o[selected_hart] = dmcontrol_q.resumereq;</pre>
<pre>  assign dmactive_o  = dmcontrol_q.dmactive;</pre>
<pre>  assign cmd_o       = command_q;</pre>
<pre>  assign cmd_valid_o = cmd_valid_q;</pre>
<pre>  assign progbuf_o   = progbuf_q;</pre>
<pre>  assign data_o      = data_q;</pre>
<pre>  assign ndmreset_o = dmcontrol_q.ndmreset;</pre>
<pre>  logic unused_testmode;</pre>
<pre>  assign unused_testmode = testmode_i;</pre>
<pre>  prim_fifo_sync #(</pre>
<pre>    .Width (32),</pre>
<pre>    .Pass  (1'b0),</pre>
<pre>    .Depth (2)</pre>
<pre style="background-color: #FF0000;">  ) i_fifo (</pre>
<pre>    .clk_i   ( clk_i                ),</pre>
<pre>    .rst_ni  ( dmi_rst_ni           ), // reset only when system is re-set</pre>
<pre>    .clr_i   ( 1'b0                 ),</pre>
<pre>    .wdata   ( resp_queue_data      ),</pre>
<pre>    .wvalid  ( dmi_req_valid_i      ),</pre>
<pre>    .wready  ( dmi_req_ready_o      ),</pre>
<pre>    .rdata   ( dmi_resp_o.data      ),</pre>
<pre>    .rvalid  ( dmi_resp_valid_o     ),</pre>
<pre>    .rready  ( dmi_resp_ready_i     ),</pre>
<pre>    .depth   (                      )  // Doesn't use</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      dmcontrol_q    <= '0;</pre>
<pre>      cmderr_q       <= dm::CmdErrNone;</pre>
<pre>      command_q      <= '0;</pre>
<pre>      abstractauto_q <= '0;</pre>
<pre>      progbuf_q      <= '0;</pre>
<pre>      data_q         <= '0;</pre>
<pre>      sbcs_q         <= '0;</pre>
<pre>      sbaddr_q       <= '0;</pre>
<pre>      sbdata_q       <= '0;</pre>
<pre>      havereset_q    <= '1;</pre>
<pre>    end else begin</pre>
<pre>      havereset_q    <= SelectableHarts & havereset_d;</pre>
<pre>      if (!dmcontrol_q.dmactive) begin</pre>
<pre>        dmcontrol_q.haltreq          <= '0;</pre>
<pre>        dmcontrol_q.resumereq        <= '0;</pre>
<pre>        dmcontrol_q.hartreset        <= '0;</pre>
<pre>        dmcontrol_q.ackhavereset     <= '0;</pre>
<pre>        dmcontrol_q.zero1            <= '0;</pre>
<pre>        dmcontrol_q.hasel            <= '0;</pre>
<pre>        dmcontrol_q.hartsello        <= '0;</pre>
<pre>        dmcontrol_q.hartselhi        <= '0;</pre>
<pre>        dmcontrol_q.zero0            <= '0;</pre>
<pre>        dmcontrol_q.setresethaltreq  <= '0;</pre>
<pre>        dmcontrol_q.clrresethaltreq  <= '0;</pre>
<pre>        dmcontrol_q.ndmreset         <= '0;</pre>
<pre>        dmcontrol_q.dmactive         <= dmcontrol_d.dmactive;</pre>
<pre>        cmderr_q                     <= dm::CmdErrNone;</pre>
<pre>        command_q                    <= '0;</pre>
<pre>        cmd_valid_q                  <= '0;</pre>
<pre>        abstractauto_q               <= '0;</pre>
<pre>        progbuf_q                    <= '0;</pre>
<pre>        data_q                       <= '0;</pre>
<pre>        sbcs_q                       <= '0;</pre>
<pre>        sbaddr_q                     <= '0;</pre>
<pre>        sbdata_q                     <= '0;</pre>
<pre>      end else begin</pre>
<pre>        dmcontrol_q                  <= dmcontrol_d;</pre>
<pre>        cmderr_q                     <= cmderr_d;</pre>
<pre>        command_q                    <= command_d;</pre>
<pre>        cmd_valid_q                  <= cmd_valid_d;</pre>
<pre>        abstractauto_q               <= abstractauto_d;</pre>
<pre>        progbuf_q                    <= progbuf_d;</pre>
<pre>        data_q                       <= data_d;</pre>
<pre>        sbcs_q                       <= sbcs_d;</pre>
<pre>        sbaddr_q                     <= sbaddr_d;</pre>
<pre>        sbdata_q                     <= sbdata_d;</pre>
<pre style="background-color: #FF0000;">  haltsum: assert property (</pre>
<pre style="background-color: #FF0000;">      @(posedge clk_i) disable iff (!rst_ni)</pre>
<pre style="background-color: #FF0000;">          (dmi_req_ready_o && dmi_req_valid_i && dtm_op == dm::DTM_READ) |-></pre>
<pre style="background-color: #FF0000;">              !({1'b0, dmi_req_i.addr} inside</pre>
<pre style="background-color: #FF0000;">                  {dm::HaltSum0, dm::HaltSum1, dm::HaltSum2, dm::HaltSum3}))</pre>
<pre style="background-color: #FF0000;">      else $warning("Haltsums have not been properly tested yet.");</pre>
<pre style="background-color: #FF0000;">endmodule : dm_csrs</pre>
<h3>hw/vendor/pulp_riscv_dbg/src/dmi_jtag_tap.sv</h3>
<pre>module dmi_jtag_tap #(</pre>
<pre>  parameter int unsigned IrLength = 5,</pre>
<pre>  parameter logic [31:0] IdcodeValue = 32'h00000001</pre>
<pre>  input  logic        tck_i,    // JTAG test clock pad</pre>
<pre>  input  logic        tms_i,    // JTAG test mode select pad</pre>
<pre>  input  logic        trst_ni,  // JTAG test reset pad</pre>
<pre>  input  logic        td_i,     // JTAG test data input pad</pre>
<pre>  output logic        td_o,     // JTAG test data output pad</pre>
<pre>  output logic        tdo_oe_o, // Data out output enable</pre>
<pre>  input  logic        testmode_i,</pre>
<pre>  output logic        test_logic_reset_o,</pre>
<pre>  output logic        shift_dr_o,</pre>
<pre>  output logic        update_dr_o,</pre>
<pre>  output logic        capture_dr_o,</pre>
<pre>  output logic        dmi_access_o,</pre>
<pre>  output logic        dtmcs_select_o,</pre>
<pre>  output logic        dmi_reset_o,</pre>
<pre>  input  logic [1:0]  dmi_error_i,</pre>
<pre>  output logic        dmi_tdi_o,</pre>
<pre>  input  logic        dmi_tdo_i</pre>
<pre>  assign dmi_tdi_o = td_i;</pre>
<pre>  typedef enum logic [3:0] {</pre>
<pre>    TestLogicReset, RunTestIdle, SelectDrScan,</pre>
<pre>    CaptureDr, ShiftDr, Exit1Dr, PauseDr, Exit2Dr,</pre>
<pre>    UpdateDr, SelectIrScan, CaptureIr, ShiftIr,</pre>
<pre>    Exit1Ir, PauseIr, Exit2Ir, UpdateIr</pre>
<pre>  } tap_state_e;</pre>
<pre>  tap_state_e tap_state_q, tap_state_d;</pre>
<pre>  typedef enum logic [IrLength-1:0] {</pre>
<pre>    BYPASS0   = 'h0,</pre>
<pre>    IDCODE    = 'h1,</pre>
<pre>    DTMCSR    = 'h10,</pre>
<pre>    DMIACCESS = 'h11,</pre>
<pre>    BYPASS1   = 'h1f</pre>
<pre>  } ir_reg_e;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:18] zero1;</pre>
<pre>    logic         dmihardreset;</pre>
<pre>    logic         dmireset;</pre>
<pre>    logic         zero0;</pre>
<pre>    logic [14:12] idle;</pre>
<pre>    logic [11:10] dmistat;</pre>
<pre>    logic [9:4]   abits;</pre>
<pre>    logic [3:0]   version;</pre>
<pre style="background-color: #FF0000;">  } dtmcs_t;</pre>
<pre>  logic [IrLength-1:0]  jtag_ir_shift_d, jtag_ir_shift_q;</pre>
<pre>  ir_reg_e              jtag_ir_d, jtag_ir_q;</pre>
<pre>  logic capture_ir, shift_ir, update_ir; // pause_ir</pre>
<pre>  always_comb begin : p_jtag</pre>
<pre>    jtag_ir_shift_d = jtag_ir_shift_q;</pre>
<pre>    jtag_ir_d       = jtag_ir_q;</pre>
<pre>    if (shift_ir) begin</pre>
<pre>      jtag_ir_shift_d = {td_i, jtag_ir_shift_q[IrLength-1:1]};</pre>
<pre>    if (capture_ir) begin</pre>
<pre>      jtag_ir_shift_d =  IrLength'(4'b0101);</pre>
<pre>    if (update_ir) begin</pre>
<pre>      jtag_ir_d = ir_reg_e'(jtag_ir_shift_q);</pre>
<pre>    if (test_logic_reset_o) begin</pre>
<pre>      jtag_ir_shift_d = '0;</pre>
<pre>      jtag_ir_d       = IDCODE;</pre>
<pre>  always_ff @(posedge tck_i, negedge trst_ni) begin : p_jtag_ir_reg</pre>
<pre>    if (!trst_ni) begin</pre>
<pre>      jtag_ir_shift_q <= '0;</pre>
<pre>      jtag_ir_q       <= IDCODE;</pre>
<pre>    end else begin</pre>
<pre>      jtag_ir_shift_q <= jtag_ir_shift_d;</pre>
<pre>      jtag_ir_q       <= jtag_ir_d;</pre>
<pre>  logic [31:0] idcode_d, idcode_q;</pre>
<pre>  logic        idcode_select;</pre>
<pre>  logic        bypass_select;</pre>
<pre>  dtmcs_t      dtmcs_d, dtmcs_q;</pre>
<pre>  logic        bypass_d, bypass_q;  // this is a 1-bit register</pre>
<pre>  assign dmi_reset_o = dtmcs_q.dmireset;</pre>
<pre>  always_comb begin</pre>
<pre>    idcode_d = idcode_q;</pre>
<pre>    bypass_d = bypass_q;</pre>
<pre>    dtmcs_d  = dtmcs_q;</pre>
<pre>    if (capture_dr_o) begin</pre>
<pre>      if (idcode_select) idcode_d = IdcodeValue;</pre>
<pre>      if (bypass_select) bypass_d = 1'b0;</pre>
<pre>      if (dtmcs_select_o) begin</pre>
<pre>        dtmcs_d  = '{</pre>
<pre>                      zero1        : '0,</pre>
<pre>                      dmihardreset : 1'b0,</pre>
<pre>                      dmireset     : 1'b0,</pre>
<pre>                      zero0        : '0,</pre>
<pre>                      idle         : 3'd1, // 1: Enter Run-Test/Idle and leave it immediately</pre>
<pre>                      dmistat      : dmi_error_i, // 0: No error, 1: Op failed, 2: too fast</pre>
<pre>                      abits        : 6'd7, // The size of address in dmi</pre>
<pre>                      version      : 4'd1  // Version described in spec version 0.13 (and later?)</pre>
<pre>    if (shift_dr_o) begin</pre>
<pre>      if (idcode_select)  idcode_d = {td_i, 31'(idcode_q >> 1)};</pre>
<pre>      if (bypass_select)  bypass_d = td_i;</pre>
<pre>      if (dtmcs_select_o) dtmcs_d  = {td_i, 31'(dtmcs_q >> 1)};</pre>
<pre>    if (test_logic_reset_o) begin</pre>
<pre>      idcode_d = IdcodeValue;</pre>
<pre>      bypass_d = 1'b0;</pre>
<pre>  always_comb begin : p_data_reg_sel</pre>
<pre>    dmi_access_o   = 1'b0;</pre>
<pre>    dtmcs_select_o = 1'b0;</pre>
<pre>    idcode_select  = 1'b0;</pre>
<pre>    bypass_select  = 1'b0;</pre>
<pre>    unique case (jtag_ir_q)</pre>
<pre>      BYPASS0:   bypass_select  = 1'b1;</pre>
<pre>      IDCODE:    idcode_select  = 1'b1;</pre>
<pre>      DTMCSR:    dtmcs_select_o = 1'b1;</pre>
<pre>      DMIACCESS: dmi_access_o   = 1'b1;</pre>
<pre>      BYPASS1:   bypass_select  = 1'b1;</pre>
<pre>      default:   bypass_select  = 1'b1;</pre>
<pre>  logic tdo_mux;</pre>
<pre>  always_comb begin : p_out_sel</pre>
<pre>    if (shift_ir) begin</pre>
<pre>      tdo_mux = jtag_ir_shift_q[0];</pre>
<pre>    end else begin</pre>
<pre>      unique case (jtag_ir_q)</pre>
<pre>        IDCODE:         tdo_mux = idcode_q[0];     // Reading ID code</pre>
<pre>        DTMCSR:         tdo_mux = dtmcs_q.version[0];</pre>
<pre>        DMIACCESS:      tdo_mux = dmi_tdo_i;       // Read from DMI TDO</pre>
<pre>        default:        tdo_mux = bypass_q;      // BYPASS instruction</pre>
<pre>  logic tck_n;</pre>
<pre>  prim_clock_inverter #(</pre>
<pre>    .HasScanMode(1'b1)</pre>
<pre style="background-color: #FF0000;">  ) i_tck_inv (</pre>
<pre>    .clk_i      ( tck_i      ),</pre>
<pre>    .clk_no     ( tck_n      ),</pre>
<pre>    .scanmode_i ( testmode_i )</pre>
<pre>  always_ff @(posedge tck_n, negedge trst_ni) begin : p_tdo_regs</pre>
<pre>    if (!trst_ni) begin</pre>
<pre>      td_o     <= 1'b0;</pre>
<pre>      tdo_oe_o <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      td_o     <= tdo_mux;</pre>
<pre>      tdo_oe_o <= (shift_ir | shift_dr_o);</pre>
<pre>  always_comb begin : p_tap_fsm</pre>
<pre>    test_logic_reset_o = 1'b0;</pre>
<pre>    capture_dr_o       = 1'b0;</pre>
<pre>    shift_dr_o         = 1'b0;</pre>
<pre>    update_dr_o        = 1'b0;</pre>
<pre>    capture_ir         = 1'b0;</pre>
<pre>    shift_ir           = 1'b0;</pre>
<pre>    update_ir          = 1'b0;</pre>
<pre>    unique case (tap_state_q)</pre>
<pre>      TestLogicReset: begin</pre>
<pre>        tap_state_d = (tms_i) ? TestLogicReset : RunTestIdle;</pre>
<pre>        test_logic_reset_o = 1'b1;</pre>
<pre>      RunTestIdle: begin</pre>
<pre>        tap_state_d = (tms_i) ? SelectDrScan : RunTestIdle;</pre>
<pre>      SelectDrScan: begin</pre>
<pre>        tap_state_d = (tms_i) ? SelectIrScan : CaptureDr;</pre>
<pre>      CaptureDr: begin</pre>
<pre>        capture_dr_o = 1'b1;</pre>
<pre>        tap_state_d = (tms_i) ? Exit1Dr : ShiftDr;</pre>
<pre>      ShiftDr: begin</pre>
<pre>        shift_dr_o = 1'b1;</pre>
<pre>        tap_state_d = (tms_i) ? Exit1Dr : ShiftDr;</pre>
<pre>      Exit1Dr: begin</pre>
<pre>        tap_state_d = (tms_i) ? UpdateDr : PauseDr;</pre>
<pre>      PauseDr: begin</pre>
<pre>        tap_state_d = (tms_i) ? Exit2Dr : PauseDr;</pre>
<pre>      Exit2Dr: begin</pre>
<pre>        tap_state_d = (tms_i) ? UpdateDr : ShiftDr;</pre>
<pre>      UpdateDr: begin</pre>
<pre>        update_dr_o = 1'b1;</pre>
<pre>        tap_state_d = (tms_i) ? SelectDrScan : RunTestIdle;</pre>
<pre>      SelectIrScan: begin</pre>
<pre>        tap_state_d = (tms_i) ? TestLogicReset : CaptureIr;</pre>
<pre>      CaptureIr: begin</pre>
<pre>        capture_ir = 1'b1;</pre>
<pre>        tap_state_d = (tms_i) ? Exit1Ir : ShiftIr;</pre>
<pre>      ShiftIr: begin</pre>
<pre>        shift_ir = 1'b1;</pre>
<pre>        tap_state_d = (tms_i) ? Exit1Ir : ShiftIr;</pre>
<pre>      Exit1Ir: begin</pre>
<pre>        tap_state_d = (tms_i) ? UpdateIr : PauseIr;</pre>
<pre>      PauseIr: begin</pre>
<pre>        tap_state_d = (tms_i) ? Exit2Ir : PauseIr;</pre>
<pre>      Exit2Ir: begin</pre>
<pre>        tap_state_d = (tms_i) ? UpdateIr : ShiftIr;</pre>
<pre>      UpdateIr: begin</pre>
<pre>        update_ir = 1'b1;</pre>
<pre>        tap_state_d = (tms_i) ? SelectDrScan : RunTestIdle;</pre>
<pre>      default: ; // can't actually happen since case is full</pre>
<pre>  always_ff @(posedge tck_i or negedge trst_ni) begin : p_regs</pre>
<pre>    if (!trst_ni) begin</pre>
<pre>      tap_state_q <= RunTestIdle;</pre>
<pre>      idcode_q    <= IdcodeValue;</pre>
<pre>      bypass_q    <= 1'b0;</pre>
<pre>      dtmcs_q     <= '0;</pre>
<pre>    end else begin</pre>
<pre>      tap_state_q <= tap_state_d;</pre>
<pre>      idcode_q    <= idcode_d;</pre>
<pre>      bypass_q    <= bypass_d;</pre>
<pre>      dtmcs_q     <= dtmcs_d;</pre>
<pre style="background-color: #FF0000;">endmodule : dmi_jtag_tap</pre>
<h3>hw/vendor/pulp_riscv_dbg/debug_rom/debug_rom.sv</h3>
<pre>  input  logic         clk_i,</pre>
<pre>  input  logic         req_i,</pre>
<pre>  input  logic [63:0]  addr_i,</pre>
<pre>  output logic [63:0]  rdata_o</pre>
<pre>  localparam int unsigned RomSize = 19;</pre>
<pre>  const logic [RomSize-1:0][63:0] mem = {</pre>
<pre>    64'h00000000_7b200073,</pre>
<pre>    64'h7b302573_7b202473,</pre>
<pre>    64'h10852423_f1402473,</pre>
<pre>    64'ha85ff06f_7b302573,</pre>
<pre>    64'h7b202473_10052223,</pre>
<pre>    64'h00100073_7b302573,</pre>
<pre>    64'h7b202473_10052623,</pre>
<pre>    64'h00c51513_00c55513,</pre>
<pre>    64'h00000517_fd5ff06f,</pre>
<pre>    64'hfa041ce3_00247413,</pre>
<pre>    64'h40044403_00a40433,</pre>
<pre>    64'hf1402473_02041c63,</pre>
<pre>    64'h00147413_40044403,</pre>
<pre>    64'h00a40433_10852023,</pre>
<pre>    64'hf1402473_00c51513,</pre>
<pre>    64'h00c55513_00000517,</pre>
<pre>    64'h7b351073_7b241073,</pre>
<pre>    64'h0ff0000f_04c0006f,</pre>
<pre>    64'h07c0006f_00c0006f</pre>
<pre>  logic [$clog2(RomSize)-1:0] addr_q;</pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>    if (req_i) begin</pre>
<pre>      addr_q <= addr_i[$clog2(RomSize)-1+3:3];</pre>
<pre>  always_comb begin : p_outmux</pre>
<pre>    rdata_o = '0;</pre>
<pre>    if (addr_q < $clog2(RomSize)'(RomSize)) begin</pre>
<pre>        rdata_o = mem[addr_q];</pre>
<h3>hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv</h3>
<pre>module usbdev_flop_2syncpulse #(</pre>
<pre>  parameter int unsigned Width = 16</pre>
<pre>  input  logic             clk_i,    // receive clock</pre>
<pre>  input  logic             rst_ni,</pre>
<pre>  input  logic [Width-1:0] d,</pre>
<pre>  output logic [Width-1:0] q</pre>
<pre>  logic [Width-1:0] d_sync;</pre>
<pre>  prim_flop_2sync #(.Width (Width)) prim_flop_2sync (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .d,</pre>
<pre>    .q (d_sync)</pre>
<pre>  logic [Width-1:0] d_sync_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      d_sync_q <= '0;</pre>
<pre>    end else begin</pre>
<pre>      d_sync_q <= d_sync;</pre>
<pre>  assign q = d_sync & ~d_sync_q;</pre>
<h3>hw/ip/usbdev/rtl/usbdev_reg_pkg.sv</h3>
<pre>package usbdev_reg_pkg;</pre>
<pre>  parameter int NEndpoints = 12;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } pkt_received;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } pkt_sent;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } disconnected;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } host_lost;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } link_reset;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } link_suspend;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } link_resume;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } av_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } av_overflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } link_in_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_crc_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_pid_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_bitstuff_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } frame;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } connected;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } pkt_received;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } pkt_sent;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } disconnected;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } host_lost;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } link_reset;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } link_suspend;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } link_resume;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } av_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } av_overflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } link_in_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_crc_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_pid_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_bitstuff_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } frame;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } connected;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_intr_enable_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } pkt_received;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } pkt_sent;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } disconnected;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } host_lost;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } link_reset;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } link_suspend;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } link_resume;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } av_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rx_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } av_overflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } link_in_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rx_crc_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rx_pid_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rx_bitstuff_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } frame;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } connected;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_intr_test_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } enable;</pre>
<pre>    struct packed {</pre>
<pre>      logic [6:0]  q;</pre>
<pre>    } device_address;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_usbctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [4:0]  q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_avbuffer_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [4:0]  q;</pre>
<pre>      logic        re;</pre>
<pre>    } buffer;</pre>
<pre>    struct packed {</pre>
<pre>      logic [6:0]  q;</pre>
<pre>      logic        re;</pre>
<pre>    } size;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        re;</pre>
<pre>    } setup;</pre>
<pre>    struct packed {</pre>
<pre>      logic [3:0]  q;</pre>
<pre>      logic        re;</pre>
<pre>    } ep;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_rxfifo_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_rxenable_setup_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_rxenable_out_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_stall_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [4:0]  q;</pre>
<pre>    } buffer;</pre>
<pre>    struct packed {</pre>
<pre>      logic [6:0]  q;</pre>
<pre>    } size;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } pend;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rdy;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_configin_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_iso_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_data_toggle_clear_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_differential_mode;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } tx_differential_mode;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } eop_single_bit;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } override_pwr_sense_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } override_pwr_sense_val;</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_phy_config_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } pkt_received;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } pkt_sent;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } disconnected;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } host_lost;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } link_reset;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } link_suspend;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } link_resume;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } av_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rx_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } av_overflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } link_in_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rx_crc_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rx_pid_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rx_bitstuff_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } frame;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } connected;</pre>
<pre style="background-color: #FF0000;">  } usbdev_hw2reg_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [6:0]  d;</pre>
<pre>      logic        de;</pre>
<pre>    } device_address;</pre>
<pre style="background-color: #FF0000;">  } usbdev_hw2reg_usbctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [10:0] d;</pre>
<pre>    } frame;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } host_lost;</pre>
<pre>    struct packed {</pre>
<pre>      logic [2:0]  d;</pre>
<pre>    } link_state;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } usb_sense;</pre>
<pre>    struct packed {</pre>
<pre>      logic [2:0]  d;</pre>
<pre>    } av_depth;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } av_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic [2:0]  d;</pre>
<pre>    } rx_depth;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } rx_empty;</pre>
<pre style="background-color: #FF0000;">  } usbdev_hw2reg_usbstat_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [4:0]  d;</pre>
<pre>    } buffer;</pre>
<pre>    struct packed {</pre>
<pre>      logic [6:0]  d;</pre>
<pre>    } size;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } setup;</pre>
<pre>    struct packed {</pre>
<pre>      logic [3:0]  d;</pre>
<pre>    } ep;</pre>
<pre style="background-color: #FF0000;">  } usbdev_hw2reg_rxfifo_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } usbdev_hw2reg_in_sent_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic        d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } usbdev_hw2reg_stall_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } pend;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rdy;</pre>
<pre style="background-color: #FF0000;">  } usbdev_hw2reg_configin_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    usbdev_reg2hw_intr_state_reg_t intr_state; // [343:328]</pre>
<pre>    usbdev_reg2hw_intr_enable_reg_t intr_enable; // [327:312]</pre>
<pre>    usbdev_reg2hw_intr_test_reg_t intr_test; // [311:280]</pre>
<pre>    usbdev_reg2hw_usbctrl_reg_t usbctrl; // [279:272]</pre>
<pre>    usbdev_reg2hw_avbuffer_reg_t avbuffer; // [271:266]</pre>
<pre>    usbdev_reg2hw_rxfifo_reg_t rxfifo; // [265:245]</pre>
<pre>    usbdev_reg2hw_rxenable_setup_mreg_t [11:0] rxenable_setup; // [244:233]</pre>
<pre>    usbdev_reg2hw_rxenable_out_mreg_t [11:0] rxenable_out; // [232:221]</pre>
<pre>    usbdev_reg2hw_stall_mreg_t [11:0] stall; // [220:209]</pre>
<pre>    usbdev_reg2hw_configin_mreg_t [11:0] configin; // [208:41]</pre>
<pre>    usbdev_reg2hw_iso_mreg_t [11:0] iso; // [40:29]</pre>
<pre>    usbdev_reg2hw_data_toggle_clear_mreg_t [11:0] data_toggle_clear; // [28:5]</pre>
<pre>    usbdev_reg2hw_phy_config_reg_t phy_config; // [4:0]</pre>
<pre style="background-color: #FF0000;">  } usbdev_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    usbdev_hw2reg_intr_state_reg_t intr_state; // [176:161]</pre>
<pre>    usbdev_hw2reg_usbctrl_reg_t usbctrl; // [160:153]</pre>
<pre>    usbdev_hw2reg_usbstat_reg_t usbstat; // [152:153]</pre>
<pre>    usbdev_hw2reg_rxfifo_reg_t rxfifo; // [152:132]</pre>
<pre>    usbdev_hw2reg_in_sent_mreg_t [11:0] in_sent; // [131:108]</pre>
<pre>    usbdev_hw2reg_stall_mreg_t [11:0] stall; // [107:84]</pre>
<pre>    usbdev_hw2reg_configin_mreg_t [11:0] configin; // [83:36]</pre>
<pre style="background-color: #FF0000;">  } usbdev_hw2reg_t;</pre>
<pre>  parameter logic [11:0] USBDEV_INTR_STATE_OFFSET = 12'h 0;</pre>
<pre>  parameter logic [11:0] USBDEV_INTR_ENABLE_OFFSET = 12'h 4;</pre>
<pre>  parameter logic [11:0] USBDEV_INTR_TEST_OFFSET = 12'h 8;</pre>
<pre>  parameter logic [11:0] USBDEV_USBCTRL_OFFSET = 12'h c;</pre>
<pre>  parameter logic [11:0] USBDEV_USBSTAT_OFFSET = 12'h 10;</pre>
<pre>  parameter logic [11:0] USBDEV_AVBUFFER_OFFSET = 12'h 14;</pre>
<pre>  parameter logic [11:0] USBDEV_RXFIFO_OFFSET = 12'h 18;</pre>
<pre>  parameter logic [11:0] USBDEV_RXENABLE_SETUP_OFFSET = 12'h 1c;</pre>
<pre>  parameter logic [11:0] USBDEV_RXENABLE_OUT_OFFSET = 12'h 20;</pre>
<pre>  parameter logic [11:0] USBDEV_IN_SENT_OFFSET = 12'h 24;</pre>
<pre>  parameter logic [11:0] USBDEV_STALL_OFFSET = 12'h 28;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN0_OFFSET = 12'h 2c;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN1_OFFSET = 12'h 30;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN2_OFFSET = 12'h 34;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN3_OFFSET = 12'h 38;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN4_OFFSET = 12'h 3c;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN5_OFFSET = 12'h 40;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN6_OFFSET = 12'h 44;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN7_OFFSET = 12'h 48;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN8_OFFSET = 12'h 4c;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN9_OFFSET = 12'h 50;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN10_OFFSET = 12'h 54;</pre>
<pre>  parameter logic [11:0] USBDEV_CONFIGIN11_OFFSET = 12'h 58;</pre>
<pre>  parameter logic [11:0] USBDEV_ISO_OFFSET = 12'h 5c;</pre>
<pre>  parameter logic [11:0] USBDEV_DATA_TOGGLE_CLEAR_OFFSET = 12'h 60;</pre>
<pre>  parameter logic [11:0] USBDEV_PHY_CONFIG_OFFSET = 12'h 64;</pre>
<pre>  parameter logic [11:0] USBDEV_BUFFER_OFFSET = 12'h 800;</pre>
<pre>  parameter logic [11:0] USBDEV_BUFFER_SIZE   = 12'h 800;</pre>
<pre>  typedef enum int {</pre>
<pre>    USBDEV_INTR_STATE,</pre>
<pre>    USBDEV_INTR_ENABLE,</pre>
<pre>    USBDEV_INTR_TEST,</pre>
<pre>    USBDEV_USBCTRL,</pre>
<pre>    USBDEV_USBSTAT,</pre>
<pre>    USBDEV_AVBUFFER,</pre>
<pre>    USBDEV_RXFIFO,</pre>
<pre>    USBDEV_RXENABLE_SETUP,</pre>
<pre>    USBDEV_RXENABLE_OUT,</pre>
<pre>    USBDEV_IN_SENT,</pre>
<pre>    USBDEV_STALL,</pre>
<pre>    USBDEV_CONFIGIN0,</pre>
<pre>    USBDEV_CONFIGIN1,</pre>
<pre>    USBDEV_CONFIGIN2,</pre>
<pre>    USBDEV_CONFIGIN3,</pre>
<pre>    USBDEV_CONFIGIN4,</pre>
<pre>    USBDEV_CONFIGIN5,</pre>
<pre>    USBDEV_CONFIGIN6,</pre>
<pre>    USBDEV_CONFIGIN7,</pre>
<pre>    USBDEV_CONFIGIN8,</pre>
<pre>    USBDEV_CONFIGIN9,</pre>
<pre>    USBDEV_CONFIGIN10,</pre>
<pre>    USBDEV_CONFIGIN11,</pre>
<pre>    USBDEV_ISO,</pre>
<pre>    USBDEV_DATA_TOGGLE_CLEAR,</pre>
<pre>    USBDEV_PHY_CONFIG</pre>
<pre>  } usbdev_id_e;</pre>
<pre>  parameter logic [3:0] USBDEV_PERMIT [26] = '{</pre>
<pre>    4'b 0011, // index[ 0] USBDEV_INTR_STATE</pre>
<pre>    4'b 0011, // index[ 1] USBDEV_INTR_ENABLE</pre>
<pre>    4'b 0011, // index[ 2] USBDEV_INTR_TEST</pre>
<pre>    4'b 0111, // index[ 3] USBDEV_USBCTRL</pre>
<pre>    4'b 1111, // index[ 4] USBDEV_USBSTAT</pre>
<pre>    4'b 0001, // index[ 5] USBDEV_AVBUFFER</pre>
<pre>    4'b 0111, // index[ 6] USBDEV_RXFIFO</pre>
<pre>    4'b 0011, // index[ 7] USBDEV_RXENABLE_SETUP</pre>
<pre>    4'b 0011, // index[ 8] USBDEV_RXENABLE_OUT</pre>
<pre>    4'b 0011, // index[ 9] USBDEV_IN_SENT</pre>
<pre>    4'b 0011, // index[10] USBDEV_STALL</pre>
<pre>    4'b 1111, // index[11] USBDEV_CONFIGIN0</pre>
<pre>    4'b 1111, // index[12] USBDEV_CONFIGIN1</pre>
<pre>    4'b 1111, // index[13] USBDEV_CONFIGIN2</pre>
<pre>    4'b 1111, // index[14] USBDEV_CONFIGIN3</pre>
<pre>    4'b 1111, // index[15] USBDEV_CONFIGIN4</pre>
<pre>    4'b 1111, // index[16] USBDEV_CONFIGIN5</pre>
<pre>    4'b 1111, // index[17] USBDEV_CONFIGIN6</pre>
<pre>    4'b 1111, // index[18] USBDEV_CONFIGIN7</pre>
<pre>    4'b 1111, // index[19] USBDEV_CONFIGIN8</pre>
<pre>    4'b 1111, // index[20] USBDEV_CONFIGIN9</pre>
<pre>    4'b 1111, // index[21] USBDEV_CONFIGIN10</pre>
<pre>    4'b 1111, // index[22] USBDEV_CONFIGIN11</pre>
<pre>    4'b 0011, // index[23] USBDEV_ISO</pre>
<pre>    4'b 0011, // index[24] USBDEV_DATA_TOGGLE_CLEAR</pre>
<pre>    4'b 0001  // index[25] USBDEV_PHY_CONFIG</pre>
<h3>hw/ip/usbdev/rtl/usbdev_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_win_o  [1],</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_win_i  [1],</pre>
<pre>  output usbdev_reg_pkg::usbdev_reg2hw_t reg2hw, // Write</pre>
<pre>  input  usbdev_reg_pkg::usbdev_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam int AW = 12;</pre>
<pre>  localparam int DW = 32;</pre>
<pre>  localparam int DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_socket_h2d [2];</pre>
<pre>  tlul_pkg::tl_d2h_t tl_socket_d2h [2];</pre>
<pre>  logic [1:0] reg_steer;</pre>
<pre>  assign tl_reg_h2d = tl_socket_h2d[1];</pre>
<pre>  assign tl_socket_d2h[1] = tl_reg_d2h;</pre>
<pre>  assign tl_win_o[0] = tl_socket_h2d[0];</pre>
<pre>  assign tl_socket_d2h[0] = tl_win_i[0];</pre>
<pre>  tlul_socket_1n #(</pre>
<pre>    .N          (2),</pre>
<pre>    .HReqPass   (1'b1),</pre>
<pre>    .HRspPass   (1'b1),</pre>
<pre>    .DReqPass   ({2{1'b1}}),</pre>
<pre>    .DRspPass   ({2{1'b1}}),</pre>
<pre>    .HReqDepth  (4'h0),</pre>
<pre>    .HRspDepth  (4'h0),</pre>
<pre>    .DReqDepth  ({2{4'h0}}),</pre>
<pre>    .DRspDepth  ({2{4'h0}})</pre>
<pre style="background-color: #FF0000;">  ) u_socket (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_h_i (tl_i),</pre>
<pre>    .tl_h_o (tl_o),</pre>
<pre>    .tl_d_o (tl_socket_h2d),</pre>
<pre>    .tl_d_i (tl_socket_d2h),</pre>
<pre>    .dev_select (reg_steer)</pre>
<pre>  always_comb begin</pre>
<pre>    reg_steer = 1;       // Default set to register</pre>
<pre>    if (tl_i.a_address[AW-1:0] >= 2048) begin</pre>
<pre>      reg_steer = 0;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic intr_state_pkt_received_qs;</pre>
<pre>  logic intr_state_pkt_received_wd;</pre>
<pre>  logic intr_state_pkt_received_we;</pre>
<pre>  logic intr_state_pkt_sent_qs;</pre>
<pre>  logic intr_state_pkt_sent_wd;</pre>
<pre>  logic intr_state_pkt_sent_we;</pre>
<pre>  logic intr_state_disconnected_qs;</pre>
<pre>  logic intr_state_disconnected_wd;</pre>
<pre>  logic intr_state_disconnected_we;</pre>
<pre>  logic intr_state_host_lost_qs;</pre>
<pre>  logic intr_state_host_lost_wd;</pre>
<pre>  logic intr_state_host_lost_we;</pre>
<pre>  logic intr_state_link_reset_qs;</pre>
<pre>  logic intr_state_link_reset_wd;</pre>
<pre>  logic intr_state_link_reset_we;</pre>
<pre>  logic intr_state_link_suspend_qs;</pre>
<pre>  logic intr_state_link_suspend_wd;</pre>
<pre>  logic intr_state_link_suspend_we;</pre>
<pre>  logic intr_state_link_resume_qs;</pre>
<pre>  logic intr_state_link_resume_wd;</pre>
<pre>  logic intr_state_link_resume_we;</pre>
<pre>  logic intr_state_av_empty_qs;</pre>
<pre>  logic intr_state_av_empty_wd;</pre>
<pre>  logic intr_state_av_empty_we;</pre>
<pre>  logic intr_state_rx_full_qs;</pre>
<pre>  logic intr_state_rx_full_wd;</pre>
<pre>  logic intr_state_rx_full_we;</pre>
<pre>  logic intr_state_av_overflow_qs;</pre>
<pre>  logic intr_state_av_overflow_wd;</pre>
<pre>  logic intr_state_av_overflow_we;</pre>
<pre>  logic intr_state_link_in_err_qs;</pre>
<pre>  logic intr_state_link_in_err_wd;</pre>
<pre>  logic intr_state_link_in_err_we;</pre>
<pre>  logic intr_state_rx_crc_err_qs;</pre>
<pre>  logic intr_state_rx_crc_err_wd;</pre>
<pre>  logic intr_state_rx_crc_err_we;</pre>
<pre>  logic intr_state_rx_pid_err_qs;</pre>
<pre>  logic intr_state_rx_pid_err_wd;</pre>
<pre>  logic intr_state_rx_pid_err_we;</pre>
<pre>  logic intr_state_rx_bitstuff_err_qs;</pre>
<pre>  logic intr_state_rx_bitstuff_err_wd;</pre>
<pre>  logic intr_state_rx_bitstuff_err_we;</pre>
<pre>  logic intr_state_frame_qs;</pre>
<pre>  logic intr_state_frame_wd;</pre>
<pre>  logic intr_state_frame_we;</pre>
<pre>  logic intr_state_connected_qs;</pre>
<pre>  logic intr_state_connected_wd;</pre>
<pre>  logic intr_state_connected_we;</pre>
<pre>  logic intr_enable_pkt_received_qs;</pre>
<pre>  logic intr_enable_pkt_received_wd;</pre>
<pre>  logic intr_enable_pkt_received_we;</pre>
<pre>  logic intr_enable_pkt_sent_qs;</pre>
<pre>  logic intr_enable_pkt_sent_wd;</pre>
<pre>  logic intr_enable_pkt_sent_we;</pre>
<pre>  logic intr_enable_disconnected_qs;</pre>
<pre>  logic intr_enable_disconnected_wd;</pre>
<pre>  logic intr_enable_disconnected_we;</pre>
<pre>  logic intr_enable_host_lost_qs;</pre>
<pre>  logic intr_enable_host_lost_wd;</pre>
<pre>  logic intr_enable_host_lost_we;</pre>
<pre>  logic intr_enable_link_reset_qs;</pre>
<pre>  logic intr_enable_link_reset_wd;</pre>
<pre>  logic intr_enable_link_reset_we;</pre>
<pre>  logic intr_enable_link_suspend_qs;</pre>
<pre>  logic intr_enable_link_suspend_wd;</pre>
<pre>  logic intr_enable_link_suspend_we;</pre>
<pre>  logic intr_enable_link_resume_qs;</pre>
<pre>  logic intr_enable_link_resume_wd;</pre>
<pre>  logic intr_enable_link_resume_we;</pre>
<pre>  logic intr_enable_av_empty_qs;</pre>
<pre>  logic intr_enable_av_empty_wd;</pre>
<pre>  logic intr_enable_av_empty_we;</pre>
<pre>  logic intr_enable_rx_full_qs;</pre>
<pre>  logic intr_enable_rx_full_wd;</pre>
<pre>  logic intr_enable_rx_full_we;</pre>
<pre>  logic intr_enable_av_overflow_qs;</pre>
<pre>  logic intr_enable_av_overflow_wd;</pre>
<pre>  logic intr_enable_av_overflow_we;</pre>
<pre>  logic intr_enable_link_in_err_qs;</pre>
<pre>  logic intr_enable_link_in_err_wd;</pre>
<pre>  logic intr_enable_link_in_err_we;</pre>
<pre>  logic intr_enable_rx_crc_err_qs;</pre>
<pre>  logic intr_enable_rx_crc_err_wd;</pre>
<pre>  logic intr_enable_rx_crc_err_we;</pre>
<pre>  logic intr_enable_rx_pid_err_qs;</pre>
<pre>  logic intr_enable_rx_pid_err_wd;</pre>
<pre>  logic intr_enable_rx_pid_err_we;</pre>
<pre>  logic intr_enable_rx_bitstuff_err_qs;</pre>
<pre>  logic intr_enable_rx_bitstuff_err_wd;</pre>
<pre>  logic intr_enable_rx_bitstuff_err_we;</pre>
<pre>  logic intr_enable_frame_qs;</pre>
<pre>  logic intr_enable_frame_wd;</pre>
<pre>  logic intr_enable_frame_we;</pre>
<pre>  logic intr_enable_connected_qs;</pre>
<pre>  logic intr_enable_connected_wd;</pre>
<pre>  logic intr_enable_connected_we;</pre>
<pre>  logic intr_test_pkt_received_wd;</pre>
<pre>  logic intr_test_pkt_received_we;</pre>
<pre>  logic intr_test_pkt_sent_wd;</pre>
<pre>  logic intr_test_pkt_sent_we;</pre>
<pre>  logic intr_test_disconnected_wd;</pre>
<pre>  logic intr_test_disconnected_we;</pre>
<pre>  logic intr_test_host_lost_wd;</pre>
<pre>  logic intr_test_host_lost_we;</pre>
<pre>  logic intr_test_link_reset_wd;</pre>
<pre>  logic intr_test_link_reset_we;</pre>
<pre>  logic intr_test_link_suspend_wd;</pre>
<pre>  logic intr_test_link_suspend_we;</pre>
<pre>  logic intr_test_link_resume_wd;</pre>
<pre>  logic intr_test_link_resume_we;</pre>
<pre>  logic intr_test_av_empty_wd;</pre>
<pre>  logic intr_test_av_empty_we;</pre>
<pre>  logic intr_test_rx_full_wd;</pre>
<pre>  logic intr_test_rx_full_we;</pre>
<pre>  logic intr_test_av_overflow_wd;</pre>
<pre>  logic intr_test_av_overflow_we;</pre>
<pre>  logic intr_test_link_in_err_wd;</pre>
<pre>  logic intr_test_link_in_err_we;</pre>
<pre>  logic intr_test_rx_crc_err_wd;</pre>
<pre>  logic intr_test_rx_crc_err_we;</pre>
<pre>  logic intr_test_rx_pid_err_wd;</pre>
<pre>  logic intr_test_rx_pid_err_we;</pre>
<pre>  logic intr_test_rx_bitstuff_err_wd;</pre>
<pre>  logic intr_test_rx_bitstuff_err_we;</pre>
<pre>  logic intr_test_frame_wd;</pre>
<pre>  logic intr_test_frame_we;</pre>
<pre>  logic intr_test_connected_wd;</pre>
<pre>  logic intr_test_connected_we;</pre>
<pre>  logic usbctrl_enable_qs;</pre>
<pre>  logic usbctrl_enable_wd;</pre>
<pre>  logic usbctrl_enable_we;</pre>
<pre>  logic [6:0] usbctrl_device_address_qs;</pre>
<pre>  logic [6:0] usbctrl_device_address_wd;</pre>
<pre>  logic usbctrl_device_address_we;</pre>
<pre>  logic [10:0] usbstat_frame_qs;</pre>
<pre>  logic usbstat_frame_re;</pre>
<pre>  logic usbstat_host_lost_qs;</pre>
<pre>  logic usbstat_host_lost_re;</pre>
<pre>  logic [2:0] usbstat_link_state_qs;</pre>
<pre>  logic usbstat_link_state_re;</pre>
<pre>  logic usbstat_usb_sense_qs;</pre>
<pre>  logic usbstat_usb_sense_re;</pre>
<pre>  logic [2:0] usbstat_av_depth_qs;</pre>
<pre>  logic usbstat_av_depth_re;</pre>
<pre>  logic usbstat_av_full_qs;</pre>
<pre>  logic usbstat_av_full_re;</pre>
<pre>  logic [2:0] usbstat_rx_depth_qs;</pre>
<pre>  logic usbstat_rx_depth_re;</pre>
<pre>  logic usbstat_rx_empty_qs;</pre>
<pre>  logic usbstat_rx_empty_re;</pre>
<pre>  logic [4:0] avbuffer_wd;</pre>
<pre>  logic avbuffer_we;</pre>
<pre>  logic [4:0] rxfifo_buffer_qs;</pre>
<pre>  logic rxfifo_buffer_re;</pre>
<pre>  logic [6:0] rxfifo_size_qs;</pre>
<pre>  logic rxfifo_size_re;</pre>
<pre>  logic rxfifo_setup_qs;</pre>
<pre>  logic rxfifo_setup_re;</pre>
<pre>  logic [3:0] rxfifo_ep_qs;</pre>
<pre>  logic rxfifo_ep_re;</pre>
<pre>  logic rxenable_setup_setup0_qs;</pre>
<pre>  logic rxenable_setup_setup0_wd;</pre>
<pre>  logic rxenable_setup_setup0_we;</pre>
<pre>  logic rxenable_setup_setup1_qs;</pre>
<pre>  logic rxenable_setup_setup1_wd;</pre>
<pre>  logic rxenable_setup_setup1_we;</pre>
<pre>  logic rxenable_setup_setup2_qs;</pre>
<pre>  logic rxenable_setup_setup2_wd;</pre>
<pre>  logic rxenable_setup_setup2_we;</pre>
<pre>  logic rxenable_setup_setup3_qs;</pre>
<pre>  logic rxenable_setup_setup3_wd;</pre>
<pre>  logic rxenable_setup_setup3_we;</pre>
<pre>  logic rxenable_setup_setup4_qs;</pre>
<pre>  logic rxenable_setup_setup4_wd;</pre>
<pre>  logic rxenable_setup_setup4_we;</pre>
<pre>  logic rxenable_setup_setup5_qs;</pre>
<pre>  logic rxenable_setup_setup5_wd;</pre>
<pre>  logic rxenable_setup_setup5_we;</pre>
<pre>  logic rxenable_setup_setup6_qs;</pre>
<pre>  logic rxenable_setup_setup6_wd;</pre>
<pre>  logic rxenable_setup_setup6_we;</pre>
<pre>  logic rxenable_setup_setup7_qs;</pre>
<pre>  logic rxenable_setup_setup7_wd;</pre>
<pre>  logic rxenable_setup_setup7_we;</pre>
<pre>  logic rxenable_setup_setup8_qs;</pre>
<pre>  logic rxenable_setup_setup8_wd;</pre>
<pre>  logic rxenable_setup_setup8_we;</pre>
<pre>  logic rxenable_setup_setup9_qs;</pre>
<pre>  logic rxenable_setup_setup9_wd;</pre>
<pre>  logic rxenable_setup_setup9_we;</pre>
<pre>  logic rxenable_setup_setup10_qs;</pre>
<pre>  logic rxenable_setup_setup10_wd;</pre>
<pre>  logic rxenable_setup_setup10_we;</pre>
<pre>  logic rxenable_setup_setup11_qs;</pre>
<pre>  logic rxenable_setup_setup11_wd;</pre>
<pre>  logic rxenable_setup_setup11_we;</pre>
<pre>  logic rxenable_out_out0_qs;</pre>
<pre>  logic rxenable_out_out0_wd;</pre>
<pre>  logic rxenable_out_out0_we;</pre>
<pre>  logic rxenable_out_out1_qs;</pre>
<pre>  logic rxenable_out_out1_wd;</pre>
<pre>  logic rxenable_out_out1_we;</pre>
<pre>  logic rxenable_out_out2_qs;</pre>
<pre>  logic rxenable_out_out2_wd;</pre>
<pre>  logic rxenable_out_out2_we;</pre>
<pre>  logic rxenable_out_out3_qs;</pre>
<pre>  logic rxenable_out_out3_wd;</pre>
<pre>  logic rxenable_out_out3_we;</pre>
<pre>  logic rxenable_out_out4_qs;</pre>
<pre>  logic rxenable_out_out4_wd;</pre>
<pre>  logic rxenable_out_out4_we;</pre>
<pre>  logic rxenable_out_out5_qs;</pre>
<pre>  logic rxenable_out_out5_wd;</pre>
<pre>  logic rxenable_out_out5_we;</pre>
<pre>  logic rxenable_out_out6_qs;</pre>
<pre>  logic rxenable_out_out6_wd;</pre>
<pre>  logic rxenable_out_out6_we;</pre>
<pre>  logic rxenable_out_out7_qs;</pre>
<pre>  logic rxenable_out_out7_wd;</pre>
<pre>  logic rxenable_out_out7_we;</pre>
<pre>  logic rxenable_out_out8_qs;</pre>
<pre>  logic rxenable_out_out8_wd;</pre>
<pre>  logic rxenable_out_out8_we;</pre>
<pre>  logic rxenable_out_out9_qs;</pre>
<pre>  logic rxenable_out_out9_wd;</pre>
<pre>  logic rxenable_out_out9_we;</pre>
<pre>  logic rxenable_out_out10_qs;</pre>
<pre>  logic rxenable_out_out10_wd;</pre>
<pre>  logic rxenable_out_out10_we;</pre>
<pre>  logic rxenable_out_out11_qs;</pre>
<pre>  logic rxenable_out_out11_wd;</pre>
<pre>  logic rxenable_out_out11_we;</pre>
<pre>  logic in_sent_sent0_qs;</pre>
<pre>  logic in_sent_sent0_wd;</pre>
<pre>  logic in_sent_sent0_we;</pre>
<pre>  logic in_sent_sent1_qs;</pre>
<pre>  logic in_sent_sent1_wd;</pre>
<pre>  logic in_sent_sent1_we;</pre>
<pre>  logic in_sent_sent2_qs;</pre>
<pre>  logic in_sent_sent2_wd;</pre>
<pre>  logic in_sent_sent2_we;</pre>
<pre>  logic in_sent_sent3_qs;</pre>
<pre>  logic in_sent_sent3_wd;</pre>
<pre>  logic in_sent_sent3_we;</pre>
<pre>  logic in_sent_sent4_qs;</pre>
<pre>  logic in_sent_sent4_wd;</pre>
<pre>  logic in_sent_sent4_we;</pre>
<pre>  logic in_sent_sent5_qs;</pre>
<pre>  logic in_sent_sent5_wd;</pre>
<pre>  logic in_sent_sent5_we;</pre>
<pre>  logic in_sent_sent6_qs;</pre>
<pre>  logic in_sent_sent6_wd;</pre>
<pre>  logic in_sent_sent6_we;</pre>
<pre>  logic in_sent_sent7_qs;</pre>
<pre>  logic in_sent_sent7_wd;</pre>
<pre>  logic in_sent_sent7_we;</pre>
<pre>  logic in_sent_sent8_qs;</pre>
<pre>  logic in_sent_sent8_wd;</pre>
<pre>  logic in_sent_sent8_we;</pre>
<pre>  logic in_sent_sent9_qs;</pre>
<pre>  logic in_sent_sent9_wd;</pre>
<pre>  logic in_sent_sent9_we;</pre>
<pre>  logic in_sent_sent10_qs;</pre>
<pre>  logic in_sent_sent10_wd;</pre>
<pre>  logic in_sent_sent10_we;</pre>
<pre>  logic in_sent_sent11_qs;</pre>
<pre>  logic in_sent_sent11_wd;</pre>
<pre>  logic in_sent_sent11_we;</pre>
<pre>  logic stall_stall0_qs;</pre>
<pre>  logic stall_stall0_wd;</pre>
<pre>  logic stall_stall0_we;</pre>
<pre>  logic stall_stall1_qs;</pre>
<pre>  logic stall_stall1_wd;</pre>
<pre>  logic stall_stall1_we;</pre>
<pre>  logic stall_stall2_qs;</pre>
<pre>  logic stall_stall2_wd;</pre>
<pre>  logic stall_stall2_we;</pre>
<pre>  logic stall_stall3_qs;</pre>
<pre>  logic stall_stall3_wd;</pre>
<pre>  logic stall_stall3_we;</pre>
<pre>  logic stall_stall4_qs;</pre>
<pre>  logic stall_stall4_wd;</pre>
<pre>  logic stall_stall4_we;</pre>
<pre>  logic stall_stall5_qs;</pre>
<pre>  logic stall_stall5_wd;</pre>
<pre>  logic stall_stall5_we;</pre>
<pre>  logic stall_stall6_qs;</pre>
<pre>  logic stall_stall6_wd;</pre>
<pre>  logic stall_stall6_we;</pre>
<pre>  logic stall_stall7_qs;</pre>
<pre>  logic stall_stall7_wd;</pre>
<pre>  logic stall_stall7_we;</pre>
<pre>  logic stall_stall8_qs;</pre>
<pre>  logic stall_stall8_wd;</pre>
<pre>  logic stall_stall8_we;</pre>
<pre>  logic stall_stall9_qs;</pre>
<pre>  logic stall_stall9_wd;</pre>
<pre>  logic stall_stall9_we;</pre>
<pre>  logic stall_stall10_qs;</pre>
<pre>  logic stall_stall10_wd;</pre>
<pre>  logic stall_stall10_we;</pre>
<pre>  logic stall_stall11_qs;</pre>
<pre>  logic stall_stall11_wd;</pre>
<pre>  logic stall_stall11_we;</pre>
<pre>  logic [4:0] configin0_buffer0_qs;</pre>
<pre>  logic [4:0] configin0_buffer0_wd;</pre>
<pre>  logic configin0_buffer0_we;</pre>
<pre>  logic [6:0] configin0_size0_qs;</pre>
<pre>  logic [6:0] configin0_size0_wd;</pre>
<pre>  logic configin0_size0_we;</pre>
<pre>  logic configin0_pend0_qs;</pre>
<pre>  logic configin0_pend0_wd;</pre>
<pre>  logic configin0_pend0_we;</pre>
<pre>  logic configin0_rdy0_qs;</pre>
<pre>  logic configin0_rdy0_wd;</pre>
<pre>  logic configin0_rdy0_we;</pre>
<pre>  logic [4:0] configin1_buffer1_qs;</pre>
<pre>  logic [4:0] configin1_buffer1_wd;</pre>
<pre>  logic configin1_buffer1_we;</pre>
<pre>  logic [6:0] configin1_size1_qs;</pre>
<pre>  logic [6:0] configin1_size1_wd;</pre>
<pre>  logic configin1_size1_we;</pre>
<pre>  logic configin1_pend1_qs;</pre>
<pre>  logic configin1_pend1_wd;</pre>
<pre>  logic configin1_pend1_we;</pre>
<pre>  logic configin1_rdy1_qs;</pre>
<pre>  logic configin1_rdy1_wd;</pre>
<pre>  logic configin1_rdy1_we;</pre>
<pre>  logic [4:0] configin2_buffer2_qs;</pre>
<pre>  logic [4:0] configin2_buffer2_wd;</pre>
<pre>  logic configin2_buffer2_we;</pre>
<pre>  logic [6:0] configin2_size2_qs;</pre>
<pre>  logic [6:0] configin2_size2_wd;</pre>
<pre>  logic configin2_size2_we;</pre>
<pre>  logic configin2_pend2_qs;</pre>
<pre>  logic configin2_pend2_wd;</pre>
<pre>  logic configin2_pend2_we;</pre>
<pre>  logic configin2_rdy2_qs;</pre>
<pre>  logic configin2_rdy2_wd;</pre>
<pre>  logic configin2_rdy2_we;</pre>
<pre>  logic [4:0] configin3_buffer3_qs;</pre>
<pre>  logic [4:0] configin3_buffer3_wd;</pre>
<pre>  logic configin3_buffer3_we;</pre>
<pre>  logic [6:0] configin3_size3_qs;</pre>
<pre>  logic [6:0] configin3_size3_wd;</pre>
<pre>  logic configin3_size3_we;</pre>
<pre>  logic configin3_pend3_qs;</pre>
<pre>  logic configin3_pend3_wd;</pre>
<pre>  logic configin3_pend3_we;</pre>
<pre>  logic configin3_rdy3_qs;</pre>
<pre>  logic configin3_rdy3_wd;</pre>
<pre>  logic configin3_rdy3_we;</pre>
<pre>  logic [4:0] configin4_buffer4_qs;</pre>
<pre>  logic [4:0] configin4_buffer4_wd;</pre>
<pre>  logic configin4_buffer4_we;</pre>
<pre>  logic [6:0] configin4_size4_qs;</pre>
<pre>  logic [6:0] configin4_size4_wd;</pre>
<pre>  logic configin4_size4_we;</pre>
<pre>  logic configin4_pend4_qs;</pre>
<pre>  logic configin4_pend4_wd;</pre>
<pre>  logic configin4_pend4_we;</pre>
<pre>  logic configin4_rdy4_qs;</pre>
<pre>  logic configin4_rdy4_wd;</pre>
<pre>  logic configin4_rdy4_we;</pre>
<pre>  logic [4:0] configin5_buffer5_qs;</pre>
<pre>  logic [4:0] configin5_buffer5_wd;</pre>
<pre>  logic configin5_buffer5_we;</pre>
<pre>  logic [6:0] configin5_size5_qs;</pre>
<pre>  logic [6:0] configin5_size5_wd;</pre>
<pre>  logic configin5_size5_we;</pre>
<pre>  logic configin5_pend5_qs;</pre>
<pre>  logic configin5_pend5_wd;</pre>
<pre>  logic configin5_pend5_we;</pre>
<pre>  logic configin5_rdy5_qs;</pre>
<pre>  logic configin5_rdy5_wd;</pre>
<pre>  logic configin5_rdy5_we;</pre>
<pre>  logic [4:0] configin6_buffer6_qs;</pre>
<pre>  logic [4:0] configin6_buffer6_wd;</pre>
<pre>  logic configin6_buffer6_we;</pre>
<pre>  logic [6:0] configin6_size6_qs;</pre>
<pre>  logic [6:0] configin6_size6_wd;</pre>
<pre>  logic configin6_size6_we;</pre>
<pre>  logic configin6_pend6_qs;</pre>
<pre>  logic configin6_pend6_wd;</pre>
<pre>  logic configin6_pend6_we;</pre>
<pre>  logic configin6_rdy6_qs;</pre>
<pre>  logic configin6_rdy6_wd;</pre>
<pre>  logic configin6_rdy6_we;</pre>
<pre>  logic [4:0] configin7_buffer7_qs;</pre>
<pre>  logic [4:0] configin7_buffer7_wd;</pre>
<pre>  logic configin7_buffer7_we;</pre>
<pre>  logic [6:0] configin7_size7_qs;</pre>
<pre>  logic [6:0] configin7_size7_wd;</pre>
<pre>  logic configin7_size7_we;</pre>
<pre>  logic configin7_pend7_qs;</pre>
<pre>  logic configin7_pend7_wd;</pre>
<pre>  logic configin7_pend7_we;</pre>
<pre>  logic configin7_rdy7_qs;</pre>
<pre>  logic configin7_rdy7_wd;</pre>
<pre>  logic configin7_rdy7_we;</pre>
<pre>  logic [4:0] configin8_buffer8_qs;</pre>
<pre>  logic [4:0] configin8_buffer8_wd;</pre>
<pre>  logic configin8_buffer8_we;</pre>
<pre>  logic [6:0] configin8_size8_qs;</pre>
<pre>  logic [6:0] configin8_size8_wd;</pre>
<pre>  logic configin8_size8_we;</pre>
<pre>  logic configin8_pend8_qs;</pre>
<pre>  logic configin8_pend8_wd;</pre>
<pre>  logic configin8_pend8_we;</pre>
<pre>  logic configin8_rdy8_qs;</pre>
<pre>  logic configin8_rdy8_wd;</pre>
<pre>  logic configin8_rdy8_we;</pre>
<pre>  logic [4:0] configin9_buffer9_qs;</pre>
<pre>  logic [4:0] configin9_buffer9_wd;</pre>
<pre>  logic configin9_buffer9_we;</pre>
<pre>  logic [6:0] configin9_size9_qs;</pre>
<pre>  logic [6:0] configin9_size9_wd;</pre>
<pre>  logic configin9_size9_we;</pre>
<pre>  logic configin9_pend9_qs;</pre>
<pre>  logic configin9_pend9_wd;</pre>
<pre>  logic configin9_pend9_we;</pre>
<pre>  logic configin9_rdy9_qs;</pre>
<pre>  logic configin9_rdy9_wd;</pre>
<pre>  logic configin9_rdy9_we;</pre>
<pre>  logic [4:0] configin10_buffer10_qs;</pre>
<pre>  logic [4:0] configin10_buffer10_wd;</pre>
<pre>  logic configin10_buffer10_we;</pre>
<pre>  logic [6:0] configin10_size10_qs;</pre>
<pre>  logic [6:0] configin10_size10_wd;</pre>
<pre>  logic configin10_size10_we;</pre>
<pre>  logic configin10_pend10_qs;</pre>
<pre>  logic configin10_pend10_wd;</pre>
<pre>  logic configin10_pend10_we;</pre>
<pre>  logic configin10_rdy10_qs;</pre>
<pre>  logic configin10_rdy10_wd;</pre>
<pre>  logic configin10_rdy10_we;</pre>
<pre>  logic [4:0] configin11_buffer11_qs;</pre>
<pre>  logic [4:0] configin11_buffer11_wd;</pre>
<pre>  logic configin11_buffer11_we;</pre>
<pre>  logic [6:0] configin11_size11_qs;</pre>
<pre>  logic [6:0] configin11_size11_wd;</pre>
<pre>  logic configin11_size11_we;</pre>
<pre>  logic configin11_pend11_qs;</pre>
<pre>  logic configin11_pend11_wd;</pre>
<pre>  logic configin11_pend11_we;</pre>
<pre>  logic configin11_rdy11_qs;</pre>
<pre>  logic configin11_rdy11_wd;</pre>
<pre>  logic configin11_rdy11_we;</pre>
<pre>  logic iso_iso0_qs;</pre>
<pre>  logic iso_iso0_wd;</pre>
<pre>  logic iso_iso0_we;</pre>
<pre>  logic iso_iso1_qs;</pre>
<pre>  logic iso_iso1_wd;</pre>
<pre>  logic iso_iso1_we;</pre>
<pre>  logic iso_iso2_qs;</pre>
<pre>  logic iso_iso2_wd;</pre>
<pre>  logic iso_iso2_we;</pre>
<pre>  logic iso_iso3_qs;</pre>
<pre>  logic iso_iso3_wd;</pre>
<pre>  logic iso_iso3_we;</pre>
<pre>  logic iso_iso4_qs;</pre>
<pre>  logic iso_iso4_wd;</pre>
<pre>  logic iso_iso4_we;</pre>
<pre>  logic iso_iso5_qs;</pre>
<pre>  logic iso_iso5_wd;</pre>
<pre>  logic iso_iso5_we;</pre>
<pre>  logic iso_iso6_qs;</pre>
<pre>  logic iso_iso6_wd;</pre>
<pre>  logic iso_iso6_we;</pre>
<pre>  logic iso_iso7_qs;</pre>
<pre>  logic iso_iso7_wd;</pre>
<pre>  logic iso_iso7_we;</pre>
<pre>  logic iso_iso8_qs;</pre>
<pre>  logic iso_iso8_wd;</pre>
<pre>  logic iso_iso8_we;</pre>
<pre>  logic iso_iso9_qs;</pre>
<pre>  logic iso_iso9_wd;</pre>
<pre>  logic iso_iso9_we;</pre>
<pre>  logic iso_iso10_qs;</pre>
<pre>  logic iso_iso10_wd;</pre>
<pre>  logic iso_iso10_we;</pre>
<pre>  logic iso_iso11_qs;</pre>
<pre>  logic iso_iso11_wd;</pre>
<pre>  logic iso_iso11_we;</pre>
<pre>  logic data_toggle_clear_clear0_wd;</pre>
<pre>  logic data_toggle_clear_clear0_we;</pre>
<pre>  logic data_toggle_clear_clear1_wd;</pre>
<pre>  logic data_toggle_clear_clear1_we;</pre>
<pre>  logic data_toggle_clear_clear2_wd;</pre>
<pre>  logic data_toggle_clear_clear2_we;</pre>
<pre>  logic data_toggle_clear_clear3_wd;</pre>
<pre>  logic data_toggle_clear_clear3_we;</pre>
<pre>  logic data_toggle_clear_clear4_wd;</pre>
<pre>  logic data_toggle_clear_clear4_we;</pre>
<pre>  logic data_toggle_clear_clear5_wd;</pre>
<pre>  logic data_toggle_clear_clear5_we;</pre>
<pre>  logic data_toggle_clear_clear6_wd;</pre>
<pre>  logic data_toggle_clear_clear6_we;</pre>
<pre>  logic data_toggle_clear_clear7_wd;</pre>
<pre>  logic data_toggle_clear_clear7_we;</pre>
<pre>  logic data_toggle_clear_clear8_wd;</pre>
<pre>  logic data_toggle_clear_clear8_we;</pre>
<pre>  logic data_toggle_clear_clear9_wd;</pre>
<pre>  logic data_toggle_clear_clear9_we;</pre>
<pre>  logic data_toggle_clear_clear10_wd;</pre>
<pre>  logic data_toggle_clear_clear10_we;</pre>
<pre>  logic data_toggle_clear_clear11_wd;</pre>
<pre>  logic data_toggle_clear_clear11_we;</pre>
<pre>  logic phy_config_rx_differential_mode_qs;</pre>
<pre>  logic phy_config_rx_differential_mode_wd;</pre>
<pre>  logic phy_config_rx_differential_mode_we;</pre>
<pre>  logic phy_config_tx_differential_mode_qs;</pre>
<pre>  logic phy_config_tx_differential_mode_wd;</pre>
<pre>  logic phy_config_tx_differential_mode_we;</pre>
<pre>  logic phy_config_eop_single_bit_qs;</pre>
<pre>  logic phy_config_eop_single_bit_wd;</pre>
<pre>  logic phy_config_eop_single_bit_we;</pre>
<pre>  logic phy_config_override_pwr_sense_en_qs;</pre>
<pre>  logic phy_config_override_pwr_sense_en_wd;</pre>
<pre>  logic phy_config_override_pwr_sense_en_we;</pre>
<pre>  logic phy_config_override_pwr_sense_val_qs;</pre>
<pre>  logic phy_config_override_pwr_sense_val_wd;</pre>
<pre>  logic phy_config_override_pwr_sense_val_we;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_pkt_received (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_pkt_received_we),</pre>
<pre>    .wd     (intr_state_pkt_received_wd),</pre>
<pre>    .de     (hw2reg.intr_state.pkt_received.de),</pre>
<pre>    .d      (hw2reg.intr_state.pkt_received.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.pkt_received.q ),</pre>
<pre>    .qs     (intr_state_pkt_received_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_pkt_sent (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_pkt_sent_we),</pre>
<pre>    .wd     (intr_state_pkt_sent_wd),</pre>
<pre>    .de     (hw2reg.intr_state.pkt_sent.de),</pre>
<pre>    .d      (hw2reg.intr_state.pkt_sent.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.pkt_sent.q ),</pre>
<pre>    .qs     (intr_state_pkt_sent_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_disconnected (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_disconnected_we),</pre>
<pre>    .wd     (intr_state_disconnected_wd),</pre>
<pre>    .de     (hw2reg.intr_state.disconnected.de),</pre>
<pre>    .d      (hw2reg.intr_state.disconnected.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.disconnected.q ),</pre>
<pre>    .qs     (intr_state_disconnected_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_host_lost (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_host_lost_we),</pre>
<pre>    .wd     (intr_state_host_lost_wd),</pre>
<pre>    .de     (hw2reg.intr_state.host_lost.de),</pre>
<pre>    .d      (hw2reg.intr_state.host_lost.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.host_lost.q ),</pre>
<pre>    .qs     (intr_state_host_lost_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_link_reset (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_link_reset_we),</pre>
<pre>    .wd     (intr_state_link_reset_wd),</pre>
<pre>    .de     (hw2reg.intr_state.link_reset.de),</pre>
<pre>    .d      (hw2reg.intr_state.link_reset.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.link_reset.q ),</pre>
<pre>    .qs     (intr_state_link_reset_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_link_suspend (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_link_suspend_we),</pre>
<pre>    .wd     (intr_state_link_suspend_wd),</pre>
<pre>    .de     (hw2reg.intr_state.link_suspend.de),</pre>
<pre>    .d      (hw2reg.intr_state.link_suspend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.link_suspend.q ),</pre>
<pre>    .qs     (intr_state_link_suspend_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_link_resume (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_link_resume_we),</pre>
<pre>    .wd     (intr_state_link_resume_wd),</pre>
<pre>    .de     (hw2reg.intr_state.link_resume.de),</pre>
<pre>    .d      (hw2reg.intr_state.link_resume.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.link_resume.q ),</pre>
<pre>    .qs     (intr_state_link_resume_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_av_empty (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_av_empty_we),</pre>
<pre>    .wd     (intr_state_av_empty_wd),</pre>
<pre>    .de     (hw2reg.intr_state.av_empty.de),</pre>
<pre>    .d      (hw2reg.intr_state.av_empty.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.av_empty.q ),</pre>
<pre>    .qs     (intr_state_av_empty_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rx_full (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rx_full_we),</pre>
<pre>    .wd     (intr_state_rx_full_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rx_full.de),</pre>
<pre>    .d      (hw2reg.intr_state.rx_full.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rx_full.q ),</pre>
<pre>    .qs     (intr_state_rx_full_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_av_overflow (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_av_overflow_we),</pre>
<pre>    .wd     (intr_state_av_overflow_wd),</pre>
<pre>    .de     (hw2reg.intr_state.av_overflow.de),</pre>
<pre>    .d      (hw2reg.intr_state.av_overflow.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.av_overflow.q ),</pre>
<pre>    .qs     (intr_state_av_overflow_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_link_in_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_link_in_err_we),</pre>
<pre>    .wd     (intr_state_link_in_err_wd),</pre>
<pre>    .de     (hw2reg.intr_state.link_in_err.de),</pre>
<pre>    .d      (hw2reg.intr_state.link_in_err.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.link_in_err.q ),</pre>
<pre>    .qs     (intr_state_link_in_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rx_crc_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rx_crc_err_we),</pre>
<pre>    .wd     (intr_state_rx_crc_err_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rx_crc_err.de),</pre>
<pre>    .d      (hw2reg.intr_state.rx_crc_err.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rx_crc_err.q ),</pre>
<pre>    .qs     (intr_state_rx_crc_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rx_pid_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rx_pid_err_we),</pre>
<pre>    .wd     (intr_state_rx_pid_err_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rx_pid_err.de),</pre>
<pre>    .d      (hw2reg.intr_state.rx_pid_err.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rx_pid_err.q ),</pre>
<pre>    .qs     (intr_state_rx_pid_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rx_bitstuff_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rx_bitstuff_err_we),</pre>
<pre>    .wd     (intr_state_rx_bitstuff_err_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rx_bitstuff_err.de),</pre>
<pre>    .d      (hw2reg.intr_state.rx_bitstuff_err.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rx_bitstuff_err.q ),</pre>
<pre>    .qs     (intr_state_rx_bitstuff_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_frame (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_frame_we),</pre>
<pre>    .wd     (intr_state_frame_wd),</pre>
<pre>    .de     (hw2reg.intr_state.frame.de),</pre>
<pre>    .d      (hw2reg.intr_state.frame.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.frame.q ),</pre>
<pre>    .qs     (intr_state_frame_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_connected (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_connected_we),</pre>
<pre>    .wd     (intr_state_connected_wd),</pre>
<pre>    .de     (hw2reg.intr_state.connected.de),</pre>
<pre>    .d      (hw2reg.intr_state.connected.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.connected.q ),</pre>
<pre>    .qs     (intr_state_connected_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_pkt_received (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_pkt_received_we),</pre>
<pre>    .wd     (intr_enable_pkt_received_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.pkt_received.q ),</pre>
<pre>    .qs     (intr_enable_pkt_received_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_pkt_sent (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_pkt_sent_we),</pre>
<pre>    .wd     (intr_enable_pkt_sent_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.pkt_sent.q ),</pre>
<pre>    .qs     (intr_enable_pkt_sent_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_disconnected (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_disconnected_we),</pre>
<pre>    .wd     (intr_enable_disconnected_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.disconnected.q ),</pre>
<pre>    .qs     (intr_enable_disconnected_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_host_lost (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_host_lost_we),</pre>
<pre>    .wd     (intr_enable_host_lost_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.host_lost.q ),</pre>
<pre>    .qs     (intr_enable_host_lost_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_link_reset (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_link_reset_we),</pre>
<pre>    .wd     (intr_enable_link_reset_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.link_reset.q ),</pre>
<pre>    .qs     (intr_enable_link_reset_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_link_suspend (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_link_suspend_we),</pre>
<pre>    .wd     (intr_enable_link_suspend_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.link_suspend.q ),</pre>
<pre>    .qs     (intr_enable_link_suspend_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_link_resume (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_link_resume_we),</pre>
<pre>    .wd     (intr_enable_link_resume_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.link_resume.q ),</pre>
<pre>    .qs     (intr_enable_link_resume_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_av_empty (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_av_empty_we),</pre>
<pre>    .wd     (intr_enable_av_empty_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.av_empty.q ),</pre>
<pre>    .qs     (intr_enable_av_empty_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rx_full (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rx_full_we),</pre>
<pre>    .wd     (intr_enable_rx_full_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rx_full.q ),</pre>
<pre>    .qs     (intr_enable_rx_full_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_av_overflow (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_av_overflow_we),</pre>
<pre>    .wd     (intr_enable_av_overflow_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.av_overflow.q ),</pre>
<pre>    .qs     (intr_enable_av_overflow_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_link_in_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_link_in_err_we),</pre>
<pre>    .wd     (intr_enable_link_in_err_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.link_in_err.q ),</pre>
<pre>    .qs     (intr_enable_link_in_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rx_crc_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rx_crc_err_we),</pre>
<pre>    .wd     (intr_enable_rx_crc_err_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rx_crc_err.q ),</pre>
<pre>    .qs     (intr_enable_rx_crc_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rx_pid_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rx_pid_err_we),</pre>
<pre>    .wd     (intr_enable_rx_pid_err_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rx_pid_err.q ),</pre>
<pre>    .qs     (intr_enable_rx_pid_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rx_bitstuff_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rx_bitstuff_err_we),</pre>
<pre>    .wd     (intr_enable_rx_bitstuff_err_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rx_bitstuff_err.q ),</pre>
<pre>    .qs     (intr_enable_rx_bitstuff_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_frame (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_frame_we),</pre>
<pre>    .wd     (intr_enable_frame_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.frame.q ),</pre>
<pre>    .qs     (intr_enable_frame_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_connected (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_connected_we),</pre>
<pre>    .wd     (intr_enable_connected_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.connected.q ),</pre>
<pre>    .qs     (intr_enable_connected_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_pkt_received (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_pkt_received_we),</pre>
<pre>    .wd     (intr_test_pkt_received_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.pkt_received.qe),</pre>
<pre>    .q      (reg2hw.intr_test.pkt_received.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_pkt_sent (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_pkt_sent_we),</pre>
<pre>    .wd     (intr_test_pkt_sent_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.pkt_sent.qe),</pre>
<pre>    .q      (reg2hw.intr_test.pkt_sent.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_disconnected (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_disconnected_we),</pre>
<pre>    .wd     (intr_test_disconnected_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.disconnected.qe),</pre>
<pre>    .q      (reg2hw.intr_test.disconnected.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_host_lost (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_host_lost_we),</pre>
<pre>    .wd     (intr_test_host_lost_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.host_lost.qe),</pre>
<pre>    .q      (reg2hw.intr_test.host_lost.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_link_reset (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_link_reset_we),</pre>
<pre>    .wd     (intr_test_link_reset_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.link_reset.qe),</pre>
<pre>    .q      (reg2hw.intr_test.link_reset.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_link_suspend (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_link_suspend_we),</pre>
<pre>    .wd     (intr_test_link_suspend_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.link_suspend.qe),</pre>
<pre>    .q      (reg2hw.intr_test.link_suspend.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_link_resume (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_link_resume_we),</pre>
<pre>    .wd     (intr_test_link_resume_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.link_resume.qe),</pre>
<pre>    .q      (reg2hw.intr_test.link_resume.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_av_empty (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_av_empty_we),</pre>
<pre>    .wd     (intr_test_av_empty_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.av_empty.qe),</pre>
<pre>    .q      (reg2hw.intr_test.av_empty.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rx_full (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rx_full_we),</pre>
<pre>    .wd     (intr_test_rx_full_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rx_full.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rx_full.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_av_overflow (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_av_overflow_we),</pre>
<pre>    .wd     (intr_test_av_overflow_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.av_overflow.qe),</pre>
<pre>    .q      (reg2hw.intr_test.av_overflow.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_link_in_err (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_link_in_err_we),</pre>
<pre>    .wd     (intr_test_link_in_err_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.link_in_err.qe),</pre>
<pre>    .q      (reg2hw.intr_test.link_in_err.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rx_crc_err (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rx_crc_err_we),</pre>
<pre>    .wd     (intr_test_rx_crc_err_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rx_crc_err.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rx_crc_err.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rx_pid_err (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rx_pid_err_we),</pre>
<pre>    .wd     (intr_test_rx_pid_err_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rx_pid_err.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rx_pid_err.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rx_bitstuff_err (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rx_bitstuff_err_we),</pre>
<pre>    .wd     (intr_test_rx_bitstuff_err_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rx_bitstuff_err.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rx_bitstuff_err.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_frame (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_frame_we),</pre>
<pre>    .wd     (intr_test_frame_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.frame.qe),</pre>
<pre>    .q      (reg2hw.intr_test.frame.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_connected (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_connected_we),</pre>
<pre>    .wd     (intr_test_connected_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.connected.qe),</pre>
<pre>    .q      (reg2hw.intr_test.connected.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_usbctrl_enable (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (usbctrl_enable_we),</pre>
<pre>    .wd     (usbctrl_enable_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.usbctrl.enable.q ),</pre>
<pre>    .qs     (usbctrl_enable_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_usbctrl_device_address (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (usbctrl_device_address_we),</pre>
<pre>    .wd     (usbctrl_device_address_wd),</pre>
<pre>    .de     (hw2reg.usbctrl.device_address.de),</pre>
<pre>    .d      (hw2reg.usbctrl.device_address.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.usbctrl.device_address.q ),</pre>
<pre>    .qs     (usbctrl_device_address_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (11)</pre>
<pre style="background-color: #FF0000;">  ) u_usbstat_frame (</pre>
<pre>    .re     (usbstat_frame_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.usbstat.frame.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (usbstat_frame_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_usbstat_host_lost (</pre>
<pre>    .re     (usbstat_host_lost_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.usbstat.host_lost.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (usbstat_host_lost_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (3)</pre>
<pre style="background-color: #FF0000;">  ) u_usbstat_link_state (</pre>
<pre>    .re     (usbstat_link_state_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.usbstat.link_state.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (usbstat_link_state_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_usbstat_usb_sense (</pre>
<pre>    .re     (usbstat_usb_sense_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.usbstat.usb_sense.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (usbstat_usb_sense_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (3)</pre>
<pre style="background-color: #FF0000;">  ) u_usbstat_av_depth (</pre>
<pre>    .re     (usbstat_av_depth_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.usbstat.av_depth.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (usbstat_av_depth_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_usbstat_av_full (</pre>
<pre>    .re     (usbstat_av_full_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.usbstat.av_full.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (usbstat_av_full_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (3)</pre>
<pre style="background-color: #FF0000;">  ) u_usbstat_rx_depth (</pre>
<pre>    .re     (usbstat_rx_depth_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.usbstat.rx_depth.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (usbstat_rx_depth_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_usbstat_rx_empty (</pre>
<pre>    .re     (usbstat_rx_empty_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.usbstat.rx_empty.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (usbstat_rx_empty_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_avbuffer (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (avbuffer_we),</pre>
<pre>    .wd     (avbuffer_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.avbuffer.qe),</pre>
<pre>    .q      (reg2hw.avbuffer.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (5)</pre>
<pre style="background-color: #FF0000;">  ) u_rxfifo_buffer (</pre>
<pre>    .re     (rxfifo_buffer_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.rxfifo.buffer.d),</pre>
<pre>    .qre    (reg2hw.rxfifo.buffer.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxfifo.buffer.q ),</pre>
<pre>    .qs     (rxfifo_buffer_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (7)</pre>
<pre style="background-color: #FF0000;">  ) u_rxfifo_size (</pre>
<pre>    .re     (rxfifo_size_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.rxfifo.size.d),</pre>
<pre>    .qre    (reg2hw.rxfifo.size.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxfifo.size.q ),</pre>
<pre>    .qs     (rxfifo_size_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_rxfifo_setup (</pre>
<pre>    .re     (rxfifo_setup_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.rxfifo.setup.d),</pre>
<pre>    .qre    (reg2hw.rxfifo.setup.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxfifo.setup.q ),</pre>
<pre>    .qs     (rxfifo_setup_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (4)</pre>
<pre style="background-color: #FF0000;">  ) u_rxfifo_ep (</pre>
<pre>    .re     (rxfifo_ep_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.rxfifo.ep.d),</pre>
<pre>    .qre    (reg2hw.rxfifo.ep.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxfifo.ep.q ),</pre>
<pre>    .qs     (rxfifo_ep_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup0_we),</pre>
<pre>    .wd     (rxenable_setup_setup0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[0].q ),</pre>
<pre>    .qs     (rxenable_setup_setup0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup1_we),</pre>
<pre>    .wd     (rxenable_setup_setup1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[1].q ),</pre>
<pre>    .qs     (rxenable_setup_setup1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup2_we),</pre>
<pre>    .wd     (rxenable_setup_setup2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[2].q ),</pre>
<pre>    .qs     (rxenable_setup_setup2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup3_we),</pre>
<pre>    .wd     (rxenable_setup_setup3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[3].q ),</pre>
<pre>    .qs     (rxenable_setup_setup3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup4_we),</pre>
<pre>    .wd     (rxenable_setup_setup4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[4].q ),</pre>
<pre>    .qs     (rxenable_setup_setup4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup5_we),</pre>
<pre>    .wd     (rxenable_setup_setup5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[5].q ),</pre>
<pre>    .qs     (rxenable_setup_setup5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup6_we),</pre>
<pre>    .wd     (rxenable_setup_setup6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[6].q ),</pre>
<pre>    .qs     (rxenable_setup_setup6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup7_we),</pre>
<pre>    .wd     (rxenable_setup_setup7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[7].q ),</pre>
<pre>    .qs     (rxenable_setup_setup7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup8_we),</pre>
<pre>    .wd     (rxenable_setup_setup8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[8].q ),</pre>
<pre>    .qs     (rxenable_setup_setup8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup9_we),</pre>
<pre>    .wd     (rxenable_setup_setup9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[9].q ),</pre>
<pre>    .qs     (rxenable_setup_setup9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup10_we),</pre>
<pre>    .wd     (rxenable_setup_setup10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[10].q ),</pre>
<pre>    .qs     (rxenable_setup_setup10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_setup_setup11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_setup_setup11_we),</pre>
<pre>    .wd     (rxenable_setup_setup11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_setup[11].q ),</pre>
<pre>    .qs     (rxenable_setup_setup11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out0_we),</pre>
<pre>    .wd     (rxenable_out_out0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[0].q ),</pre>
<pre>    .qs     (rxenable_out_out0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out1_we),</pre>
<pre>    .wd     (rxenable_out_out1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[1].q ),</pre>
<pre>    .qs     (rxenable_out_out1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out2_we),</pre>
<pre>    .wd     (rxenable_out_out2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[2].q ),</pre>
<pre>    .qs     (rxenable_out_out2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out3_we),</pre>
<pre>    .wd     (rxenable_out_out3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[3].q ),</pre>
<pre>    .qs     (rxenable_out_out3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out4_we),</pre>
<pre>    .wd     (rxenable_out_out4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[4].q ),</pre>
<pre>    .qs     (rxenable_out_out4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out5_we),</pre>
<pre>    .wd     (rxenable_out_out5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[5].q ),</pre>
<pre>    .qs     (rxenable_out_out5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out6_we),</pre>
<pre>    .wd     (rxenable_out_out6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[6].q ),</pre>
<pre>    .qs     (rxenable_out_out6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out7_we),</pre>
<pre>    .wd     (rxenable_out_out7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[7].q ),</pre>
<pre>    .qs     (rxenable_out_out7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out8_we),</pre>
<pre>    .wd     (rxenable_out_out8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[8].q ),</pre>
<pre>    .qs     (rxenable_out_out8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out9_we),</pre>
<pre>    .wd     (rxenable_out_out9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[9].q ),</pre>
<pre>    .qs     (rxenable_out_out9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out10_we),</pre>
<pre>    .wd     (rxenable_out_out10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[10].q ),</pre>
<pre>    .qs     (rxenable_out_out10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxenable_out_out11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxenable_out_out11_we),</pre>
<pre>    .wd     (rxenable_out_out11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxenable_out[11].q ),</pre>
<pre>    .qs     (rxenable_out_out11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent0_we),</pre>
<pre>    .wd     (in_sent_sent0_wd),</pre>
<pre>    .de     (hw2reg.in_sent[0].de),</pre>
<pre>    .d      (hw2reg.in_sent[0].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent1_we),</pre>
<pre>    .wd     (in_sent_sent1_wd),</pre>
<pre>    .de     (hw2reg.in_sent[1].de),</pre>
<pre>    .d      (hw2reg.in_sent[1].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent2_we),</pre>
<pre>    .wd     (in_sent_sent2_wd),</pre>
<pre>    .de     (hw2reg.in_sent[2].de),</pre>
<pre>    .d      (hw2reg.in_sent[2].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent3_we),</pre>
<pre>    .wd     (in_sent_sent3_wd),</pre>
<pre>    .de     (hw2reg.in_sent[3].de),</pre>
<pre>    .d      (hw2reg.in_sent[3].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent4_we),</pre>
<pre>    .wd     (in_sent_sent4_wd),</pre>
<pre>    .de     (hw2reg.in_sent[4].de),</pre>
<pre>    .d      (hw2reg.in_sent[4].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent5_we),</pre>
<pre>    .wd     (in_sent_sent5_wd),</pre>
<pre>    .de     (hw2reg.in_sent[5].de),</pre>
<pre>    .d      (hw2reg.in_sent[5].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent6_we),</pre>
<pre>    .wd     (in_sent_sent6_wd),</pre>
<pre>    .de     (hw2reg.in_sent[6].de),</pre>
<pre>    .d      (hw2reg.in_sent[6].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent7_we),</pre>
<pre>    .wd     (in_sent_sent7_wd),</pre>
<pre>    .de     (hw2reg.in_sent[7].de),</pre>
<pre>    .d      (hw2reg.in_sent[7].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent8_we),</pre>
<pre>    .wd     (in_sent_sent8_wd),</pre>
<pre>    .de     (hw2reg.in_sent[8].de),</pre>
<pre>    .d      (hw2reg.in_sent[8].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent9_we),</pre>
<pre>    .wd     (in_sent_sent9_wd),</pre>
<pre>    .de     (hw2reg.in_sent[9].de),</pre>
<pre>    .d      (hw2reg.in_sent[9].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent10_we),</pre>
<pre>    .wd     (in_sent_sent10_wd),</pre>
<pre>    .de     (hw2reg.in_sent[10].de),</pre>
<pre>    .d      (hw2reg.in_sent[10].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_in_sent_sent11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (in_sent_sent11_we),</pre>
<pre>    .wd     (in_sent_sent11_wd),</pre>
<pre>    .de     (hw2reg.in_sent[11].de),</pre>
<pre>    .d      (hw2reg.in_sent[11].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (in_sent_sent11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall0_we),</pre>
<pre>    .wd     (stall_stall0_wd),</pre>
<pre>    .de     (hw2reg.stall[0].de),</pre>
<pre>    .d      (hw2reg.stall[0].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[0].q ),</pre>
<pre>    .qs     (stall_stall0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall1_we),</pre>
<pre>    .wd     (stall_stall1_wd),</pre>
<pre>    .de     (hw2reg.stall[1].de),</pre>
<pre>    .d      (hw2reg.stall[1].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[1].q ),</pre>
<pre>    .qs     (stall_stall1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall2_we),</pre>
<pre>    .wd     (stall_stall2_wd),</pre>
<pre>    .de     (hw2reg.stall[2].de),</pre>
<pre>    .d      (hw2reg.stall[2].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[2].q ),</pre>
<pre>    .qs     (stall_stall2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall3_we),</pre>
<pre>    .wd     (stall_stall3_wd),</pre>
<pre>    .de     (hw2reg.stall[3].de),</pre>
<pre>    .d      (hw2reg.stall[3].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[3].q ),</pre>
<pre>    .qs     (stall_stall3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall4_we),</pre>
<pre>    .wd     (stall_stall4_wd),</pre>
<pre>    .de     (hw2reg.stall[4].de),</pre>
<pre>    .d      (hw2reg.stall[4].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[4].q ),</pre>
<pre>    .qs     (stall_stall4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall5_we),</pre>
<pre>    .wd     (stall_stall5_wd),</pre>
<pre>    .de     (hw2reg.stall[5].de),</pre>
<pre>    .d      (hw2reg.stall[5].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[5].q ),</pre>
<pre>    .qs     (stall_stall5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall6_we),</pre>
<pre>    .wd     (stall_stall6_wd),</pre>
<pre>    .de     (hw2reg.stall[6].de),</pre>
<pre>    .d      (hw2reg.stall[6].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[6].q ),</pre>
<pre>    .qs     (stall_stall6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall7_we),</pre>
<pre>    .wd     (stall_stall7_wd),</pre>
<pre>    .de     (hw2reg.stall[7].de),</pre>
<pre>    .d      (hw2reg.stall[7].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[7].q ),</pre>
<pre>    .qs     (stall_stall7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall8_we),</pre>
<pre>    .wd     (stall_stall8_wd),</pre>
<pre>    .de     (hw2reg.stall[8].de),</pre>
<pre>    .d      (hw2reg.stall[8].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[8].q ),</pre>
<pre>    .qs     (stall_stall8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall9_we),</pre>
<pre>    .wd     (stall_stall9_wd),</pre>
<pre>    .de     (hw2reg.stall[9].de),</pre>
<pre>    .d      (hw2reg.stall[9].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[9].q ),</pre>
<pre>    .qs     (stall_stall9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall10_we),</pre>
<pre>    .wd     (stall_stall10_wd),</pre>
<pre>    .de     (hw2reg.stall[10].de),</pre>
<pre>    .d      (hw2reg.stall[10].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[10].q ),</pre>
<pre>    .qs     (stall_stall10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_stall_stall11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (stall_stall11_we),</pre>
<pre>    .wd     (stall_stall11_wd),</pre>
<pre>    .de     (hw2reg.stall[11].de),</pre>
<pre>    .d      (hw2reg.stall[11].d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.stall[11].q ),</pre>
<pre>    .qs     (stall_stall11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin0_buffer0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin0_buffer0_we),</pre>
<pre>    .wd     (configin0_buffer0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[0].buffer.q ),</pre>
<pre>    .qs     (configin0_buffer0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin0_size0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin0_size0_we),</pre>
<pre>    .wd     (configin0_size0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[0].size.q ),</pre>
<pre>    .qs     (configin0_size0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin0_pend0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin0_pend0_we),</pre>
<pre>    .wd     (configin0_pend0_wd),</pre>
<pre>    .de     (hw2reg.configin[0].pend.de),</pre>
<pre>    .d      (hw2reg.configin[0].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[0].pend.q ),</pre>
<pre>    .qs     (configin0_pend0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin0_rdy0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin0_rdy0_we),</pre>
<pre>    .wd     (configin0_rdy0_wd),</pre>
<pre>    .de     (hw2reg.configin[0].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[0].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[0].rdy.q ),</pre>
<pre>    .qs     (configin0_rdy0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin1_buffer1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin1_buffer1_we),</pre>
<pre>    .wd     (configin1_buffer1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[1].buffer.q ),</pre>
<pre>    .qs     (configin1_buffer1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin1_size1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin1_size1_we),</pre>
<pre>    .wd     (configin1_size1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[1].size.q ),</pre>
<pre>    .qs     (configin1_size1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin1_pend1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin1_pend1_we),</pre>
<pre>    .wd     (configin1_pend1_wd),</pre>
<pre>    .de     (hw2reg.configin[1].pend.de),</pre>
<pre>    .d      (hw2reg.configin[1].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[1].pend.q ),</pre>
<pre>    .qs     (configin1_pend1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin1_rdy1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin1_rdy1_we),</pre>
<pre>    .wd     (configin1_rdy1_wd),</pre>
<pre>    .de     (hw2reg.configin[1].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[1].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[1].rdy.q ),</pre>
<pre>    .qs     (configin1_rdy1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin2_buffer2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin2_buffer2_we),</pre>
<pre>    .wd     (configin2_buffer2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[2].buffer.q ),</pre>
<pre>    .qs     (configin2_buffer2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin2_size2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin2_size2_we),</pre>
<pre>    .wd     (configin2_size2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[2].size.q ),</pre>
<pre>    .qs     (configin2_size2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin2_pend2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin2_pend2_we),</pre>
<pre>    .wd     (configin2_pend2_wd),</pre>
<pre>    .de     (hw2reg.configin[2].pend.de),</pre>
<pre>    .d      (hw2reg.configin[2].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[2].pend.q ),</pre>
<pre>    .qs     (configin2_pend2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin2_rdy2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin2_rdy2_we),</pre>
<pre>    .wd     (configin2_rdy2_wd),</pre>
<pre>    .de     (hw2reg.configin[2].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[2].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[2].rdy.q ),</pre>
<pre>    .qs     (configin2_rdy2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin3_buffer3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin3_buffer3_we),</pre>
<pre>    .wd     (configin3_buffer3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[3].buffer.q ),</pre>
<pre>    .qs     (configin3_buffer3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin3_size3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin3_size3_we),</pre>
<pre>    .wd     (configin3_size3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[3].size.q ),</pre>
<pre>    .qs     (configin3_size3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin3_pend3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin3_pend3_we),</pre>
<pre>    .wd     (configin3_pend3_wd),</pre>
<pre>    .de     (hw2reg.configin[3].pend.de),</pre>
<pre>    .d      (hw2reg.configin[3].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[3].pend.q ),</pre>
<pre>    .qs     (configin3_pend3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin3_rdy3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin3_rdy3_we),</pre>
<pre>    .wd     (configin3_rdy3_wd),</pre>
<pre>    .de     (hw2reg.configin[3].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[3].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[3].rdy.q ),</pre>
<pre>    .qs     (configin3_rdy3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin4_buffer4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin4_buffer4_we),</pre>
<pre>    .wd     (configin4_buffer4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[4].buffer.q ),</pre>
<pre>    .qs     (configin4_buffer4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin4_size4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin4_size4_we),</pre>
<pre>    .wd     (configin4_size4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[4].size.q ),</pre>
<pre>    .qs     (configin4_size4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin4_pend4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin4_pend4_we),</pre>
<pre>    .wd     (configin4_pend4_wd),</pre>
<pre>    .de     (hw2reg.configin[4].pend.de),</pre>
<pre>    .d      (hw2reg.configin[4].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[4].pend.q ),</pre>
<pre>    .qs     (configin4_pend4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin4_rdy4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin4_rdy4_we),</pre>
<pre>    .wd     (configin4_rdy4_wd),</pre>
<pre>    .de     (hw2reg.configin[4].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[4].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[4].rdy.q ),</pre>
<pre>    .qs     (configin4_rdy4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin5_buffer5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin5_buffer5_we),</pre>
<pre>    .wd     (configin5_buffer5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[5].buffer.q ),</pre>
<pre>    .qs     (configin5_buffer5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin5_size5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin5_size5_we),</pre>
<pre>    .wd     (configin5_size5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[5].size.q ),</pre>
<pre>    .qs     (configin5_size5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin5_pend5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin5_pend5_we),</pre>
<pre>    .wd     (configin5_pend5_wd),</pre>
<pre>    .de     (hw2reg.configin[5].pend.de),</pre>
<pre>    .d      (hw2reg.configin[5].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[5].pend.q ),</pre>
<pre>    .qs     (configin5_pend5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin5_rdy5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin5_rdy5_we),</pre>
<pre>    .wd     (configin5_rdy5_wd),</pre>
<pre>    .de     (hw2reg.configin[5].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[5].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[5].rdy.q ),</pre>
<pre>    .qs     (configin5_rdy5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin6_buffer6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin6_buffer6_we),</pre>
<pre>    .wd     (configin6_buffer6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[6].buffer.q ),</pre>
<pre>    .qs     (configin6_buffer6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin6_size6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin6_size6_we),</pre>
<pre>    .wd     (configin6_size6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[6].size.q ),</pre>
<pre>    .qs     (configin6_size6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin6_pend6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin6_pend6_we),</pre>
<pre>    .wd     (configin6_pend6_wd),</pre>
<pre>    .de     (hw2reg.configin[6].pend.de),</pre>
<pre>    .d      (hw2reg.configin[6].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[6].pend.q ),</pre>
<pre>    .qs     (configin6_pend6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin6_rdy6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin6_rdy6_we),</pre>
<pre>    .wd     (configin6_rdy6_wd),</pre>
<pre>    .de     (hw2reg.configin[6].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[6].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[6].rdy.q ),</pre>
<pre>    .qs     (configin6_rdy6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin7_buffer7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin7_buffer7_we),</pre>
<pre>    .wd     (configin7_buffer7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[7].buffer.q ),</pre>
<pre>    .qs     (configin7_buffer7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin7_size7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin7_size7_we),</pre>
<pre>    .wd     (configin7_size7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[7].size.q ),</pre>
<pre>    .qs     (configin7_size7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin7_pend7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin7_pend7_we),</pre>
<pre>    .wd     (configin7_pend7_wd),</pre>
<pre>    .de     (hw2reg.configin[7].pend.de),</pre>
<pre>    .d      (hw2reg.configin[7].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[7].pend.q ),</pre>
<pre>    .qs     (configin7_pend7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin7_rdy7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin7_rdy7_we),</pre>
<pre>    .wd     (configin7_rdy7_wd),</pre>
<pre>    .de     (hw2reg.configin[7].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[7].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[7].rdy.q ),</pre>
<pre>    .qs     (configin7_rdy7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin8_buffer8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin8_buffer8_we),</pre>
<pre>    .wd     (configin8_buffer8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[8].buffer.q ),</pre>
<pre>    .qs     (configin8_buffer8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin8_size8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin8_size8_we),</pre>
<pre>    .wd     (configin8_size8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[8].size.q ),</pre>
<pre>    .qs     (configin8_size8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin8_pend8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin8_pend8_we),</pre>
<pre>    .wd     (configin8_pend8_wd),</pre>
<pre>    .de     (hw2reg.configin[8].pend.de),</pre>
<pre>    .d      (hw2reg.configin[8].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[8].pend.q ),</pre>
<pre>    .qs     (configin8_pend8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin8_rdy8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin8_rdy8_we),</pre>
<pre>    .wd     (configin8_rdy8_wd),</pre>
<pre>    .de     (hw2reg.configin[8].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[8].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[8].rdy.q ),</pre>
<pre>    .qs     (configin8_rdy8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin9_buffer9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin9_buffer9_we),</pre>
<pre>    .wd     (configin9_buffer9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[9].buffer.q ),</pre>
<pre>    .qs     (configin9_buffer9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin9_size9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin9_size9_we),</pre>
<pre>    .wd     (configin9_size9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[9].size.q ),</pre>
<pre>    .qs     (configin9_size9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin9_pend9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin9_pend9_we),</pre>
<pre>    .wd     (configin9_pend9_wd),</pre>
<pre>    .de     (hw2reg.configin[9].pend.de),</pre>
<pre>    .d      (hw2reg.configin[9].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[9].pend.q ),</pre>
<pre>    .qs     (configin9_pend9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin9_rdy9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin9_rdy9_we),</pre>
<pre>    .wd     (configin9_rdy9_wd),</pre>
<pre>    .de     (hw2reg.configin[9].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[9].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[9].rdy.q ),</pre>
<pre>    .qs     (configin9_rdy9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin10_buffer10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin10_buffer10_we),</pre>
<pre>    .wd     (configin10_buffer10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[10].buffer.q ),</pre>
<pre>    .qs     (configin10_buffer10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin10_size10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin10_size10_we),</pre>
<pre>    .wd     (configin10_size10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[10].size.q ),</pre>
<pre>    .qs     (configin10_size10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin10_pend10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin10_pend10_we),</pre>
<pre>    .wd     (configin10_pend10_wd),</pre>
<pre>    .de     (hw2reg.configin[10].pend.de),</pre>
<pre>    .d      (hw2reg.configin[10].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[10].pend.q ),</pre>
<pre>    .qs     (configin10_pend10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin10_rdy10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin10_rdy10_we),</pre>
<pre>    .wd     (configin10_rdy10_wd),</pre>
<pre>    .de     (hw2reg.configin[10].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[10].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[10].rdy.q ),</pre>
<pre>    .qs     (configin10_rdy10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (5),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (5'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin11_buffer11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin11_buffer11_we),</pre>
<pre>    .wd     (configin11_buffer11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[11].buffer.q ),</pre>
<pre>    .qs     (configin11_buffer11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (7),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (7'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin11_size11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin11_size11_we),</pre>
<pre>    .wd     (configin11_size11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[11].size.q ),</pre>
<pre>    .qs     (configin11_size11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin11_pend11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin11_pend11_we),</pre>
<pre>    .wd     (configin11_pend11_wd),</pre>
<pre>    .de     (hw2reg.configin[11].pend.de),</pre>
<pre>    .d      (hw2reg.configin[11].pend.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[11].pend.q ),</pre>
<pre>    .qs     (configin11_pend11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_configin11_rdy11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (configin11_rdy11_we),</pre>
<pre>    .wd     (configin11_rdy11_wd),</pre>
<pre>    .de     (hw2reg.configin[11].rdy.de),</pre>
<pre>    .d      (hw2reg.configin[11].rdy.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.configin[11].rdy.q ),</pre>
<pre>    .qs     (configin11_rdy11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso0_we),</pre>
<pre>    .wd     (iso_iso0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[0].q ),</pre>
<pre>    .qs     (iso_iso0_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso1_we),</pre>
<pre>    .wd     (iso_iso1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[1].q ),</pre>
<pre>    .qs     (iso_iso1_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso2_we),</pre>
<pre>    .wd     (iso_iso2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[2].q ),</pre>
<pre>    .qs     (iso_iso2_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso3_we),</pre>
<pre>    .wd     (iso_iso3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[3].q ),</pre>
<pre>    .qs     (iso_iso3_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso4_we),</pre>
<pre>    .wd     (iso_iso4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[4].q ),</pre>
<pre>    .qs     (iso_iso4_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso5_we),</pre>
<pre>    .wd     (iso_iso5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[5].q ),</pre>
<pre>    .qs     (iso_iso5_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso6_we),</pre>
<pre>    .wd     (iso_iso6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[6].q ),</pre>
<pre>    .qs     (iso_iso6_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso7_we),</pre>
<pre>    .wd     (iso_iso7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[7].q ),</pre>
<pre>    .qs     (iso_iso7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso8_we),</pre>
<pre>    .wd     (iso_iso8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[8].q ),</pre>
<pre>    .qs     (iso_iso8_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso9_we),</pre>
<pre>    .wd     (iso_iso9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[9].q ),</pre>
<pre>    .qs     (iso_iso9_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso10_we),</pre>
<pre>    .wd     (iso_iso10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[10].q ),</pre>
<pre>    .qs     (iso_iso10_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_iso_iso11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (iso_iso11_we),</pre>
<pre>    .wd     (iso_iso11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.iso[11].q ),</pre>
<pre>    .qs     (iso_iso11_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear0_we),</pre>
<pre>    .wd     (data_toggle_clear_clear0_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[0].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[0].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear1_we),</pre>
<pre>    .wd     (data_toggle_clear_clear1_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[1].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[1].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear2_we),</pre>
<pre>    .wd     (data_toggle_clear_clear2_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[2].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[2].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear3_we),</pre>
<pre>    .wd     (data_toggle_clear_clear3_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[3].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[3].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear4 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear4_we),</pre>
<pre>    .wd     (data_toggle_clear_clear4_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[4].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[4].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear5 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear5_we),</pre>
<pre>    .wd     (data_toggle_clear_clear5_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[5].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[5].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear6 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear6_we),</pre>
<pre>    .wd     (data_toggle_clear_clear6_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[6].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[6].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear7 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear7_we),</pre>
<pre>    .wd     (data_toggle_clear_clear7_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[7].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[7].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear8 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear8_we),</pre>
<pre>    .wd     (data_toggle_clear_clear8_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[8].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[8].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear9 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear9_we),</pre>
<pre>    .wd     (data_toggle_clear_clear9_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[9].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[9].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear10 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear10_we),</pre>
<pre>    .wd     (data_toggle_clear_clear10_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[10].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[10].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_toggle_clear_clear11 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_toggle_clear_clear11_we),</pre>
<pre>    .wd     (data_toggle_clear_clear11_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.data_toggle_clear[11].qe),</pre>
<pre>    .q      (reg2hw.data_toggle_clear[11].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_phy_config_rx_differential_mode (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (phy_config_rx_differential_mode_we),</pre>
<pre>    .wd     (phy_config_rx_differential_mode_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.phy_config.rx_differential_mode.q ),</pre>
<pre>    .qs     (phy_config_rx_differential_mode_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_phy_config_tx_differential_mode (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (phy_config_tx_differential_mode_we),</pre>
<pre>    .wd     (phy_config_tx_differential_mode_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.phy_config.tx_differential_mode.q ),</pre>
<pre>    .qs     (phy_config_tx_differential_mode_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_phy_config_eop_single_bit (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (phy_config_eop_single_bit_we),</pre>
<pre>    .wd     (phy_config_eop_single_bit_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.phy_config.eop_single_bit.q ),</pre>
<pre>    .qs     (phy_config_eop_single_bit_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_phy_config_override_pwr_sense_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (phy_config_override_pwr_sense_en_we),</pre>
<pre>    .wd     (phy_config_override_pwr_sense_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.phy_config.override_pwr_sense_en.q ),</pre>
<pre>    .qs     (phy_config_override_pwr_sense_en_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_phy_config_override_pwr_sense_val (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (phy_config_override_pwr_sense_val_we),</pre>
<pre>    .wd     (phy_config_override_pwr_sense_val_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.phy_config.override_pwr_sense_val.q ),</pre>
<pre>    .qs     (phy_config_override_pwr_sense_val_qs)</pre>
<pre>  logic [25:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[ 0] = (reg_addr == USBDEV_INTR_STATE_OFFSET);</pre>
<pre>    addr_hit[ 1] = (reg_addr == USBDEV_INTR_ENABLE_OFFSET);</pre>
<pre>    addr_hit[ 2] = (reg_addr == USBDEV_INTR_TEST_OFFSET);</pre>
<pre>    addr_hit[ 3] = (reg_addr == USBDEV_USBCTRL_OFFSET);</pre>
<pre>    addr_hit[ 4] = (reg_addr == USBDEV_USBSTAT_OFFSET);</pre>
<pre>    addr_hit[ 5] = (reg_addr == USBDEV_AVBUFFER_OFFSET);</pre>
<pre>    addr_hit[ 6] = (reg_addr == USBDEV_RXFIFO_OFFSET);</pre>
<pre>    addr_hit[ 7] = (reg_addr == USBDEV_RXENABLE_SETUP_OFFSET);</pre>
<pre>    addr_hit[ 8] = (reg_addr == USBDEV_RXENABLE_OUT_OFFSET);</pre>
<pre>    addr_hit[ 9] = (reg_addr == USBDEV_IN_SENT_OFFSET);</pre>
<pre>    addr_hit[10] = (reg_addr == USBDEV_STALL_OFFSET);</pre>
<pre>    addr_hit[11] = (reg_addr == USBDEV_CONFIGIN0_OFFSET);</pre>
<pre>    addr_hit[12] = (reg_addr == USBDEV_CONFIGIN1_OFFSET);</pre>
<pre>    addr_hit[13] = (reg_addr == USBDEV_CONFIGIN2_OFFSET);</pre>
<pre>    addr_hit[14] = (reg_addr == USBDEV_CONFIGIN3_OFFSET);</pre>
<pre>    addr_hit[15] = (reg_addr == USBDEV_CONFIGIN4_OFFSET);</pre>
<pre>    addr_hit[16] = (reg_addr == USBDEV_CONFIGIN5_OFFSET);</pre>
<pre>    addr_hit[17] = (reg_addr == USBDEV_CONFIGIN6_OFFSET);</pre>
<pre>    addr_hit[18] = (reg_addr == USBDEV_CONFIGIN7_OFFSET);</pre>
<pre>    addr_hit[19] = (reg_addr == USBDEV_CONFIGIN8_OFFSET);</pre>
<pre>    addr_hit[20] = (reg_addr == USBDEV_CONFIGIN9_OFFSET);</pre>
<pre>    addr_hit[21] = (reg_addr == USBDEV_CONFIGIN10_OFFSET);</pre>
<pre>    addr_hit[22] = (reg_addr == USBDEV_CONFIGIN11_OFFSET);</pre>
<pre>    addr_hit[23] = (reg_addr == USBDEV_ISO_OFFSET);</pre>
<pre>    addr_hit[24] = (reg_addr == USBDEV_DATA_TOGGLE_CLEAR_OFFSET);</pre>
<pre>    addr_hit[25] = (reg_addr == USBDEV_PHY_CONFIG_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[ 0] && reg_we && (USBDEV_PERMIT[ 0] != (USBDEV_PERMIT[ 0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 1] && reg_we && (USBDEV_PERMIT[ 1] != (USBDEV_PERMIT[ 1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 2] && reg_we && (USBDEV_PERMIT[ 2] != (USBDEV_PERMIT[ 2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 3] && reg_we && (USBDEV_PERMIT[ 3] != (USBDEV_PERMIT[ 3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 4] && reg_we && (USBDEV_PERMIT[ 4] != (USBDEV_PERMIT[ 4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 5] && reg_we && (USBDEV_PERMIT[ 5] != (USBDEV_PERMIT[ 5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 6] && reg_we && (USBDEV_PERMIT[ 6] != (USBDEV_PERMIT[ 6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 7] && reg_we && (USBDEV_PERMIT[ 7] != (USBDEV_PERMIT[ 7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 8] && reg_we && (USBDEV_PERMIT[ 8] != (USBDEV_PERMIT[ 8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 9] && reg_we && (USBDEV_PERMIT[ 9] != (USBDEV_PERMIT[ 9] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[10] && reg_we && (USBDEV_PERMIT[10] != (USBDEV_PERMIT[10] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[11] && reg_we && (USBDEV_PERMIT[11] != (USBDEV_PERMIT[11] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[12] && reg_we && (USBDEV_PERMIT[12] != (USBDEV_PERMIT[12] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[13] && reg_we && (USBDEV_PERMIT[13] != (USBDEV_PERMIT[13] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[14] && reg_we && (USBDEV_PERMIT[14] != (USBDEV_PERMIT[14] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[15] && reg_we && (USBDEV_PERMIT[15] != (USBDEV_PERMIT[15] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[16] && reg_we && (USBDEV_PERMIT[16] != (USBDEV_PERMIT[16] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[17] && reg_we && (USBDEV_PERMIT[17] != (USBDEV_PERMIT[17] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[18] && reg_we && (USBDEV_PERMIT[18] != (USBDEV_PERMIT[18] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[19] && reg_we && (USBDEV_PERMIT[19] != (USBDEV_PERMIT[19] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[20] && reg_we && (USBDEV_PERMIT[20] != (USBDEV_PERMIT[20] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[21] && reg_we && (USBDEV_PERMIT[21] != (USBDEV_PERMIT[21] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[22] && reg_we && (USBDEV_PERMIT[22] != (USBDEV_PERMIT[22] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[23] && reg_we && (USBDEV_PERMIT[23] != (USBDEV_PERMIT[23] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[24] && reg_we && (USBDEV_PERMIT[24] != (USBDEV_PERMIT[24] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[25] && reg_we && (USBDEV_PERMIT[25] != (USBDEV_PERMIT[25] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign intr_state_pkt_received_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_pkt_received_wd = reg_wdata[0];</pre>
<pre>  assign intr_state_pkt_sent_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_pkt_sent_wd = reg_wdata[1];</pre>
<pre>  assign intr_state_disconnected_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_disconnected_wd = reg_wdata[2];</pre>
<pre>  assign intr_state_host_lost_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_host_lost_wd = reg_wdata[3];</pre>
<pre>  assign intr_state_link_reset_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_link_reset_wd = reg_wdata[4];</pre>
<pre>  assign intr_state_link_suspend_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_link_suspend_wd = reg_wdata[5];</pre>
<pre>  assign intr_state_link_resume_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_link_resume_wd = reg_wdata[6];</pre>
<pre>  assign intr_state_av_empty_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_av_empty_wd = reg_wdata[7];</pre>
<pre>  assign intr_state_rx_full_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rx_full_wd = reg_wdata[8];</pre>
<pre>  assign intr_state_av_overflow_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_av_overflow_wd = reg_wdata[9];</pre>
<pre>  assign intr_state_link_in_err_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_link_in_err_wd = reg_wdata[10];</pre>
<pre>  assign intr_state_rx_crc_err_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rx_crc_err_wd = reg_wdata[11];</pre>
<pre>  assign intr_state_rx_pid_err_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rx_pid_err_wd = reg_wdata[12];</pre>
<pre>  assign intr_state_rx_bitstuff_err_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rx_bitstuff_err_wd = reg_wdata[13];</pre>
<pre>  assign intr_state_frame_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_frame_wd = reg_wdata[14];</pre>
<pre>  assign intr_state_connected_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_connected_wd = reg_wdata[15];</pre>
<pre>  assign intr_enable_pkt_received_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_pkt_received_wd = reg_wdata[0];</pre>
<pre>  assign intr_enable_pkt_sent_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_pkt_sent_wd = reg_wdata[1];</pre>
<pre>  assign intr_enable_disconnected_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_disconnected_wd = reg_wdata[2];</pre>
<pre>  assign intr_enable_host_lost_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_host_lost_wd = reg_wdata[3];</pre>
<pre>  assign intr_enable_link_reset_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_link_reset_wd = reg_wdata[4];</pre>
<pre>  assign intr_enable_link_suspend_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_link_suspend_wd = reg_wdata[5];</pre>
<pre>  assign intr_enable_link_resume_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_link_resume_wd = reg_wdata[6];</pre>
<pre>  assign intr_enable_av_empty_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_av_empty_wd = reg_wdata[7];</pre>
<pre>  assign intr_enable_rx_full_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rx_full_wd = reg_wdata[8];</pre>
<pre>  assign intr_enable_av_overflow_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_av_overflow_wd = reg_wdata[9];</pre>
<pre>  assign intr_enable_link_in_err_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_link_in_err_wd = reg_wdata[10];</pre>
<pre>  assign intr_enable_rx_crc_err_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rx_crc_err_wd = reg_wdata[11];</pre>
<pre>  assign intr_enable_rx_pid_err_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rx_pid_err_wd = reg_wdata[12];</pre>
<pre>  assign intr_enable_rx_bitstuff_err_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rx_bitstuff_err_wd = reg_wdata[13];</pre>
<pre>  assign intr_enable_frame_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_frame_wd = reg_wdata[14];</pre>
<pre>  assign intr_enable_connected_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_connected_wd = reg_wdata[15];</pre>
<pre>  assign intr_test_pkt_received_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_pkt_received_wd = reg_wdata[0];</pre>
<pre>  assign intr_test_pkt_sent_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_pkt_sent_wd = reg_wdata[1];</pre>
<pre>  assign intr_test_disconnected_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_disconnected_wd = reg_wdata[2];</pre>
<pre>  assign intr_test_host_lost_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_host_lost_wd = reg_wdata[3];</pre>
<pre>  assign intr_test_link_reset_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_link_reset_wd = reg_wdata[4];</pre>
<pre>  assign intr_test_link_suspend_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_link_suspend_wd = reg_wdata[5];</pre>
<pre>  assign intr_test_link_resume_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_link_resume_wd = reg_wdata[6];</pre>
<pre>  assign intr_test_av_empty_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_av_empty_wd = reg_wdata[7];</pre>
<pre>  assign intr_test_rx_full_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rx_full_wd = reg_wdata[8];</pre>
<pre>  assign intr_test_av_overflow_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_av_overflow_wd = reg_wdata[9];</pre>
<pre>  assign intr_test_link_in_err_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_link_in_err_wd = reg_wdata[10];</pre>
<pre>  assign intr_test_rx_crc_err_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rx_crc_err_wd = reg_wdata[11];</pre>
<pre>  assign intr_test_rx_pid_err_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rx_pid_err_wd = reg_wdata[12];</pre>
<pre>  assign intr_test_rx_bitstuff_err_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rx_bitstuff_err_wd = reg_wdata[13];</pre>
<pre>  assign intr_test_frame_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_frame_wd = reg_wdata[14];</pre>
<pre>  assign intr_test_connected_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_connected_wd = reg_wdata[15];</pre>
<pre>  assign usbctrl_enable_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign usbctrl_enable_wd = reg_wdata[0];</pre>
<pre>  assign usbctrl_device_address_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign usbctrl_device_address_wd = reg_wdata[22:16];</pre>
<pre>  assign usbstat_frame_re = addr_hit[4] && reg_re;</pre>
<pre>  assign usbstat_host_lost_re = addr_hit[4] && reg_re;</pre>
<pre>  assign usbstat_link_state_re = addr_hit[4] && reg_re;</pre>
<pre>  assign usbstat_usb_sense_re = addr_hit[4] && reg_re;</pre>
<pre>  assign usbstat_av_depth_re = addr_hit[4] && reg_re;</pre>
<pre>  assign usbstat_av_full_re = addr_hit[4] && reg_re;</pre>
<pre>  assign usbstat_rx_depth_re = addr_hit[4] && reg_re;</pre>
<pre>  assign usbstat_rx_empty_re = addr_hit[4] && reg_re;</pre>
<pre>  assign avbuffer_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign avbuffer_wd = reg_wdata[4:0];</pre>
<pre>  assign rxfifo_buffer_re = addr_hit[6] && reg_re;</pre>
<pre>  assign rxfifo_size_re = addr_hit[6] && reg_re;</pre>
<pre>  assign rxfifo_setup_re = addr_hit[6] && reg_re;</pre>
<pre>  assign rxfifo_ep_re = addr_hit[6] && reg_re;</pre>
<pre>  assign rxenable_setup_setup0_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup0_wd = reg_wdata[0];</pre>
<pre>  assign rxenable_setup_setup1_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup1_wd = reg_wdata[1];</pre>
<pre>  assign rxenable_setup_setup2_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup2_wd = reg_wdata[2];</pre>
<pre>  assign rxenable_setup_setup3_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup3_wd = reg_wdata[3];</pre>
<pre>  assign rxenable_setup_setup4_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup4_wd = reg_wdata[4];</pre>
<pre>  assign rxenable_setup_setup5_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup5_wd = reg_wdata[5];</pre>
<pre>  assign rxenable_setup_setup6_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup6_wd = reg_wdata[6];</pre>
<pre>  assign rxenable_setup_setup7_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup7_wd = reg_wdata[7];</pre>
<pre>  assign rxenable_setup_setup8_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup8_wd = reg_wdata[8];</pre>
<pre>  assign rxenable_setup_setup9_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup9_wd = reg_wdata[9];</pre>
<pre>  assign rxenable_setup_setup10_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup10_wd = reg_wdata[10];</pre>
<pre>  assign rxenable_setup_setup11_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_setup_setup11_wd = reg_wdata[11];</pre>
<pre>  assign rxenable_out_out0_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out0_wd = reg_wdata[0];</pre>
<pre>  assign rxenable_out_out1_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out1_wd = reg_wdata[1];</pre>
<pre>  assign rxenable_out_out2_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out2_wd = reg_wdata[2];</pre>
<pre>  assign rxenable_out_out3_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out3_wd = reg_wdata[3];</pre>
<pre>  assign rxenable_out_out4_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out4_wd = reg_wdata[4];</pre>
<pre>  assign rxenable_out_out5_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out5_wd = reg_wdata[5];</pre>
<pre>  assign rxenable_out_out6_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out6_wd = reg_wdata[6];</pre>
<pre>  assign rxenable_out_out7_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out7_wd = reg_wdata[7];</pre>
<pre>  assign rxenable_out_out8_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out8_wd = reg_wdata[8];</pre>
<pre>  assign rxenable_out_out9_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out9_wd = reg_wdata[9];</pre>
<pre>  assign rxenable_out_out10_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out10_wd = reg_wdata[10];</pre>
<pre>  assign rxenable_out_out11_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxenable_out_out11_wd = reg_wdata[11];</pre>
<pre>  assign in_sent_sent0_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent0_wd = reg_wdata[0];</pre>
<pre>  assign in_sent_sent1_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent1_wd = reg_wdata[1];</pre>
<pre>  assign in_sent_sent2_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent2_wd = reg_wdata[2];</pre>
<pre>  assign in_sent_sent3_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent3_wd = reg_wdata[3];</pre>
<pre>  assign in_sent_sent4_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent4_wd = reg_wdata[4];</pre>
<pre>  assign in_sent_sent5_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent5_wd = reg_wdata[5];</pre>
<pre>  assign in_sent_sent6_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent6_wd = reg_wdata[6];</pre>
<pre>  assign in_sent_sent7_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent7_wd = reg_wdata[7];</pre>
<pre>  assign in_sent_sent8_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent8_wd = reg_wdata[8];</pre>
<pre>  assign in_sent_sent9_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent9_wd = reg_wdata[9];</pre>
<pre>  assign in_sent_sent10_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent10_wd = reg_wdata[10];</pre>
<pre>  assign in_sent_sent11_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign in_sent_sent11_wd = reg_wdata[11];</pre>
<pre>  assign stall_stall0_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall0_wd = reg_wdata[0];</pre>
<pre>  assign stall_stall1_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall1_wd = reg_wdata[1];</pre>
<pre>  assign stall_stall2_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall2_wd = reg_wdata[2];</pre>
<pre>  assign stall_stall3_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall3_wd = reg_wdata[3];</pre>
<pre>  assign stall_stall4_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall4_wd = reg_wdata[4];</pre>
<pre>  assign stall_stall5_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall5_wd = reg_wdata[5];</pre>
<pre>  assign stall_stall6_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall6_wd = reg_wdata[6];</pre>
<pre>  assign stall_stall7_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall7_wd = reg_wdata[7];</pre>
<pre>  assign stall_stall8_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall8_wd = reg_wdata[8];</pre>
<pre>  assign stall_stall9_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall9_wd = reg_wdata[9];</pre>
<pre>  assign stall_stall10_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall10_wd = reg_wdata[10];</pre>
<pre>  assign stall_stall11_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign stall_stall11_wd = reg_wdata[11];</pre>
<pre>  assign configin0_buffer0_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign configin0_buffer0_wd = reg_wdata[4:0];</pre>
<pre>  assign configin0_size0_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign configin0_size0_wd = reg_wdata[14:8];</pre>
<pre>  assign configin0_pend0_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign configin0_pend0_wd = reg_wdata[30];</pre>
<pre>  assign configin0_rdy0_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign configin0_rdy0_wd = reg_wdata[31];</pre>
<pre>  assign configin1_buffer1_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign configin1_buffer1_wd = reg_wdata[4:0];</pre>
<pre>  assign configin1_size1_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign configin1_size1_wd = reg_wdata[14:8];</pre>
<pre>  assign configin1_pend1_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign configin1_pend1_wd = reg_wdata[30];</pre>
<pre>  assign configin1_rdy1_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign configin1_rdy1_wd = reg_wdata[31];</pre>
<pre>  assign configin2_buffer2_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign configin2_buffer2_wd = reg_wdata[4:0];</pre>
<pre>  assign configin2_size2_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign configin2_size2_wd = reg_wdata[14:8];</pre>
<pre>  assign configin2_pend2_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign configin2_pend2_wd = reg_wdata[30];</pre>
<pre>  assign configin2_rdy2_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign configin2_rdy2_wd = reg_wdata[31];</pre>
<pre>  assign configin3_buffer3_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign configin3_buffer3_wd = reg_wdata[4:0];</pre>
<pre>  assign configin3_size3_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign configin3_size3_wd = reg_wdata[14:8];</pre>
<pre>  assign configin3_pend3_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign configin3_pend3_wd = reg_wdata[30];</pre>
<pre>  assign configin3_rdy3_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign configin3_rdy3_wd = reg_wdata[31];</pre>
<pre>  assign configin4_buffer4_we = addr_hit[15] & reg_we & ~wr_err;</pre>
<pre>  assign configin4_buffer4_wd = reg_wdata[4:0];</pre>
<pre>  assign configin4_size4_we = addr_hit[15] & reg_we & ~wr_err;</pre>
<pre>  assign configin4_size4_wd = reg_wdata[14:8];</pre>
<pre>  assign configin4_pend4_we = addr_hit[15] & reg_we & ~wr_err;</pre>
<pre>  assign configin4_pend4_wd = reg_wdata[30];</pre>
<pre>  assign configin4_rdy4_we = addr_hit[15] & reg_we & ~wr_err;</pre>
<pre>  assign configin4_rdy4_wd = reg_wdata[31];</pre>
<pre>  assign configin5_buffer5_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign configin5_buffer5_wd = reg_wdata[4:0];</pre>
<pre>  assign configin5_size5_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign configin5_size5_wd = reg_wdata[14:8];</pre>
<pre>  assign configin5_pend5_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign configin5_pend5_wd = reg_wdata[30];</pre>
<pre>  assign configin5_rdy5_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign configin5_rdy5_wd = reg_wdata[31];</pre>
<pre>  assign configin6_buffer6_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign configin6_buffer6_wd = reg_wdata[4:0];</pre>
<pre>  assign configin6_size6_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign configin6_size6_wd = reg_wdata[14:8];</pre>
<pre>  assign configin6_pend6_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign configin6_pend6_wd = reg_wdata[30];</pre>
<pre>  assign configin6_rdy6_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign configin6_rdy6_wd = reg_wdata[31];</pre>
<pre>  assign configin7_buffer7_we = addr_hit[18] & reg_we & ~wr_err;</pre>
<pre>  assign configin7_buffer7_wd = reg_wdata[4:0];</pre>
<pre>  assign configin7_size7_we = addr_hit[18] & reg_we & ~wr_err;</pre>
<pre>  assign configin7_size7_wd = reg_wdata[14:8];</pre>
<pre>  assign configin7_pend7_we = addr_hit[18] & reg_we & ~wr_err;</pre>
<pre>  assign configin7_pend7_wd = reg_wdata[30];</pre>
<pre>  assign configin7_rdy7_we = addr_hit[18] & reg_we & ~wr_err;</pre>
<pre>  assign configin7_rdy7_wd = reg_wdata[31];</pre>
<pre>  assign configin8_buffer8_we = addr_hit[19] & reg_we & ~wr_err;</pre>
<pre>  assign configin8_buffer8_wd = reg_wdata[4:0];</pre>
<pre>  assign configin8_size8_we = addr_hit[19] & reg_we & ~wr_err;</pre>
<pre>  assign configin8_size8_wd = reg_wdata[14:8];</pre>
<pre>  assign configin8_pend8_we = addr_hit[19] & reg_we & ~wr_err;</pre>
<pre>  assign configin8_pend8_wd = reg_wdata[30];</pre>
<pre>  assign configin8_rdy8_we = addr_hit[19] & reg_we & ~wr_err;</pre>
<pre>  assign configin8_rdy8_wd = reg_wdata[31];</pre>
<pre>  assign configin9_buffer9_we = addr_hit[20] & reg_we & ~wr_err;</pre>
<pre>  assign configin9_buffer9_wd = reg_wdata[4:0];</pre>
<pre>  assign configin9_size9_we = addr_hit[20] & reg_we & ~wr_err;</pre>
<pre>  assign configin9_size9_wd = reg_wdata[14:8];</pre>
<pre>  assign configin9_pend9_we = addr_hit[20] & reg_we & ~wr_err;</pre>
<pre>  assign configin9_pend9_wd = reg_wdata[30];</pre>
<pre>  assign configin9_rdy9_we = addr_hit[20] & reg_we & ~wr_err;</pre>
<pre>  assign configin9_rdy9_wd = reg_wdata[31];</pre>
<pre>  assign configin10_buffer10_we = addr_hit[21] & reg_we & ~wr_err;</pre>
<pre>  assign configin10_buffer10_wd = reg_wdata[4:0];</pre>
<pre>  assign configin10_size10_we = addr_hit[21] & reg_we & ~wr_err;</pre>
<pre>  assign configin10_size10_wd = reg_wdata[14:8];</pre>
<pre>  assign configin10_pend10_we = addr_hit[21] & reg_we & ~wr_err;</pre>
<pre>  assign configin10_pend10_wd = reg_wdata[30];</pre>
<pre>  assign configin10_rdy10_we = addr_hit[21] & reg_we & ~wr_err;</pre>
<pre>  assign configin10_rdy10_wd = reg_wdata[31];</pre>
<pre>  assign configin11_buffer11_we = addr_hit[22] & reg_we & ~wr_err;</pre>
<pre>  assign configin11_buffer11_wd = reg_wdata[4:0];</pre>
<pre>  assign configin11_size11_we = addr_hit[22] & reg_we & ~wr_err;</pre>
<pre>  assign configin11_size11_wd = reg_wdata[14:8];</pre>
<pre>  assign configin11_pend11_we = addr_hit[22] & reg_we & ~wr_err;</pre>
<pre>  assign configin11_pend11_wd = reg_wdata[30];</pre>
<pre>  assign configin11_rdy11_we = addr_hit[22] & reg_we & ~wr_err;</pre>
<pre>  assign configin11_rdy11_wd = reg_wdata[31];</pre>
<pre>  assign iso_iso0_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso0_wd = reg_wdata[0];</pre>
<pre>  assign iso_iso1_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso1_wd = reg_wdata[1];</pre>
<pre>  assign iso_iso2_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso2_wd = reg_wdata[2];</pre>
<pre>  assign iso_iso3_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso3_wd = reg_wdata[3];</pre>
<pre>  assign iso_iso4_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso4_wd = reg_wdata[4];</pre>
<pre>  assign iso_iso5_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso5_wd = reg_wdata[5];</pre>
<pre>  assign iso_iso6_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso6_wd = reg_wdata[6];</pre>
<pre>  assign iso_iso7_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso7_wd = reg_wdata[7];</pre>
<pre>  assign iso_iso8_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso8_wd = reg_wdata[8];</pre>
<pre>  assign iso_iso9_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso9_wd = reg_wdata[9];</pre>
<pre>  assign iso_iso10_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso10_wd = reg_wdata[10];</pre>
<pre>  assign iso_iso11_we = addr_hit[23] & reg_we & ~wr_err;</pre>
<pre>  assign iso_iso11_wd = reg_wdata[11];</pre>
<pre>  assign data_toggle_clear_clear0_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear0_wd = reg_wdata[0];</pre>
<pre>  assign data_toggle_clear_clear1_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear1_wd = reg_wdata[1];</pre>
<pre>  assign data_toggle_clear_clear2_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear2_wd = reg_wdata[2];</pre>
<pre>  assign data_toggle_clear_clear3_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear3_wd = reg_wdata[3];</pre>
<pre>  assign data_toggle_clear_clear4_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear4_wd = reg_wdata[4];</pre>
<pre>  assign data_toggle_clear_clear5_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear5_wd = reg_wdata[5];</pre>
<pre>  assign data_toggle_clear_clear6_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear6_wd = reg_wdata[6];</pre>
<pre>  assign data_toggle_clear_clear7_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear7_wd = reg_wdata[7];</pre>
<pre>  assign data_toggle_clear_clear8_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear8_wd = reg_wdata[8];</pre>
<pre>  assign data_toggle_clear_clear9_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear9_wd = reg_wdata[9];</pre>
<pre>  assign data_toggle_clear_clear10_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear10_wd = reg_wdata[10];</pre>
<pre>  assign data_toggle_clear_clear11_we = addr_hit[24] & reg_we & ~wr_err;</pre>
<pre>  assign data_toggle_clear_clear11_wd = reg_wdata[11];</pre>
<pre>  assign phy_config_rx_differential_mode_we = addr_hit[25] & reg_we & ~wr_err;</pre>
<pre>  assign phy_config_rx_differential_mode_wd = reg_wdata[0];</pre>
<pre>  assign phy_config_tx_differential_mode_we = addr_hit[25] & reg_we & ~wr_err;</pre>
<pre>  assign phy_config_tx_differential_mode_wd = reg_wdata[1];</pre>
<pre>  assign phy_config_eop_single_bit_we = addr_hit[25] & reg_we & ~wr_err;</pre>
<pre>  assign phy_config_eop_single_bit_wd = reg_wdata[2];</pre>
<pre>  assign phy_config_override_pwr_sense_en_we = addr_hit[25] & reg_we & ~wr_err;</pre>
<pre>  assign phy_config_override_pwr_sense_en_wd = reg_wdata[3];</pre>
<pre>  assign phy_config_override_pwr_sense_val_we = addr_hit[25] & reg_we & ~wr_err;</pre>
<pre>  assign phy_config_override_pwr_sense_val_wd = reg_wdata[4];</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[0] = intr_state_pkt_received_qs;</pre>
<pre>        reg_rdata_next[1] = intr_state_pkt_sent_qs;</pre>
<pre>        reg_rdata_next[2] = intr_state_disconnected_qs;</pre>
<pre>        reg_rdata_next[3] = intr_state_host_lost_qs;</pre>
<pre>        reg_rdata_next[4] = intr_state_link_reset_qs;</pre>
<pre>        reg_rdata_next[5] = intr_state_link_suspend_qs;</pre>
<pre>        reg_rdata_next[6] = intr_state_link_resume_qs;</pre>
<pre>        reg_rdata_next[7] = intr_state_av_empty_qs;</pre>
<pre>        reg_rdata_next[8] = intr_state_rx_full_qs;</pre>
<pre>        reg_rdata_next[9] = intr_state_av_overflow_qs;</pre>
<pre>        reg_rdata_next[10] = intr_state_link_in_err_qs;</pre>
<pre>        reg_rdata_next[11] = intr_state_rx_crc_err_qs;</pre>
<pre>        reg_rdata_next[12] = intr_state_rx_pid_err_qs;</pre>
<pre>        reg_rdata_next[13] = intr_state_rx_bitstuff_err_qs;</pre>
<pre>        reg_rdata_next[14] = intr_state_frame_qs;</pre>
<pre>        reg_rdata_next[15] = intr_state_connected_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[0] = intr_enable_pkt_received_qs;</pre>
<pre>        reg_rdata_next[1] = intr_enable_pkt_sent_qs;</pre>
<pre>        reg_rdata_next[2] = intr_enable_disconnected_qs;</pre>
<pre>        reg_rdata_next[3] = intr_enable_host_lost_qs;</pre>
<pre>        reg_rdata_next[4] = intr_enable_link_reset_qs;</pre>
<pre>        reg_rdata_next[5] = intr_enable_link_suspend_qs;</pre>
<pre>        reg_rdata_next[6] = intr_enable_link_resume_qs;</pre>
<pre>        reg_rdata_next[7] = intr_enable_av_empty_qs;</pre>
<pre>        reg_rdata_next[8] = intr_enable_rx_full_qs;</pre>
<pre>        reg_rdata_next[9] = intr_enable_av_overflow_qs;</pre>
<pre>        reg_rdata_next[10] = intr_enable_link_in_err_qs;</pre>
<pre>        reg_rdata_next[11] = intr_enable_rx_crc_err_qs;</pre>
<pre>        reg_rdata_next[12] = intr_enable_rx_pid_err_qs;</pre>
<pre>        reg_rdata_next[13] = intr_enable_rx_bitstuff_err_qs;</pre>
<pre>        reg_rdata_next[14] = intr_enable_frame_qs;</pre>
<pre>        reg_rdata_next[15] = intr_enable_connected_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>        reg_rdata_next[2] = '0;</pre>
<pre>        reg_rdata_next[3] = '0;</pre>
<pre>        reg_rdata_next[4] = '0;</pre>
<pre>        reg_rdata_next[5] = '0;</pre>
<pre>        reg_rdata_next[6] = '0;</pre>
<pre>        reg_rdata_next[7] = '0;</pre>
<pre>        reg_rdata_next[8] = '0;</pre>
<pre>        reg_rdata_next[9] = '0;</pre>
<pre>        reg_rdata_next[10] = '0;</pre>
<pre>        reg_rdata_next[11] = '0;</pre>
<pre>        reg_rdata_next[12] = '0;</pre>
<pre>        reg_rdata_next[13] = '0;</pre>
<pre>        reg_rdata_next[14] = '0;</pre>
<pre>        reg_rdata_next[15] = '0;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[0] = usbctrl_enable_qs;</pre>
<pre>        reg_rdata_next[22:16] = usbctrl_device_address_qs;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[10:0] = usbstat_frame_qs;</pre>
<pre>        reg_rdata_next[11] = usbstat_host_lost_qs;</pre>
<pre>        reg_rdata_next[14:12] = usbstat_link_state_qs;</pre>
<pre>        reg_rdata_next[15] = usbstat_usb_sense_qs;</pre>
<pre>        reg_rdata_next[18:16] = usbstat_av_depth_qs;</pre>
<pre>        reg_rdata_next[23] = usbstat_av_full_qs;</pre>
<pre>        reg_rdata_next[26:24] = usbstat_rx_depth_qs;</pre>
<pre>        reg_rdata_next[31] = usbstat_rx_empty_qs;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[4:0] = '0;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[4:0] = rxfifo_buffer_qs;</pre>
<pre>        reg_rdata_next[14:8] = rxfifo_size_qs;</pre>
<pre>        reg_rdata_next[19] = rxfifo_setup_qs;</pre>
<pre>        reg_rdata_next[23:20] = rxfifo_ep_qs;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[0] = rxenable_setup_setup0_qs;</pre>
<pre>        reg_rdata_next[1] = rxenable_setup_setup1_qs;</pre>
<pre>        reg_rdata_next[2] = rxenable_setup_setup2_qs;</pre>
<pre>        reg_rdata_next[3] = rxenable_setup_setup3_qs;</pre>
<pre>        reg_rdata_next[4] = rxenable_setup_setup4_qs;</pre>
<pre>        reg_rdata_next[5] = rxenable_setup_setup5_qs;</pre>
<pre>        reg_rdata_next[6] = rxenable_setup_setup6_qs;</pre>
<pre>        reg_rdata_next[7] = rxenable_setup_setup7_qs;</pre>
<pre>        reg_rdata_next[8] = rxenable_setup_setup8_qs;</pre>
<pre>        reg_rdata_next[9] = rxenable_setup_setup9_qs;</pre>
<pre>        reg_rdata_next[10] = rxenable_setup_setup10_qs;</pre>
<pre>        reg_rdata_next[11] = rxenable_setup_setup11_qs;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[0] = rxenable_out_out0_qs;</pre>
<pre>        reg_rdata_next[1] = rxenable_out_out1_qs;</pre>
<pre>        reg_rdata_next[2] = rxenable_out_out2_qs;</pre>
<pre>        reg_rdata_next[3] = rxenable_out_out3_qs;</pre>
<pre>        reg_rdata_next[4] = rxenable_out_out4_qs;</pre>
<pre>        reg_rdata_next[5] = rxenable_out_out5_qs;</pre>
<pre>        reg_rdata_next[6] = rxenable_out_out6_qs;</pre>
<pre>        reg_rdata_next[7] = rxenable_out_out7_qs;</pre>
<pre>        reg_rdata_next[8] = rxenable_out_out8_qs;</pre>
<pre>        reg_rdata_next[9] = rxenable_out_out9_qs;</pre>
<pre>        reg_rdata_next[10] = rxenable_out_out10_qs;</pre>
<pre>        reg_rdata_next[11] = rxenable_out_out11_qs;</pre>
<pre>      addr_hit[9]: begin</pre>
<pre>        reg_rdata_next[0] = in_sent_sent0_qs;</pre>
<pre>        reg_rdata_next[1] = in_sent_sent1_qs;</pre>
<pre>        reg_rdata_next[2] = in_sent_sent2_qs;</pre>
<pre>        reg_rdata_next[3] = in_sent_sent3_qs;</pre>
<pre>        reg_rdata_next[4] = in_sent_sent4_qs;</pre>
<pre>        reg_rdata_next[5] = in_sent_sent5_qs;</pre>
<pre>        reg_rdata_next[6] = in_sent_sent6_qs;</pre>
<pre>        reg_rdata_next[7] = in_sent_sent7_qs;</pre>
<pre>        reg_rdata_next[8] = in_sent_sent8_qs;</pre>
<pre>        reg_rdata_next[9] = in_sent_sent9_qs;</pre>
<pre>        reg_rdata_next[10] = in_sent_sent10_qs;</pre>
<pre>        reg_rdata_next[11] = in_sent_sent11_qs;</pre>
<pre>      addr_hit[10]: begin</pre>
<pre>        reg_rdata_next[0] = stall_stall0_qs;</pre>
<pre>        reg_rdata_next[1] = stall_stall1_qs;</pre>
<pre>        reg_rdata_next[2] = stall_stall2_qs;</pre>
<pre>        reg_rdata_next[3] = stall_stall3_qs;</pre>
<pre>        reg_rdata_next[4] = stall_stall4_qs;</pre>
<pre>        reg_rdata_next[5] = stall_stall5_qs;</pre>
<pre>        reg_rdata_next[6] = stall_stall6_qs;</pre>
<pre>        reg_rdata_next[7] = stall_stall7_qs;</pre>
<pre>        reg_rdata_next[8] = stall_stall8_qs;</pre>
<pre>        reg_rdata_next[9] = stall_stall9_qs;</pre>
<pre>        reg_rdata_next[10] = stall_stall10_qs;</pre>
<pre>        reg_rdata_next[11] = stall_stall11_qs;</pre>
<pre>      addr_hit[11]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin0_buffer0_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin0_size0_qs;</pre>
<pre>        reg_rdata_next[30] = configin0_pend0_qs;</pre>
<pre>        reg_rdata_next[31] = configin0_rdy0_qs;</pre>
<pre>      addr_hit[12]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin1_buffer1_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin1_size1_qs;</pre>
<pre>        reg_rdata_next[30] = configin1_pend1_qs;</pre>
<pre>        reg_rdata_next[31] = configin1_rdy1_qs;</pre>
<pre>      addr_hit[13]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin2_buffer2_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin2_size2_qs;</pre>
<pre>        reg_rdata_next[30] = configin2_pend2_qs;</pre>
<pre>        reg_rdata_next[31] = configin2_rdy2_qs;</pre>
<pre>      addr_hit[14]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin3_buffer3_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin3_size3_qs;</pre>
<pre>        reg_rdata_next[30] = configin3_pend3_qs;</pre>
<pre>        reg_rdata_next[31] = configin3_rdy3_qs;</pre>
<pre>      addr_hit[15]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin4_buffer4_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin4_size4_qs;</pre>
<pre>        reg_rdata_next[30] = configin4_pend4_qs;</pre>
<pre>        reg_rdata_next[31] = configin4_rdy4_qs;</pre>
<pre>      addr_hit[16]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin5_buffer5_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin5_size5_qs;</pre>
<pre>        reg_rdata_next[30] = configin5_pend5_qs;</pre>
<pre>        reg_rdata_next[31] = configin5_rdy5_qs;</pre>
<pre>      addr_hit[17]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin6_buffer6_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin6_size6_qs;</pre>
<pre>        reg_rdata_next[30] = configin6_pend6_qs;</pre>
<pre>        reg_rdata_next[31] = configin6_rdy6_qs;</pre>
<pre>      addr_hit[18]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin7_buffer7_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin7_size7_qs;</pre>
<pre>        reg_rdata_next[30] = configin7_pend7_qs;</pre>
<pre>        reg_rdata_next[31] = configin7_rdy7_qs;</pre>
<pre>      addr_hit[19]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin8_buffer8_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin8_size8_qs;</pre>
<pre>        reg_rdata_next[30] = configin8_pend8_qs;</pre>
<pre>        reg_rdata_next[31] = configin8_rdy8_qs;</pre>
<pre>      addr_hit[20]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin9_buffer9_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin9_size9_qs;</pre>
<pre>        reg_rdata_next[30] = configin9_pend9_qs;</pre>
<pre>        reg_rdata_next[31] = configin9_rdy9_qs;</pre>
<pre>      addr_hit[21]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin10_buffer10_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin10_size10_qs;</pre>
<pre>        reg_rdata_next[30] = configin10_pend10_qs;</pre>
<pre>        reg_rdata_next[31] = configin10_rdy10_qs;</pre>
<pre>      addr_hit[22]: begin</pre>
<pre>        reg_rdata_next[4:0] = configin11_buffer11_qs;</pre>
<pre>        reg_rdata_next[14:8] = configin11_size11_qs;</pre>
<pre>        reg_rdata_next[30] = configin11_pend11_qs;</pre>
<pre>        reg_rdata_next[31] = configin11_rdy11_qs;</pre>
<pre>      addr_hit[23]: begin</pre>
<pre>        reg_rdata_next[0] = iso_iso0_qs;</pre>
<pre>        reg_rdata_next[1] = iso_iso1_qs;</pre>
<pre>        reg_rdata_next[2] = iso_iso2_qs;</pre>
<pre>        reg_rdata_next[3] = iso_iso3_qs;</pre>
<pre>        reg_rdata_next[4] = iso_iso4_qs;</pre>
<pre>        reg_rdata_next[5] = iso_iso5_qs;</pre>
<pre>        reg_rdata_next[6] = iso_iso6_qs;</pre>
<pre>        reg_rdata_next[7] = iso_iso7_qs;</pre>
<pre>        reg_rdata_next[8] = iso_iso8_qs;</pre>
<pre>        reg_rdata_next[9] = iso_iso9_qs;</pre>
<pre>        reg_rdata_next[10] = iso_iso10_qs;</pre>
<pre>        reg_rdata_next[11] = iso_iso11_qs;</pre>
<pre>      addr_hit[24]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>        reg_rdata_next[2] = '0;</pre>
<pre>        reg_rdata_next[3] = '0;</pre>
<pre>        reg_rdata_next[4] = '0;</pre>
<pre>        reg_rdata_next[5] = '0;</pre>
<pre>        reg_rdata_next[6] = '0;</pre>
<pre>        reg_rdata_next[7] = '0;</pre>
<pre>        reg_rdata_next[8] = '0;</pre>
<pre>        reg_rdata_next[9] = '0;</pre>
<pre>        reg_rdata_next[10] = '0;</pre>
<pre>        reg_rdata_next[11] = '0;</pre>
<pre>      addr_hit[25]: begin</pre>
<pre>        reg_rdata_next[0] = phy_config_rx_differential_mode_qs;</pre>
<pre>        reg_rdata_next[1] = phy_config_tx_differential_mode_qs;</pre>
<pre>        reg_rdata_next[2] = phy_config_eop_single_bit_qs;</pre>
<pre>        reg_rdata_next[3] = phy_config_override_pwr_sense_en_qs;</pre>
<pre>        reg_rdata_next[4] = phy_config_override_pwr_sense_val_qs;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/ip/usbdev/rtl/usbdev_linkstate.sv</h3>
<pre>  input  logic clk_48mhz_i,</pre>
<pre>  input  logic rst_ni,</pre>
<pre>  input  logic us_tick_i,</pre>
<pre>  input  logic usb_sense_i,</pre>
<pre>  input  logic usb_rx_d_i,</pre>
<pre>  input  logic usb_rx_se0_i,</pre>
<pre>  input  logic sof_valid_i,</pre>
<pre>  output logic link_disconnect_o,  // level</pre>
<pre>  output logic link_connect_o,     // level</pre>
<pre>  output logic link_reset_o,       // level</pre>
<pre>  output logic link_suspend_o,     // level</pre>
<pre>  output logic link_resume_o,      // pulse</pre>
<pre>  output logic host_lost_o,        // level</pre>
<pre>  output logic [2:0] link_state_o</pre>
<pre>  localparam logic [11:0] SUSPEND_TIMEOUT = 12'd3000; // 3ms by spec</pre>
<pre>  localparam logic [2:0]  RESET_TIMEOUT   = 3'd3;     // 3us. Can be 2.5us - 10ms by spec</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    LinkDisconnect = 0,</pre>
<pre>    LinkPowered = 1,</pre>
<pre>    LinkPoweredSuspend = 2,</pre>
<pre>    LinkActive = 3,</pre>
<pre>    LinkSuspend = 4</pre>
<pre>  } link_state_e;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    NoRst,</pre>
<pre>    RstCnt,</pre>
<pre>    RstPend</pre>
<pre>  } link_rst_state_e;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    Active,</pre>
<pre>    InactCnt,</pre>
<pre>    InactPend</pre>
<pre>  } link_inac_state_e;</pre>
<pre>  link_state_e  link_state_d, link_state_q;</pre>
<pre>  logic         link_active;</pre>
<pre>  logic         line_se0_raw, line_idle_raw;</pre>
<pre>  logic         see_se0, see_idle, see_pwr_sense;</pre>
<pre>  logic [2:0]      link_rst_timer_d, link_rst_timer_q;</pre>
<pre>  link_rst_state_e link_rst_state_d, link_rst_state_q;</pre>
<pre>  logic            link_reset; // reset detected (level)</pre>
<pre>  logic              monitor_inac; // monitor link inactivity</pre>
<pre>  logic [11:0]       link_inac_timer_d, link_inac_timer_q;</pre>
<pre>  link_inac_state_e  link_inac_state_d, link_inac_state_q;</pre>
<pre>  logic ev_bus_active;</pre>
<pre>  logic ev_bus_inactive, ev_reset;</pre>
<pre>  assign link_disconnect_o = (link_state_q == LinkDisconnect);</pre>
<pre>  assign link_connect_o    = (link_state_q != LinkDisconnect);</pre>
<pre>  assign link_suspend_o    = (link_state_q == LinkSuspend ||</pre>
<pre>    link_state_q == LinkPoweredSuspend);</pre>
<pre>  assign link_active       = (link_state_q == LinkActive);</pre>
<pre>  assign link_state_o      =  link_state_q;</pre>
<pre>  assign line_se0_raw = usb_rx_se0_i;</pre>
<pre>  assign line_idle_raw = usb_rx_d_i && !usb_rx_se0_i; // same as J</pre>
<pre>  prim_filter #(.Cycles(6)) filter_se0 (</pre>
<pre>    .clk_i    (clk_48mhz_i),</pre>
<pre>    .rst_ni   (rst_ni),</pre>
<pre>    .enable_i (1'b1),</pre>
<pre>    .filter_i (line_se0_raw),</pre>
<pre>    .filter_o (see_se0)</pre>
<pre>  prim_filter #(.Cycles(6)) filter_idle (</pre>
<pre>    .clk_i    (clk_48mhz_i),</pre>
<pre>    .rst_ni   (rst_ni),</pre>
<pre>    .enable_i (1'b1),</pre>
<pre>    .filter_i (line_idle_raw),</pre>
<pre>    .filter_o (see_idle)</pre>
<pre>  prim_filter #(.Cycles(6)) filter_pwr_sense (</pre>
<pre>    .clk_i    (clk_48mhz_i),</pre>
<pre>    .rst_ni   (rst_ni),</pre>
<pre>    .enable_i (1'b1),</pre>
<pre>    .filter_i (usb_sense_i),</pre>
<pre>    .filter_o (see_pwr_sense)</pre>
<pre>  assign ev_bus_active = !see_idle;</pre>
<pre>  always_comb begin</pre>
<pre>    link_state_d = link_state_q;</pre>
<pre>    link_resume_o = 0;</pre>
<pre>    monitor_inac = 0;</pre>
<pre>    if (!see_pwr_sense) begin</pre>
<pre>      link_state_d = LinkDisconnect;</pre>
<pre>    end else begin</pre>
<pre>      unique case (link_state_q)</pre>
<pre>        LinkDisconnect: begin</pre>
<pre>          if (see_pwr_sense) begin</pre>
<pre>            link_state_d = LinkPowered;</pre>
<pre>        LinkPowered: begin</pre>
<pre>          monitor_inac = 1;</pre>
<pre>          if (ev_reset) begin</pre>
<pre>            link_state_d = LinkActive;</pre>
<pre>          end else if (ev_bus_inactive) begin</pre>
<pre>            link_state_d = LinkPoweredSuspend;</pre>
<pre>        LinkPoweredSuspend: begin</pre>
<pre>          if (ev_reset) begin</pre>
<pre>            link_state_d = LinkActive;</pre>
<pre>          end else if (ev_bus_active) begin</pre>
<pre>            link_resume_o = 1;</pre>
<pre>            link_state_d  = LinkPowered;</pre>
<pre>        LinkActive: begin</pre>
<pre>          monitor_inac = 1;</pre>
<pre>          if (ev_bus_inactive) begin</pre>
<pre>            link_state_d = LinkSuspend;</pre>
<pre>        LinkSuspend: begin</pre>
<pre>          if (ev_reset || ev_bus_active) begin</pre>
<pre>            link_resume_o = 1;</pre>
<pre>            link_state_d  = LinkActive;</pre>
<pre>        default: begin</pre>
<pre>          link_state_d = LinkDisconnect;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      link_state_q <= LinkDisconnect;</pre>
<pre>    end else begin</pre>
<pre>      link_state_q <= link_state_d;</pre>
<pre>  always_comb begin : proc_rst_fsm</pre>
<pre>    link_rst_state_d  = link_rst_state_q;</pre>
<pre>    link_rst_timer_d  = link_rst_timer_q;</pre>
<pre>    ev_reset          = 1'b0;</pre>
<pre>    link_reset        = 1'b0;</pre>
<pre>    unique case (link_rst_state_q)</pre>
<pre>      NoRst: begin</pre>
<pre>        if (see_se0) begin</pre>
<pre>          link_rst_state_d = RstCnt;</pre>
<pre>          link_rst_timer_d = 0;</pre>
<pre>      RstCnt: begin</pre>
<pre>        if (!see_se0) begin</pre>
<pre>          link_rst_state_d = NoRst;</pre>
<pre>        end else begin</pre>
<pre>          if (us_tick_i) begin</pre>
<pre>            if (link_rst_timer_q == RESET_TIMEOUT) begin</pre>
<pre>              link_rst_state_d = RstPend;</pre>
<pre>            end else begin</pre>
<pre>              link_rst_timer_d = link_rst_timer_q + 1;</pre>
<pre>      RstPend: begin</pre>
<pre>        if (!see_se0) begin</pre>
<pre>          link_rst_state_d = NoRst;</pre>
<pre>          ev_reset = 1'b1;</pre>
<pre>        link_reset = 1'b1;</pre>
<pre>      default : link_rst_state_d = NoRst;</pre>
<pre>  assign link_reset_o = link_reset;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin : proc_reg_rst</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      link_rst_state_q <= NoRst;</pre>
<pre>      link_rst_timer_q <= 0;</pre>
<pre>    end else begin</pre>
<pre>      link_rst_state_q <= link_rst_state_d;</pre>
<pre>      link_rst_timer_q <= link_rst_timer_d;</pre>
<pre>  always_comb begin : proc_idle_det</pre>
<pre>    link_inac_state_d = link_inac_state_q;</pre>
<pre>    link_inac_timer_d = link_inac_timer_q;</pre>
<pre>    ev_bus_inactive   = 0;</pre>
<pre>    unique case (link_inac_state_q)</pre>
<pre>      Active: begin</pre>
<pre>        link_inac_timer_d = 0;</pre>
<pre>        if (see_idle && monitor_inac) begin</pre>
<pre>          link_inac_state_d = InactCnt;</pre>
<pre>      InactCnt: begin</pre>
<pre>        if (!see_idle || !monitor_inac) begin</pre>
<pre>          link_inac_state_d  = Active;</pre>
<pre>        end else if (us_tick_i) begin</pre>
<pre>          if (link_inac_timer_q == SUSPEND_TIMEOUT) begin</pre>
<pre>            link_inac_state_d = InactPend;</pre>
<pre>            ev_bus_inactive = 1;</pre>
<pre>          end else begin</pre>
<pre>            link_inac_timer_d = link_inac_timer_q + 1;</pre>
<pre>      InactPend: begin</pre>
<pre>        if (!see_idle || !monitor_inac) begin</pre>
<pre>          link_inac_state_d  = Active;</pre>
<pre>      default : link_inac_state_d = Active;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin : proc_reg_idle_det</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      link_inac_state_q <= Active;</pre>
<pre>      link_inac_timer_q <= 0;</pre>
<pre>    end else begin</pre>
<pre>      link_inac_state_q <= link_inac_state_d;</pre>
<pre>      link_inac_timer_q <= link_inac_timer_d;</pre>
<pre>  logic [12:0] host_presence_timer;</pre>
<pre>  assign host_lost_o = host_presence_timer[12];</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      host_presence_timer <= '0;</pre>
<pre>    end else begin</pre>
<pre>      if (sof_valid_i || !link_active || link_reset) begin</pre>
<pre>        host_presence_timer <= '0;</pre>
<pre>      end else if (us_tick_i && !host_lost_o) begin</pre>
<pre>        host_presence_timer <= host_presence_timer + 1;</pre>
<h3>hw/ip/usbdev/rtl/usbdev.sv</h3>
<pre>  input  logic       clk_i,</pre>
<pre>  input  logic       rst_ni,</pre>
<pre>  input  logic       clk_usb_48mhz_i, // use usb_ prefix for signals in this clk</pre>
<pre>  input  logic       rst_usb_ni, // async reset, with relase sync to clk_usb_48_mhz_i</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  input  logic       cio_usb_d_i,</pre>
<pre>  input  logic       cio_usb_dp_i,</pre>
<pre>  input  logic       cio_usb_dn_i,</pre>
<pre>  output logic       cio_usb_d_o,</pre>
<pre>  output logic       cio_usb_se0_o,</pre>
<pre>  output logic       cio_usb_dp_o,</pre>
<pre>  output logic       cio_usb_dn_o,</pre>
<pre>  output logic       cio_usb_oe_o,</pre>
<pre>  output logic       cio_usb_tx_mode_se_o,</pre>
<pre>  input  logic       cio_usb_sense_i,</pre>
<pre>  output logic       cio_usb_pullup_en_o,</pre>
<pre>  output logic       cio_usb_suspend_o,</pre>
<pre>  output logic       intr_pkt_received_o, // Packet received</pre>
<pre>  output logic       intr_pkt_sent_o, // Packet sent</pre>
<pre>  output logic       intr_connected_o,</pre>
<pre>  output logic       intr_disconnected_o,</pre>
<pre>  output logic       intr_host_lost_o,</pre>
<pre>  output logic       intr_link_reset_o,</pre>
<pre>  output logic       intr_link_suspend_o,</pre>
<pre>  output logic       intr_link_resume_o,</pre>
<pre>  output logic       intr_av_empty_o,</pre>
<pre>  output logic       intr_rx_full_o,</pre>
<pre>  output logic       intr_av_overflow_o,</pre>
<pre>  output logic       intr_link_in_err_o,</pre>
<pre>  output logic       intr_rx_crc_err_o,</pre>
<pre>  output logic       intr_rx_pid_err_o,</pre>
<pre>  output logic       intr_rx_bitstuff_err_o,</pre>
<pre>  output logic       intr_frame_o</pre>
<pre>  localparam int SramDw = 32; // Places packing bytes to SRAM assume this</pre>
<pre>  localparam int SramDepth = 512; // 2kB, SRAM Width is DW</pre>
<pre>  localparam int MaxPktSizeByte = 64;</pre>
<pre>  localparam int SramAw = $clog2(SramDepth);</pre>
<pre>  localparam int SizeWidth = $clog2(MaxPktSizeByte);</pre>
<pre>  localparam int NBuf = (SramDepth * SramDw) / (MaxPktSizeByte * 8);</pre>
<pre>  localparam int NBufWidth = $clog2(NBuf);</pre>
<pre>  localparam int AVFifoWidth = NBufWidth;</pre>
<pre>  localparam int AVFifoDepth = 4;</pre>
<pre>  localparam int RXFifoWidth = NBufWidth + (1+SizeWidth)         +  4  + 1;</pre>
<pre>  localparam int RXFifoDepth = 4;</pre>
<pre>  localparam int NEndpoints = usbdev_reg_pkg::NEndpoints;</pre>
<pre>  usbdev_reg2hw_t reg2hw;</pre>
<pre>  usbdev_hw2reg_t hw2reg;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_sram_h2d [1];</pre>
<pre>  tlul_pkg::tl_d2h_t tl_sram_d2h [1];</pre>
<pre>  logic              mem_a_req;</pre>
<pre>  logic              mem_a_write;</pre>
<pre>  logic [SramAw-1:0] mem_a_addr;</pre>
<pre>  logic [SramDw-1:0] mem_a_wdata;</pre>
<pre>  logic              mem_a_rvalid;</pre>
<pre>  logic [SramDw-1:0] mem_a_rdata;</pre>
<pre>  logic [1:0]        mem_a_rerror;</pre>
<pre>  logic              usb_mem_b_req;</pre>
<pre>  logic              usb_mem_b_write;</pre>
<pre>  logic [SramAw-1:0] usb_mem_b_addr;</pre>
<pre>  logic [SramDw-1:0] usb_mem_b_wdata;</pre>
<pre>  logic [SramDw-1:0] usb_mem_b_rdata;</pre>
<pre>  logic              usb_clr_devaddr;</pre>
<pre>  logic              usb_event_av_empty, event_av_overflow, usb_event_rx_full;</pre>
<pre>  logic              event_av_empty, event_rx_full;</pre>
<pre>  logic              usb_event_link_reset, usb_event_link_suspend, usb_event_link_resume;</pre>
<pre>  logic              usb_event_host_lost, usb_event_disconnect, usb_event_connect;</pre>
<pre>  logic              usb_event_rx_crc_err, usb_event_rx_pid_err;</pre>
<pre>  logic              usb_event_rx_bitstuff_err;</pre>
<pre>  logic              usb_event_in_err;</pre>
<pre>  logic              usb_event_frame;</pre>
<pre>  logic              event_link_reset, event_link_suspend, event_link_resume;</pre>
<pre>  logic              event_host_lost, event_disconnect, event_connect;</pre>
<pre>  logic              event_rx_crc_err, event_rx_pid_err;</pre>
<pre>  logic              event_rx_bitstuff_err;</pre>
<pre>  logic              event_in_err;</pre>
<pre>  logic              event_frame;</pre>
<pre>  logic [10:0]       usb_frame;</pre>
<pre>  logic [2:0]        usb_link_state;</pre>
<pre>  logic              usb_enable;</pre>
<pre>  logic [6:0]        usb_device_addr;</pre>
<pre>  logic                  usb_data_toggle_clear_en;</pre>
<pre>  logic [NEndpoints-1:0] usb_data_toggle_clear;</pre>
<pre>  logic usb_rx_d;</pre>
<pre>  logic usb_rx_se0;</pre>
<pre>  logic usb_tx_d;</pre>
<pre>  logic usb_tx_se0;</pre>
<pre>  logic usb_tx_oe;</pre>
<pre>  logic usb_pwr_sense;</pre>
<pre>  logic usb_pullup_en;</pre>
<pre>  logic              av_fifo_wready;</pre>
<pre>  logic              event_pkt_received;</pre>
<pre>  logic              usb_av_rvalid, usb_av_rready;</pre>
<pre>  logic              usb_rx_wvalid, usb_rx_wready;</pre>
<pre>  logic              rx_fifo_rvalid;</pre>
<pre>  logic [AVFifoWidth - 1:0] usb_av_rdata;</pre>
<pre>  logic [RXFifoWidth - 1:0] usb_rx_wdata, rx_rdata_raw, rx_rdata;</pre>
<pre>  assign event_av_overflow = reg2hw.avbuffer.qe & (~av_fifo_wready);</pre>
<pre>  assign hw2reg.usbstat.av_full.d = ~av_fifo_wready;</pre>
<pre>  assign hw2reg.usbstat.rx_empty.d = ~rx_fifo_rvalid;</pre>
<pre>  prim_fifo_async #(</pre>
<pre>    .Width(AVFifoWidth),</pre>
<pre>    .Depth(AVFifoDepth)</pre>
<pre style="background-color: #FF0000;">  ) usbdev_avfifo (</pre>
<pre>    .clk_wr_i  (clk_i),</pre>
<pre>    .rst_wr_ni (rst_ni),</pre>
<pre>    .wvalid    (reg2hw.avbuffer.qe),</pre>
<pre>    .wready    (av_fifo_wready),</pre>
<pre>    .wdata     (reg2hw.avbuffer.q),</pre>
<pre>    .wdepth    (hw2reg.usbstat.av_depth.d),</pre>
<pre>    .clk_rd_i  (clk_usb_48mhz_i),</pre>
<pre>    .rst_rd_ni (rst_usb_ni),</pre>
<pre>    .rvalid    (usb_av_rvalid),</pre>
<pre>    .rready    (usb_av_rready),</pre>
<pre>    .rdata     (usb_av_rdata),</pre>
<pre>    .rdepth    () // only using empty</pre>
<pre>  prim_fifo_async #(</pre>
<pre>    .Width(RXFifoWidth),</pre>
<pre>    .Depth(RXFifoDepth)</pre>
<pre style="background-color: #FF0000;">  ) usbdev_rxfifo (</pre>
<pre>    .clk_wr_i  (clk_usb_48mhz_i),</pre>
<pre>    .rst_wr_ni (rst_usb_ni),</pre>
<pre>    .wvalid    (usb_rx_wvalid),</pre>
<pre>    .wready    (usb_rx_wready),</pre>
<pre>    .wdata     (usb_rx_wdata),</pre>
<pre>    .wdepth    (),</pre>
<pre>    .clk_rd_i  (clk_i),</pre>
<pre>    .rst_rd_ni (rst_ni),</pre>
<pre>    .rvalid    (rx_fifo_rvalid),</pre>
<pre>    .rready    (reg2hw.rxfifo.buffer.re),</pre>
<pre>    .rdata     (rx_rdata_raw),</pre>
<pre>    .rdepth    (hw2reg.usbstat.rx_depth.d)</pre>
<pre>  assign rx_rdata = rx_fifo_rvalid ? rx_rdata_raw : '0;</pre>
<pre>  assign hw2reg.rxfifo.ep.d = rx_rdata[16:13];</pre>
<pre>  assign hw2reg.rxfifo.setup.d = rx_rdata[12];</pre>
<pre>  assign hw2reg.rxfifo.size.d = rx_rdata[11:5];</pre>
<pre>  assign hw2reg.rxfifo.buffer.d = rx_rdata[4:0];</pre>
<pre>  assign event_pkt_received = rx_fifo_rvalid;</pre>
<pre>  logic [2:0]               unused_re;</pre>
<pre>  assign unused_re = {reg2hw.rxfifo.ep.re, reg2hw.rxfifo.setup.re, reg2hw.rxfifo.size.re};</pre>
<pre>  logic [NBufWidth-1:0]  usb_in_buf [NEndpoints];</pre>
<pre>  logic [SizeWidth:0]    usb_in_size [NEndpoints];</pre>
<pre>  logic [3:0]            usb_in_endpoint;</pre>
<pre>  logic [NEndpoints-1:0] usb_in_rdy;</pre>
<pre>  logic [NEndpoints-1:0] clear_rdybit, set_sentbit, update_pend;</pre>
<pre>  logic                  usb_setup_received, setup_received, usb_set_sent, set_sent;</pre>
<pre>  logic [NEndpoints-1:0] ep_iso;</pre>
<pre>  logic [NEndpoints-1:0] enable_setup, enable_out, ep_stall;</pre>
<pre>  logic [NEndpoints-1:0] usb_enable_setup, usb_enable_out, usb_ep_stall;</pre>
<pre>  logic [NEndpoints-1:0] in_rdy_async;</pre>
<pre>  logic [3:0]            usb_out_endpoint;</pre>
<pre>  always_comb begin : proc_map_rxenable</pre>
<pre>    for (int i = 0; i < NEndpoints; i++) begin</pre>
<pre>      enable_setup[i] = reg2hw.rxenable_setup[i].q;</pre>
<pre>      enable_out[i]   = reg2hw.rxenable_out[i].q;</pre>
<pre>  always_comb begin : proc_map_stall</pre>
<pre>    for (int i = 0; i < NEndpoints; i++) begin</pre>
<pre>      ep_stall[i] = reg2hw.stall[i];</pre>
<pre>  prim_flop_2sync #(</pre>
<pre>    .Width(3*NEndpoints)</pre>
<pre style="background-color: #FF0000;">  ) usbdev_sync_ep_cfg (</pre>
<pre>    .clk_i  (clk_usb_48mhz_i),</pre>
<pre>    .rst_ni (rst_usb_ni),</pre>
<pre>    .d      ({enable_setup, enable_out, ep_stall}),</pre>
<pre>    .q      ({usb_enable_setup, usb_enable_out, usb_ep_stall})</pre>
<pre>  always_comb begin : proc_map_iso</pre>
<pre>    for (int i = 0; i < NEndpoints; i++) begin</pre>
<pre>      ep_iso[i] = reg2hw.iso[i].q;</pre>
<pre>  always_comb begin : proc_map_buf_size</pre>
<pre>    for (int i = 0; i < NEndpoints; i++) begin</pre>
<pre>      usb_in_buf[i]  = reg2hw.configin[i].buffer.q;</pre>
<pre>      usb_in_size[i] = reg2hw.configin[i].size.q;</pre>
<pre>  always_comb begin : proc_map_rdy_reg2hw</pre>
<pre>    for (int i = 0; i < NEndpoints; i++) begin</pre>
<pre>      in_rdy_async[i] = reg2hw.configin[i].rdy.q;</pre>
<pre>  prim_flop_2sync #(</pre>
<pre>    .Width (NEndpoints)</pre>
<pre style="background-color: #FF0000;">  ) usbdev_rdysync (</pre>
<pre>    .clk_i  (clk_usb_48mhz_i),</pre>
<pre>    .rst_ni (rst_usb_ni),</pre>
<pre>    .d      (in_rdy_async),</pre>
<pre>    .q      (usb_in_rdy)</pre>
<pre>  prim_pulse_sync usbdev_data_toggle_clear (</pre>
<pre>    .clk_src_i   (clk_i),</pre>
<pre>    .clk_dst_i   (clk_usb_48mhz_i),</pre>
<pre>    .rst_src_ni  (rst_ni),</pre>
<pre>    .rst_dst_ni  (rst_usb_ni),</pre>
<pre>    .src_pulse_i (reg2hw.data_toggle_clear[0].qe),</pre>
<pre>    .dst_pulse_o (usb_data_toggle_clear_en)</pre>
<pre>  always_comb begin : proc_usb_data_toggle_clear</pre>
<pre>    usb_data_toggle_clear = '0;</pre>
<pre>    for (int i = 0; i < NEndpoints; i++) begin</pre>
<pre>      if (usb_data_toggle_clear_en) begin</pre>
<pre>        usb_data_toggle_clear[i] = reg2hw.data_toggle_clear[i].q;</pre>
<pre>  prim_pulse_sync usbdev_setsent (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_set_sent),</pre>
<pre>    .dst_pulse_o (set_sent)</pre>
<pre>  always_comb begin</pre>
<pre>    set_sentbit = '0;</pre>
<pre>    if (set_sent) begin</pre>
<pre>      set_sentbit[usb_in_endpoint] = 1; // lint: usb_in_endpoint range was checked</pre>
<pre>  always_comb begin : proc_map_sent</pre>
<pre>    for (int i = 0; i < NEndpoints; i++) begin</pre>
<pre>      hw2reg.in_sent[i].de = set_sentbit[i];</pre>
<pre>      hw2reg.in_sent[i].d  = 1'b1;</pre>
<pre>  prim_pulse_sync usbdev_sync_in_err (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_event_in_err),</pre>
<pre>    .dst_pulse_o (event_in_err)</pre>
<pre>  prim_pulse_sync usbdev_outrdyclr (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_setup_received),</pre>
<pre>    .dst_pulse_o (setup_received)</pre>
<pre>  prim_pulse_sync sync_usb_event_rx_crc_err (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_event_rx_crc_err),</pre>
<pre>    .dst_pulse_o (event_rx_crc_err)</pre>
<pre>  prim_pulse_sync sync_usb_event_rx_pid_err (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_event_rx_pid_err),</pre>
<pre>    .dst_pulse_o (event_rx_pid_err)</pre>
<pre>  prim_pulse_sync sync_usb_event_rx_bitstuff_err (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_event_rx_bitstuff_err),</pre>
<pre>    .dst_pulse_o (event_rx_bitstuff_err)</pre>
<pre>  prim_pulse_sync sync_usb_event_frame (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_event_frame),</pre>
<pre>    .dst_pulse_o (event_frame)</pre>
<pre>  logic event_link_reset_q;</pre>
<pre>  always_ff @(posedge clk_usb_48mhz_i or negedge rst_usb_ni) begin</pre>
<pre>    if (!rst_usb_ni) begin</pre>
<pre>      event_link_reset_q <= 0;</pre>
<pre>    end else begin</pre>
<pre>      event_link_reset_q <= event_link_reset;</pre>
<pre>  always_comb begin</pre>
<pre>    clear_rdybit = '0;</pre>
<pre>    update_pend  = '0;</pre>
<pre>    if (event_link_reset && !event_link_reset_q) begin</pre>
<pre>      clear_rdybit = {NEndpoints{1'b1}};</pre>
<pre>      update_pend  = {NEndpoints{1'b1}};</pre>
<pre>    end else begin</pre>
<pre>      clear_rdybit[usb_out_endpoint] = setup_received;</pre>
<pre>      update_pend[usb_out_endpoint]  = setup_received;</pre>
<pre>      clear_rdybit[usb_in_endpoint] = set_sent;</pre>
<pre>  always_comb begin : proc_map_rdy_hw2reg</pre>
<pre>    for (int i = 0; i < NEndpoints; i++) begin</pre>
<pre>      hw2reg.configin[i].rdy.de = clear_rdybit[i];</pre>
<pre>      hw2reg.configin[i].rdy.d  = 1'b0;</pre>
<pre>  always_comb begin : proc_map_pend</pre>
<pre>    for (int i = 0; i < NEndpoints; i++) begin</pre>
<pre>      hw2reg.configin[i].pend.de = update_pend[i];</pre>
<pre>      hw2reg.configin[i].pend.d  = reg2hw.configin[i].rdy.q | reg2hw.configin[i].pend.q;</pre>
<pre>  usbdev_usbif #(</pre>
<pre>    .NEndpoints     (NEndpoints),</pre>
<pre>    .AVFifoWidth    (AVFifoWidth),</pre>
<pre>    .RXFifoWidth    (RXFifoWidth),</pre>
<pre>    .MaxPktSizeByte (MaxPktSizeByte),</pre>
<pre>    .NBuf           (NBuf),</pre>
<pre>    .SramAw         (SramAw)</pre>
<pre style="background-color: #FF0000;">  ) usbdev_impl (</pre>
<pre>    .clk_48mhz_i          (clk_usb_48mhz_i),</pre>
<pre>    .rst_ni               (rst_usb_ni),</pre>
<pre>    .usb_d_i              (usb_rx_d),</pre>
<pre>    .usb_se0_i            (usb_rx_se0),</pre>
<pre>    .usb_oe_o             (usb_tx_oe),</pre>
<pre>    .usb_d_o              (usb_tx_d),</pre>
<pre>    .usb_se0_o            (usb_tx_se0),</pre>
<pre>    .usb_sense_i          (usb_pwr_sense),</pre>
<pre>    .usb_pullup_en_o      (usb_pullup_en),</pre>
<pre>    .rx_setup_i           (usb_enable_setup),</pre>
<pre>    .rx_out_i             (usb_enable_out),</pre>
<pre>    .rx_stall_i           (usb_ep_stall),</pre>
<pre>    .av_rvalid_i          (usb_av_rvalid),</pre>
<pre>    .av_rready_o          (usb_av_rready),</pre>
<pre>    .av_rdata_i           (usb_av_rdata),</pre>
<pre>    .event_av_empty_o     (usb_event_av_empty),</pre>
<pre>    .rx_wvalid_o          (usb_rx_wvalid),</pre>
<pre>    .rx_wready_i          (usb_rx_wready),</pre>
<pre>    .rx_wdata_o           (usb_rx_wdata),</pre>
<pre>    .event_rx_full_o      (usb_event_rx_full),</pre>
<pre>    .setup_received_o     (usb_setup_received),</pre>
<pre>    .out_endpoint_o       (usb_out_endpoint),  // will be stable for several cycles</pre>
<pre>    .in_buf_i             (usb_in_buf[usb_in_endpoint]),  // lint: usb_in_endpoint range was checked</pre>
<pre>    .in_size_i            (usb_in_size[usb_in_endpoint]),  // lint: usb_in_endpoint range was checked</pre>
<pre>    .in_stall_i           (usb_ep_stall),</pre>
<pre>    .in_rdy_i             (usb_in_rdy),</pre>
<pre>    .set_sent_o           (usb_set_sent),</pre>
<pre>    .in_endpoint_o        (usb_in_endpoint),</pre>
<pre>    .mem_req_o            (usb_mem_b_req),</pre>
<pre>    .mem_write_o          (usb_mem_b_write),</pre>
<pre>    .mem_addr_o           (usb_mem_b_addr),</pre>
<pre>    .mem_wdata_o          (usb_mem_b_wdata),</pre>
<pre>    .mem_rdata_i          (usb_mem_b_rdata),</pre>
<pre>    .enable_i             (usb_enable),</pre>
<pre>    .devaddr_i            (usb_device_addr),</pre>
<pre>    .clr_devaddr_o        (usb_clr_devaddr),</pre>
<pre>    .ep_iso_i             (ep_iso), // cdc ok, quasi-static</pre>
<pre>    .cfg_eop_single_bit_i (reg2hw.phy_config.eop_single_bit.q), // cdc ok: quasi-static</pre>
<pre>    .tx_osc_test_mode_i   (1'b0), // cdc ok: quasi-static & testmode only</pre>
<pre>    .data_toggle_clear_i  (usb_data_toggle_clear),</pre>
<pre>    .frame_o              (usb_frame),</pre>
<pre>    .frame_start_o        (usb_event_frame),</pre>
<pre>    .link_state_o         (usb_link_state),</pre>
<pre>    .link_disconnect_o    (usb_event_disconnect),</pre>
<pre>    .link_connect_o       (usb_event_connect),</pre>
<pre>    .link_reset_o         (usb_event_link_reset),</pre>
<pre>    .link_suspend_o       (usb_event_link_suspend),</pre>
<pre>    .link_resume_o        (usb_event_link_resume),</pre>
<pre>    .host_lost_o          (usb_event_host_lost),</pre>
<pre>    .link_in_err_o        (usb_event_in_err),</pre>
<pre>    .rx_crc_err_o         (usb_event_rx_crc_err),</pre>
<pre>    .rx_pid_err_o         (usb_event_rx_pid_err),</pre>
<pre>    .rx_bitstuff_err_o    (usb_event_rx_bitstuff_err)</pre>
<pre>  prim_flop_2sync #(</pre>
<pre>    .Width      (3+11)</pre>
<pre style="background-color: #FF0000;">  ) cdc_usb_to_sys (</pre>
<pre>    .clk_i  (clk_i),</pre>
<pre>    .rst_ni (rst_ni),</pre>
<pre>    .d      ({usb_link_state,              usb_frame}),</pre>
<pre>    .q      ({hw2reg.usbstat.link_state.d, hw2reg.usbstat.frame.d})</pre>
<pre>  prim_flop_2sync #(</pre>
<pre>    .Width      (1+7)</pre>
<pre style="background-color: #FF0000;">  ) cdc_sys_to_usb (</pre>
<pre>    .clk_i  (clk_usb_48mhz_i),</pre>
<pre>    .rst_ni (rst_usb_ni),</pre>
<pre>    .d      ({reg2hw.usbctrl.enable.q, reg2hw.usbctrl.device_address.q}),</pre>
<pre>    .q      ({usb_enable,              usb_device_addr})</pre>
<pre>  usbdev_flop_2syncpulse #(.Width(5)) syncevent (</pre>
<pre>    .clk_i  (clk_i),</pre>
<pre>    .rst_ni (rst_ni),</pre>
<pre>    .d      ({usb_event_disconnect, usb_event_link_reset, usb_event_link_suspend,</pre>
<pre>              usb_event_host_lost, usb_event_connect}),</pre>
<pre>    .q      ({event_disconnect, event_link_reset, event_link_suspend,</pre>
<pre>              event_host_lost, event_connect})</pre>
<pre>  prim_pulse_sync usbdev_resume (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_event_link_resume),</pre>
<pre>    .dst_pulse_o (event_link_resume)</pre>
<pre>  assign hw2reg.usbstat.host_lost.d = event_host_lost;</pre>
<pre>  prim_pulse_sync usbdev_devclr (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_clr_devaddr),</pre>
<pre>    .dst_pulse_o (hw2reg.usbctrl.device_address.de)</pre>
<pre>  assign hw2reg.usbctrl.device_address.d = '0;</pre>
<pre>  prim_pulse_sync sync_usb_event_av_empty (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_event_av_empty),</pre>
<pre>    .dst_pulse_o (event_av_empty)</pre>
<pre>  prim_pulse_sync sync_usb_event_rx_full (</pre>
<pre>    .clk_src_i   (clk_usb_48mhz_i),</pre>
<pre>    .clk_dst_i   (clk_i),</pre>
<pre>    .rst_src_ni  (rst_usb_ni),</pre>
<pre>    .rst_dst_ni  (rst_ni),</pre>
<pre>    .src_pulse_i (usb_event_rx_full),</pre>
<pre>    .dst_pulse_o (event_rx_full)</pre>
<pre>  always_comb begin : proc_stall_tieoff</pre>
<pre>    for (int i = 0; i < NEndpoints; i++) begin</pre>
<pre>      hw2reg.stall[i].d  = 1'b0;</pre>
<pre>      if (setup_received && usb_out_endpoint == 4'(i)) begin</pre>
<pre>        hw2reg.stall[i].de = 1'b1;</pre>
<pre>      end else begin</pre>
<pre>        hw2reg.stall[i].de = 1'b0;</pre>
<pre>  logic        unused_mem_a_rerror_d;</pre>
<pre>  tlul_adapter_sram #(</pre>
<pre>    .SramAw(SramAw),</pre>
<pre>    .ByteAccess(0)</pre>
<pre style="background-color: #FF0000;">  ) u_tlul2sram (</pre>
<pre>    .clk_i    (clk_i),</pre>
<pre>    .rst_ni   (rst_ni),</pre>
<pre>    .tl_i     (tl_sram_h2d [0]),</pre>
<pre>    .tl_o     (tl_sram_d2h [0]),</pre>
<pre>    .req_o    (mem_a_req),</pre>
<pre>    .gnt_i    (mem_a_req),  //Always grant when request</pre>
<pre>    .we_o     (mem_a_write),</pre>
<pre>    .addr_o   (mem_a_addr),</pre>
<pre>    .wdata_o  (mem_a_wdata),</pre>
<pre>    .wmask_o  (),           // Not used</pre>
<pre>    .rdata_i  (mem_a_rdata),</pre>
<pre>    .rvalid_i (mem_a_rvalid),</pre>
<pre>    .rerror_i (mem_a_rerror)</pre>
<pre>  assign unused_mem_a_rerror_d = mem_a_rerror[1] ; // Only uncorrectable error</pre>
<pre>  prim_ram_2p_async_adv #(</pre>
<pre>    .Depth (SramDepth),</pre>
<pre>    .Width (SramDw),    // 32 x 512 --> 2kB</pre>
<pre>    .CfgW  (8),</pre>
<pre>    .EnableECC           (0), // No Protection</pre>
<pre>    .EnableParity        (0),</pre>
<pre>    .EnableInputPipeline (0),</pre>
<pre>    .EnableOutputPipeline(0),</pre>
<pre>    .MemT ("SRAM")</pre>
<pre style="background-color: #FF0000;">  ) u_memory_2p (</pre>
<pre>    .clk_a_i    (clk_i),</pre>
<pre>    .clk_b_i    (clk_usb_48mhz_i),</pre>
<pre>    .rst_a_ni   (rst_ni),</pre>
<pre>    .rst_b_ni   (rst_usb_ni),</pre>
<pre>    .a_req_i    (mem_a_req),</pre>
<pre>    .a_write_i  (mem_a_write),</pre>
<pre>    .a_addr_i   (mem_a_addr),</pre>
<pre>    .a_wdata_i  (mem_a_wdata),</pre>
<pre>    .a_rvalid_o (mem_a_rvalid),</pre>
<pre>    .a_rdata_o  (mem_a_rdata),</pre>
<pre>    .a_rerror_o (mem_a_rerror),</pre>
<pre>    .b_req_i    (usb_mem_b_req),</pre>
<pre>    .b_write_i  (usb_mem_b_write),</pre>
<pre>    .b_addr_i   (usb_mem_b_addr),</pre>
<pre>    .b_wdata_i  (usb_mem_b_wdata),</pre>
<pre>    .b_rvalid_o (),</pre>
<pre>    .b_rdata_o  (usb_mem_b_rdata),</pre>
<pre>    .b_rerror_o (),</pre>
<pre>    .cfg_i      (8'h0)</pre>
<pre>  usbdev_reg_top u_reg (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_i),</pre>
<pre>    .tl_o (tl_o),</pre>
<pre>    .tl_win_o (tl_sram_h2d),</pre>
<pre>    .tl_win_i (tl_sram_d2h),</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .devmode_i (1'b1)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_pkt_received (</pre>
<pre>    .event_intr_i           (event_pkt_received),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.pkt_received.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.pkt_received.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.pkt_received.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.pkt_received.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.pkt_received.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.pkt_received.d),</pre>
<pre>    .intr_o                 (intr_pkt_received_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_pkt_sent (</pre>
<pre>    .event_intr_i           (set_sent),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.pkt_sent.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.pkt_sent.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.pkt_sent.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.pkt_sent.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.pkt_sent.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.pkt_sent.d),</pre>
<pre>    .intr_o                 (intr_pkt_sent_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_disconnected (</pre>
<pre>    .event_intr_i           (event_disconnect),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.disconnected.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.disconnected.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.disconnected.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.disconnected.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.disconnected.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.disconnected.d),</pre>
<pre>    .intr_o                 (intr_disconnected_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_connected (</pre>
<pre>    .event_intr_i           (event_connect),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.connected.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.connected.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.connected.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.connected.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.connected.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.connected.d),</pre>
<pre>    .intr_o                 (intr_connected_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_host_lost (</pre>
<pre>    .event_intr_i           (event_host_lost),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.host_lost.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.host_lost.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.host_lost.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.host_lost.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.host_lost.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.host_lost.d),</pre>
<pre>    .intr_o                 (intr_host_lost_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_link_reset (</pre>
<pre>    .event_intr_i           (event_link_reset),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.link_reset.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.link_reset.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.link_reset.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.link_reset.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.link_reset.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.link_reset.d),</pre>
<pre>    .intr_o                 (intr_link_reset_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_link_suspend (</pre>
<pre>    .event_intr_i           (event_link_suspend),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.link_suspend.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.link_suspend.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.link_suspend.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.link_suspend.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.link_suspend.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.link_suspend.d),</pre>
<pre>    .intr_o                 (intr_link_suspend_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_link_resume (</pre>
<pre>    .event_intr_i           (event_link_resume),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.link_resume.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.link_resume.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.link_resume.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.link_resume.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.link_resume.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.link_resume.d),</pre>
<pre>    .intr_o                 (intr_link_resume_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_av_empty (</pre>
<pre>    .event_intr_i           (event_av_empty),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.av_empty.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.av_empty.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.av_empty.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.av_empty.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.av_empty.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.av_empty.d),</pre>
<pre>    .intr_o                 (intr_av_empty_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_rx_full (</pre>
<pre>    .event_intr_i           (event_rx_full),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_full.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.rx_full.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.rx_full.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.rx_full.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.rx_full.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.rx_full.d),</pre>
<pre>    .intr_o                 (intr_rx_full_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_av_overflow (</pre>
<pre>    .event_intr_i           (event_av_overflow),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.av_overflow.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.av_overflow.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.av_overflow.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.av_overflow.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.av_overflow.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.av_overflow.d),</pre>
<pre>    .intr_o                 (intr_av_overflow_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_link_in_err (</pre>
<pre>    .event_intr_i           (event_in_err),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.link_in_err.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.link_in_err.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.link_in_err.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.link_in_err.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.link_in_err.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.link_in_err.d),</pre>
<pre>    .intr_o                 (intr_link_in_err_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_rx_crc_err (</pre>
<pre>    .event_intr_i           (event_rx_crc_err),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_crc_err.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.rx_crc_err.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.rx_crc_err.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.rx_crc_err.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.rx_crc_err.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.rx_crc_err.d),</pre>
<pre>    .intr_o                 (intr_rx_crc_err_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_rx_pid_err (</pre>
<pre>    .event_intr_i           (event_rx_pid_err),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_pid_err.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.rx_pid_err.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.rx_pid_err.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.rx_pid_err.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.rx_pid_err.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.rx_pid_err.d),</pre>
<pre>    .intr_o                 (intr_rx_pid_err_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_rx_bitstuff_err (</pre>
<pre>    .event_intr_i           (event_rx_bitstuff_err),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_bitstuff_err.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.rx_bitstuff_err.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.rx_bitstuff_err.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.rx_bitstuff_err.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.rx_bitstuff_err.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.rx_bitstuff_err.d),</pre>
<pre>    .intr_o                 (intr_rx_bitstuff_err_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_frame (</pre>
<pre>    .event_intr_i           (event_frame),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.frame.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.frame.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.frame.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.frame.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.frame.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.frame.d),</pre>
<pre>    .intr_o                 (intr_frame_o)</pre>
<pre>  usbdev_iomux i_usbdev_iomux (</pre>
<pre>    .clk_i                  (clk_i),</pre>
<pre>    .rst_ni                 (rst_ni),</pre>
<pre>    .clk_usb_48mhz_i        (clk_usb_48mhz_i),</pre>
<pre>    .rst_usb_ni             (rst_usb_ni),</pre>
<pre>    .rx_differential_mode_i (reg2hw.phy_config.rx_differential_mode),</pre>
<pre>    .tx_differential_mode_i (reg2hw.phy_config.tx_differential_mode),</pre>
<pre>    .sys_reg2hw_config_i    (reg2hw.phy_config),</pre>
<pre>    .sys_usb_sense_o        (hw2reg.usbstat.usb_sense.d),</pre>
<pre>    .cio_usb_d_i            (cio_usb_d_i),</pre>
<pre>    .cio_usb_dp_i           (cio_usb_dp_i),</pre>
<pre>    .cio_usb_dn_i           (cio_usb_dn_i),</pre>
<pre>    .cio_usb_d_o            (cio_usb_d_o),</pre>
<pre>    .cio_usb_se0_o          (cio_usb_se0_o),</pre>
<pre>    .cio_usb_dp_o           (cio_usb_dp_o),</pre>
<pre>    .cio_usb_dn_o           (cio_usb_dn_o),</pre>
<pre>    .cio_usb_oe_o           (cio_usb_oe_o),</pre>
<pre>    .cio_usb_tx_mode_se_o   (cio_usb_tx_mode_se_o),</pre>
<pre>    .cio_usb_sense_i        (cio_usb_sense_i),</pre>
<pre>    .cio_usb_pullup_en_o    (cio_usb_pullup_en_o),</pre>
<pre>    .cio_usb_suspend_o      (cio_usb_suspend_o),</pre>
<pre>    .usb_rx_d_o             (usb_rx_d),</pre>
<pre>    .usb_rx_se0_o           (usb_rx_se0),</pre>
<pre>    .usb_tx_d_i             (usb_tx_d),</pre>
<pre>    .usb_tx_se0_i           (usb_tx_se0),</pre>
<pre>    .usb_tx_oe_i            (usb_tx_oe),</pre>
<pre>    .usb_pwr_sense_o        (usb_pwr_sense),</pre>
<pre>    .usb_pullup_en_i        (usb_pullup_en),</pre>
<pre>    .usb_suspend_i          (usb_event_link_suspend)</pre>
<h3>hw/ip/usbdev/rtl/usbdev_iomux.sv</h3>
<pre>  input  logic                          clk_i,</pre>
<pre>  input  logic                          rst_ni,</pre>
<pre>  input  logic                          clk_usb_48mhz_i, // use usb_ prefix for signals in this clk</pre>
<pre>  input  logic                          rst_usb_ni,</pre>
<pre>  input  logic                          rx_differential_mode_i,</pre>
<pre>  input  logic                          tx_differential_mode_i,</pre>
<pre>  input  usbdev_reg2hw_phy_config_reg_t sys_reg2hw_config_i,</pre>
<pre>  output logic                          sys_usb_sense_o,</pre>
<pre>  input  logic                          cio_usb_d_i,</pre>
<pre>  input  logic                          cio_usb_dp_i,</pre>
<pre>  input  logic                          cio_usb_dn_i,</pre>
<pre>  output logic                          cio_usb_d_o,</pre>
<pre>  output logic                          cio_usb_se0_o,</pre>
<pre>  output logic                          cio_usb_dp_o,</pre>
<pre>  output logic                          cio_usb_dn_o,</pre>
<pre>  output logic                          cio_usb_oe_o,</pre>
<pre>  output logic                          cio_usb_tx_mode_se_o,</pre>
<pre>  input  logic                          cio_usb_sense_i,</pre>
<pre>  output logic                          cio_usb_pullup_en_o,</pre>
<pre>  output logic                          cio_usb_suspend_o,</pre>
<pre>  output logic                          usb_rx_d_o,</pre>
<pre>  output logic                          usb_rx_se0_o,</pre>
<pre>  input  logic                          usb_tx_d_i,</pre>
<pre>  input  logic                          usb_tx_se0_i,</pre>
<pre>  input  logic                          usb_tx_oe_i,</pre>
<pre>  output logic                          usb_pwr_sense_o,</pre>
<pre>  input  logic                          usb_pullup_en_i,</pre>
<pre>  input  logic                          usb_suspend_i</pre>
<pre>  logic async_pwr_sense;</pre>
<pre>  logic sys_usb_sense;</pre>
<pre>  logic usb_rx_d;</pre>
<pre>  logic usb_rx_dp;</pre>
<pre>  logic usb_rx_dn;</pre>
<pre>  prim_flop_2sync #(</pre>
<pre>    .Width (1)</pre>
<pre style="background-color: #FF0000;">  ) cdc_io_to_sys (</pre>
<pre>    .clk_i  (clk_i),</pre>
<pre>    .rst_ni (rst_ni),</pre>
<pre>    .d      ({cio_usb_sense_i}),</pre>
<pre>    .q      ({sys_usb_sense})</pre>
<pre>  assign sys_usb_sense_o                = sys_usb_sense;</pre>
<pre>  prim_flop_2sync #(</pre>
<pre>    .Width (4)</pre>
<pre style="background-color: #FF0000;">  ) cdc_io_to_usb (</pre>
<pre>    .clk_i  (clk_usb_48mhz_i),</pre>
<pre>    .rst_ni (rst_usb_ni),</pre>
<pre>    .d      ({cio_usb_dp_i,</pre>
<pre>              cio_usb_dn_i,</pre>
<pre>              cio_usb_d_i,</pre>
<pre>              async_pwr_sense}),</pre>
<pre>    .q      ({usb_rx_dp,</pre>
<pre>              usb_rx_dn,</pre>
<pre>              usb_rx_d,</pre>
<pre>              usb_pwr_sense_o})</pre>
<pre>  always_comb begin : proc_drive_out</pre>
<pre>    cio_usb_dn_o           = 1'b0;</pre>
<pre>    cio_usb_dp_o           = 1'b0;</pre>
<pre>    cio_usb_pullup_en_o    = usb_pullup_en_i;</pre>
<pre>    cio_usb_suspend_o      = usb_suspend_i;</pre>
<pre>    if (tx_differential_mode_i) begin</pre>
<pre>      cio_usb_tx_mode_se_o   = 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      cio_usb_tx_mode_se_o   = 1'b1;</pre>
<pre>      if (usb_tx_se0_i) begin</pre>
<pre>        cio_usb_dp_o = 1'b0;</pre>
<pre>        cio_usb_dn_o = 1'b0;</pre>
<pre>      end else begin</pre>
<pre>        cio_usb_dp_o = usb_tx_d_i;</pre>
<pre>        cio_usb_dn_o = !usb_tx_d_i;</pre>
<pre>  assign cio_usb_d_o   = usb_tx_d_i;</pre>
<pre>  assign cio_usb_se0_o = usb_tx_se0_i;</pre>
<pre>  assign cio_usb_oe_o  = usb_tx_oe_i;</pre>
<pre>  always_comb begin : proc_mux_data_input</pre>
<pre>    usb_rx_se0_o = ~usb_rx_dp & ~usb_rx_dn;</pre>
<pre>    if (rx_differential_mode_i) begin</pre>
<pre>      usb_rx_d_o = usb_rx_d;</pre>
<pre>    end else begin</pre>
<pre>      usb_rx_d_o = usb_rx_dp; // SE1 is interpreted as differential 1</pre>
<pre>  always_comb begin : proc_mux_pwr_input</pre>
<pre>    if (sys_reg2hw_config_i.override_pwr_sense_en.q) begin</pre>
<pre>      async_pwr_sense = sys_reg2hw_config_i.override_pwr_sense_val.q;</pre>
<pre>    end else begin</pre>
<pre>      async_pwr_sense = cio_usb_sense_i;</pre>
<h3>hw/ip/usbdev/rtl/usbdev_usbif.sv</h3>
<pre>module usbdev_usbif  #(</pre>
<pre>  parameter int NEndpoints = 12,</pre>
<pre>  parameter int AVFifoWidth = 4,</pre>
<pre>  parameter int RXFifoWidth = 4,</pre>
<pre>  parameter int MaxPktSizeByte = 64,</pre>
<pre>  parameter int NBuf = 4,</pre>
<pre>  parameter int SramAw = 4,</pre>
<pre>  localparam int NBufWidth = $clog2(NBuf), // derived parameter</pre>
<pre>  localparam int PktW = $clog2(MaxPktSizeByte) // derived parameter</pre>
<pre>  input  logic                     clk_48mhz_i, // 48MHz USB clock</pre>
<pre>  input  logic                     rst_ni,</pre>
<pre>  input  logic                     usb_d_i,</pre>
<pre>  input  logic                     usb_se0_i,</pre>
<pre>  output logic                     usb_d_o,</pre>
<pre>  output logic                     usb_se0_o,</pre>
<pre>  output logic                     usb_oe_o,</pre>
<pre>  output logic                     usb_pullup_en_o,</pre>
<pre>  input  logic                     usb_sense_i,</pre>
<pre>  input  logic [NEndpoints-1:0]    rx_setup_i,</pre>
<pre>  input  logic [NEndpoints-1:0]    rx_out_i,</pre>
<pre>  input  logic [NEndpoints-1:0]    rx_stall_i,</pre>
<pre>  input  logic                     av_rvalid_i,</pre>
<pre>  output logic                     av_rready_o,</pre>
<pre>  input  logic [AVFifoWidth - 1: 0]av_rdata_i,</pre>
<pre>  output logic                     event_av_empty_o,</pre>
<pre>  output logic                     rx_wvalid_o,</pre>
<pre>  input  logic                     rx_wready_i,</pre>
<pre>  output logic [RXFifoWidth - 1:0] rx_wdata_o,</pre>
<pre>  output logic                     event_rx_full_o,</pre>
<pre>  output logic                     setup_received_o,</pre>
<pre>  output [3:0]                     out_endpoint_o,</pre>
<pre>  input  logic [NBufWidth - 1:0]   in_buf_i,</pre>
<pre>  input  logic [PktW:0]            in_size_i,</pre>
<pre>  input  logic [NEndpoints-1:0]    in_stall_i,</pre>
<pre>  input  logic [NEndpoints-1:0]    in_rdy_i,</pre>
<pre>  output logic                     set_sent_o,</pre>
<pre>  output [3:0]                     in_endpoint_o,</pre>
<pre>  output logic                     mem_req_o,</pre>
<pre>  output logic                     mem_write_o,</pre>
<pre>  output logic [SramAw-1:0]        mem_addr_o,</pre>
<pre>  output logic [31:0]              mem_wdata_o,</pre>
<pre>  input  logic [31:0]              mem_rdata_i,</pre>
<pre>  input  logic                     enable_i,</pre>
<pre>  input  logic [6:0]               devaddr_i,</pre>
<pre>  output logic                     clr_devaddr_o,</pre>
<pre>  input  logic [NEndpoints-1:0]    ep_iso_i,</pre>
<pre>  input  logic                     cfg_eop_single_bit_i, // 1: detect a single SE0 bit as EOP</pre>
<pre>  input  logic                     tx_osc_test_mode_i, // Oscillator test mode (constantly output JK)</pre>
<pre>  input  logic [NEndpoints-1:0]    data_toggle_clear_i, // Clear the data toggles for an EP</pre>
<pre>  output logic                     frame_start_o,</pre>
<pre>  output logic [10:0]              frame_o,</pre>
<pre>  output logic [2:0]               link_state_o,</pre>
<pre>  output logic                     link_disconnect_o,</pre>
<pre>  output logic                     link_connect_o,</pre>
<pre>  output logic                     link_reset_o,</pre>
<pre>  output logic                     link_suspend_o,</pre>
<pre>  output logic                     link_resume_o,</pre>
<pre>  output logic                     link_in_err_o,</pre>
<pre>  output logic                     host_lost_o,</pre>
<pre>  output logic                     rx_crc_err_o,</pre>
<pre>  output logic                     rx_pid_err_o,</pre>
<pre>  output logic                     rx_bitstuff_err_o</pre>
<pre>  assign usb_pullup_en_o = enable_i;</pre>
<pre>  logic [PktW:0]                     out_max_used_d, out_max_used_q;</pre>
<pre>  logic [PktW-1:0]                   out_ep_put_addr;</pre>
<pre>  logic [7:0]                        out_ep_data;</pre>
<pre>  logic [3:0]                        out_ep_current;</pre>
<pre>  logic                              out_ep_data_put, out_ep_acked, out_ep_rollback;</pre>
<pre>  logic                              current_setup, all_out_blocked, out_ep_newpkt;</pre>
<pre>  logic [NEndpoints-1:0]             out_ep_setup, out_ep_full, out_ep_stall;</pre>
<pre>  logic [NEndpoints-1:0]             setup_blocked, out_blocked;</pre>
<pre>  logic [31:0]                       wdata;</pre>
<pre>  logic                              mem_read;</pre>
<pre>  logic [SramAw-1:0]                 mem_waddr, mem_raddr;</pre>
<pre>  logic                              link_reset;</pre>
<pre>  logic                              sof_valid;</pre>
<pre>  assign out_endpoint_o = out_ep_current;</pre>
<pre>  assign link_reset_o   = link_reset;</pre>
<pre>  assign clr_devaddr_o  = ~enable_i | link_reset;</pre>
<pre>  assign frame_start_o  = sof_valid;</pre>
<pre>  always_comb begin</pre>
<pre>    if (out_ep_acked || out_ep_rollback) begin</pre>
<pre>      out_max_used_d = 0;</pre>
<pre>    end else if (out_ep_data_put) begin</pre>
<pre>      if (out_max_used_q < MaxPktSizeByte - 1) begin</pre>
<pre>        out_max_used_d = out_ep_put_addr;</pre>
<pre>      end else if (out_max_used_q < MaxPktSizeByte + 1) begin</pre>
<pre>        out_max_used_d = out_max_used_q + 1;</pre>
<pre>      end else begin</pre>
<pre>        out_max_used_d = out_max_used_q;</pre>
<pre>    end else begin</pre>
<pre>      out_max_used_d = out_max_used_q;</pre>
<pre>  logic std_write_d, std_write_q;</pre>
<pre>  assign std_write_d = out_ep_data_put & ((out_max_used_q < MaxPktSizeByte - 1) & (out_ep_put_addr[1:0] == 2'b11));</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      out_max_used_q <= '0;</pre>
<pre>      wdata          <= '0;</pre>
<pre>      std_write_q    <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      out_max_used_q <= out_max_used_d;</pre>
<pre>      std_write_q    <= std_write_d;</pre>
<pre>      if (out_ep_data_put) begin</pre>
<pre>        unique case (out_ep_put_addr[1:0])</pre>
<pre>          0: begin</pre>
<pre>            wdata[7:0] <= out_ep_data;</pre>
<pre>          1: begin</pre>
<pre>            wdata[15:8] <= out_ep_data;</pre>
<pre>          2: begin</pre>
<pre>            wdata[23:16] <= out_ep_data;</pre>
<pre>          3: begin</pre>
<pre>            wdata[31:24] <= out_ep_data;</pre>
<pre>  assign mem_write_o = std_write_q |</pre>
<pre>                       (~out_max_used_q[PktW] & (out_max_used_q[1:0] != 2'b11) & out_ep_acked);</pre>
<pre>  assign mem_waddr = {av_rdata_i, out_max_used_q[PktW-1:2]};</pre>
<pre>  assign mem_wdata_o = wdata;</pre>
<pre>  assign mem_addr_o = mem_write_o ? mem_waddr : mem_raddr;</pre>
<pre>  assign mem_req_o = mem_read | mem_write_o;</pre>
<pre>  assign current_setup = out_ep_setup[out_ep_current];  // lint: out_ep_current range was checked</pre>
<pre>  logic [PktW:0] out_max_minus1;</pre>
<pre>  assign out_max_minus1 = out_max_used_q - 1;</pre>
<pre>  assign rx_wdata_o = {</pre>
<pre>      out_ep_current,</pre>
<pre>      current_setup,</pre>
<pre>      out_max_minus1,</pre>
<pre>      av_rdata_i</pre>
<pre>  assign rx_wvalid_o = out_ep_acked & ~all_out_blocked;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      av_rready_o <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      av_rready_o <= rx_wvalid_o;</pre>
<pre>  assign setup_blocked = out_ep_setup & ~rx_setup_i;</pre>
<pre>  assign out_blocked = ~out_ep_setup & ~rx_out_i;</pre>
<pre>  assign all_out_blocked = (~rx_wready_i) | (~av_rvalid_i);</pre>
<pre>  assign event_av_empty_o = out_ep_newpkt & (~av_rvalid_i);</pre>
<pre>  assign event_rx_full_o = out_ep_newpkt & (~rx_wready_i);</pre>
<pre>  assign out_ep_full = {NEndpoints{all_out_blocked}} | setup_blocked | out_blocked;</pre>
<pre>  assign out_ep_stall = rx_stall_i;</pre>
<pre>  assign setup_received_o = current_setup & rx_wvalid_o;</pre>
<pre>  logic in_ep_acked, in_ep_data_get, in_data_done, in_ep_newpkt, pkt_start_rd;</pre>
<pre>  logic [NEndpoints-1:0] in_ep_data_done;</pre>
<pre>  logic [PktW-1:0] in_ep_get_addr;</pre>
<pre>  logic [7:0]      in_ep_data;</pre>
<pre>  assign in_data_done = {1'b0, in_ep_get_addr} == in_size_i;</pre>
<pre>  always_comb begin</pre>
<pre>    in_ep_data_done = '0;</pre>
<pre>    in_ep_data_done[in_endpoint_o] = in_data_done;  // lint: in_endpoint_o range was checked</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      pkt_start_rd <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      pkt_start_rd <= in_ep_newpkt;</pre>
<pre>  assign mem_raddr = {in_buf_i,in_ep_get_addr[PktW-1:2]};</pre>
<pre>  assign mem_read = pkt_start_rd | (in_ep_data_get & (in_ep_get_addr[1:0] == 2'b0));</pre>
<pre>  assign in_ep_data = in_ep_get_addr[1] ?</pre>
<pre>                      (in_ep_get_addr[0] ? mem_rdata_i[31:24] : mem_rdata_i[23:16]) :</pre>
<pre>                      (in_ep_get_addr[0] ? mem_rdata_i[15:8]  : mem_rdata_i[7:0]);</pre>
<pre>  assign set_sent_o = in_ep_acked;</pre>
<pre>  logic [10:0]     frame_index_raw;</pre>
<pre>  usb_fs_nb_pe #(</pre>
<pre>    .NumOutEps      (NEndpoints),</pre>
<pre>    .NumInEps       (NEndpoints),</pre>
<pre>    .MaxPktSizeByte (MaxPktSizeByte)</pre>
<pre style="background-color: #FF0000;">  ) u_usb_fs_nb_pe (</pre>
<pre>    .clk_48mhz_i           (clk_48mhz_i),</pre>
<pre>    .rst_ni                (rst_ni),</pre>
<pre>    .link_reset_i          (link_reset),</pre>
<pre>    .cfg_eop_single_bit_i  (cfg_eop_single_bit_i),</pre>
<pre>    .tx_osc_test_mode_i    (tx_osc_test_mode_i),</pre>
<pre>    .data_toggle_clear_i   (data_toggle_clear_i),</pre>
<pre>    .usb_d_i               (usb_d_i),</pre>
<pre>    .usb_se0_i             (usb_se0_i),</pre>
<pre>    .usb_d_o               (usb_d_o),</pre>
<pre>    .usb_se0_o             (usb_se0_o),</pre>
<pre>    .usb_oe_o              (usb_oe_o),</pre>
<pre>    .dev_addr_i            (devaddr_i),</pre>
<pre>    .out_ep_current_o      (out_ep_current),</pre>
<pre>    .out_ep_newpkt_o       (out_ep_newpkt),</pre>
<pre>    .out_ep_data_put_o     (out_ep_data_put),</pre>
<pre>    .out_ep_put_addr_o     (out_ep_put_addr),</pre>
<pre>    .out_ep_data_o         (out_ep_data),</pre>
<pre>    .out_ep_acked_o        (out_ep_acked),</pre>
<pre>    .out_ep_rollback_o     (out_ep_rollback),</pre>
<pre>    .out_ep_setup_o        (out_ep_setup),</pre>
<pre>    .out_ep_full_i         (out_ep_full),</pre>
<pre>    .out_ep_stall_i        (out_ep_stall),</pre>
<pre>    .out_ep_iso_i          (ep_iso_i),</pre>
<pre>    .in_ep_current_o       (in_endpoint_o),</pre>
<pre>    .in_ep_rollback_o      (link_in_err_o),</pre>
<pre>    .in_ep_acked_o         (in_ep_acked),</pre>
<pre>    .in_ep_get_addr_o      (in_ep_get_addr),</pre>
<pre>    .in_ep_data_get_o      (in_ep_data_get),</pre>
<pre>    .in_ep_newpkt_o        (in_ep_newpkt),</pre>
<pre>    .in_ep_stall_i         (in_stall_i),</pre>
<pre>    .in_ep_has_data_i      (in_rdy_i),</pre>
<pre>    .in_ep_data_i          (in_ep_data),</pre>
<pre>    .in_ep_data_done_i     (in_ep_data_done),</pre>
<pre>    .in_ep_iso_i           (ep_iso_i),</pre>
<pre>    .rx_crc_err_o          (rx_crc_err_o),</pre>
<pre>    .rx_pid_err_o          (rx_pid_err_o),</pre>
<pre>    .rx_bitstuff_err_o     (rx_bitstuff_err_o),</pre>
<pre>    .sof_valid_o           (sof_valid),</pre>
<pre>    .frame_index_o         (frame_index_raw)</pre>
<pre>  logic [5:0]   ns_cnt;</pre>
<pre>  logic         us_tick;</pre>
<pre>  assign us_tick = (ns_cnt == 6'd48);</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      ns_cnt <= '0;</pre>
<pre>    end else begin</pre>
<pre>      if (us_tick) begin</pre>
<pre>        ns_cnt <= '0;</pre>
<pre>      end else begin</pre>
<pre>        ns_cnt <= ns_cnt + 1'b1;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      frame_o <= '0;</pre>
<pre>    end else begin</pre>
<pre>      if (sof_valid) begin</pre>
<pre>        frame_o <= frame_index_raw;</pre>
<pre>  usbdev_linkstate u_usbdev_linkstate (</pre>
<pre>    .clk_48mhz_i       (clk_48mhz_i),</pre>
<pre>    .rst_ni            (rst_ni),</pre>
<pre>    .us_tick_i         (us_tick),</pre>
<pre>    .usb_sense_i       (usb_sense_i),</pre>
<pre>    .usb_rx_d_i        (usb_d_i),</pre>
<pre>    .usb_rx_se0_i      (usb_se0_i),</pre>
<pre>    .sof_valid_i       (sof_valid),</pre>
<pre>    .link_disconnect_o (link_disconnect_o),</pre>
<pre>    .link_connect_o    (link_connect_o),</pre>
<pre>    .link_reset_o      (link_reset),</pre>
<pre>    .link_suspend_o    (link_suspend_o),</pre>
<pre>    .link_resume_o     (link_resume_o),</pre>
<pre>    .link_state_o      (link_state_o),</pre>
<pre>    .host_lost_o       (host_lost_o)</pre>
<h3>hw/ip/usb_fs_nb_pe/rtl/usb_fs_tx_mux.sv</h3>
<pre>  input  logic in_tx_pkt_start_i,</pre>
<pre>  input  logic [3:0] in_tx_pid_i,</pre>
<pre>  input  logic out_tx_pkt_start_i,</pre>
<pre>  input  logic [3:0] out_tx_pid_i,</pre>
<pre>  output logic tx_pkt_start_o,</pre>
<pre>  output logic [3:0] tx_pid_o</pre>
<pre>  assign tx_pkt_start_o = in_tx_pkt_start_i | out_tx_pkt_start_i;</pre>
<pre>  assign tx_pid_o       = out_tx_pkt_start_i ? out_tx_pid_i : in_tx_pid_i;</pre>
<h3>hw/ip/usb_fs_nb_pe/rtl/usb_consts_pkg.sv</h3>
<pre>package usb_consts_pkg;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    UsbPidTypeSpecial    = 2'b00,</pre>
<pre>    UsbPidTypeToken      = 2'b01,</pre>
<pre>    UsbPidTypeHandshake  = 2'b10,</pre>
<pre>    UsbPidTypeData       = 2'b11</pre>
<pre>  } usb_pid_type_e;</pre>
<pre>  typedef enum logic [3:0] {</pre>
<pre>    UsbPidOut   = 4'b0001,</pre>
<pre>    UsbPidIn    = 4'b1001,</pre>
<pre>    UsbPidSof   = 4'b0101,</pre>
<pre>    UsbPidSetup = 4'b1101,</pre>
<pre>    UsbPidData0 = 4'b0011,</pre>
<pre>    UsbPidData1 = 4'b1011,</pre>
<pre>    UsbPidData2 = 4'b0111, // Only valid for High Speed</pre>
<pre>    UsbPidMData = 4'b1111, // Only valid for High Speed</pre>
<pre>    UsbPidAck   = 4'b0010,</pre>
<pre>    UsbPidNak   = 4'b1010,</pre>
<pre>    UsbPidStall = 4'b1110,</pre>
<pre>    UsbPidNyet  = 4'b0110</pre>
<pre>  } usb_pid_e;</pre>
<pre>  typedef enum logic [7:0] {</pre>
<pre>    SetupGetStatus        = 8'd0,</pre>
<pre>    SetupClearFeature     = 8'd1,</pre>
<pre>    SetupSetFeature       = 8'd3,</pre>
<pre>    SetupSetAddress       = 8'd5,</pre>
<pre>    SetupGetDescriptor    = 8'd6,</pre>
<pre>    SetupSetDescriptor    = 8'd7,</pre>
<pre>    SetupGetConfiguration = 8'd8,</pre>
<pre>    SetupSetConfiguration = 8'd9,</pre>
<pre>    SetupGetInterface     = 8'd10,</pre>
<pre>    SetupSetInterface     = 8'd11,</pre>
<pre>    SetupSynchFrame       = 8'd12</pre>
<pre>  } usb_setup_request_e;</pre>
<pre>  typedef enum logic [7:0] {</pre>
<pre>    DscrTypeDevice        = 8'd1,</pre>
<pre>    DscrTypeConfiguration = 8'd2,</pre>
<pre>    DscrTypeString        = 8'd3,</pre>
<pre>    DscrTypeInterface     = 8'd4,</pre>
<pre>    DscrTypeEndpoint      = 8'd5,</pre>
<pre>    DscrTypeDevQual       = 8'd6,</pre>
<pre>    DscrTypeOthrSpd       = 8'd7,</pre>
<pre>    DscrTypeIntPwr        = 8'd8</pre>
<pre>  } usb_dscr_type_e;</pre>
<h3>hw/ip/usb_fs_nb_pe/rtl/usb_fs_nb_pe.sv</h3>
<pre>module usb_fs_nb_pe #(</pre>
<pre>  parameter int unsigned NumOutEps = 2,</pre>
<pre>  parameter int unsigned NumInEps = 2,</pre>
<pre>  parameter int unsigned MaxPktSizeByte = 32,</pre>
<pre>  parameter int unsigned PktW = $clog2(MaxPktSizeByte)</pre>
<pre>  input  logic                   clk_48mhz_i,</pre>
<pre>  input  logic                   rst_ni,        // Async. reset, active low</pre>
<pre>  input  logic                   link_reset_i,  // USB reset, sync to 48 MHz, active high</pre>
<pre>  input  logic [6:0]             dev_addr_i,</pre>
<pre>  input  logic                   cfg_eop_single_bit_i, // 1: detect a single SE0 bit as EOP</pre>
<pre>  input  logic                   tx_osc_test_mode_i, // Oscillator test mode (constantly output JK)</pre>
<pre>  input  logic [NumOutEps-1:0]   data_toggle_clear_i, // Clear the data toggles for an EP</pre>
<pre>  output logic [3:0]             out_ep_current_o, // Other signals address to this ep</pre>
<pre>  output logic                   out_ep_data_put_o, // put the data (put addr advances after)</pre>
<pre>  output logic [PktW - 1:0]      out_ep_put_addr_o, // Offset to put data (0..pktlen)</pre>
<pre>  output logic [7:0]             out_ep_data_o,</pre>
<pre>  output logic                   out_ep_newpkt_o,// New OUT pkt start (with in_ep_current_o update)</pre>
<pre>  output logic                   out_ep_acked_o, // good termination, device has acked</pre>
<pre>  output logic                   out_ep_rollback_o, // bad termination, discard data</pre>
<pre>  output logic [NumOutEps-1:0]   out_ep_setup_o,</pre>
<pre>  input  logic [NumOutEps-1:0]   out_ep_full_i, // Cannot accept data</pre>
<pre>  input  logic [NumOutEps-1:0]   out_ep_stall_i, // Stalled</pre>
<pre>  input  logic [NumOutEps-1:0]   out_ep_iso_i, // Configure endpoint in isochronous mode</pre>
<pre>  output logic [3:0]             in_ep_current_o, // Other signals addressed to this ep</pre>
<pre>  output logic                   in_ep_rollback_o, // Bad termination, rollback transaction</pre>
<pre>  output logic                   in_ep_acked_o, // good termination, transaction complete</pre>
<pre>  output logic [PktW - 1:0]      in_ep_get_addr_o, // Offset requested (0..pktlen)</pre>
<pre>  output logic                   in_ep_data_get_o, // Accept data (get_addr advances too)</pre>
<pre>  output logic                   in_ep_newpkt_o, // New IN pkt start (with in_ep_current_o update)</pre>
<pre>  input  logic [NumInEps-1:0]    in_ep_stall_i, // Endpoint in a stall state</pre>
<pre>  input  logic [NumInEps-1:0]    in_ep_has_data_i, // Endpoint has data to supply</pre>
<pre>  input  logic [7:0]             in_ep_data_i, // Data for current get_addr</pre>
<pre>  input  logic [NumInEps-1:0]    in_ep_data_done_i, // Set when out of data</pre>
<pre>  input  logic  [NumInEps-1:0]   in_ep_iso_i, // Configure endpoint in isochronous mode</pre>
<pre>  output logic                   sof_valid_o,</pre>
<pre>  output logic [10:0]            frame_index_o,</pre>
<pre>  output logic                   rx_crc_err_o,</pre>
<pre>  output logic                   rx_pid_err_o,</pre>
<pre>  output logic                   rx_bitstuff_err_o,</pre>
<pre>  input  logic                   usb_d_i,</pre>
<pre>  input  logic                   usb_se0_i,</pre>
<pre>  output logic                   usb_d_o,</pre>
<pre>  output logic                   usb_se0_o,</pre>
<pre>  output logic                   usb_oe_o</pre>
<pre>  logic bit_strobe;</pre>
<pre>  logic rx_pkt_start;</pre>
<pre>  logic rx_pkt_end;</pre>
<pre>  logic [3:0] rx_pid;</pre>
<pre>  logic [6:0] rx_addr;</pre>
<pre>  logic [3:0] rx_endp;</pre>
<pre>  logic [10:0] rx_frame_num;</pre>
<pre>  logic rx_data_put;</pre>
<pre>  logic [7:0] rx_data;</pre>
<pre>  logic rx_pkt_valid;</pre>
<pre>  logic in_tx_pkt_start;</pre>
<pre>  logic [3:0] in_tx_pid;</pre>
<pre>  logic out_tx_pkt_start;</pre>
<pre>  logic [3:0] out_tx_pid;</pre>
<pre>  logic tx_pkt_start;</pre>
<pre>  logic tx_pkt_end;</pre>
<pre>  logic [3:0] tx_pid;</pre>
<pre>  logic tx_data_avail;</pre>
<pre>  logic tx_data_get;</pre>
<pre>  logic [7:0] tx_data;</pre>
<pre>  logic usb_oe;</pre>
<pre>  assign sof_valid_o = rx_pkt_end & rx_pkt_valid & (usb_pid_e'(rx_pid) == UsbPidSof);</pre>
<pre>  assign frame_index_o = rx_frame_num;</pre>
<pre>  assign usb_oe_o = usb_oe;</pre>
<pre>  usb_fs_nb_in_pe #(</pre>
<pre>    .NumInEps           (NumInEps),</pre>
<pre>    .MaxInPktSizeByte   (MaxPktSizeByte)</pre>
<pre style="background-color: #FF0000;">  ) u_usb_fs_nb_in_pe (</pre>
<pre>    .clk_48mhz_i           (clk_48mhz_i),</pre>
<pre>    .rst_ni                (rst_ni),</pre>
<pre>    .link_reset_i          (link_reset_i),</pre>
<pre>    .dev_addr_i            (dev_addr_i),</pre>
<pre>    .in_ep_current_o       (in_ep_current_o),</pre>
<pre>    .in_ep_rollback_o      (in_ep_rollback_o),</pre>
<pre>    .in_ep_acked_o         (in_ep_acked_o),</pre>
<pre>    .in_ep_get_addr_o      (in_ep_get_addr_o),</pre>
<pre>    .in_ep_data_get_o      (in_ep_data_get_o),</pre>
<pre>    .in_ep_newpkt_o        (in_ep_newpkt_o),</pre>
<pre>    .in_ep_stall_i         (in_ep_stall_i),</pre>
<pre>    .in_ep_has_data_i      (in_ep_has_data_i),</pre>
<pre>    .in_ep_data_i          (in_ep_data_i),</pre>
<pre>    .in_ep_data_done_i     (in_ep_data_done_i),</pre>
<pre>    .in_ep_iso_i           (in_ep_iso_i),</pre>
<pre>    .data_toggle_clear_i   (data_toggle_clear_i),</pre>
<pre>    .rx_pkt_start_i        (rx_pkt_start),</pre>
<pre>    .rx_pkt_end_i          (rx_pkt_end),</pre>
<pre>    .rx_pkt_valid_i        (rx_pkt_valid),</pre>
<pre>    .rx_pid_i              (rx_pid),</pre>
<pre>    .rx_addr_i             (rx_addr),</pre>
<pre>    .rx_endp_i             (rx_endp),</pre>
<pre>    .tx_pkt_start_o        (in_tx_pkt_start),</pre>
<pre>    .tx_pkt_end_i          (tx_pkt_end),</pre>
<pre>    .tx_pid_o              (in_tx_pid),</pre>
<pre>    .tx_data_avail_o       (tx_data_avail),</pre>
<pre>    .tx_data_get_i         (tx_data_get),</pre>
<pre>    .tx_data_o             (tx_data)</pre>
<pre>  usb_fs_nb_out_pe #(</pre>
<pre>    .NumOutEps           (NumOutEps),</pre>
<pre>    .MaxOutPktSizeByte   (MaxPktSizeByte)</pre>
<pre style="background-color: #FF0000;">  ) u_usb_fs_nb_out_pe (</pre>
<pre>    .clk_48mhz_i            (clk_48mhz_i),</pre>
<pre>    .rst_ni                 (rst_ni),</pre>
<pre>    .link_reset_i           (link_reset_i),</pre>
<pre>    .dev_addr_i             (dev_addr_i),</pre>
<pre>    .out_ep_current_o       (out_ep_current_o),</pre>
<pre>    .out_ep_data_put_o      (out_ep_data_put_o),</pre>
<pre>    .out_ep_put_addr_o      (out_ep_put_addr_o),</pre>
<pre>    .out_ep_data_o          (out_ep_data_o),</pre>
<pre>    .out_ep_newpkt_o        (out_ep_newpkt_o),</pre>
<pre>    .out_ep_acked_o         (out_ep_acked_o),</pre>
<pre>    .out_ep_rollback_o      (out_ep_rollback_o),</pre>
<pre>    .out_ep_setup_o         (out_ep_setup_o),</pre>
<pre>    .out_ep_full_i          (out_ep_full_i),</pre>
<pre>    .out_ep_stall_i         (out_ep_stall_i),</pre>
<pre>    .out_ep_iso_i           (out_ep_iso_i),</pre>
<pre>    .data_toggle_clear_i    (data_toggle_clear_i),</pre>
<pre>    .rx_pkt_start_i         (rx_pkt_start),</pre>
<pre>    .rx_pkt_end_i           (rx_pkt_end),</pre>
<pre>    .rx_pkt_valid_i         (rx_pkt_valid),</pre>
<pre>    .rx_pid_i               (rx_pid),</pre>
<pre>    .rx_addr_i              (rx_addr),</pre>
<pre>    .rx_endp_i              (rx_endp),</pre>
<pre>    .rx_data_put_i          (rx_data_put),</pre>
<pre>    .rx_data_i              (rx_data),</pre>
<pre>    .tx_pkt_start_o         (out_tx_pkt_start),</pre>
<pre>    .tx_pkt_end_i           (tx_pkt_end),</pre>
<pre>    .tx_pid_o               (out_tx_pid)</pre>
<pre>  usb_fs_rx u_usb_fs_rx (</pre>
<pre>    .clk_i                  (clk_48mhz_i),</pre>
<pre>    .rst_ni                 (rst_ni),</pre>
<pre>    .link_reset_i           (link_reset_i),</pre>
<pre>    .cfg_eop_single_bit_i   (cfg_eop_single_bit_i),</pre>
<pre>    .usb_d_i                (usb_d_i),</pre>
<pre>    .usb_se0_i              (usb_se0_i),</pre>
<pre>    .tx_en_i                (usb_oe),</pre>
<pre>    .bit_strobe_o           (bit_strobe),</pre>
<pre>    .pkt_start_o            (rx_pkt_start),</pre>
<pre>    .pkt_end_o              (rx_pkt_end),</pre>
<pre>    .pid_o                  (rx_pid),</pre>
<pre>    .addr_o                 (rx_addr),</pre>
<pre>    .endp_o                 (rx_endp),</pre>
<pre>    .frame_num_o            (rx_frame_num),</pre>
<pre>    .rx_data_put_o          (rx_data_put),</pre>
<pre>    .rx_data_o              (rx_data),</pre>
<pre>    .valid_packet_o         (rx_pkt_valid),</pre>
<pre>    .crc_error_o            (rx_crc_err_o),</pre>
<pre>    .pid_error_o            (rx_pid_err_o),</pre>
<pre>    .bitstuff_error_o       (rx_bitstuff_err_o)</pre>
<pre>  usb_fs_tx_mux u_usb_fs_tx_mux (</pre>
<pre>    .in_tx_pkt_start_i  (in_tx_pkt_start),</pre>
<pre>    .in_tx_pid_i        (in_tx_pid),</pre>
<pre>    .out_tx_pkt_start_i (out_tx_pkt_start),</pre>
<pre>    .out_tx_pid_i       (out_tx_pid),</pre>
<pre>    .tx_pkt_start_o     (tx_pkt_start),</pre>
<pre>    .tx_pid_o           (tx_pid)</pre>
<pre>  usb_fs_tx u_usb_fs_tx (</pre>
<pre>    .clk_i                  (clk_48mhz_i),</pre>
<pre>    .rst_ni                 (rst_ni),</pre>
<pre>    .link_reset_i           (link_reset_i),</pre>
<pre>    .tx_osc_test_mode_i     (tx_osc_test_mode_i),</pre>
<pre>    .bit_strobe_i           (bit_strobe),</pre>
<pre>    .usb_d_o                (usb_d_o),</pre>
<pre>    .usb_se0_o              (usb_se0_o),</pre>
<pre>    .usb_oe_o               (usb_oe),</pre>
<pre>    .pkt_start_i            (tx_pkt_start),</pre>
<pre>    .pkt_end_o              (tx_pkt_end),</pre>
<pre>    .pid_i                  (tx_pid),</pre>
<pre>    .tx_data_avail_i        (tx_data_avail),</pre>
<pre>    .tx_data_get_o          (tx_data_get),</pre>
<pre>    .tx_data_i              (tx_data)</pre>
<h3>hw/ip/usb_fs_nb_pe/rtl/usb_fs_rx.sv</h3>
<pre>  input  logic clk_i,</pre>
<pre>  input  logic rst_ni,</pre>
<pre>  input  logic link_reset_i,</pre>
<pre>  input  logic cfg_eop_single_bit_i,</pre>
<pre>  input  logic usb_d_i,</pre>
<pre>  input  logic usb_se0_i,</pre>
<pre>  input  logic tx_en_i,</pre>
<pre>  output logic bit_strobe_o,</pre>
<pre>  output logic pkt_start_o,</pre>
<pre>  output logic pkt_end_o,</pre>
<pre>  output logic [3:0]  pid_o,</pre>
<pre>  output logic [6:0]  addr_o,</pre>
<pre>  output logic [3:0]  endp_o,</pre>
<pre>  output logic [10:0] frame_num_o,</pre>
<pre>  output logic rx_data_put_o,</pre>
<pre>  output logic [7:0] rx_data_o,</pre>
<pre>  output logic valid_packet_o,</pre>
<pre>  output logic crc_error_o,</pre>
<pre>  output logic pid_error_o,</pre>
<pre>  output logic bitstuff_error_o</pre>
<pre>  logic [6:0] bitstuff_history_q, bitstuff_history_d;</pre>
<pre>  logic       bitstuff_error;</pre>
<pre>  logic       bitstuff_error_q, bitstuff_error_d;</pre>
<pre>  logic [2:0] line_state_q, line_state_d;</pre>
<pre>  localparam logic [2:0]  DT = 3'b100;</pre>
<pre>  localparam logic [2:0]  DJ = 3'b010;</pre>
<pre>  localparam logic [2:0]  DK = 3'b001;</pre>
<pre>  localparam logic [2:0] SE0 = 3'b000;</pre>
<pre>  localparam logic [2:0] SE1 = 3'b011;</pre>
<pre>  logic [1:0] dpair;</pre>
<pre>  always_comb begin : proc_dpair_mute</pre>
<pre>    if (tx_en_i) begin</pre>
<pre>      dpair = DJ[1:0]; // J</pre>
<pre>    end else begin</pre>
<pre>      dpair = (usb_se0_i) ? 2'b00 : {usb_d_i, ~usb_d_i};</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_line_state_q</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      line_state_q <= SE0;</pre>
<pre>    end else begin</pre>
<pre>      if (link_reset_i) begin</pre>
<pre>        line_state_q <= SE0;</pre>
<pre>      end else begin</pre>
<pre>        line_state_q <= line_state_d;</pre>
<pre>  always_comb begin : proc_line_state_d</pre>
<pre>    line_state_d = line_state_q;</pre>
<pre>    if (line_state_q == DT) begin</pre>
<pre>      line_state_d = {1'b0, dpair};</pre>
<pre>    end else begin</pre>
<pre>      if (dpair != line_state_q[1:0]) begin</pre>
<pre>        line_state_d = DT;</pre>
<pre>  logic [1:0] bit_phase_q, bit_phase_d;</pre>
<pre>  logic line_state_valid;</pre>
<pre>  assign line_state_valid = (bit_phase_q == 2'd1);</pre>
<pre>  assign bit_strobe_o     = (bit_phase_q == 2'd2);</pre>
<pre>  assign bit_phase_d = (line_state_q == DT) ? 0 : bit_phase_q + 1;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bit_phase_q</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      bit_phase_q <= 0;</pre>
<pre>    end else begin</pre>
<pre>      if (link_reset_i) begin</pre>
<pre>        bit_phase_q <= 0;</pre>
<pre>      end else begin</pre>
<pre>        bit_phase_q <= bit_phase_d;</pre>
<pre>  logic [11:0] line_history_q, line_history_d;</pre>
<pre>  logic packet_valid_q, packet_valid_d;</pre>
<pre>  logic see_eop, packet_start, packet_end;</pre>
<pre>  assign packet_start = packet_valid_d & ~packet_valid_q;</pre>
<pre>  assign packet_end   = ~packet_valid_d & packet_valid_q;</pre>
<pre>  assign see_eop = (cfg_eop_single_bit_i && line_history_q[1:0] == 2'b00)</pre>
<pre>    || (line_history_q[3:0] == 4'b0000) || bitstuff_error_q;</pre>
<pre>  always_comb begin : proc_packet_valid_d</pre>
<pre>    if (line_state_valid) begin</pre>
<pre>      if (!packet_valid_q && line_history_q[11:0] == 12'b011001100101) begin</pre>
<pre>        packet_valid_d = 1;</pre>
<pre>      else if (packet_valid_q && see_eop) begin</pre>
<pre>        packet_valid_d = 0;</pre>
<pre>      end else begin</pre>
<pre>        packet_valid_d = packet_valid_q;</pre>
<pre>    end else begin</pre>
<pre>      packet_valid_d = packet_valid_q;</pre>
<pre>  assign line_history_d = line_state_valid ? {line_history_q[9:0], line_state_q[1:0]} : line_history_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_reg_pkt_line</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      packet_valid_q <= 0;</pre>
<pre>      line_history_q <= 12'b101010101010; // all K</pre>
<pre>    end else begin</pre>
<pre>      if (link_reset_i) begin</pre>
<pre>        packet_valid_q <= 0;</pre>
<pre>        line_history_q <= 12'b101010101010; // all K</pre>
<pre>      end else begin</pre>
<pre>        packet_valid_q <= packet_valid_d;</pre>
<pre>        line_history_q <= line_history_d;</pre>
<pre>  logic dvalid_raw;</pre>
<pre>  logic din;</pre>
<pre>  always_comb begin</pre>
<pre>    unique case (line_history_q[3:0])</pre>
<pre>      4'b0101 : din = 1;</pre>
<pre>      4'b0110 : din = 0;</pre>
<pre>      4'b1001 : din = 0;</pre>
<pre>      4'b1010 : din = 1;</pre>
<pre>      default : din = 0;</pre>
<pre>    if (packet_valid_q && line_state_valid) begin</pre>
<pre>      unique case (line_history_q[3:0])</pre>
<pre>        4'b0101 : dvalid_raw = 1;</pre>
<pre>        4'b0110 : dvalid_raw = 1;</pre>
<pre>        4'b1001 : dvalid_raw = 1;</pre>
<pre>        4'b1010 : dvalid_raw = 1;</pre>
<pre>        default : dvalid_raw = 0;</pre>
<pre>    end else begin</pre>
<pre>      dvalid_raw = 0;</pre>
<pre>  always_comb begin : proc_bitstuff_history_d</pre>
<pre>    if (packet_end) begin</pre>
<pre>      bitstuff_history_d = '0;</pre>
<pre>    end else if (dvalid_raw) begin</pre>
<pre>      bitstuff_history_d = {bitstuff_history_q[5:0], din};</pre>
<pre>    end else begin</pre>
<pre>      bitstuff_history_d = bitstuff_history_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_history_q</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      bitstuff_history_q <= 0;</pre>
<pre>    end else begin</pre>
<pre>      if (link_reset_i) begin</pre>
<pre>        bitstuff_history_q <= 0;</pre>
<pre>      end else begin</pre>
<pre>        bitstuff_history_q <= bitstuff_history_d;</pre>
<pre>  logic dvalid;</pre>
<pre>  assign dvalid = dvalid_raw && !(bitstuff_history_q[5:0] == 6'b111111);</pre>
<pre>  assign bitstuff_error = bitstuff_history_q == 7'b1111111;</pre>
<pre>  always_comb begin : proc_bistuff_error_d</pre>
<pre>    bitstuff_error_d = bitstuff_error_q;</pre>
<pre>    if (packet_start) begin</pre>
<pre>      bitstuff_error_d = 0;</pre>
<pre>    end else if (bitstuff_error && dvalid_raw) begin</pre>
<pre>      bitstuff_error_d = 1;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_error_q</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      bitstuff_error_q <= 0;</pre>
<pre>    end else begin</pre>
<pre>      bitstuff_error_q <= bitstuff_error_d;</pre>
<pre>  assign bitstuff_error_o = bitstuff_error_q && packet_end;</pre>
<pre>  logic [8:0] full_pid_q, full_pid_d;</pre>
<pre>  logic pid_valid, pid_complete;</pre>
<pre>  assign pid_valid    = full_pid_q[4:1] == ~full_pid_q[8:5];</pre>
<pre>  assign pid_complete = full_pid_q[0];</pre>
<pre>  always_comb begin : proc_full_pid_d</pre>
<pre>    if (dvalid && !pid_complete) begin</pre>
<pre>      full_pid_d = {din, full_pid_q[8:1]};</pre>
<pre>    end else if (packet_start) begin</pre>
<pre>      full_pid_d = 9'b100000000;</pre>
<pre>    end else begin</pre>
<pre>      full_pid_d = full_pid_q;</pre>
<pre>  logic [4:0] crc5_q, crc5_d;</pre>
<pre>  logic crc5_valid, crc5_invert;</pre>
<pre>  assign crc5_valid  = crc5_q == 5'b01100;</pre>
<pre>  assign crc5_invert = din ^ crc5_q[4];</pre>
<pre>  always_comb begin</pre>
<pre>    crc5_d = crc5_q; // default value</pre>
<pre>    if (packet_start) begin</pre>
<pre>      crc5_d = 5'b11111;</pre>
<pre>    if (dvalid && pid_complete) begin</pre>
<pre>      crc5_d = {crc5_q[3:0], 1'b0} ^ ({5{crc5_invert}} & 5'b00101);</pre>
<pre>  logic [15:0] crc16_q, crc16_d;</pre>
<pre>  logic crc16_valid, crc16_invert;</pre>
<pre>  assign crc16_valid  = crc16_q == 16'b1000000000001101;</pre>
<pre>  assign crc16_invert = din ^ crc16_q[15];</pre>
<pre>  always_comb begin</pre>
<pre>    crc16_d = crc16_q; // default value</pre>
<pre>    if (packet_start) begin</pre>
<pre>      crc16_d = 16'b1111111111111111;</pre>
<pre>    if (dvalid && pid_complete) begin</pre>
<pre>      crc16_d = {crc16_q[14:0], 1'b0} ^ ({16{crc16_invert}} & 16'b1000000000000101);</pre>
<pre>  logic pkt_is_token, pkt_is_data, pkt_is_handshake;</pre>
<pre>  assign pkt_is_token     = full_pid_q[2:1] == 2'b01;</pre>
<pre>  assign pkt_is_data      = full_pid_q[2:1] == 2'b11;</pre>
<pre>  assign pkt_is_handshake = full_pid_q[2:1] == 2'b10;</pre>
<pre>  assign valid_packet_o = pid_valid && !bitstuff_error_q &&</pre>
<pre>    ((pkt_is_handshake) ||</pre>
<pre>    (pkt_is_data && crc16_valid) ||</pre>
<pre>    (pkt_is_token && crc5_valid)</pre>
<pre>  assign crc_error_o = ((pkt_is_data && !crc16_valid) ||</pre>
<pre>    (pkt_is_token && !crc5_valid)) && packet_end;</pre>
<pre>  assign pid_error_o = !pid_valid && packet_end;</pre>
<pre>  logic [11:0] token_payload_q, token_payload_d;</pre>
<pre>  logic token_payload_done;</pre>
<pre>  assign token_payload_done = token_payload_q[0];</pre>
<pre>  logic [6:0] addr_q, addr_d;</pre>
<pre>  logic [3:0] endp_q, endp_d;</pre>
<pre>  logic [10:0] frame_num_q, frame_num_d;</pre>
<pre>  always_comb begin</pre>
<pre>    token_payload_d = token_payload_q; // default</pre>
<pre>    if (packet_start) begin</pre>
<pre>      token_payload_d = 12'b100000000000;</pre>
<pre>    if (dvalid && pid_complete && pkt_is_token && !token_payload_done) begin</pre>
<pre>      token_payload_d = {din, token_payload_q[11:1]};</pre>
<pre>  always_comb begin</pre>
<pre>    addr_d      = addr_q;</pre>
<pre>    endp_d      = endp_q;</pre>
<pre>    frame_num_d = frame_num_q;</pre>
<pre>    if (token_payload_done && pkt_is_token) begin</pre>
<pre>      addr_d      = token_payload_q[7:1];</pre>
<pre>      endp_d      = token_payload_q[11:8];</pre>
<pre>      frame_num_d = token_payload_q[11:1];</pre>
<pre>  assign addr_o      = addr_q;</pre>
<pre>  assign endp_o      = endp_q;</pre>
<pre>  assign frame_num_o = frame_num_q;</pre>
<pre>  assign pid_o       = full_pid_q[4:1];</pre>
<pre>  assign pkt_start_o = packet_start;</pre>
<pre>  assign pkt_end_o   = packet_end;</pre>
<pre>  logic [8:0] rx_data_buffer_q, rx_data_buffer_d;</pre>
<pre>  logic rx_data_buffer_full;</pre>
<pre>  assign rx_data_buffer_full = rx_data_buffer_q[0];</pre>
<pre>  assign rx_data_put_o       = rx_data_buffer_full;</pre>
<pre>  assign rx_data_o           = rx_data_buffer_q[8:1];</pre>
<pre>  always_comb begin</pre>
<pre>    rx_data_buffer_d = rx_data_buffer_q; // default</pre>
<pre>    if (packet_start || rx_data_buffer_full) begin</pre>
<pre>      rx_data_buffer_d = 9'b100000000;</pre>
<pre>    if (dvalid && pid_complete && pkt_is_data) begin</pre>
<pre>      rx_data_buffer_d = {din, rx_data_buffer_q[8:1]};</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_gp_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      full_pid_q          <= 0;</pre>
<pre>      crc16_q             <= 0;</pre>
<pre>      crc5_q              <= 0;</pre>
<pre>      token_payload_q     <= 0;</pre>
<pre>      addr_q              <= 0;</pre>
<pre>      endp_q              <= 0;</pre>
<pre>      frame_num_q         <= 0;</pre>
<pre>      rx_data_buffer_q    <= 0;</pre>
<pre>    end else begin</pre>
<pre>      if (link_reset_i) begin</pre>
<pre>        full_pid_q          <= 0;</pre>
<pre>        crc16_q             <= 0;</pre>
<pre>        crc5_q              <= 0;</pre>
<pre>        token_payload_q     <= 0;</pre>
<pre>        addr_q              <= 0;</pre>
<pre>        endp_q              <= 0;</pre>
<pre>        frame_num_q         <= 0;</pre>
<pre>        rx_data_buffer_q    <= 0;</pre>
<pre>      end else begin</pre>
<pre>        full_pid_q          <= full_pid_d;</pre>
<pre>        crc16_q             <= crc16_d;</pre>
<pre>        crc5_q              <= crc5_d;</pre>
<pre>        token_payload_q     <= token_payload_d;</pre>
<pre>        addr_q              <= addr_d;</pre>
<pre>        endp_q              <= endp_d;</pre>
<pre>        frame_num_q         <= frame_num_d;</pre>
<pre>        rx_data_buffer_q    <= rx_data_buffer_d;</pre>
<h3>hw/ip/usb_fs_nb_pe/rtl/usb_fs_nb_out_pe.sv</h3>
<pre>module usb_fs_nb_out_pe #(</pre>
<pre>  parameter int unsigned NumOutEps = 1,</pre>
<pre>  parameter int unsigned MaxOutPktSizeByte = 32,</pre>
<pre>  parameter int unsigned PktW = $clog2(MaxOutPktSizeByte),</pre>
<pre>  parameter int unsigned OutEpW = $clog2(NumOutEps)</pre>
<pre>  input  logic                   clk_48mhz_i,</pre>
<pre>  input  logic                   rst_ni,</pre>
<pre>  input  logic                   link_reset_i,</pre>
<pre>  input  logic [6:0]             dev_addr_i,</pre>
<pre>  output logic [3:0]             out_ep_current_o, // Other signals address to this ep, this signal will be stable for several cycles</pre>
<pre>  output logic                   out_ep_data_put_o, // put the data (put addr advances after)</pre>
<pre>  output logic [PktW - 1:0]      out_ep_put_addr_o, // Offset to put data (0..pktlen)</pre>
<pre>  output logic [7:0]             out_ep_data_o,</pre>
<pre>  output logic                   out_ep_newpkt_o, // new packed, current was set</pre>
<pre>  output logic                   out_ep_acked_o, // good termination, device has acked</pre>
<pre>  output logic                   out_ep_rollback_o, // bad termination, discard data</pre>
<pre>  output logic [NumOutEps-1:0]   out_ep_setup_o,</pre>
<pre>  input  logic [NumOutEps-1:0]   out_ep_full_i, // Cannot accept data</pre>
<pre>  input  logic [NumOutEps-1:0]   out_ep_stall_i, // Stalled</pre>
<pre>  input  logic [NumOutEps-1:0]   out_ep_iso_i, // Configure endpoint in isochronous mode</pre>
<pre>  input logic  [NumOutEps-1:0]   data_toggle_clear_i, // Clear the data toggles for an EP</pre>
<pre>  input  logic                 rx_pkt_start_i,</pre>
<pre>  input  logic                 rx_pkt_end_i,</pre>
<pre>  input  logic                 rx_pkt_valid_i,</pre>
<pre>  input  logic [3:0]           rx_pid_i,</pre>
<pre>  input  logic [6:0]           rx_addr_i,</pre>
<pre>  input  logic [3:0]           rx_endp_i,</pre>
<pre>  input  logic                 rx_data_put_i,</pre>
<pre>  input  logic [7:0]           rx_data_i,</pre>
<pre>  output logic                 tx_pkt_start_o,</pre>
<pre>  input  logic                 tx_pkt_end_i,</pre>
<pre>  output logic [3:0]           tx_pid_o</pre>
<pre>  logic                      unused_1;</pre>
<pre>  assign unused_1 = tx_pkt_end_i;</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    StIdle,</pre>
<pre>    StRcvdOut,</pre>
<pre>    StRcvdDataStart,</pre>
<pre>    StRcvdDataEnd,</pre>
<pre>    StRcvdIsoDataEnd</pre>
<pre>  } state_out_e;</pre>
<pre>  state_out_e  out_xfr_state;</pre>
<pre>  state_out_e  out_xfr_state_next;</pre>
<pre>  logic out_xfr_start;</pre>
<pre>  logic new_pkt_end;</pre>
<pre>  logic rollback_data;</pre>
<pre>  logic nak_out_transfer;</pre>
<pre>  logic [NumOutEps - 1:0] data_toggle_q, data_toggle_d;</pre>
<pre>  logic [OutEpW - 1 : 0]    out_ep_index;</pre>
<pre>  assign out_ep_index = out_ep_current_o[0 +: OutEpW];</pre>
<pre>  logic token_received, out_token_received, setup_token_received;</pre>
<pre>  logic invalid_packet_received, data_packet_received, non_data_packet_received;</pre>
<pre>  logic bad_data_toggle;</pre>
<pre>  logic current_xfer_setup_q;</pre>
<pre>  usb_pid_type_e rx_pid_type;</pre>
<pre>  usb_pid_e      rx_pid;</pre>
<pre>  assign rx_pid_type = usb_pid_type_e'(rx_pid_i[1:0]);</pre>
<pre>  assign rx_pid      = usb_pid_e'(rx_pid_i);</pre>
<pre>  assign token_received =</pre>
<pre>    rx_pkt_end_i &&</pre>
<pre>    rx_pkt_valid_i &&</pre>
<pre>    rx_pid_type == UsbPidTypeToken &&</pre>
<pre>    rx_addr_i == dev_addr_i &&</pre>
<pre>    rx_endp_i < NumOutEps;</pre>
<pre>  assign out_token_received =</pre>
<pre>    token_received &&</pre>
<pre>    rx_pid == UsbPidOut;</pre>
<pre>  assign setup_token_received =</pre>
<pre>    token_received &&</pre>
<pre>    rx_pid == UsbPidSetup;</pre>
<pre>  assign invalid_packet_received =</pre>
<pre>    rx_pkt_end_i &&</pre>
<pre>    !rx_pkt_valid_i;</pre>
<pre>  assign data_packet_received =</pre>
<pre>    rx_pkt_end_i &&</pre>
<pre>    rx_pkt_valid_i &&</pre>
<pre>    ((rx_pid == UsbPidData0) || (rx_pid == UsbPidData1));</pre>
<pre>  assign non_data_packet_received =</pre>
<pre>    rx_pkt_end_i &&</pre>
<pre>    rx_pkt_valid_i &&</pre>
<pre>    !((rx_pid == UsbPidData0) || (rx_pid == UsbPidData1));</pre>
<pre>  assign bad_data_toggle =</pre>
<pre>    data_packet_received &&</pre>
<pre>    rx_pid_i[3] != data_toggle_q[rx_endp_i[0 +: OutEpW]]; // lint: rx_endp_i range was checked</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      out_ep_setup_o <= '0;</pre>
<pre>    end else begin</pre>
<pre>      if (setup_token_received) begin</pre>
<pre>        out_ep_setup_o[rx_endp_i[0 +: OutEpW]] <= 1; // lint: rx_endp_i range was checked</pre>
<pre>      end else if (out_token_received) begin</pre>
<pre>        out_ep_setup_o[rx_endp_i[0 +: OutEpW]] <= 0; // lint: rx_endp_i range was checked</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      out_ep_data_o <= 0;</pre>
<pre>    end else begin</pre>
<pre>      if (rx_data_put_i) begin</pre>
<pre>        out_ep_data_o <= rx_data_i;</pre>
<pre>  always_comb begin</pre>
<pre>    out_ep_acked_o = 1'b0;</pre>
<pre>    out_xfr_start = 1'b0;</pre>
<pre>    out_xfr_state_next = out_xfr_state;</pre>
<pre>    tx_pkt_start_o = 1'b0;</pre>
<pre>    tx_pid_o = 4'b0000;</pre>
<pre>    new_pkt_end = 1'b0;</pre>
<pre>    rollback_data = 1'b0;</pre>
<pre>    unique case (out_xfr_state)</pre>
<pre>      StIdle: begin</pre>
<pre>        if (out_token_received || setup_token_received) begin</pre>
<pre>          out_xfr_state_next = StRcvdOut;</pre>
<pre>          out_xfr_start = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          out_xfr_state_next = StIdle;</pre>
<pre>      StRcvdOut: begin</pre>
<pre>        if (rx_pkt_start_i) begin</pre>
<pre>          out_xfr_state_next = StRcvdDataStart;</pre>
<pre>        end else begin</pre>
<pre>          out_xfr_state_next = StRcvdOut;</pre>
<pre>      StRcvdDataStart: begin</pre>
<pre>        if (out_ep_iso_i[out_ep_index] && data_packet_received) begin</pre>
<pre>          out_xfr_state_next = StRcvdIsoDataEnd;</pre>
<pre>        end else if (bad_data_toggle) begin</pre>
<pre>          out_xfr_state_next = StIdle;</pre>
<pre>          rollback_data = 1'b1;</pre>
<pre>          tx_pkt_start_o = 1'b1;</pre>
<pre>          tx_pid_o = {UsbPidAck}; // ACK by spec because this is most likely previous ACK was lost</pre>
<pre>        end else if (invalid_packet_received || non_data_packet_received) begin</pre>
<pre>          out_xfr_state_next = StIdle;</pre>
<pre>          rollback_data = 1'b1;</pre>
<pre>        end else if (data_packet_received) begin</pre>
<pre>          out_xfr_state_next = StRcvdDataEnd;</pre>
<pre>        end else begin</pre>
<pre>          out_xfr_state_next = StRcvdDataStart;</pre>
<pre>      StRcvdDataEnd: begin</pre>
<pre>        out_xfr_state_next = StIdle;</pre>
<pre>        tx_pkt_start_o = 1'b1;</pre>
<pre>        if (out_ep_stall_i[out_ep_index] && !current_xfer_setup_q) begin // lint: out_ep_index range was checked</pre>
<pre>          tx_pid_o = {UsbPidStall}; // STALL</pre>
<pre>        end else if (nak_out_transfer) begin</pre>
<pre>          tx_pid_o = {UsbPidNak}; // NAK -- the endpoint could not accept the data at the moment</pre>
<pre>          rollback_data = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          tx_pid_o = {UsbPidAck}; // ACK</pre>
<pre>          new_pkt_end = 1'b1;</pre>
<pre>          out_ep_acked_o = 1'b1;</pre>
<pre>      StRcvdIsoDataEnd: begin</pre>
<pre>        out_xfr_state_next = StIdle;</pre>
<pre>        if (out_ep_stall_i[out_ep_index] && !current_xfer_setup_q) begin</pre>
<pre>          tx_pkt_start_o = 1'b1;</pre>
<pre>          tx_pid_o       = {UsbPidStall}; // STALL</pre>
<pre>        end else if (nak_out_transfer) begin</pre>
<pre>          rollback_data = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          new_pkt_end    = 1'b1;</pre>
<pre>          out_ep_acked_o = 1'b1;</pre>
<pre>      default: out_xfr_state_next = StIdle;</pre>
<pre>  assign out_ep_rollback_o = rollback_data;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      out_xfr_state <= StIdle;</pre>
<pre>    end else begin</pre>
<pre>      out_xfr_state <= link_reset_i ? StIdle : out_xfr_state_next;</pre>
<pre>  always_comb begin : proc_data_toggle_d</pre>
<pre>    data_toggle_d = data_toggle_q;</pre>
<pre>    if (setup_token_received) begin</pre>
<pre>      data_toggle_d[rx_endp_i[0 +: OutEpW]] = 1'b0; // lint: rx_endp_i range was checked</pre>
<pre>    end else if (new_pkt_end) begin</pre>
<pre>      data_toggle_d[out_ep_index] = ~data_toggle_q[out_ep_index]; // lint: range was checked</pre>
<pre>    data_toggle_d = data_toggle_d & ~data_toggle_clear_i;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      data_toggle_q <= '0; // All endpoints</pre>
<pre>    end else if (link_reset_i) begin</pre>
<pre>      data_toggle_q <= '0; // All endpoints</pre>
<pre>    end else begin</pre>
<pre>      data_toggle_q <= data_toggle_d;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      out_ep_newpkt_o       <= 1'b0;</pre>
<pre>      out_ep_current_o      <= '0;</pre>
<pre>      current_xfer_setup_q  <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      if (out_xfr_start) begin</pre>
<pre>        out_ep_newpkt_o      <= 1'b1;</pre>
<pre>        out_ep_current_o     <= rx_endp_i;</pre>
<pre>        current_xfer_setup_q <= setup_token_received;</pre>
<pre>      end else begin</pre>
<pre>        out_ep_newpkt_o <= 1'b0;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      out_ep_data_put_o <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      out_ep_data_put_o <= ((out_xfr_state == StRcvdDataStart) && rx_data_put_i);</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      nak_out_transfer <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      if ((out_xfr_state == StIdle) || (out_xfr_state == StRcvdOut)) begin</pre>
<pre>        nak_out_transfer <= 1'b0;</pre>
<pre>      end else if (out_ep_data_put_o && out_ep_full_i[out_ep_index]) begin // lint: range checked</pre>
<pre>        nak_out_transfer <= 1'b1;</pre>
<pre>  logic increment_addr;</pre>
<pre>  assign increment_addr = !nak_out_transfer && (~&out_ep_put_addr_o) && out_ep_data_put_o;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      out_ep_put_addr_o <= '0;</pre>
<pre>    end else begin</pre>
<pre>      if (out_xfr_state == StRcvdOut) begin</pre>
<pre>        out_ep_put_addr_o <= '0;</pre>
<pre>      end else if ((out_xfr_state == StRcvdDataStart) && increment_addr) begin</pre>
<pre>        out_ep_put_addr_o <= out_ep_put_addr_o + 1;</pre>
<h3>hw/ip/usb_fs_nb_pe/rtl/usb_fs_nb_in_pe.sv</h3>
<pre>module usb_fs_nb_in_pe #(</pre>
<pre>  parameter logic [4:0] NumInEps = 11,</pre>
<pre>  parameter int unsigned MaxInPktSizeByte = 32,</pre>
<pre>  parameter int unsigned PktW = $clog2(MaxInPktSizeByte),</pre>
<pre>  parameter int unsigned InEpW = $clog2(NumInEps)</pre>
<pre>  input  logic               clk_48mhz_i,</pre>
<pre>  input  logic               rst_ni,</pre>
<pre>  input  logic               link_reset_i,</pre>
<pre>  input  logic [6:0]         dev_addr_i,</pre>
<pre>  output logic [3:0]            in_ep_current_o, // Other signals addressed to this ep</pre>
<pre>  output logic                  in_ep_rollback_o, // Bad termination, rollback transaction</pre>
<pre>  output logic                  in_ep_acked_o, // good termination, transaction complete</pre>
<pre>  output logic [PktW - 1:0]     in_ep_get_addr_o, // Offset requested (0..pktlen)</pre>
<pre>  output logic                  in_ep_data_get_o, // Accept data (get_addr advances too)</pre>
<pre>  output logic                  in_ep_newpkt_o, // New IN packet starting (with in_ep_current_o update)</pre>
<pre>  input  logic [NumInEps-1:0]   in_ep_stall_i, // Endpoint in a stall state</pre>
<pre>  input  logic [NumInEps-1:0]   in_ep_has_data_i, // Endpoint has data to supply</pre>
<pre>  input  logic [7:0]            in_ep_data_i, // Data for current get_addr</pre>
<pre>  input  logic [NumInEps-1:0]   in_ep_data_done_i, // Set when out of data</pre>
<pre>  input  logic [NumInEps-1:0]   in_ep_iso_i, // Configure endpoint in isochronous mode</pre>
<pre>  input  logic [NumInEps-1:0]   data_toggle_clear_i, // Clear the data toggles for an EP</pre>
<pre>  input  logic              rx_pkt_start_i,</pre>
<pre>  input  logic              rx_pkt_end_i,</pre>
<pre>  input  logic              rx_pkt_valid_i,</pre>
<pre>  input  logic [3:0]        rx_pid_i,</pre>
<pre>  input  logic [6:0]        rx_addr_i,</pre>
<pre>  input  logic [3:0]        rx_endp_i,</pre>
<pre>  output logic              tx_pkt_start_o,</pre>
<pre>  input  logic              tx_pkt_end_i,</pre>
<pre>  output logic [3:0]        tx_pid_o,</pre>
<pre>  output logic              tx_data_avail_o,</pre>
<pre>  input  logic              tx_data_get_i,</pre>
<pre>  output logic [7:0]        tx_data_o</pre>
<pre>  logic                      unused_1, unused_2;</pre>
<pre>  assign unused_1 = tx_pkt_end_i;</pre>
<pre>  assign unused_2 = rx_pkt_start_i;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    StIdle,</pre>
<pre>    StRcvdIn,</pre>
<pre>    StSendData,</pre>
<pre>    StWaitAck</pre>
<pre>  } state_in_e;</pre>
<pre>  state_in_e  in_xfr_state;</pre>
<pre>  state_in_e  in_xfr_state_next;</pre>
<pre>  logic in_xfr_end;</pre>
<pre>  assign in_ep_acked_o = in_xfr_end;</pre>
<pre>  logic [NumInEps - 1:0] data_toggle_q, data_toggle_d;</pre>
<pre>  logic                    token_received, setup_token_received, in_token_received, ack_received;</pre>
<pre>  logic                    more_data_to_send;</pre>
<pre>  logic [InEpW - 1 : 0]    in_ep_index;</pre>
<pre>  assign in_ep_index = in_ep_current_o[0 +: InEpW];</pre>
<pre>  usb_pid_type_e rx_pid_type;</pre>
<pre>  usb_pid_e      rx_pid;</pre>
<pre>  assign rx_pid_type = usb_pid_type_e'(rx_pid_i[1:0]);</pre>
<pre>  assign rx_pid      = usb_pid_e'(rx_pid_i);</pre>
<pre>  assign token_received =</pre>
<pre>    rx_pkt_end_i &&</pre>
<pre>    rx_pkt_valid_i &&</pre>
<pre>    rx_pid_type == UsbPidTypeToken &&</pre>
<pre>    rx_addr_i == dev_addr_i &&</pre>
<pre>    {1'b0, rx_endp_i} < NumInEps;</pre>
<pre>  assign setup_token_received =</pre>
<pre>    token_received &&</pre>
<pre>    rx_pid == UsbPidSetup;</pre>
<pre>  assign in_token_received =</pre>
<pre>    token_received &&</pre>
<pre>    rx_pid == UsbPidIn;</pre>
<pre>  assign ack_received =</pre>
<pre>    rx_pkt_end_i &&</pre>
<pre>    rx_pkt_valid_i &&</pre>
<pre>    rx_pid == UsbPidAck;</pre>
<pre>  assign more_data_to_send = in_ep_has_data_i[in_ep_index] & ~in_ep_data_done_i[in_ep_index];  // lint: in_ep_index range was checked</pre>
<pre>  assign tx_data_avail_o = logic'(in_xfr_state == StSendData) & more_data_to_send;</pre>
<pre>  logic rollback_in_xfr;</pre>
<pre>  always_comb begin</pre>
<pre>    in_xfr_state_next = in_xfr_state;</pre>
<pre>    in_xfr_end = 1'b0;</pre>
<pre>    tx_pkt_start_o = 1'b0;</pre>
<pre>    tx_pid_o = 4'b0000;</pre>
<pre>    rollback_in_xfr = 1'b0;</pre>
<pre>    unique case (in_xfr_state)</pre>
<pre>      StIdle: begin</pre>
<pre>        if (in_token_received) begin</pre>
<pre>          in_xfr_state_next = StRcvdIn;</pre>
<pre>        end else begin</pre>
<pre>          in_xfr_state_next = StIdle;</pre>
<pre>      StRcvdIn: begin</pre>
<pre>        tx_pkt_start_o = 1'b1; // Need to transmit NACK/STALL or DATA</pre>
<pre>        if (in_ep_stall_i[in_ep_index]) begin  // lint: in_ep_index range was checked</pre>
<pre>          in_xfr_state_next = StIdle;</pre>
<pre>          tx_pid_o = {UsbPidStall}; // STALL</pre>
<pre>        end else if (in_ep_iso_i[in_ep_index]) begin</pre>
<pre>          in_xfr_state_next = StSendData;</pre>
<pre>          tx_pid_o = {data_toggle_q[in_ep_index], 1'b0, {UsbPidTypeData}}; // DATA0/1 lint: checked</pre>
<pre>        end else if (in_ep_has_data_i[in_ep_index]) begin  // lint: in_ep_index range was checked</pre>
<pre>          in_xfr_state_next = StSendData;</pre>
<pre>          tx_pid_o = {data_toggle_q[in_ep_index], 1'b0, {UsbPidTypeData}}; // DATA0/1 lint: checked</pre>
<pre>        end else begin</pre>
<pre>          in_xfr_state_next = StIdle;</pre>
<pre>          tx_pid_o = {UsbPidNak}; // NAK</pre>
<pre>      StSendData: begin</pre>
<pre>        if ((!more_data_to_send) || ((&in_ep_get_addr_o) && tx_data_get_i)) begin</pre>
<pre>          if (in_ep_iso_i[in_ep_index]) begin</pre>
<pre>            in_xfr_state_next = StIdle; // no ACK for ISO EPs</pre>
<pre>          end else begin</pre>
<pre>            in_xfr_state_next = StWaitAck;</pre>
<pre>        end else begin</pre>
<pre>          in_xfr_state_next = StSendData;</pre>
<pre>      StWaitAck: begin</pre>
<pre>        if (ack_received) begin</pre>
<pre>          in_xfr_state_next = StIdle;</pre>
<pre>          in_xfr_end = 1'b1;</pre>
<pre>        end else if (in_token_received) begin</pre>
<pre>          in_xfr_state_next = StRcvdIn;</pre>
<pre>          rollback_in_xfr = 1'b1;</pre>
<pre>        end else if (rx_pkt_end_i) begin</pre>
<pre>          in_xfr_state_next = StIdle;</pre>
<pre>          rollback_in_xfr = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          in_xfr_state_next = StWaitAck;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      tx_data_o <= '0;</pre>
<pre>    end else begin</pre>
<pre>      tx_data_o <= in_ep_data_i;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      in_xfr_state <= StIdle;</pre>
<pre>      in_ep_rollback_o <= 1'b0;</pre>
<pre>    end else if (link_reset_i) begin</pre>
<pre>      in_xfr_state <= StIdle;</pre>
<pre>      in_ep_rollback_o <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      in_xfr_state <= in_xfr_state_next;</pre>
<pre>      in_ep_rollback_o <= rollback_in_xfr;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      in_ep_get_addr_o <= '0;</pre>
<pre>    end else begin</pre>
<pre>      if (in_xfr_state == StIdle) begin</pre>
<pre>        in_ep_get_addr_o <= '0;</pre>
<pre>      end else if ((in_xfr_state == StSendData) && tx_data_get_i) begin</pre>
<pre>        in_ep_get_addr_o <= in_ep_get_addr_o + 1'b1;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      in_ep_newpkt_o <= 1'b0;</pre>
<pre>      in_ep_current_o <= '0;</pre>
<pre>    end else begin</pre>
<pre>      if (in_token_received) begin</pre>
<pre>        in_ep_current_o <= rx_endp_i;</pre>
<pre>        in_ep_newpkt_o <= 1'b1;</pre>
<pre>      end else begin</pre>
<pre>        in_ep_newpkt_o <= 1'b0;</pre>
<pre>  always_comb begin : proc_data_toggle_d</pre>
<pre>    data_toggle_d = data_toggle_q;</pre>
<pre>    if (setup_token_received) begin</pre>
<pre>      data_toggle_d[rx_endp_i[0 +: InEpW]] = 1'b1;</pre>
<pre>    end else if ((in_xfr_state == StWaitAck) && ack_received) begin</pre>
<pre>      data_toggle_d[in_ep_index] = ~data_toggle_q[in_ep_index]; // lint: range was checked</pre>
<pre>    data_toggle_d = data_toggle_d & ~data_toggle_clear_i;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      data_toggle_q <= '0; // Clear for all endpoints</pre>
<pre>    end else if (link_reset_i) begin</pre>
<pre>      data_toggle_q <= '0; // Clear for all endpoints</pre>
<pre>    end else begin</pre>
<pre>      data_toggle_q <= data_toggle_d;</pre>
<pre>  always_ff @(posedge clk_48mhz_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      in_ep_data_get_o <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      if ((in_xfr_state == StSendData) && tx_data_get_i) begin</pre>
<pre>        in_ep_data_get_o <= 1'b1;</pre>
<pre>      end else begin</pre>
<pre>        in_ep_data_get_o <= 1'b0;</pre>
<h3>hw/ip/usb_fs_nb_pe/rtl/usb_fs_tx.sv</h3>
<pre>  input  logic clk_i,</pre>
<pre>  input  logic rst_ni,  // asyc reset</pre>
<pre>  input  logic link_reset_i, // USB reset, sync to 48 MHz, active high</pre>
<pre>  input  logic tx_osc_test_mode_i,</pre>
<pre>  input  logic bit_strobe_i,</pre>
<pre>  output logic usb_oe_o,</pre>
<pre>  output logic usb_d_o,</pre>
<pre>  output logic usb_se0_o,</pre>
<pre>  input  logic pkt_start_i,</pre>
<pre>  output logic pkt_end_o,</pre>
<pre>  input  logic [3:0] pid_i,</pre>
<pre>  input  logic tx_data_avail_i,</pre>
<pre>  output logic tx_data_get_o,</pre>
<pre>  input  logic [7:0] tx_data_i</pre>
<pre>  typedef enum logic [2:0] {Idle, Sync, Pid, DataOrCrc160, Crc161, Eop, OscTest} state_e;</pre>
<pre>  typedef enum logic [1:0] {OsIdle, OsWaitByte, OsTransmit} out_state_e;</pre>
<pre>  logic [3:0] pid_q, pid_d;</pre>
<pre>  logic bitstuff;</pre>
<pre>  logic bitstuff_q;</pre>
<pre>  logic bitstuff_q2;</pre>
<pre>  logic bitstuff_q3;</pre>
<pre>  logic bitstuff_q4;</pre>
<pre>  logic [5:0] bit_history;</pre>
<pre>  state_e      state_d, state_q;</pre>
<pre>  out_state_e  out_state_d, out_state_q;</pre>
<pre>  logic [7:0] data_shift_reg_q, data_shift_reg_d;</pre>
<pre>  logic [7:0] oe_shift_reg_q, oe_shift_reg_d;</pre>
<pre>  logic [7:0] se0_shift_reg_q, se0_shift_reg_d;</pre>
<pre>  logic data_payload_q, data_payload_d;</pre>
<pre>  logic tx_data_get_q, tx_data_get_d;</pre>
<pre>  logic byte_strobe_q, byte_strobe_d;</pre>
<pre>  logic [4:0] bit_history_d, bit_history_q;</pre>
<pre>  logic [2:0] bit_count_d, bit_count_q;</pre>
<pre>  logic [15:0] crc16_d, crc16_q;</pre>
<pre>  logic oe_q, oe_d;</pre>
<pre>  logic usb_d_q, usb_d_d;</pre>
<pre>  logic usb_se0_q, usb_se0_d;</pre>
<pre>  logic [2:0] dp_eop_q, dp_eop_d;</pre>
<pre>  logic test_mode_start;</pre>
<pre>  logic serial_tx_data;</pre>
<pre>  logic serial_tx_oe;</pre>
<pre>  logic serial_tx_se0;</pre>
<pre>  logic crc16_invert;</pre>
<pre>  logic pkt_end;</pre>
<pre>  logic out_nrzi_en;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_pid</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      pid_q <= 0;</pre>
<pre>    end else begin</pre>
<pre>      if (link_reset_i) begin</pre>
<pre>        pid_q <= 0;</pre>
<pre>      end else begin</pre>
<pre>        pid_q <= pid_d;</pre>
<pre>  assign pid_d = pkt_start_i ? pid_i : pid_q;</pre>
<pre>  assign serial_tx_data = data_shift_reg_q[0];</pre>
<pre>  assign serial_tx_oe = oe_shift_reg_q[0];</pre>
<pre>  assign serial_tx_se0 = se0_shift_reg_q[0];</pre>
<pre>  assign bit_history = {serial_tx_data, bit_history_q};</pre>
<pre>  assign bitstuff    = bit_history == 6'b111111;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      bitstuff_q  <= 0;</pre>
<pre>      bitstuff_q2 <= 0;</pre>
<pre>      bitstuff_q3 <= 0;</pre>
<pre>      bitstuff_q4 <= 0;</pre>
<pre>    end else begin</pre>
<pre>      if (link_reset_i) begin</pre>
<pre>        bitstuff_q  <= 0;</pre>
<pre>        bitstuff_q2 <= 0;</pre>
<pre>        bitstuff_q3 <= 0;</pre>
<pre>        bitstuff_q4 <= 0;</pre>
<pre>      end else begin</pre>
<pre>        bitstuff_q  <= bitstuff;</pre>
<pre>        bitstuff_q2 <= bitstuff_q;</pre>
<pre>        bitstuff_q3 <= bitstuff_q2;</pre>
<pre>        bitstuff_q4 <= bitstuff_q3;</pre>
<pre>  assign pkt_end   = bit_strobe_i && se0_shift_reg_q[1:0] == 2'b01;</pre>
<pre>  assign pkt_end_o = pkt_end;</pre>
<pre>  always_comb begin : proc_fsm</pre>
<pre>    state_d          = state_q;</pre>
<pre>    data_shift_reg_d = data_shift_reg_q;</pre>
<pre>    oe_shift_reg_d   = oe_shift_reg_q;</pre>
<pre>    se0_shift_reg_d  = se0_shift_reg_q;</pre>
<pre>    data_payload_d   = data_payload_q;</pre>
<pre>    tx_data_get_d    = tx_data_get_q;</pre>
<pre>    bit_history_d    = bit_history_q;</pre>
<pre>    bit_count_d      = bit_count_q;</pre>
<pre>    test_mode_start  = 0;</pre>
<pre>    unique case (state_q)</pre>
<pre>      Idle : begin</pre>
<pre>        if (tx_osc_test_mode_i) begin</pre>
<pre>          state_d         = OscTest;</pre>
<pre>          test_mode_start = 1;</pre>
<pre>        end else if (pkt_start_i) begin</pre>
<pre>          state_d = Sync;</pre>
<pre>      Sync : begin</pre>
<pre>        if (byte_strobe_q) begin</pre>
<pre>          state_d = Pid;</pre>
<pre>          data_shift_reg_d = 8'b10000000;</pre>
<pre>          oe_shift_reg_d = 8'b11111111;</pre>
<pre>          se0_shift_reg_d = 8'b00000000;</pre>
<pre>      Pid : begin</pre>
<pre>        if (byte_strobe_q) begin</pre>
<pre>          if (pid_q[1:0] == 2'b11) begin</pre>
<pre>            state_d = DataOrCrc160;</pre>
<pre>          end else begin</pre>
<pre>            state_d = Eop;</pre>
<pre>          data_shift_reg_d = {~pid_q, pid_q};</pre>
<pre>          oe_shift_reg_d = 8'b11111111;</pre>
<pre>          se0_shift_reg_d = 8'b00000000;</pre>
<pre>      DataOrCrc160 : begin</pre>
<pre>        if (byte_strobe_q) begin</pre>
<pre>          if (tx_data_avail_i) begin</pre>
<pre>            state_d = DataOrCrc160;</pre>
<pre>            data_payload_d = 1;</pre>
<pre>            tx_data_get_d = 1;</pre>
<pre>            data_shift_reg_d = tx_data_i;</pre>
<pre>            oe_shift_reg_d = 8'b11111111;</pre>
<pre>            se0_shift_reg_d = 8'b00000000;</pre>
<pre>          end else begin</pre>
<pre>            state_d = Crc161;</pre>
<pre>            data_payload_d = 0;</pre>
<pre>            tx_data_get_d = 0;</pre>
<pre>            data_shift_reg_d = ~{crc16_q[8], crc16_q[9], crc16_q[10], crc16_q[11], crc16_q[12], crc16_q[13], crc16_q[14], crc16_q[15]};</pre>
<pre>            oe_shift_reg_d = 8'b11111111;</pre>
<pre>            se0_shift_reg_d = 8'b00000000;</pre>
<pre>        end else begin</pre>
<pre>          tx_data_get_d = 0;</pre>
<pre>      Crc161 : begin</pre>
<pre>        if (byte_strobe_q) begin</pre>
<pre>          state_d = Eop;</pre>
<pre>          data_shift_reg_d = ~{crc16_q[0], crc16_q[1], crc16_q[2], crc16_q[3], crc16_q[4], crc16_q[5], crc16_q[6], crc16_q[7]};</pre>
<pre>          oe_shift_reg_d = 8'b11111111;</pre>
<pre>          se0_shift_reg_d = 8'b00000000;</pre>
<pre>      Eop : begin</pre>
<pre>        if (byte_strobe_q) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          oe_shift_reg_d = 8'b00000111;</pre>
<pre>          se0_shift_reg_d = 8'b00000111;</pre>
<pre>      OscTest: begin</pre>
<pre>        if (!tx_osc_test_mode_i && byte_strobe_q) begin</pre>
<pre>          oe_shift_reg_d   = 8'b00000000;</pre>
<pre>          state_d = Idle;</pre>
<pre>        end else if (byte_strobe_q) begin</pre>
<pre>          data_shift_reg_d = 8'b00000000;</pre>
<pre>          oe_shift_reg_d   = 8'b11111111;</pre>
<pre>          se0_shift_reg_d  = 8'b00000000;</pre>
<pre>    if (pkt_start_i) begin</pre>
<pre>      bit_count_d   = 7; // 8-7 = 1</pre>
<pre>      bit_history_d = 0;</pre>
<pre>    end else if (bit_strobe_i) begin</pre>
<pre>      if (bitstuff /* && !serial_tx_se0*/) begin</pre>
<pre>        bit_history_d       = bit_history[5:1];</pre>
<pre>        data_shift_reg_d[0] = 0;</pre>
<pre>      end else begin</pre>
<pre>        bit_count_d = bit_count_q + 1;</pre>
<pre>        data_shift_reg_d  = (data_shift_reg_q >> 1);</pre>
<pre>        oe_shift_reg_d    = (oe_shift_reg_q >> 1);</pre>
<pre>        se0_shift_reg_d   = (se0_shift_reg_q >> 1);</pre>
<pre>        bit_history_d = bit_history[5:1];</pre>
<pre>  always_comb begin : proc_byte_str</pre>
<pre>    if (bit_strobe_i && !bitstuff && !pkt_start_i) begin</pre>
<pre>      byte_strobe_d = (bit_count_q == 3'b000);</pre>
<pre>    end else begin</pre>
<pre>      byte_strobe_d = 0;</pre>
<pre>  assign tx_data_get_o = tx_data_get_q;</pre>
<pre>  assign crc16_invert = serial_tx_data ^ crc16_q[15];</pre>
<pre>  always_comb begin : proc_crc16</pre>
<pre>    crc16_d = crc16_q; // default assignment</pre>
<pre>    if (pkt_start_i) begin</pre>
<pre>      crc16_d = 16'b1111111111111111;</pre>
<pre>    if (bit_strobe_i && data_payload_q && !bitstuff_q4 && !pkt_start_i) begin</pre>
<pre>      crc16_d = {crc16_q[14:0], 1'b0} ^ ({16{crc16_invert}} & 16'b1000000000000101);</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      state_q           <= Idle;</pre>
<pre>      data_payload_q    <= 0;</pre>
<pre>      data_shift_reg_q  <= 0;</pre>
<pre>      oe_shift_reg_q    <= 0;</pre>
<pre>      se0_shift_reg_q   <= 0;</pre>
<pre>      tx_data_get_q     <= 0;</pre>
<pre>      byte_strobe_q     <= 0;</pre>
<pre>      bit_history_q     <= 0;</pre>
<pre>      bit_count_q       <= 0;</pre>
<pre>      crc16_q           <= 0;</pre>
<pre>    end else begin</pre>
<pre>      if (link_reset_i) begin</pre>
<pre>        state_q           <= Idle;</pre>
<pre>        data_payload_q    <= 0;</pre>
<pre>        data_shift_reg_q  <= 0;</pre>
<pre>        oe_shift_reg_q    <= 0;</pre>
<pre>        se0_shift_reg_q   <= 0;</pre>
<pre>        tx_data_get_q     <= 0;</pre>
<pre>        byte_strobe_q     <= 0;</pre>
<pre>        bit_history_q     <= 0;</pre>
<pre>        bit_count_q       <= 0;</pre>
<pre>        crc16_q           <= 0;</pre>
<pre>      end else begin</pre>
<pre>        state_q           <= state_d;</pre>
<pre>        data_payload_q    <= data_payload_d;</pre>
<pre>        data_shift_reg_q  <= data_shift_reg_d;</pre>
<pre>        oe_shift_reg_q    <= oe_shift_reg_d;</pre>
<pre>        se0_shift_reg_q   <= se0_shift_reg_d;</pre>
<pre>        tx_data_get_q     <= tx_data_get_d;</pre>
<pre>        byte_strobe_q     <= byte_strobe_d;</pre>
<pre>        bit_history_q     <= bit_history_d;</pre>
<pre>        bit_count_q       <= bit_count_d;</pre>
<pre>        crc16_q           <= crc16_d;</pre>
<pre>  always_comb begin : proc_out_fsm</pre>
<pre>    out_state_d          = out_state_q;</pre>
<pre>    out_nrzi_en          = 1'b0;</pre>
<pre>    unique case (out_state_q)</pre>
<pre>      OsIdle: begin</pre>
<pre>        if (pkt_start_i || test_mode_start) begin</pre>
<pre>          out_state_d = OsWaitByte;</pre>
<pre>      OsWaitByte: begin</pre>
<pre>        if (byte_strobe_q) begin</pre>
<pre>          out_state_d = OsTransmit;</pre>
<pre>      OsTransmit: begin</pre>
<pre>        out_nrzi_en          = 1'b1;</pre>
<pre>        if ((bit_strobe_i && !serial_tx_oe)) begin</pre>
<pre>          out_state_d = OsIdle;</pre>
<pre>      default : out_state_d = OsIdle;</pre>
<pre>  always_comb begin : proc_diff</pre>
<pre>    usb_d_d   = usb_d_q;</pre>
<pre>    usb_se0_d = usb_se0_q;</pre>
<pre>    oe_d     = oe_q;</pre>
<pre>    dp_eop_d = dp_eop_q;</pre>
<pre>    if (pkt_start_i) begin</pre>
<pre>      usb_d_d = 1; // J -> first bit will be K (start of sync)</pre>
<pre>      dp_eop_d = 3'b100; // Eop: {SE0, SE0, J}</pre>
<pre>    end else if (bit_strobe_i && out_nrzi_en) begin</pre>
<pre>      oe_d = serial_tx_oe;</pre>
<pre>      if (serial_tx_se0) begin</pre>
<pre>        dp_eop_d = dp_eop_q >> 1;</pre>
<pre>        if (dp_eop_q[0]) begin</pre>
<pre>          usb_d_d   = 1;</pre>
<pre>          usb_se0_d = 0;</pre>
<pre>        end else begin</pre>
<pre>          usb_se0_d = 1;</pre>
<pre>      end else if (serial_tx_data) begin</pre>
<pre>      end else begin</pre>
<pre>        usb_d_d = !usb_d_q;</pre>
<pre>      if (!oe_d) begin</pre>
<pre>        usb_d_d = 1;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_diff_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      dp_eop_q             <= 0;</pre>
<pre>      oe_q                 <= 0;</pre>
<pre>      usb_d_q              <= 1; // J state = idle state</pre>
<pre>      usb_se0_q            <= 0;</pre>
<pre>      out_state_q          <= OsIdle;</pre>
<pre>    end else begin</pre>
<pre>      if (link_reset_i) begin</pre>
<pre>        dp_eop_q             <= 0;</pre>
<pre>        oe_q                 <= 0;</pre>
<pre>        usb_d_q              <= 1;</pre>
<pre>        usb_se0_q            <= 0;</pre>
<pre>        out_state_q          <= OsIdle;</pre>
<pre>      end else begin</pre>
<pre>        dp_eop_q             <= dp_eop_d;</pre>
<pre>        oe_q                 <= oe_d;</pre>
<pre>        usb_d_q              <= usb_d_d;</pre>
<pre>        usb_se0_q            <= usb_se0_d;</pre>
<pre>        out_state_q          <= out_state_d;</pre>
<pre>  assign usb_oe_o  = oe_q;</pre>
<pre>  assign usb_d_o   = usb_d_q;</pre>
<pre>  assign usb_se0_o = usb_se0_q;</pre>
<h3>hw/ip/prim_generic/rtl/prim_generic_rom.sv</h3>
<pre>module prim_generic_rom #(</pre>
<pre>  parameter  int Width     = 32,</pre>
<pre>  parameter  int Depth     = 2048, // 8kB default</pre>
<pre>  parameter  int Aw        = $clog2(Depth)</pre>
<pre>  input                        clk_i,</pre>
<pre>  input                        rst_ni,</pre>
<pre>  input        [Aw-1:0]        addr_i,</pre>
<pre>  input                        cs_i,</pre>
<pre>  output logic [Width-1:0]     dout_o,</pre>
<pre>  output logic                 dvalid_o</pre>
<pre>  logic [Width-1:0] mem [Depth];</pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>    if (cs_i) begin</pre>
<pre>      dout_o <= mem[addr_i];</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      dvalid_o <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      dvalid_o <= cs_i;</pre>
<h3>hw/ip/prim/rtl/prim_arbiter_ppc.sv</h3>
<pre>module prim_arbiter_ppc #(</pre>
<pre>  parameter int unsigned N  = 4,</pre>
<pre>  parameter int unsigned DW = 32</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input        [ N-1:0]        req_i,</pre>
<pre>  input        [DW-1:0]        data_i [N],</pre>
<pre>  output logic [ N-1:0]        gnt_o,</pre>
<pre>  output logic [$clog2(N)-1:0] idx_o,</pre>
<pre>  output logic          valid_o,</pre>
<pre>  output logic [DW-1:0] data_o,</pre>
<pre>  input                 ready_i</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">    assign data_o   = data_i[0];</pre>
<pre style="background-color: #FF0000;">    assign gnt_o[0] = valid_o & ready_i;</pre>
<pre style="background-color: #FF0000;">    assign idx_o    = '0;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre style="background-color: #FF0000;">    logic [N-1:0] ppc_out;</pre>
<pre style="background-color: #FF0000;">    logic [N-1:0] arb_req;</pre>
<pre style="background-color: #FF0000;">    logic [N-1:0] mask, mask_next;</pre>
<pre style="background-color: #FF0000;">    logic [N-1:0] winner;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>    assign arb_req = (|masked_req) ? masked_req : req_i;</pre>
<pre></pre>
<pre>      ppc_out[0] = arb_req[0];</pre>
<pre>      for (int i = 1 ; i < N ; i++) begin</pre>
<pre>        ppc_out[i] = ppc_out[i-1] | arb_req[i];</pre>
<pre>      end</pre>
<pre>    assign gnt_o    = (ready_i) ? winner : '0;</pre>
<pre></pre>
<pre>    // Mask Generation</pre>
<pre>    always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>      if (!rst_ni) begin</pre>
<pre>        mask <= '0;</pre>
<pre>      end else if (valid_o && ready_i) begin</pre>
<pre>        // Latch only when requests accepted</pre>
<pre>      end else if (valid_o && !ready_i) begin</pre>
<pre>        // Downstream isn't yet ready so, keep current request alive. (First come first serve)</pre>
<pre>      end</pre>
<pre>      data_o = '0;</pre>
<pre>      idx_o  = '0;</pre>
<pre>      for (int i = 0 ; i < N ; i++) begin</pre>
<pre>        if (winner[i]) begin</pre>
<pre>          data_o = data_i[i];</pre>
<pre>          idx_o  = i;</pre>
<pre>        end</pre>
<h3>hw/ip/prim/rtl/prim_esc_sender.sv</h3>
<pre>  input           clk_i,</pre>
<pre>  input           rst_ni,</pre>
<pre>  input           ping_en_i,</pre>
<pre>  output logic    ping_ok_o,</pre>
<pre>  output logic    integ_fail_o,</pre>
<pre>  input           esc_en_i,</pre>
<pre>  input esc_rx_t  esc_rx_i,</pre>
<pre>  output esc_tx_t esc_tx_o</pre>
<pre>  logic resp, sigint_detected;</pre>
<pre style="background-color: #FF0000;">  prim_diff_decode #(</pre>
<pre style="background-color: #FF0000;">    .AsyncOn(1'b0)</pre>
<pre style="background-color: #FF0000;">  ) i_decode_resp (</pre>
<pre style="background-color: #FF0000;">    .clk_i,</pre>
<pre style="background-color: #FF0000;">    .rst_ni,</pre>
<pre style="background-color: #FF0000;">    .diff_pi  ( esc_rx_i.resp_p ),</pre>
<pre style="background-color: #FF0000;">    .diff_ni  ( esc_rx_i.resp_n ),</pre>
<pre style="background-color: #FF0000;">    .level_o  ( resp            ),</pre>
<pre style="background-color: #FF0000;">    .rise_o   (                 ),</pre>
<pre style="background-color: #FF0000;">    .fall_o   (                 ),</pre>
<pre style="background-color: #FF0000;">    .event_o  (                 ),</pre>
<pre style="background-color: #FF0000;">    .sigint_o ( sigint_detected )</pre>
<pre>  logic ping_en_d, ping_en_q;</pre>
<pre>  logic esc_en_d, esc_en_q, esc_en_q1;</pre>
<pre>  assign ping_en_d = ping_en_i;</pre>
<pre>  assign esc_en_d  = esc_en_i;</pre>
<pre>  assign esc_tx_o.esc_p = esc_en_i | esc_en_q | ( ping_en_d & ~ping_en_q);</pre>
<pre>  assign esc_tx_o.esc_n = ~esc_tx_o.esc_p;</pre>
<pre>  typedef enum logic [2:0] {Idle, CheckEscRespLo, CheckEscRespHi,</pre>
<pre>    CheckPingResp0, CheckPingResp1, CheckPingResp2, CheckPingResp3} fsm_e;</pre>
<pre>  fsm_e state_d, state_q;</pre>
<pre>  always_comb begin : p_fsm</pre>
<pre>    state_d      = state_q;</pre>
<pre>    ping_ok_o    = 1'b0;</pre>
<pre>    integ_fail_o = sigint_detected;</pre>
<pre>    unique case (state_q)</pre>
<pre>      Idle: begin</pre>
<pre>        if (esc_en_i) begin</pre>
<pre>          state_d = CheckEscRespHi;</pre>
<pre>        end else if (ping_en_i) begin</pre>
<pre>          state_d = CheckPingResp0;</pre>
<pre>        if (resp) begin</pre>
<pre>          integ_fail_o = 1'b1;</pre>
<pre>      CheckEscRespLo: begin</pre>
<pre>        state_d      = CheckEscRespHi;</pre>
<pre>        if (!esc_en_i || resp) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          integ_fail_o = sigint_detected | resp;</pre>
<pre>      CheckEscRespHi: begin</pre>
<pre>        state_d = CheckEscRespLo;</pre>
<pre>        if (!esc_en_i || !resp) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          integ_fail_o = sigint_detected | ~resp;</pre>
<pre>      CheckPingResp0: begin</pre>
<pre>        state_d = CheckPingResp1;</pre>
<pre>        if (esc_en_i) begin</pre>
<pre>          state_d = CheckEscRespLo;</pre>
<pre>        end else if (!resp) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          integ_fail_o = 1'b1;</pre>
<pre>      CheckPingResp1: begin</pre>
<pre>        state_d = CheckPingResp2;</pre>
<pre>        if (esc_en_i) begin</pre>
<pre>          state_d = CheckEscRespHi;</pre>
<pre>        end else if (resp) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          integ_fail_o = 1'b1;</pre>
<pre>      CheckPingResp2: begin</pre>
<pre>        state_d = CheckPingResp3;</pre>
<pre>        if (esc_en_i) begin</pre>
<pre>          state_d = CheckEscRespLo;</pre>
<pre>        end else if (!resp) begin</pre>
<pre>          state_d = Idle;</pre>
<pre>          integ_fail_o = 1'b1;</pre>
<pre>      CheckPingResp3: begin</pre>
<pre>        state_d = Idle;</pre>
<pre>        if (esc_en_i) begin</pre>
<pre>          state_d = CheckEscRespHi;</pre>
<pre>        end else if (resp) begin</pre>
<pre>          integ_fail_o = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          ping_ok_o = ping_en_i;</pre>
<pre>      default : state_d = Idle;</pre>
<pre>    if ((esc_en_i || esc_en_q || esc_en_q1) && ping_en_i) begin</pre>
<pre>      ping_ok_o = 1'b1;</pre>
<pre>    if (sigint_detected) begin</pre>
<pre>      ping_ok_o = 1'b0;</pre>
<pre>      state_d = Idle;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      state_q   <= Idle;</pre>
<pre>      esc_en_q  <= 1'b0;</pre>
<pre>      esc_en_q1 <= 1'b0;</pre>
<pre>      ping_en_q <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      state_q   <= state_d;</pre>
<pre>      esc_en_q  <= esc_en_d;</pre>
<pre>      esc_en_q1 <= esc_en_q;</pre>
<pre>      ping_en_q <= ping_en_d;</pre>
<pre style="background-color: #FF0000;">endmodule : prim_esc_sender</pre>
<h3>hw/ip/prim/rtl/prim_packer.sv</h3>
<pre>module prim_packer #(</pre>
<pre>  parameter int InW  = 32,</pre>
<pre>  parameter int OutW = 32</pre>
<pre>  input clk_i ,</pre>
<pre>  input rst_ni,</pre>
<pre>  input                   valid_i,</pre>
<pre>  input        [InW-1:0]  data_i,</pre>
<pre>  input        [InW-1:0]  mask_i,</pre>
<pre>  output                  ready_o,</pre>
<pre>  output logic            valid_o,</pre>
<pre>  output logic [OutW-1:0] data_o,</pre>
<pre>  output logic [OutW-1:0] mask_o,</pre>
<pre>  input                   ready_i,</pre>
<pre>  input                   flush_i,  // If 1, send out remnant and clear state</pre>
<pre>  output logic            flush_done_o</pre>
<pre>  localparam int Width = InW + OutW;</pre>
<pre>  localparam int PtrW = $clog2(Width+1);</pre>
<pre>  localparam int MaxW = (InW > OutW) ? InW : OutW;</pre>
<pre>  logic valid_next, ready_next;</pre>
<pre>  logic [MaxW-1:0]  stored_data, stored_mask;</pre>
<pre>  logic [Width-1:0] concat_data, concat_mask;</pre>
<pre>  logic [Width-1:0] shiftl_data, shiftl_mask;</pre>
<pre>  logic [PtrW-1:0]        pos, pos_next; // Current write position</pre>
<pre>  logic [$clog2(InW)-1:0] lod_idx;       // result of Leading One Detector</pre>
<pre>  logic [$clog2(InW+1)-1:0] inmask_ones;   // Counting Ones for mask_i</pre>
<pre>  logic ack_in, ack_out;</pre>
<pre>  logic flush_ready; // flush_i is pulse, so only when the output is ready flush_ready assets</pre>
<pre>  always_comb begin</pre>
<pre>    inmask_ones = '0;</pre>
<pre>    for (int i = 0 ; i < InW ; i++) begin</pre>
<pre>      inmask_ones = inmask_ones + mask_i[i];</pre>
<pre>  assign pos_next = (valid_i) ? pos + PtrW'(inmask_ones) : pos;  // pos always stays (% OutW)</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      pos <= '0;</pre>
<pre>    end else if (flush_ready) begin</pre>
<pre>      pos <= '0;</pre>
<pre>      `ASSERT_I(pos_next_gte_outw_p, pos_next >= OutW)</pre>
<pre>    end else if (ack_in) begin</pre>
<pre>      pos <= pos_next;</pre>
<pre>    end</pre>
<pre>    lod_idx = 0;</pre>
<pre>    for (int i = InW-1; i >= 0 ; i--) begin</pre>
<pre>      if (mask_i[i] == 1'b1) begin</pre>
<pre>        lod_idx = i;</pre>
<pre>      end</pre>
<pre>  assign ack_out = valid_o & ready_i;</pre>
<pre></pre>
<pre>  assign shiftl_mask = (valid_i) ? Width'(mask_i >> lod_idx) << pos : '0;</pre>
<pre>  assign concat_data = {{(Width-MaxW){1'b0}}, stored_data & stored_mask} |</pre>
<pre>                       (shiftl_data & shiftl_mask);</pre>
<pre>  assign concat_mask = {{(Width-MaxW){1'b0}}, stored_mask} | shiftl_mask;</pre>
<pre></pre>
<pre></pre>
<pre>    assign stored_data_next = concat_data[OutW+:InW];</pre>
<pre>    assign stored_mask_next = concat_mask[OutW+:InW];</pre>
<pre>  end else begin : gen_stored_out</pre>
<pre style="background-color: #FF0000;">    assign stored_data_next = {{(OutW-InW){1'b0}}, concat_data[OutW+:InW]};</pre>
<pre style="background-color: #FF0000;">    assign stored_mask_next = {{(OutW-InW){1'b0}}, concat_mask[OutW+:InW]};</pre>
<pre style="background-color: #FF0000;">  end</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      stored_data <= '0;</pre>
<pre>      stored_mask <= '0;</pre>
<pre>    end else if (flush_ready) begin</pre>
<pre>      stored_data <= '0;</pre>
<pre>      stored_mask <= '0;</pre>
<pre>    end else if (ack_out) begin</pre>
<pre>      stored_data <= stored_data_next;</pre>
<pre>      stored_mask <= stored_mask_next;</pre>
<pre>    end else if (ack_in) begin</pre>
<pre>      // When the requested size is smaller than OutW or output isn't ready</pre>
<pre>      stored_mask <= concat_mask[MaxW-1:0];</pre>
<pre>    end</pre>
<pre>    FlushIdle,</pre>
<pre>    FlushWait</pre>
<pre>  } flush_st_e;</pre>
<pre>  flush_st_e flush_st, flush_st_next;</pre>
<pre></pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      flush_st <= FlushIdle;</pre>
<pre>    end else begin</pre>
<pre>      flush_st <= flush_st_next;</pre>
<pre>    end</pre>
<pre>    flush_st_next = FlushIdle;</pre>
<pre></pre>
<pre></pre>
<pre>      FlushIdle: begin</pre>
<pre>        if (flush_i && !ready_i) begin</pre>
<pre>          // Wait until hold released</pre>
<pre></pre>
<pre>        end else if (flush_i && ready_i) begin</pre>
<pre>          // Can write right away!</pre>
<pre></pre>
<pre>        end else begin</pre>
<pre>          flush_st_next = FlushIdle;</pre>
<pre>        end</pre>
<pre>        // TODO: Add timeout and force flush</pre>
<pre>          // Ready to write</pre>
<pre></pre>
<pre>        end else begin</pre>
<pre>          // Wait ...</pre>
<pre></pre>
<pre>        end</pre>
<pre>        flush_st_next = FlushIdle;</pre>
<pre></pre>
<pre>      end</pre>
<pre></pre>
<pre>  assign ready_next = ack_out ? 1'b1 : pos_next <= MaxW; // New `we` needs to be hold.</pre>
<pre></pre>
<pre>  assign data_o  = concat_data[OutW-1:0];</pre>
<pre>  assign mask_o  = concat_mask[OutW-1:0];</pre>
<pre></pre>
<pre></pre>
<h3>hw/ip/prim/rtl/prim_flop_2sync.sv</h3>
<pre>module prim_flop_2sync #(</pre>
<pre>  parameter int Width      = 16,</pre>
<pre>  parameter bit ResetValue = 0</pre>
<pre>  input                    clk_i,    // receive clock</pre>
<pre>  input                    rst_ni,</pre>
<pre>  input        [Width-1:0] d,</pre>
<pre>  output logic [Width-1:0] q</pre>
<pre>  logic [Width-1:0] intq;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni)</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      intq <= {Width{ResetValue}};</pre>
<pre>      q    <= {Width{ResetValue}};</pre>
<pre>    end else begin</pre>
<pre>      intq <= d;</pre>
<pre>      q    <= intq;</pre>
<h3>hw/ip/prim/rtl/prim_filter.sv</h3>
<pre>  input  clk_i,</pre>
<pre>  input  rst_ni,</pre>
<pre>  input  enable_i,</pre>
<pre>  input  filter_i,</pre>
<pre>  output filter_o</pre>
<pre>  logic [Cycles-1:0] stored_vector_q, stored_vector_d;</pre>
<pre>  logic stored_value_q, update_stored_value;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      stored_value_q <= 1'b0;</pre>
<pre>    end else if (update_stored_value) begin</pre>
<pre>      stored_value_q <= filter_i;</pre>
<pre>  assign stored_vector_d = {stored_vector_q[Cycles-2:0],filter_i};</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      stored_vector_q <= {Cycles{1'b0}};</pre>
<pre>    end else begin</pre>
<pre>      stored_vector_q <= stored_vector_d;</pre>
<pre>  assign update_stored_value =</pre>
<pre>             (stored_vector_d == {Cycles{1'b0}}) |</pre>
<pre>             (stored_vector_d == {Cycles{1'b1}});</pre>
<pre>  assign filter_o = enable_i ? stored_value_q : filter_i;</pre>
<h3>hw/ip/prim/rtl/prim_lfsr.sv</h3>
<pre>module prim_lfsr #(</pre>
<pre>  parameter                    LfsrType     = "GAL_XOR",</pre>
<pre>  parameter int unsigned       LfsrDw       = 32,</pre>
<pre>  parameter int unsigned       EntropyDw    =  8,</pre>
<pre>  parameter int unsigned       StateOutDw   =  8,</pre>
<pre>  parameter logic [LfsrDw-1:0] DefaultSeed  = LfsrDw'(1),</pre>
<pre>  parameter logic [LfsrDw-1:0] CustomCoeffs = '0,</pre>
<pre>  parameter bit                MaxLenSVA    = 1'b1,</pre>
<pre>  parameter bit                LockupSVA    = 1'b1,</pre>
<pre>  parameter bit                ExtSeedSVA   = 1'b1</pre>
<pre>  input                         clk_i,</pre>
<pre>  input                         rst_ni,</pre>
<pre>  input                         seed_en_i, // load external seed into the state (takes precedence)</pre>
<pre>  input        [LfsrDw-1:0]     seed_i,    // external seed input</pre>
<pre>  input                         lfsr_en_i, // enables the LFSR</pre>
<pre>  input        [EntropyDw-1:0]  entropy_i, // additional entropy to be XOR'ed into the state</pre>
<pre>  output logic [StateOutDw-1:0] state_o    // (partial) LFSR state output</pre>
<pre>  localparam int unsigned GAL_XOR_LUT_OFF = 4;</pre>
<pre>  localparam logic [63:0] GAL_XOR_COEFFS [61] =</pre>
<pre>    '{ 64'h9,</pre>
<pre>       64'h12,</pre>
<pre>       64'h21,</pre>
<pre>       64'h41,</pre>
<pre>       64'h8E,</pre>
<pre>       64'h108,</pre>
<pre>       64'h204,</pre>
<pre>       64'h402,</pre>
<pre>       64'h829,</pre>
<pre>       64'h100D,</pre>
<pre>       64'h2015,</pre>
<pre>       64'h4001,</pre>
<pre>       64'h8016,</pre>
<pre>       64'h10004,</pre>
<pre>       64'h20013,</pre>
<pre>       64'h40013,</pre>
<pre>       64'h80004,</pre>
<pre>       64'h100002,</pre>
<pre>       64'h200001,</pre>
<pre>       64'h400010,</pre>
<pre>       64'h80000D,</pre>
<pre>       64'h1000004,</pre>
<pre>       64'h2000023,</pre>
<pre>       64'h4000013,</pre>
<pre>       64'h8000004,</pre>
<pre>       64'h10000002,</pre>
<pre>       64'h20000029,</pre>
<pre>       64'h40000004,</pre>
<pre>       64'h80000057,</pre>
<pre>       64'h100000029,</pre>
<pre>       64'h200000073,</pre>
<pre>       64'h400000002,</pre>
<pre>       64'h80000003B,</pre>
<pre>       64'h100000001F,</pre>
<pre>       64'h2000000031,</pre>
<pre>       64'h4000000008,</pre>
<pre>       64'h800000001C,</pre>
<pre>       64'h10000000004,</pre>
<pre>       64'h2000000001F,</pre>
<pre>       64'h4000000002C,</pre>
<pre>       64'h80000000032,</pre>
<pre>       64'h10000000000D,</pre>
<pre>       64'h200000000097,</pre>
<pre>       64'h400000000010,</pre>
<pre>       64'h80000000005B,</pre>
<pre>       64'h1000000000038,</pre>
<pre>       64'h200000000000E,</pre>
<pre>       64'h4000000000025,</pre>
<pre>       64'h8000000000004,</pre>
<pre>       64'h10000000000023,</pre>
<pre>       64'h2000000000003E,</pre>
<pre>       64'h40000000000023,</pre>
<pre>       64'h8000000000004A,</pre>
<pre>       64'h100000000000016,</pre>
<pre>       64'h200000000000031,</pre>
<pre>       64'h40000000000003D,</pre>
<pre>       64'h800000000000001,</pre>
<pre>       64'h1000000000000013,</pre>
<pre>       64'h2000000000000034,</pre>
<pre>       64'h4000000000000001,</pre>
<pre>       64'h800000000000000D };</pre>
<pre>  localparam int unsigned FIB_XNOR_LUT_OFF = 3;</pre>
<pre>  localparam logic [167:0] FIB_XNOR_COEFFS [166] =</pre>
<pre>    '{ 168'h6,</pre>
<pre>       168'hC,</pre>
<pre>       168'h14,</pre>
<pre>       168'h30,</pre>
<pre>       168'h60,</pre>
<pre>       168'hB8,</pre>
<pre>       168'h110,</pre>
<pre>       168'h240,</pre>
<pre>       168'h500,</pre>
<pre>       168'h829,</pre>
<pre>       168'h100D,</pre>
<pre>       168'h2015,</pre>
<pre>       168'h6000,</pre>
<pre>       168'hD008,</pre>
<pre>       168'h12000,</pre>
<pre>       168'h20400,</pre>
<pre>       168'h40023,</pre>
<pre>       168'h90000,</pre>
<pre>       168'h140000,</pre>
<pre>       168'h300000,</pre>
<pre>       168'h420000,</pre>
<pre>       168'hE10000,</pre>
<pre>       168'h1200000,</pre>
<pre>       168'h2000023,</pre>
<pre>       168'h4000013,</pre>
<pre>       168'h9000000,</pre>
<pre>       168'h14000000,</pre>
<pre>       168'h20000029,</pre>
<pre>       168'h48000000,</pre>
<pre>       168'h80200003,</pre>
<pre>       168'h100080000,</pre>
<pre>       168'h204000003,</pre>
<pre>       168'h500000000,</pre>
<pre>       168'h801000000,</pre>
<pre>       168'h100000001F,</pre>
<pre>       168'h2000000031,</pre>
<pre>       168'h4400000000,</pre>
<pre>       168'hA000140000,</pre>
<pre>       168'h12000000000,</pre>
<pre>       168'h300000C0000,</pre>
<pre>       168'h63000000000,</pre>
<pre>       168'hC0000030000,</pre>
<pre>       168'h1B0000000000,</pre>
<pre>       168'h300003000000,</pre>
<pre>       168'h420000000000,</pre>
<pre>       168'hC00000180000,</pre>
<pre>       168'h1008000000000,</pre>
<pre>       168'h3000000C00000,</pre>
<pre>       168'h6000C00000000,</pre>
<pre>       168'h9000000000000,</pre>
<pre>       168'h18003000000000,</pre>
<pre>       168'h30000000030000,</pre>
<pre>       168'h40000040000000,</pre>
<pre>       168'hC0000600000000,</pre>
<pre>       168'h102000000000000,</pre>
<pre>       168'h200004000000000,</pre>
<pre>       168'h600003000000000,</pre>
<pre>       168'hC00000000000000,</pre>
<pre>       168'h1800300000000000,</pre>
<pre>       168'h3000000000000030,</pre>
<pre>       168'h6000000000000000,</pre>
<pre>       168'hD800000000000000,</pre>
<pre>       168'h10000400000000000,</pre>
<pre>       168'h30180000000000000,</pre>
<pre>       168'h60300000000000000,</pre>
<pre>       168'h80400000000000000,</pre>
<pre>       168'h140000028000000000,</pre>
<pre>       168'h300060000000000000,</pre>
<pre>       168'h410000000000000000,</pre>
<pre>       168'h820000000001040000,</pre>
<pre>       168'h1000000800000000000,</pre>
<pre>       168'h3000600000000000000,</pre>
<pre>       168'h6018000000000000000,</pre>
<pre>       168'hC000000018000000000,</pre>
<pre>       168'h18000000600000000000,</pre>
<pre>       168'h30000600000000000000,</pre>
<pre>       168'h40200000000000000000,</pre>
<pre>       168'hC0000000060000000000,</pre>
<pre>       168'h110000000000000000000,</pre>
<pre>       168'h240000000480000000000,</pre>
<pre>       168'h600000000003000000000,</pre>
<pre>       168'h800400000000000000000,</pre>
<pre>       168'h1800000300000000000000,</pre>
<pre>       168'h3003000000000000000000,</pre>
<pre>       168'h4002000000000000000000,</pre>
<pre>       168'hC000000000000000018000,</pre>
<pre>       168'h10000000004000000000000,</pre>
<pre>       168'h30000C00000000000000000,</pre>
<pre>       168'h600000000000000000000C0,</pre>
<pre>       168'hC00C0000000000000000000,</pre>
<pre>       168'h140000000000000000000000,</pre>
<pre>       168'h200001000000000000000000,</pre>
<pre>       168'h400800000000000000000000,</pre>
<pre>       168'hA00000000001400000000000,</pre>
<pre>       168'h1040000000000000000000000,</pre>
<pre>       168'h2004000000000000000000000,</pre>
<pre>       168'h5000000000028000000000000,</pre>
<pre>       168'h8000000004000000000000000,</pre>
<pre>       168'h18600000000000000000000000,</pre>
<pre>       168'h30000000000000000C00000000,</pre>
<pre>       168'h40200000000000000000000000,</pre>
<pre>       168'hC0300000000000000000000000,</pre>
<pre>       168'h100010000000000000000000000,</pre>
<pre>       168'h200040000000000000000000000,</pre>
<pre>       168'h5000000000000000A0000000000,</pre>
<pre>       168'h800000010000000000000000000,</pre>
<pre>       168'h1860000000000000000000000000,</pre>
<pre>       168'h3003000000000000000000000000,</pre>
<pre>       168'h4010000000000000000000000000,</pre>
<pre>       168'hA000000000140000000000000000,</pre>
<pre>       168'h10080000000000000000000000000,</pre>
<pre>       168'h30000000000000000000180000000,</pre>
<pre>       168'h60018000000000000000000000000,</pre>
<pre>       168'hC0000000000000000300000000000,</pre>
<pre>       168'h140005000000000000000000000000,</pre>
<pre>       168'h200000001000000000000000000000,</pre>
<pre>       168'h404000000000000000000000000000,</pre>
<pre>       168'h810000000000000000000000000102,</pre>
<pre>       168'h1000040000000000000000000000000,</pre>
<pre>       168'h3000000000000006000000000000000,</pre>
<pre>       168'h5000000000000000000000000000000,</pre>
<pre>       168'h8000000004000000000000000000000,</pre>
<pre>       168'h18000000000000000000000000030000,</pre>
<pre>       168'h30000000030000000000000000000000,</pre>
<pre>       168'h60000000000000000000000000000000,</pre>
<pre>       168'hA0000014000000000000000000000000,</pre>
<pre>       168'h108000000000000000000000000000000,</pre>
<pre>       168'h240000000000000000000000000000000,</pre>
<pre>       168'h600000000000C00000000000000000000,</pre>
<pre>       168'h800000040000000000000000000000000,</pre>
<pre>       168'h1800000000000300000000000000000000,</pre>
<pre>       168'h2000000000000010000000000000000000,</pre>
<pre>       168'h4008000000000000000000000000000000,</pre>
<pre>       168'hC000000000000000000000000000000600,</pre>
<pre>       168'h10000080000000000000000000000000000,</pre>
<pre>       168'h30600000000000000000000000000000000,</pre>
<pre>       168'h4A400000000000000000000000000000000,</pre>
<pre>       168'h80000004000000000000000000000000000,</pre>
<pre>       168'h180000003000000000000000000000000000,</pre>
<pre>       168'h200001000000000000000000000000000000,</pre>
<pre>       168'h600006000000000000000000000000000000,</pre>
<pre>       168'hC00000000000000006000000000000000000,</pre>
<pre>       168'h1000000000000100000000000000000000000,</pre>
<pre>       168'h3000000000000006000000000000000000000,</pre>
<pre>       168'h6000000003000000000000000000000000000,</pre>
<pre>       168'h8000001000000000000000000000000000000,</pre>
<pre>       168'h1800000000000000000000000000C000000000,</pre>
<pre>       168'h20000000000001000000000000000000000000,</pre>
<pre>       168'h48000000000000000000000000000000000000,</pre>
<pre>       168'hC0000000000000006000000000000000000000,</pre>
<pre>       168'h180000000000000000000000000000000000000,</pre>
<pre>       168'h280000000000000000000000000000005000000,</pre>
<pre>       168'h60000000C000000000000000000000000000000,</pre>
<pre>       168'hC00000000000000000000000000018000000000,</pre>
<pre>       168'h1800000600000000000000000000000000000000,</pre>
<pre>       168'h3000000C00000000000000000000000000000000,</pre>
<pre>       168'h4000000080000000000000000000000000000000,</pre>
<pre>       168'hC000300000000000000000000000000000000000,</pre>
<pre>       168'h10000400000000000000000000000000000000000,</pre>
<pre>       168'h30000000000000000000006000000000000000000,</pre>
<pre>       168'h600000000000000C0000000000000000000000000,</pre>
<pre>       168'hC0060000000000000000000000000000000000000,</pre>
<pre>       168'h180000006000000000000000000000000000000000,</pre>
<pre>       168'h3000000000C0000000000000000000000000000000,</pre>
<pre>       168'h410000000000000000000000000000000000000000,</pre>
<pre>       168'hA00140000000000000000000000000000000000000 };</pre>
<pre>  logic lockup;</pre>
<pre>  logic [LfsrDw-1:0] lfsr_d, lfsr_q;</pre>
<pre>  logic [LfsrDw-1:0] next_lfsr_state, coeffs;</pre>
<pre>  if (64'(LfsrType) == 64'("GAL_XOR")) begin : gen_gal_xor</pre>
<pre style="background-color: #FF0000;">    if (CustomCoeffs > 0) begin : gen_custom</pre>
<pre style="background-color: #FF0000;">      assign coeffs = CustomCoeffs[LfsrDw-1:0];</pre>
<pre>    end else begin : gen_lut</pre>
<pre>      assign coeffs = GAL_XOR_COEFFS[LfsrDw-GAL_XOR_LUT_OFF][LfsrDw-1:0];</pre>
<pre></pre>
<pre></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">      assign coeffs = CustomCoeffs[LfsrDw-1:0];</pre>
<pre style="background-color: #FF0000;">    end else begin : gen_lut</pre>
<pre style="background-color: #FF0000;">      assign coeffs = FIB_XNOR_COEFFS[LfsrDw-FIB_XNOR_LUT_OFF][LfsrDw-1:0];</pre>
<pre style="background-color: #FF0000;">      // check that the most significant bit of polynomial is 1</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">    `ASSERT_INIT(UnknownLfsrType_A, 0)</pre>
<pre>                  (lfsr_en_i && lockup) ? DefaultSeed     :</pre>
<pre>                  (lfsr_en_i)           ? next_lfsr_state :</pre>
<pre>                                          lfsr_q;</pre>
<pre></pre>
<pre></pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      lfsr_q <= DefaultSeed;</pre>
<pre>    end else begin</pre>
<pre>      lfsr_q <= lfsr_d;</pre>
<pre>    end</pre>
<pre style="background-color: #FF0000;">    // check that external seed is correctly loaded into the state</pre>
<pre>  if (LockupSVA) begin : gen_lockup_mechanism_sva</pre>
<pre>  if (MaxLenSVA) begin : gen_max_len_sva</pre>
<h3>hw/ip/prim/rtl/prim_fifo_async.sv</h3>
<pre>module prim_fifo_async #(</pre>
<pre>  parameter  int unsigned Width  = 16,</pre>
<pre>  parameter  int unsigned Depth  = 3,</pre>
<pre>  localparam int unsigned DepthW = $clog2(Depth+1) // derived parameter representing [0..Depth]</pre>
<pre>  input                  clk_wr_i,</pre>
<pre>  input                  rst_wr_ni,</pre>
<pre>  input                  wvalid,</pre>
<pre>  output                 wready,</pre>
<pre>  input [Width-1:0]      wdata,</pre>
<pre>  output [DepthW-1:0]    wdepth,</pre>
<pre>  input                  clk_rd_i,</pre>
<pre>  input                  rst_rd_ni,</pre>
<pre>  output                 rvalid,</pre>
<pre>  input                  rready,</pre>
<pre>  output [Width-1:0]     rdata,</pre>
<pre>  output [DepthW-1:0]    rdepth</pre>
<pre>  localparam logic [PTRV_W-1:0] DepthMinus1 = PTRV_W'(Depth - 1);</pre>
<pre>  localparam int unsigned PTR_WIDTH = PTRV_W+1;</pre>
<pre></pre>
<pre>  logic [PTR_WIDTH-1:0]    fifo_wptr_sync_combi,   fifo_rptr_sync;</pre>
<pre>  logic [PTR_WIDTH-1:0]    fifo_wptr_gray_sync,    fifo_rptr_gray_sync;</pre>
<pre>  logic [PTR_WIDTH-1:0]    fifo_wptr_gray,         fifo_rptr_gray;</pre>
<pre>  logic                    fifo_incr_wptr, fifo_incr_rptr, empty;</pre>
<pre></pre>
<pre></pre>
<pre>  assign rvalid = !empty;</pre>
<pre></pre>
<pre>  assign fifo_incr_rptr = rvalid & rready;</pre>
<pre></pre>
<pre>    if (!rst_wr_ni) begin</pre>
<pre>      fifo_wptr <= {(PTR_WIDTH){1'b0}};</pre>
<pre>    end else if (fifo_incr_wptr) begin</pre>
<pre>      if (fifo_wptr[PTR_WIDTH-2:0] == DepthMinus1) begin</pre>
<pre>        fifo_wptr <= {~fifo_wptr[PTR_WIDTH-1],{(PTR_WIDTH-1){1'b0}}};</pre>
<pre>      end else begin</pre>
<pre>        fifo_wptr <= fifo_wptr + {{(PTR_WIDTH-1){1'b0}},1'b1};</pre>
<pre>    end</pre>
<pre>    if (!rst_wr_ni) begin</pre>
<pre>      fifo_wptr_gray <= {(PTR_WIDTH){1'b0}};</pre>
<pre>    end else if (fifo_incr_wptr) begin</pre>
<pre>      if (fifo_wptr[PTR_WIDTH-2:0] == DepthMinus1) begin</pre>
<pre>        fifo_wptr_gray <= dec2gray({~fifo_wptr[PTR_WIDTH-1],{(PTR_WIDTH-1){1'b0}}});</pre>
<pre>      end else begin</pre>
<pre>        fifo_wptr_gray <= dec2gray(fifo_wptr + {{(PTR_WIDTH-1){1'b0}},1'b1});</pre>
<pre>      end</pre>
<pre>    .clk_i    (clk_rd_i),</pre>
<pre>    .rst_ni   (rst_rd_ni),</pre>
<pre>    .d        (fifo_wptr_gray),</pre>
<pre>    .q        (fifo_wptr_gray_sync));</pre>
<pre></pre>
<pre></pre>
<pre>    if (!rst_rd_ni) begin</pre>
<pre>      fifo_rptr <= {(PTR_WIDTH){1'b0}};</pre>
<pre>    end else if (fifo_incr_rptr) begin</pre>
<pre>      if (fifo_rptr[PTR_WIDTH-2:0] == DepthMinus1) begin</pre>
<pre>        fifo_rptr <= {~fifo_rptr[PTR_WIDTH-1],{(PTR_WIDTH-1){1'b0}}};</pre>
<pre>      end else begin</pre>
<pre>        fifo_rptr <= fifo_rptr + {{(PTR_WIDTH-1){1'b0}},1'b1};</pre>
<pre>    end</pre>
<pre>    if (!rst_rd_ni) begin</pre>
<pre>      fifo_rptr_gray <= {(PTR_WIDTH){1'b0}};</pre>
<pre>    end else if (fifo_incr_rptr) begin</pre>
<pre>      if (fifo_rptr[PTR_WIDTH-2:0] == DepthMinus1) begin</pre>
<pre>        fifo_rptr_gray <= dec2gray({~fifo_rptr[PTR_WIDTH-1],{(PTR_WIDTH-1){1'b0}}});</pre>
<pre>      end else begin</pre>
<pre>        fifo_rptr_gray <= dec2gray(fifo_rptr + {{(PTR_WIDTH-1){1'b0}},1'b1});</pre>
<pre>      end</pre>
<pre>    .clk_i    (clk_wr_i),</pre>
<pre>    .rst_ni   (rst_wr_ni),</pre>
<pre>    .d        (fifo_rptr_gray),</pre>
<pre>    .q        (fifo_rptr_gray_sync));</pre>
<pre></pre>
<pre>    if (!rst_wr_ni) begin</pre>
<pre>      fifo_rptr_sync <= {PTR_WIDTH{1'b0}};</pre>
<pre>    end else begin</pre>
<pre>      fifo_rptr_sync <= gray2dec(fifo_rptr_gray_sync);</pre>
<pre>    end</pre>
<pre>  assign  full_rclk = (fifo_wptr_sync_combi == (fifo_rptr ^ {1'b1,{(PTR_WIDTH-1){1'b0}}}));</pre>
<pre></pre>
<pre>  logic  rptr_sync_msb;</pre>
<pre>  logic  [PTRV_W-1:0] wptr_value;</pre>
<pre>  logic  [PTRV_W-1:0] rptr_sync_value;</pre>
<pre>  assign wptr_msb = fifo_wptr[PTR_WIDTH-1];</pre>
<pre>  assign rptr_sync_msb = fifo_rptr_sync[PTR_WIDTH-1];</pre>
<pre>  assign wptr_value = fifo_wptr[0+:PTRV_W];</pre>
<pre>  assign rptr_sync_value = fifo_rptr_sync[0+:PTRV_W];</pre>
<pre>  assign wdepth = (full_wclk) ? DepthW'(Depth) :</pre>
<pre>                  (wptr_msb == rptr_sync_msb) ? DepthW'(wptr_value) - DepthW'(rptr_sync_value) :</pre>
<pre>                  (DepthW'(Depth) - DepthW'(rptr_sync_value) + DepthW'(wptr_value)) ;</pre>
<pre></pre>
<pre>  logic  rptr_msb;</pre>
<pre>  logic  wptr_sync_msb;</pre>
<pre>  logic  [PTRV_W-1:0] rptr_value;</pre>
<pre>  logic  [PTRV_W-1:0] wptr_sync_value;</pre>
<pre>  assign wptr_sync_msb = fifo_wptr_sync_combi[PTR_WIDTH-1];</pre>
<pre>  assign rptr_msb = fifo_rptr[PTR_WIDTH-1];</pre>
<pre>  assign wptr_sync_value = fifo_wptr_sync_combi[0+:PTRV_W];</pre>
<pre>  assign rptr_value = fifo_rptr[0+:PTRV_W];</pre>
<pre>  assign rdepth = (full_rclk) ? DepthW'(Depth) :</pre>
<pre>                  (wptr_sync_msb == rptr_msb) ? DepthW'(wptr_sync_value) - DepthW'(rptr_value) :</pre>
<pre>                  (DepthW'(Depth) - DepthW'(rptr_value) + DepthW'(wptr_sync_value)) ;</pre>
<pre></pre>
<pre></pre>
<pre>    if (fifo_incr_wptr) begin</pre>
<pre>      storage[fifo_wptr[PTR_WIDTH-2:0]] <= wdata;</pre>
<pre>    end</pre>
<pre></pre>
<pre>    logic [PTR_WIDTH-1:0] decval_sub;</pre>
<pre>    logic [PTR_WIDTH-2:0] decval_in;</pre>
<pre>    logic                 unused_decval_msb;</pre>
<pre></pre>
<pre></pre>
<pre>    // Was done in two assigns for low bits and top bit</pre>
<pre>                {1'b0,decval_in[PTR_WIDTH-2:1]} ^ decval_in[PTR_WIDTH-2:0]};</pre>
<pre>  endfunction</pre>
<pre>    logic [PTR_WIDTH-2:0] dec_tmp, dec_tmp_sub;</pre>
<pre>    logic                 unused_decsub_msb;</pre>
<pre></pre>
<pre>    for (int i = PTR_WIDTH-3; i >= 0; i--)</pre>
<pre>      dec_tmp[i] = dec_tmp[i+1]^grayval[i];</pre>
<pre>    {unused_decsub_msb, dec_tmp_sub} = Depth - {1'b0,dec_tmp} - 1'b1;</pre>
<pre>    if (grayval[PTR_WIDTH-1])</pre>
<pre>      gray2dec = {1'b1,dec_tmp_sub};</pre>
<pre>    else</pre>
<pre>  endfunction</pre>
<h3>hw/ip/prim/rtl/prim_ram_2p_async_adv.sv</h3>
<pre>module prim_ram_2p_async_adv #(</pre>
<pre>  parameter int Depth = 512,</pre>
<pre>  parameter int Width = 32,</pre>
<pre>  parameter int CfgW = 8,     // WTC, RTC, etc</pre>
<pre>  parameter bit EnableECC            = 0,</pre>
<pre>  parameter bit EnableParity         = 0,</pre>
<pre>  parameter bit EnableInputPipeline  = 0,</pre>
<pre>  parameter bit EnableOutputPipeline = 0,</pre>
<pre>  parameter MemT = "REGISTER", // can be "REGISTER" or "SRAM"</pre>
<pre>  parameter int SramAw = $clog2(Depth)</pre>
<pre>  input clk_a_i,</pre>
<pre>  input clk_b_i,</pre>
<pre>  input rst_a_ni,</pre>
<pre>  input rst_b_ni,</pre>
<pre>  input                     a_req_i,</pre>
<pre>  input                     a_write_i,</pre>
<pre>  input        [SramAw-1:0] a_addr_i,</pre>
<pre>  input        [Width-1:0]  a_wdata_i,</pre>
<pre>  output logic              a_rvalid_o,</pre>
<pre>  output logic [Width-1:0]  a_rdata_o,</pre>
<pre>  output logic [1:0]        a_rerror_o,</pre>
<pre>  input                     b_req_i,</pre>
<pre>  input                     b_write_i,</pre>
<pre>  input        [SramAw-1:0] b_addr_i,</pre>
<pre>  input        [Width-1:0]  b_wdata_i,</pre>
<pre>  output logic              b_rvalid_o,</pre>
<pre>  output logic [Width-1:0]  b_rdata_o,</pre>
<pre>  output logic [1:0]        b_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable</pre>
<pre>  input [CfgW-1:0] cfg_i</pre>
<pre>  localparam int ParWidth  = (EnableParity) ? 1 :</pre>
<pre>                             (!EnableECC)   ? 0 :</pre>
<pre>                             (Width <=   4) ? 4 :</pre>
<pre>                             (Width <=  11) ? 5 :</pre>
<pre>                             (Width <=  26) ? 6 :</pre>
<pre>                             (Width <=  57) ? 7 :</pre>
<pre>                             (Width <= 120) ? 8 : 8 ;</pre>
<pre>  localparam int TotalWidth = Width + ParWidth;</pre>
<pre>  logic                  a_req_q,    a_req_d ;</pre>
<pre>  logic                  a_write_q,  a_write_d ;</pre>
<pre>  logic [SramAw-1:0]     a_addr_q,   a_addr_d ;</pre>
<pre>  logic [TotalWidth-1:0] a_wdata_q,  a_wdata_d ;</pre>
<pre>  logic                  a_rvalid_q, a_rvalid_d, a_rvalid_sram ;</pre>
<pre>  logic [TotalWidth-1:0] a_rdata_d, a_rdata_sram ;</pre>
<pre>  logic [Width-1:0]      a_rdata_q ;</pre>
<pre>  logic [1:0]            a_rerror_q, a_rerror_d ;</pre>
<pre>  logic                  b_req_q,    b_req_d ;</pre>
<pre>  logic                  b_write_q,  b_write_d ;</pre>
<pre>  logic [SramAw-1:0]     b_addr_q,   b_addr_d ;</pre>
<pre>  logic [TotalWidth-1:0] b_wdata_q,  b_wdata_d ;</pre>
<pre>  logic                  b_rvalid_q, b_rvalid_d, b_rvalid_sram ;</pre>
<pre>  logic [TotalWidth-1:0] b_rdata_d, b_rdata_sram ;</pre>
<pre>  logic [Width-1:0]      b_rdata_q ;</pre>
<pre>  logic [1:0]            b_rerror_q, b_rerror_d ;</pre>
<pre style="background-color: #FF0000;">  if (MemT == "REGISTER") begin : gen_regmem</pre>
<pre style="background-color: #FF0000;">    prim_ram_2p #(</pre>
<pre style="background-color: #FF0000;">      .Width (TotalWidth),</pre>
<pre style="background-color: #FF0000;">      .Depth (Depth),</pre>
<pre style="background-color: #FF0000;">      .Impl(prim_pkg::ImplGeneric)</pre>
<pre style="background-color: #FF0000;">    ) u_mem (</pre>
<pre style="background-color: #FF0000;">      .clk_a_i    (clk_a_i),</pre>
<pre style="background-color: #FF0000;">      .clk_b_i    (clk_b_i),</pre>
<pre style="background-color: #FF0000;">      .a_req_i    (a_req_q),</pre>
<pre style="background-color: #FF0000;">      .a_write_i  (a_write_q),</pre>
<pre style="background-color: #FF0000;">      .a_addr_i   (a_addr_q),</pre>
<pre style="background-color: #FF0000;">      .a_wdata_i  (a_wdata_q),</pre>
<pre style="background-color: #FF0000;">      .a_rdata_o  (a_rdata_sram),</pre>
<pre style="background-color: #FF0000;">      .b_req_i    (b_req_q),</pre>
<pre style="background-color: #FF0000;">      .b_write_i  (b_write_q),</pre>
<pre style="background-color: #FF0000;">      .b_addr_i   (b_addr_q),</pre>
<pre style="background-color: #FF0000;">      .b_wdata_i  (b_wdata_q),</pre>
<pre style="background-color: #FF0000;">      .b_rdata_o  (b_rdata_sram)</pre>
<pre style="background-color: #FF0000;">  end else if (MemT == "SRAM") begin : gen_srammem</pre>
<pre>    prim_ram_2p #(</pre>
<pre>      .Width (TotalWidth),</pre>
<pre>      .Depth (Depth)</pre>
<pre style="background-color: #FF0000;">    ) u_mem (</pre>
<pre>      .clk_a_i    (clk_a_i),</pre>
<pre>      .clk_b_i    (clk_b_i),</pre>
<pre>      .a_req_i    (a_req_q),</pre>
<pre>      .a_write_i  (a_write_q),</pre>
<pre>      .a_addr_i   (a_addr_q),</pre>
<pre>      .a_wdata_i  (a_wdata_q),</pre>
<pre>      .a_rdata_o  (a_rdata_sram),</pre>
<pre>      .b_req_i    (b_req_q),</pre>
<pre>      .b_write_i  (b_write_q),</pre>
<pre>      .b_addr_i   (b_addr_q),</pre>
<pre>      .b_wdata_i  (b_wdata_q),</pre>
<pre>      .b_rdata_o  (b_rdata_sram)</pre>
<pre>  always_ff @(posedge clk_a_i or negedge rst_a_ni) begin</pre>
<pre>    if (!rst_a_ni) begin</pre>
<pre>      a_rvalid_sram <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      a_rvalid_sram <= a_req_q & ~a_write_q;</pre>
<pre>  always_ff @(posedge clk_b_i or negedge rst_b_ni) begin</pre>
<pre>    if (!rst_b_ni) begin</pre>
<pre>      b_rvalid_sram <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      b_rvalid_sram <= b_req_q & ~b_write_q;</pre>
<pre>  assign a_req_d              = a_req_i;</pre>
<pre>  assign a_write_d            = a_write_i;</pre>
<pre>  assign a_addr_d             = a_addr_i;</pre>
<pre>  assign a_rvalid_o           = a_rvalid_q;</pre>
<pre>  assign a_rdata_o            = a_rdata_q;</pre>
<pre>  assign a_rerror_o           = a_rerror_q;</pre>
<pre>  assign b_req_d              = b_req_i;</pre>
<pre>  assign b_write_d            = b_write_i;</pre>
<pre>  assign b_addr_d             = b_addr_i;</pre>
<pre>  assign b_rvalid_o           = b_rvalid_q;</pre>
<pre>  assign b_rdata_o            = b_rdata_q;</pre>
<pre>  assign b_rerror_o           = b_rerror_q;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">      prim_secded_39_32_enc u_enc_a (.in(a_wdata_i), .out(a_wdata_d));</pre>
<pre style="background-color: #FF0000;">      prim_secded_39_32_dec u_dec_a (</pre>
<pre style="background-color: #FF0000;">        .in         (a_rdata_sram),</pre>
<pre style="background-color: #FF0000;">        .d_o        (a_rdata_d[0+:Width]),</pre>
<pre style="background-color: #FF0000;">        .syndrome_o (a_rdata_d[Width+:ParWidth]),</pre>
<pre style="background-color: #FF0000;">        .err_o      (a_rerror_d)</pre>
<pre style="background-color: #FF0000;">      );</pre>
<pre style="background-color: #FF0000;">      prim_secded_39_32_dec u_dec_b (</pre>
<pre style="background-color: #FF0000;">        .in         (b_rdata_sram),</pre>
<pre style="background-color: #FF0000;">        .d_o        (b_rdata_d[0+:Width]),</pre>
<pre style="background-color: #FF0000;">        .syndrome_o (b_rdata_d[Width+:ParWidth]),</pre>
<pre style="background-color: #FF0000;">        .err_o      (b_rerror_d)</pre>
<pre style="background-color: #FF0000;">      );</pre>
<pre style="background-color: #FF0000;">      assign b_rvalid_d = b_rvalid_sram;</pre>
<pre style="background-color: #FF0000;">    end</pre>
<pre>    assign a_wdata_d[0+:Width] = a_wdata_i;</pre>
<pre>    assign b_wdata_d[0+:Width] = b_wdata_i;</pre>
<pre>    assign a_rdata_d[0+:Width] = a_rdata_sram;</pre>
<pre>    assign b_rdata_d[0+:Width] = b_rdata_sram;</pre>
<pre>    assign a_rvalid_d = a_rvalid_sram;</pre>
<pre>    assign b_rvalid_d = b_rvalid_sram;</pre>
<pre>    assign a_rerror_d = 2'b00;</pre>
<pre>    assign b_rerror_d = 2'b00;</pre>
<pre>  end</pre>
<pre style="background-color: #FF0000;">    // Put the register slices between ECC encoding to SRAM port</pre>
<pre style="background-color: #FF0000;">      if (!rst_a_ni) begin</pre>
<pre style="background-color: #FF0000;">        a_req_q   <= '0;</pre>
<pre style="background-color: #FF0000;">        a_write_q <= '0;</pre>
<pre style="background-color: #FF0000;">        a_addr_q  <= '0;</pre>
<pre style="background-color: #FF0000;">        a_wdata_q <= '0;</pre>
<pre style="background-color: #FF0000;">      end else begin</pre>
<pre style="background-color: #FF0000;">        a_req_q   <= a_req_d;</pre>
<pre style="background-color: #FF0000;">        a_write_q <= a_write_d;</pre>
<pre style="background-color: #FF0000;">        a_addr_q  <= a_addr_d;</pre>
<pre style="background-color: #FF0000;">        a_wdata_q <= a_wdata_d;</pre>
<pre style="background-color: #FF0000;">      end</pre>
<pre style="background-color: #FF0000;">      if (!rst_b_ni) begin</pre>
<pre style="background-color: #FF0000;">        b_req_q   <= '0;</pre>
<pre style="background-color: #FF0000;">        b_write_q <= '0;</pre>
<pre style="background-color: #FF0000;">        b_addr_q  <= '0;</pre>
<pre style="background-color: #FF0000;">        b_wdata_q <= '0;</pre>
<pre style="background-color: #FF0000;">      end else begin</pre>
<pre style="background-color: #FF0000;">        b_req_q   <= b_req_d;</pre>
<pre style="background-color: #FF0000;">        b_write_q <= b_write_d;</pre>
<pre style="background-color: #FF0000;">        b_addr_q  <= b_addr_d;</pre>
<pre style="background-color: #FF0000;">        b_wdata_q <= b_wdata_d;</pre>
<pre style="background-color: #FF0000;">      end</pre>
<pre>    assign a_req_q   = a_req_d;</pre>
<pre>    assign a_write_q = a_write_d;</pre>
<pre>    assign a_addr_q  = a_addr_d;</pre>
<pre>    assign a_wdata_q = a_wdata_d;</pre>
<pre></pre>
<pre>    assign b_write_q = b_write_d;</pre>
<pre>    assign b_addr_q  = b_addr_d;</pre>
<pre>    assign b_wdata_q = b_wdata_d;</pre>
<pre>  end</pre>
<pre style="background-color: #FF0000;">    // Put the register slices between ECC decoding to output</pre>
<pre style="background-color: #FF0000;">      if (!rst_a_ni) begin</pre>
<pre style="background-color: #FF0000;">        a_rvalid_q <= '0;</pre>
<pre style="background-color: #FF0000;">        a_rdata_q  <= '0;</pre>
<pre style="background-color: #FF0000;">        a_rerror_q <= '0;</pre>
<pre style="background-color: #FF0000;">      end else begin</pre>
<pre style="background-color: #FF0000;">        a_rvalid_q <= a_rvalid_d;</pre>
<pre style="background-color: #FF0000;">        a_rdata_q  <= a_rdata_d[0+:Width] ;</pre>
<pre style="background-color: #FF0000;">        a_rerror_q <= a_rerror_d;</pre>
<pre style="background-color: #FF0000;">      end</pre>
<pre style="background-color: #FF0000;">      if (!rst_b_ni) begin</pre>
<pre style="background-color: #FF0000;">        b_rvalid_q <= '0;</pre>
<pre style="background-color: #FF0000;">        b_rdata_q  <= '0;</pre>
<pre style="background-color: #FF0000;">        b_rerror_q <= '0;</pre>
<pre style="background-color: #FF0000;">      end else begin</pre>
<pre style="background-color: #FF0000;">        b_rvalid_q <= b_rvalid_d;</pre>
<pre style="background-color: #FF0000;">        b_rdata_q  <= b_rdata_d[0+:Width] ;</pre>
<pre style="background-color: #FF0000;">        b_rerror_q <= b_rerror_d;</pre>
<pre style="background-color: #FF0000;">      end</pre>
<pre>    assign a_rvalid_q = a_rvalid_d;</pre>
<pre>    assign a_rdata_q  = a_rdata_d[0+:Width];</pre>
<pre>    assign a_rerror_q = a_rerror_d;</pre>
<pre></pre>
<pre>    assign b_rdata_q  = b_rdata_d[0+:Width];</pre>
<pre>    assign b_rerror_q = b_rerror_d;</pre>
<pre>  end</pre>
<h3>hw/ip/prim/rtl/prim_secded_39_32_enc.sv</h3>
<pre>  input        [31:0] in,</pre>
<pre>  output logic [38:0] out</pre>
<pre>  assign out[0] = in[0] ;</pre>
<pre>  assign out[1] = in[1] ;</pre>
<pre>  assign out[2] = in[2] ;</pre>
<pre>  assign out[3] = in[3] ;</pre>
<pre>  assign out[4] = in[4] ;</pre>
<pre>  assign out[5] = in[5] ;</pre>
<pre>  assign out[6] = in[6] ;</pre>
<pre>  assign out[7] = in[7] ;</pre>
<pre>  assign out[8] = in[8] ;</pre>
<pre>  assign out[9] = in[9] ;</pre>
<pre>  assign out[10] = in[10] ;</pre>
<pre>  assign out[11] = in[11] ;</pre>
<pre>  assign out[12] = in[12] ;</pre>
<pre>  assign out[13] = in[13] ;</pre>
<pre>  assign out[14] = in[14] ;</pre>
<pre>  assign out[15] = in[15] ;</pre>
<pre>  assign out[16] = in[16] ;</pre>
<pre>  assign out[17] = in[17] ;</pre>
<pre>  assign out[18] = in[18] ;</pre>
<pre>  assign out[19] = in[19] ;</pre>
<pre>  assign out[20] = in[20] ;</pre>
<pre>  assign out[21] = in[21] ;</pre>
<pre>  assign out[22] = in[22] ;</pre>
<pre>  assign out[23] = in[23] ;</pre>
<pre>  assign out[24] = in[24] ;</pre>
<pre>  assign out[25] = in[25] ;</pre>
<pre>  assign out[26] = in[26] ;</pre>
<pre>  assign out[27] = in[27] ;</pre>
<pre>  assign out[28] = in[28] ;</pre>
<pre>  assign out[29] = in[29] ;</pre>
<pre>  assign out[30] = in[30] ;</pre>
<pre>  assign out[31] = in[31] ;</pre>
<pre>  assign out[32] = in[2] ^ in[3] ^ in[7] ^ in[8] ^ in[14] ^ in[15] ^ in[16]</pre>
<pre>                  ^ in[18] ^ in[19] ^ in[23] ^ in[24] ^ in[28] ^ in[29] ;</pre>
<pre>  assign out[33] = in[3] ^ in[6] ^ in[8] ^ in[12] ^ in[13] ^ in[15] ^ in[17]</pre>
<pre>                  ^ in[19] ^ in[21] ^ in[25] ^ in[27] ^ in[29] ^ in[30] ^ in[31] ;</pre>
<pre>  assign out[34] = in[0] ^ in[5] ^ in[7] ^ in[9] ^ in[10] ^ in[12] ^ in[13]</pre>
<pre>                  ^ in[15] ^ in[16] ^ in[22] ^ in[23] ^ in[26] ^ in[27] ^ in[31] ;</pre>
<pre>  assign out[35] = in[0] ^ in[1] ^ in[4] ^ in[6] ^ in[9] ^ in[11] ^ in[12]</pre>
<pre>                  ^ in[14] ^ in[22] ^ in[23] ^ in[25] ^ in[28] ^ in[29] ^ in[30]</pre>
<pre>  assign out[36] = in[0] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[11] ^ in[17]</pre>
<pre>                  ^ in[20] ^ in[24] ^ in[26] ^ in[27] ^ in[30] ;</pre>
<pre>  assign out[37] = in[1] ^ in[2] ^ in[4] ^ in[6] ^ in[10] ^ in[13] ^ in[14]</pre>
<pre>                  ^ in[16] ^ in[18] ^ in[19] ^ in[20] ^ in[21] ^ in[22] ^ in[26]</pre>
<pre>  assign out[38] = in[1] ^ in[5] ^ in[7] ^ in[8] ^ in[9] ^ in[10] ^ in[11]</pre>
<pre>                  ^ in[17] ^ in[18] ^ in[20] ^ in[21] ^ in[24] ^ in[25] ^ in[28]</pre>
<pre>                  ^ in[31] ;</pre>
<h3>hw/ip/prim/rtl/prim_arbiter_tree.sv</h3>
<pre>module prim_arbiter_tree #(</pre>
<pre>  parameter int unsigned N  = 4,</pre>
<pre>  parameter int unsigned DW = 32,</pre>
<pre>  parameter bit Lock      = 1'b1</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input        [ N-1:0]        req_i,</pre>
<pre>  input        [DW-1:0]        data_i [N],</pre>
<pre>  output logic [ N-1:0]        gnt_o,</pre>
<pre>  output logic [$clog2(N)-1:0] idx_o,</pre>
<pre>  output logic          valid_o,</pre>
<pre>  output logic [DW-1:0] data_o,</pre>
<pre>  input                 ready_i</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">    assign data_o   = data_i[0];</pre>
<pre style="background-color: #FF0000;">    assign gnt_o[0] = valid_o & ready_i;</pre>
<pre style="background-color: #FF0000;">    assign idx_o    = '0;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre></pre>
<pre>    logic [N-1:0]                             req;</pre>
<pre style="background-color: #FF0000;">    logic [2**(N_LEVELS+1)-2:0]               req_tree;</pre>
<pre style="background-color: #FF0000;">    logic [2**(N_LEVELS+1)-2:0]               gnt_tree;</pre>
<pre style="background-color: #FF0000;">    logic [2**(N_LEVELS+1)-2:0][N_LEVELS-1:0] idx_tree;</pre>
<pre style="background-color: #FF0000;">    logic [2**(N_LEVELS+1)-2:0][DW-1:0]       data_tree;</pre>
<pre style="background-color: #FF0000;">    logic [N_LEVELS-1:0]                      rr_q;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>      logic [N-1:0]        mask_d, mask_q;</pre>
<pre>      // if the request cannot be served, we store the current request bits</pre>
<pre>      assign req    = mask_q & req_i;</pre>
<pre></pre>
<pre>        if (!rst_ni) begin</pre>
<pre>          mask_q  <= {N{1'b1}};</pre>
<pre>        end else begin</pre>
<pre>          mask_q  <= mask_d;</pre>
<pre>        end</pre>
<pre style="background-color: #FF0000;">      assign req = req_i;</pre>
<pre style="background-color: #FF0000;">    end</pre>
<pre>      //</pre>
<pre>      localparam int unsigned base1 = (2**(level+1))-1;</pre>
<pre></pre>
<pre>        localparam int unsigned pa = base0 + offset;</pre>
<pre>        localparam int unsigned c0 = base1 + 2*offset;</pre>
<pre>        localparam int unsigned c1 = base1 + 2*offset + 1;</pre>
<pre></pre>
<pre>          if (offset < N) begin : gen_assign</pre>
<pre>            // forward path</pre>
<pre>            assign idx_tree[pa]  = offset;</pre>
<pre>            assign data_tree[pa] = data_i[offset];</pre>
<pre>            // backward (grant) path</pre>
<pre>          end else begin : gen_tie_off</pre>
<pre style="background-color: #FF0000;">            // forward path</pre>
<pre style="background-color: #FF0000;">            assign idx_tree[pa]  = '0;</pre>
<pre style="background-color: #FF0000;">            assign data_tree[pa] = '0;</pre>
<pre style="background-color: #FF0000;">          end</pre>
<pre>          // NOTE: the code below has been written in this way in order to work</pre>
<pre style="background-color: #FF0000;">          // this performs a (local) round robin arbitration using the associated rr counter bit</pre>
<pre>          // propagate requests</pre>
<pre>          // muxes</pre>
<pre>          assign data_tree[pa] = ({DW{sel}} & data_tree[c1])       | ({DW{~sel}} & data_tree[c0]);</pre>
<pre>          // backward (grant) path</pre>
<pre>          assign gnt_tree[c1] = gnt_tree[pa] &  sel;</pre>
<pre>        end</pre>
<pre style="background-color: #FF0000;">    end : gen_tree</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>    assign data_o      = data_tree[0];</pre>
<pre>    assign valid_o     = req_tree[0];</pre>
<pre>    // propagate the grant back to the requestors</pre>
<pre></pre>
<pre>      if (!rst_ni) begin</pre>
<pre>        rr_q <= '0;</pre>
<pre>      end else begin</pre>
<pre>        if (gnt_tree[0] && (rr_q == N-1)) begin</pre>
<pre>          rr_q <= '0;</pre>
<pre>        end else if (gnt_tree[0]) begin</pre>
<pre>          rr_q <= rr_q + 1'b1;</pre>
<pre>        end</pre>
<h3>hw/ip/prim/rtl/prim_secded_39_32_dec.sv</h3>
<pre>  input        [38:0] in,</pre>
<pre>  output logic [31:0] d_o,</pre>
<pre>  output logic [6:0] syndrome_o,</pre>
<pre>  output logic [1:0] err_o</pre>
<pre>  logic single_error;</pre>
<pre>  assign syndrome_o[0] = in[32] ^  in[2] ^ in[3] ^ in[7] ^ in[8] ^ in[14] ^ in[15]</pre>
<pre>                  ^ in[16] ^ in[18] ^ in[19] ^ in[23] ^ in[24] ^ in[28] ^ in[29]</pre>
<pre>  assign syndrome_o[1] = in[33] ^  in[3] ^ in[6] ^ in[8] ^ in[12] ^ in[13] ^ in[15]</pre>
<pre>                  ^ in[17] ^ in[19] ^ in[21] ^ in[25] ^ in[27] ^ in[29] ^ in[30]</pre>
<pre>                  ^ in[31] ;</pre>
<pre>  assign syndrome_o[2] = in[34] ^  in[0] ^ in[5] ^ in[7] ^ in[9] ^ in[10] ^ in[12]</pre>
<pre>                  ^ in[13] ^ in[15] ^ in[16] ^ in[22] ^ in[23] ^ in[26] ^ in[27]</pre>
<pre>                  ^ in[31] ;</pre>
<pre>  assign syndrome_o[3] = in[35] ^  in[0] ^ in[1] ^ in[4] ^ in[6] ^ in[9] ^ in[11]</pre>
<pre>                  ^ in[12] ^ in[14] ^ in[22] ^ in[23] ^ in[25] ^ in[28] ^ in[29]</pre>
<pre>                  ^ in[30] ;</pre>
<pre>  assign syndrome_o[4] = in[36] ^  in[0] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[11]</pre>
<pre>                  ^ in[17] ^ in[20] ^ in[24] ^ in[26] ^ in[27] ^ in[30] ;</pre>
<pre>  assign syndrome_o[5] = in[37] ^  in[1] ^ in[2] ^ in[4] ^ in[6] ^ in[10] ^ in[13]</pre>
<pre>                  ^ in[14] ^ in[16] ^ in[18] ^ in[19] ^ in[20] ^ in[21] ^ in[22]</pre>
<pre>                  ^ in[26] ;</pre>
<pre>  assign syndrome_o[6] = in[38] ^  in[1] ^ in[5] ^ in[7] ^ in[8] ^ in[9] ^ in[10]</pre>
<pre>                  ^ in[11] ^ in[17] ^ in[18] ^ in[20] ^ in[21] ^ in[24] ^ in[25]</pre>
<pre>                  ^ in[28] ^ in[31] ;</pre>
<pre>  assign d_o[0] = (syndrome_o == 7'h1c) ^ in[0];</pre>
<pre>  assign d_o[1] = (syndrome_o == 7'h68) ^ in[1];</pre>
<pre>  assign d_o[2] = (syndrome_o == 7'h31) ^ in[2];</pre>
<pre>  assign d_o[3] = (syndrome_o == 7'h13) ^ in[3];</pre>
<pre>  assign d_o[4] = (syndrome_o == 7'h38) ^ in[4];</pre>
<pre>  assign d_o[5] = (syndrome_o == 7'h54) ^ in[5];</pre>
<pre>  assign d_o[6] = (syndrome_o == 7'h2a) ^ in[6];</pre>
<pre>  assign d_o[7] = (syndrome_o == 7'h45) ^ in[7];</pre>
<pre>  assign d_o[8] = (syndrome_o == 7'h43) ^ in[8];</pre>
<pre>  assign d_o[9] = (syndrome_o == 7'h4c) ^ in[9];</pre>
<pre>  assign d_o[10] = (syndrome_o == 7'h64) ^ in[10];</pre>
<pre>  assign d_o[11] = (syndrome_o == 7'h58) ^ in[11];</pre>
<pre>  assign d_o[12] = (syndrome_o == 7'he) ^ in[12];</pre>
<pre>  assign d_o[13] = (syndrome_o == 7'h26) ^ in[13];</pre>
<pre>  assign d_o[14] = (syndrome_o == 7'h29) ^ in[14];</pre>
<pre>  assign d_o[15] = (syndrome_o == 7'h7) ^ in[15];</pre>
<pre>  assign d_o[16] = (syndrome_o == 7'h25) ^ in[16];</pre>
<pre>  assign d_o[17] = (syndrome_o == 7'h52) ^ in[17];</pre>
<pre>  assign d_o[18] = (syndrome_o == 7'h61) ^ in[18];</pre>
<pre>  assign d_o[19] = (syndrome_o == 7'h23) ^ in[19];</pre>
<pre>  assign d_o[20] = (syndrome_o == 7'h70) ^ in[20];</pre>
<pre>  assign d_o[21] = (syndrome_o == 7'h62) ^ in[21];</pre>
<pre>  assign d_o[22] = (syndrome_o == 7'h2c) ^ in[22];</pre>
<pre>  assign d_o[23] = (syndrome_o == 7'hd) ^ in[23];</pre>
<pre>  assign d_o[24] = (syndrome_o == 7'h51) ^ in[24];</pre>
<pre>  assign d_o[25] = (syndrome_o == 7'h4a) ^ in[25];</pre>
<pre>  assign d_o[26] = (syndrome_o == 7'h34) ^ in[26];</pre>
<pre>  assign d_o[27] = (syndrome_o == 7'h16) ^ in[27];</pre>
<pre>  assign d_o[28] = (syndrome_o == 7'h49) ^ in[28];</pre>
<pre>  assign d_o[29] = (syndrome_o == 7'hb) ^ in[29];</pre>
<pre>  assign d_o[30] = (syndrome_o == 7'h1a) ^ in[30];</pre>
<pre>  assign d_o[31] = (syndrome_o == 7'h46) ^ in[31];</pre>
<pre>  assign single_error = ^syndrome_o;</pre>
<pre>  assign err_o[0] =  single_error;</pre>
<pre>  assign err_o[1] = ~single_error & (|syndrome_o);</pre>
<h3>hw/ip/prim/rtl/prim_ram_2p_adv.sv</h3>
<pre>module prim_ram_2p_adv #(</pre>
<pre>  parameter int Depth = 512,</pre>
<pre>  parameter int Width = 32,</pre>
<pre>  parameter int CfgW = 8,     // WTC, RTC, etc</pre>
<pre>  parameter bit EnableECC            = 0,</pre>
<pre>  parameter bit EnableParity         = 0,</pre>
<pre>  parameter bit EnableInputPipeline  = 0,</pre>
<pre>  parameter bit EnableOutputPipeline = 0,</pre>
<pre>  parameter MemT = "REGISTER", // can be "REGISTER" or "SRAM"</pre>
<pre>  parameter int SramAw = $clog2(Depth)</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input                     a_req_i,</pre>
<pre>  input                     a_write_i,</pre>
<pre>  input        [SramAw-1:0] a_addr_i,</pre>
<pre>  input        [Width-1:0]  a_wdata_i,</pre>
<pre>  output logic              a_rvalid_o,</pre>
<pre>  output logic [Width-1:0]  a_rdata_o,</pre>
<pre>  output logic [1:0]        a_rerror_o,</pre>
<pre>  input                     b_req_i,</pre>
<pre>  input                     b_write_i,</pre>
<pre>  input        [SramAw-1:0] b_addr_i,</pre>
<pre>  input        [Width-1:0]  b_wdata_i,</pre>
<pre>  output logic              b_rvalid_o,</pre>
<pre>  output logic [Width-1:0]  b_rdata_o,</pre>
<pre>  output logic [1:0]        b_rerror_o, // Bit1: Uncorrectable, Bit0: Correctable</pre>
<pre>  input [CfgW-1:0] cfg_i</pre>
<pre>  localparam int ParWidth  = (EnableParity) ? 1 :</pre>
<pre>                             (!EnableECC)   ? 0 :</pre>
<pre>                             (Width <=   4) ? 4 :</pre>
<pre>                             (Width <=  11) ? 5 :</pre>
<pre>                             (Width <=  26) ? 6 :</pre>
<pre>                             (Width <=  57) ? 7 :</pre>
<pre>                             (Width <= 120) ? 8 : 8 ;</pre>
<pre>  localparam int TotalWidth = Width + ParWidth;</pre>
<pre>  logic                  a_req_q,    a_req_d ;</pre>
<pre>  logic                  a_write_q,  a_write_d ;</pre>
<pre>  logic [SramAw-1:0]     a_addr_q,   a_addr_d ;</pre>
<pre>  logic [TotalWidth-1:0] a_wdata_q,  a_wdata_d ;</pre>
<pre>  logic                  a_rvalid_q, a_rvalid_d, a_rvalid_sram ;</pre>
<pre>  logic [Width-1:0]      a_rdata_q,  a_rdata_d ;</pre>
<pre>  logic [TotalWidth-1:0] a_rdata_sram ;</pre>
<pre>  logic [1:0]            a_rerror_q, a_rerror_d ;</pre>
<pre>  logic                  b_req_q,    b_req_d ;</pre>
<pre>  logic                  b_write_q,  b_write_d ;</pre>
<pre>  logic [SramAw-1:0]     b_addr_q,   b_addr_d ;</pre>
<pre>  logic [TotalWidth-1:0] b_wdata_q,  b_wdata_d ;</pre>
<pre>  logic                  b_rvalid_q, b_rvalid_d, b_rvalid_sram ;</pre>
<pre>  logic [Width-1:0]      b_rdata_q,  b_rdata_d ;</pre>
<pre>  logic [TotalWidth-1:0] b_rdata_sram ;</pre>
<pre>  logic [1:0]            b_rerror_q, b_rerror_d ;</pre>
<pre style="background-color: #FF0000;">  if (MemT == "REGISTER") begin : gen_regmem</pre>
<pre style="background-color: #FF0000;">    prim_ram_2p #(</pre>
<pre style="background-color: #FF0000;">      .Width (TotalWidth),</pre>
<pre style="background-color: #FF0000;">      .Depth (Depth),</pre>
<pre style="background-color: #FF0000;">      .Impl(prim_pkg::ImplGeneric)</pre>
<pre style="background-color: #FF0000;">    ) u_mem (</pre>
<pre style="background-color: #FF0000;">      .clk_a_i    (clk_i),</pre>
<pre style="background-color: #FF0000;">      .clk_b_i    (clk_i),</pre>
<pre style="background-color: #FF0000;">      .a_req_i    (a_req_q),</pre>
<pre style="background-color: #FF0000;">      .a_write_i  (a_write_q),</pre>
<pre style="background-color: #FF0000;">      .a_addr_i   (a_addr_q),</pre>
<pre style="background-color: #FF0000;">      .a_wdata_i  (a_wdata_q),</pre>
<pre style="background-color: #FF0000;">      .a_rdata_o  (a_rdata_sram),</pre>
<pre style="background-color: #FF0000;">      .b_req_i    (b_req_q),</pre>
<pre style="background-color: #FF0000;">      .b_write_i  (b_write_q),</pre>
<pre style="background-color: #FF0000;">      .b_addr_i   (b_addr_q),</pre>
<pre style="background-color: #FF0000;">      .b_wdata_i  (b_wdata_q),</pre>
<pre style="background-color: #FF0000;">      .b_rdata_o  (b_rdata_sram)</pre>
<pre style="background-color: #FF0000;">  end else if (MemT == "SRAM") begin : gen_srammem</pre>
<pre>    prim_ram_2p #(</pre>
<pre>      .Width (TotalWidth),</pre>
<pre>      .Depth (Depth)</pre>
<pre style="background-color: #FF0000;">    ) u_mem (</pre>
<pre>      .clk_a_i    (clk_i),</pre>
<pre>      .clk_b_i    (clk_i),</pre>
<pre>      .a_req_i    (a_req_q),</pre>
<pre>      .a_write_i  (a_write_q),</pre>
<pre>      .a_addr_i   (a_addr_q),</pre>
<pre>      .a_wdata_i  (a_wdata_q),</pre>
<pre>      .a_rdata_o  (a_rdata_sram),</pre>
<pre>      .b_req_i    (b_req_q),</pre>
<pre>      .b_write_i  (b_write_q),</pre>
<pre>      .b_addr_i   (b_addr_q),</pre>
<pre>      .b_wdata_i  (b_wdata_q),</pre>
<pre>      .b_rdata_o  (b_rdata_sram)</pre>
<pre> always_ff @(posedge clk_i, negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>       a_rvalid_sram <= '0;</pre>
<pre>       b_rvalid_sram <= '0;</pre>
<pre>    end else begin</pre>
<pre>      a_rvalid_sram <= a_req_q & ~a_write_q;</pre>
<pre>      b_rvalid_sram <= b_req_q & ~b_write_q;</pre>
<pre>  assign a_req_d              = a_req_i;</pre>
<pre>  assign a_write_d            = a_write_i;</pre>
<pre>  assign a_addr_d             = a_addr_i;</pre>
<pre>  assign a_rvalid_o           = a_rvalid_q;</pre>
<pre>  assign a_rdata_o            = a_rdata_q;</pre>
<pre>  assign a_rerror_o           = a_rerror_q;</pre>
<pre>  assign b_req_d              = b_req_i;</pre>
<pre>  assign b_write_d            = b_write_i;</pre>
<pre>  assign b_addr_d             = b_addr_i;</pre>
<pre>  assign b_rvalid_o           = b_rvalid_q;</pre>
<pre>  assign b_rdata_o            = b_rdata_q;</pre>
<pre>  assign b_rerror_o           = b_rerror_q;</pre>
<pre></pre>
<pre>      prim_secded_39_32_enc u_enc_a (.in(a_wdata_i), .out(a_wdata_d));</pre>
<pre>      prim_secded_39_32_dec u_dec_a (</pre>
<pre>        .in         (a_rdata_sram),</pre>
<pre>        .d_o        (a_rdata_d),</pre>
<pre>        .syndrome_o (),</pre>
<pre>        .err_o      (a_rerror_d)</pre>
<pre>      );</pre>
<pre>      prim_secded_39_32_dec u_dec_b (</pre>
<pre>        .in         (b_rdata_sram),</pre>
<pre>        .d_o        (b_rdata_d),</pre>
<pre>        .syndrome_o (),</pre>
<pre>        .err_o      (b_rerror_d)</pre>
<pre>      );</pre>
<pre>      assign b_rvalid_d = b_rvalid_sram;</pre>
<pre>    end</pre>
<pre style="background-color: #FF0000;">    assign a_wdata_d[0+:Width] = a_wdata_i;</pre>
<pre style="background-color: #FF0000;">    assign b_wdata_d[0+:Width] = b_wdata_i;</pre>
<pre style="background-color: #FF0000;">    assign a_rdata_d  = a_rdata_sram;</pre>
<pre style="background-color: #FF0000;">    assign b_rdata_d  = b_rdata_sram;</pre>
<pre style="background-color: #FF0000;">    assign a_rvalid_d = a_rvalid_sram;</pre>
<pre style="background-color: #FF0000;">    assign b_rvalid_d = b_rvalid_sram;</pre>
<pre style="background-color: #FF0000;">    assign a_rerror_d = 2'b00;</pre>
<pre style="background-color: #FF0000;">    assign b_rerror_d = 2'b00;</pre>
<pre style="background-color: #FF0000;">  end</pre>
<pre style="background-color: #FF0000;">    // Put the register slices between ECC encoding to SRAM port</pre>
<pre style="background-color: #FF0000;">      if (!rst_ni) begin</pre>
<pre style="background-color: #FF0000;">        a_req_q   <= '0;</pre>
<pre style="background-color: #FF0000;">        a_write_q <= '0;</pre>
<pre style="background-color: #FF0000;">        a_addr_q  <= '0;</pre>
<pre style="background-color: #FF0000;">        a_wdata_q <= '0;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        b_write_q <= '0;</pre>
<pre style="background-color: #FF0000;">        b_addr_q  <= '0;</pre>
<pre style="background-color: #FF0000;">        b_wdata_q <= '0;</pre>
<pre style="background-color: #FF0000;">      end else begin</pre>
<pre style="background-color: #FF0000;">        a_req_q   <= a_req_d;</pre>
<pre style="background-color: #FF0000;">        a_write_q <= a_write_d;</pre>
<pre style="background-color: #FF0000;">        a_addr_q  <= a_addr_d;</pre>
<pre style="background-color: #FF0000;">        a_wdata_q <= a_wdata_d;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        b_write_q <= b_write_d;</pre>
<pre style="background-color: #FF0000;">        b_addr_q  <= b_addr_d;</pre>
<pre style="background-color: #FF0000;">        b_wdata_q <= b_wdata_d;</pre>
<pre style="background-color: #FF0000;">      end</pre>
<pre>    assign a_req_q   = a_req_d;</pre>
<pre>    assign a_write_q = a_write_d;</pre>
<pre>    assign a_addr_q  = a_addr_d;</pre>
<pre>    assign a_wdata_q = a_wdata_d;</pre>
<pre></pre>
<pre>    assign b_write_q = b_write_d;</pre>
<pre>    assign b_addr_q  = b_addr_d;</pre>
<pre>    assign b_wdata_q = b_wdata_d;</pre>
<pre>  end</pre>
<pre style="background-color: #FF0000;">    // Put the register slices between ECC decoding to output</pre>
<pre style="background-color: #FF0000;">      if (!rst_ni) begin</pre>
<pre style="background-color: #FF0000;">        a_rvalid_q <= '0;</pre>
<pre style="background-color: #FF0000;">        a_rdata_q  <= '0;</pre>
<pre style="background-color: #FF0000;">        a_rerror_q <= '0;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        b_rdata_q  <= '0;</pre>
<pre style="background-color: #FF0000;">        b_rerror_q <= '0;</pre>
<pre style="background-color: #FF0000;">      end else begin</pre>
<pre style="background-color: #FF0000;">        a_rvalid_q <= a_rvalid_d;</pre>
<pre style="background-color: #FF0000;">        a_rdata_q  <= a_rdata_d ;</pre>
<pre style="background-color: #FF0000;">        a_rerror_q <= a_rerror_d;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">        b_rdata_q  <= b_rdata_d ;</pre>
<pre style="background-color: #FF0000;">        b_rerror_q <= b_rerror_d;</pre>
<pre style="background-color: #FF0000;">      end</pre>
<pre>    assign a_rvalid_q = a_rvalid_d;</pre>
<pre>    assign a_rdata_q  = a_rdata_d;</pre>
<pre>    assign a_rerror_q = a_rerror_d;</pre>
<pre></pre>
<pre>    assign b_rdata_q  = b_rdata_d;</pre>
<pre>    assign b_rerror_q = b_rerror_d;</pre>
<pre>  end</pre>
<h3>hw/ip/prim/rtl/prim_intr_hw.sv</h3>
<pre>  input  [Width-1:0]  event_intr_i,</pre>
<pre>  input  [Width-1:0]  reg2hw_intr_enable_q_i,</pre>
<pre>  input  [Width-1:0]  reg2hw_intr_test_q_i,</pre>
<pre>  input               reg2hw_intr_test_qe_i,</pre>
<pre>  input  [Width-1:0]  reg2hw_intr_state_q_i,</pre>
<pre>  output              hw2reg_intr_state_de_o,</pre>
<pre>  output [Width-1:0]  hw2reg_intr_state_d_o,</pre>
<pre>  output [Width-1:0]  intr_o</pre>
<pre>  logic  [Width-1:0]    new_event;</pre>
<pre>  assign new_event =</pre>
<pre>             (({Width{reg2hw_intr_test_qe_i}} & reg2hw_intr_test_q_i) | event_intr_i);</pre>
<pre>  assign hw2reg_intr_state_de_o = |new_event;</pre>
<pre>  assign hw2reg_intr_state_d_o  =  new_event | reg2hw_intr_state_q_i;</pre>
<pre>  assign intr_o = reg2hw_intr_state_q_i & reg2hw_intr_enable_q_i;</pre>
<h3>hw/ip/prim/rtl/prim_subreg_ext.sv</h3>
<pre>module prim_subreg_ext #(</pre>
<pre>  parameter int unsigned DW = 32</pre>
<pre>  input          re,</pre>
<pre>  input          we,</pre>
<pre>  input [DW-1:0] wd,</pre>
<pre>  input [DW-1:0] d,</pre>
<pre>  output logic          qe,</pre>
<pre>  output logic          qre,</pre>
<pre>  output logic [DW-1:0] q,</pre>
<pre>  output logic [DW-1:0] qs</pre>
<pre>  assign qs = d;</pre>
<pre>  assign q = wd;</pre>
<pre>  assign qe = we;</pre>
<pre>  assign qre = re;</pre>
<h3>hw/ip/prim/rtl/prim_clock_inverter.sv</h3>
<pre>module prim_clock_inverter #(</pre>
<pre>  parameter bit HasScanMode = 1'b1</pre>
<pre>  input        clk_i,</pre>
<pre>  input        scanmode_i,</pre>
<pre>  output logic clk_no      // Inverted</pre>
<pre>  if (HasScanMode) begin : gen_scan</pre>
<pre>    prim_clock_mux2 i_dft_tck_mux (</pre>
<pre>     .clk0_i ( ~clk_i     ),</pre>
<pre>     .clk1_i ( clk_i      ), // bypass the inverted clock for testing</pre>
<pre>     .sel_i  ( scanmode_i ),</pre>
<pre>     .clk_o  ( clk_no     )</pre>
<pre style="background-color: #FF0000;">  end else begin : gen_noscan</pre>
<pre style="background-color: #FF0000;">    logic unused_scanmode;</pre>
<pre style="background-color: #FF0000;">    assign unused_scanmode = scanmode_i;</pre>
<pre style="background-color: #FF0000;">    assign clk_no = ~clk_i;</pre>
<h3>hw/ip/prim/rtl/prim_esc_receiver.sv</h3>
<pre>  input           clk_i,</pre>
<pre>  input           rst_ni,</pre>
<pre>  output logic    esc_en_o,</pre>
<pre>  output esc_rx_t esc_rx_o,</pre>
<pre>  input esc_tx_t  esc_tx_i</pre>
<pre>  logic esc_level, sigint_detected;</pre>
<pre>  prim_diff_decode #(</pre>
<pre>    .AsyncOn(1'b0)</pre>
<pre style="background-color: #FF0000;">  ) i_decode_esc (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .diff_pi  ( esc_tx_i.esc_p  ),</pre>
<pre>    .diff_ni  ( esc_tx_i.esc_n  ),</pre>
<pre>    .level_o  ( esc_level       ),</pre>
<pre>    .rise_o   (                 ),</pre>
<pre>    .fall_o   (                 ),</pre>
<pre>    .event_o  (                 ),</pre>
<pre>    .sigint_o ( sigint_detected )</pre>
<pre>  typedef enum logic [2:0] {Idle, Check, PingResp, EscResp, SigInt} state_e;</pre>
<pre>  state_e state_d, state_q;</pre>
<pre>  logic resp_pd, resp_pq, resp_nd, resp_nq;</pre>
<pre>  assign esc_rx_o.resp_p = resp_pq;</pre>
<pre>  assign esc_rx_o.resp_n = resp_nq;</pre>
<pre>  always_comb begin : p_fsm</pre>
<pre>    state_d  = state_q;</pre>
<pre>    resp_pd  = 1'b0;</pre>
<pre>    resp_nd  = 1'b1;</pre>
<pre>    esc_en_o = 1'b0;</pre>
<pre>    unique case (state_q)</pre>
<pre>      Idle: begin</pre>
<pre>        if (esc_level) begin</pre>
<pre>          state_d = Check;</pre>
<pre>          resp_pd = 1'b1;</pre>
<pre>          resp_nd = 1'b0;</pre>
<pre>      Check: begin</pre>
<pre>        state_d = PingResp;</pre>
<pre>        if (esc_level) begin</pre>
<pre>          state_d  = EscResp;</pre>
<pre>          esc_en_o = 1'b1;</pre>
<pre>      PingResp: begin</pre>
<pre>        state_d = Idle;</pre>
<pre>        resp_pd = 1'b1;</pre>
<pre>        resp_nd = 1'b0;</pre>
<pre>        if (esc_level) begin</pre>
<pre>          state_d  = EscResp;</pre>
<pre>          esc_en_o = 1'b1;</pre>
<pre>      EscResp: begin</pre>
<pre>        state_d = Idle;</pre>
<pre>        if (esc_level) begin</pre>
<pre>          state_d  = EscResp;</pre>
<pre>          resp_pd  = ~resp_pq;</pre>
<pre>          resp_nd  = resp_pq;</pre>
<pre>          esc_en_o = 1'b1;</pre>
<pre>      SigInt: begin</pre>
<pre>        state_d = Idle;</pre>
<pre>        if (sigint_detected) begin</pre>
<pre>          state_d = SigInt;</pre>
<pre>          resp_pd = ~resp_pq;</pre>
<pre>          resp_nd = ~resp_pq;</pre>
<pre>      default : state_d = Idle;</pre>
<pre>    if (sigint_detected && (state_q != SigInt)) begin</pre>
<pre>      state_d  = SigInt;</pre>
<pre>      resp_pd  = 1'b0;</pre>
<pre>      resp_nd  = 1'b0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      state_q <= Idle;</pre>
<pre>      resp_pq <= 1'b0;</pre>
<pre>      resp_nq <= 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      state_q <= state_d;</pre>
<pre>      resp_pq <= resp_pd;</pre>
<pre>      resp_nq <= resp_nd;</pre>
<pre style="background-color: #FF0000;">endmodule : prim_esc_receiver</pre>
<h3>hw/ip/prim/rtl/prim_alert_sender.sv</h3>
<pre>module prim_alert_sender import prim_pkg::*; #(</pre>
<pre>  parameter bit AsyncOn = 1'b1</pre>
<pre>  input             clk_i,</pre>
<pre>  input             rst_ni,</pre>
<pre>  input             alert_i,</pre>
<pre>  input alert_rx_t  alert_rx_i,</pre>
<pre>  output alert_tx_t alert_tx_o</pre>
<pre>  logic ping_sigint, ping_event;</pre>
<pre>  prim_diff_decode #(</pre>
<pre>    .AsyncOn(AsyncOn)</pre>
<pre style="background-color: #FF0000;">  ) i_decode_ping (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .diff_pi  ( alert_rx_i.ping_p     ),</pre>
<pre>    .diff_ni  ( alert_rx_i.ping_n     ),</pre>
<pre>    .level_o  (             ),</pre>
<pre>    .rise_o   (             ),</pre>
<pre>    .fall_o   (             ),</pre>
<pre>    .event_o  ( ping_event  ),</pre>
<pre>    .sigint_o ( ping_sigint )</pre>
<pre>  logic ack_sigint, ack_level;</pre>
<pre>  prim_diff_decode #(</pre>
<pre>    .AsyncOn(AsyncOn)</pre>
<pre style="background-color: #FF0000;">  ) i_decode_ack (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .diff_pi  ( alert_rx_i.ack_p      ),</pre>
<pre>    .diff_ni  ( alert_rx_i.ack_n      ),</pre>
<pre>    .level_o  ( ack_level   ),</pre>
<pre>    .rise_o   (             ),</pre>
<pre>    .fall_o   (             ),</pre>
<pre>    .event_o  (             ),</pre>
<pre>    .sigint_o ( ack_sigint  )</pre>
<pre>  typedef enum logic [2:0] {Idle, HsPhase1, HsPhase2, SigInt, Pause0, Pause1} state_e;</pre>
<pre>  state_e state_d, state_q;</pre>
<pre>  logic alert_pq, alert_nq, alert_pd, alert_nd;</pre>
<pre>  logic sigint_detected;</pre>
<pre>  assign sigint_detected = ack_sigint | ping_sigint;</pre>
<pre>  assign alert_tx_o.alert_p = alert_pq;</pre>
<pre>  assign alert_tx_o.alert_n = alert_nq;</pre>
<pre>  logic alert_set_d, alert_set_q, alert_clr;</pre>
<pre>  logic ping_set_d, ping_set_q, ping_clr;</pre>
<pre>  assign alert_set_d = (alert_clr) ? 1'b0 :  (alert_set_q | alert_i);</pre>
<pre>  assign ping_set_d  = (ping_clr) ? 1'b0 : (ping_set_q | ping_event);</pre>
<pre>  always_comb begin : p_fsm</pre>
<pre>    state_d = state_q;</pre>
<pre>    alert_pd   = 1'b0;</pre>
<pre>    alert_nd   = 1'b1;</pre>
<pre>    ping_clr   = 1'b0;</pre>
<pre>    alert_clr  = 1'b0;</pre>
<pre>    unique case (state_q)</pre>
<pre>      Idle: begin</pre>
<pre>        if (alert_i || alert_set_q || ping_event || ping_set_q) begin</pre>
<pre>          state_d   = HsPhase1;</pre>
<pre>          alert_pd  = 1'b1;</pre>
<pre>          alert_nd  = 1'b0;</pre>
<pre>          if (ping_event || ping_set_q) begin</pre>
<pre>            ping_clr  = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            alert_clr = 1'b1;</pre>
<pre>      HsPhase1: begin</pre>
<pre>        if (ack_level) begin</pre>
<pre>          state_d  = HsPhase2;</pre>
<pre>        end else begin</pre>
<pre>          alert_pd = 1'b1;</pre>
<pre>          alert_nd = 1'b0;</pre>
<pre>      HsPhase2: begin</pre>
<pre>        if (!ack_level) begin</pre>
<pre>          state_d = Pause0;</pre>
<pre>      Pause0: state_d = Pause1;</pre>
<pre>      Pause1: state_d = Idle;</pre>
<pre>      SigInt: begin</pre>
<pre>        state_d  = Idle;</pre>
<pre>        if (sigint_detected) begin</pre>
<pre>          state_d  = SigInt;</pre>
<pre>          alert_pd = ~alert_pq;</pre>
<pre>          alert_nd = ~alert_pq;</pre>
<pre>      default : state_d = Idle;</pre>
<pre>    if (sigint_detected && (state_q != SigInt)) begin</pre>
<pre>      state_d   = SigInt;</pre>
<pre>      alert_pd  = 1'b0;</pre>
<pre>      alert_nd  = 1'b0;</pre>
<pre>      ping_clr  = 1'b0;</pre>
<pre>      alert_clr = 1'b0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : p_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      state_q     <= Idle;</pre>
<pre>      alert_pq    <= 1'b0;</pre>
<pre>      alert_nq    <= 1'b1;</pre>
<pre>      alert_set_q <= 1'b0;</pre>
<pre>      ping_set_q  <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      state_q     <= state_d;</pre>
<pre>      alert_pq    <= alert_pd;</pre>
<pre>      alert_nq    <= alert_nd;</pre>
<pre>      alert_set_q <= alert_set_d;</pre>
<pre>      ping_set_q  <= ping_set_d;</pre>
<pre style="background-color: #FF0000;">    // check propagation of sigint issues to output within three cycles</pre>
<pre>        $rose(alert_tx_o.alert_p), clk_i, !rst_ni || (alert_tx_o.alert_p == alert_tx_o.alert_n))</pre>
<pre style="background-color: #FF0000;">endmodule : prim_alert_sender</pre>
<h3>hw/ip/prim/rtl/prim_fifo_sync.sv</h3>
<pre>module prim_fifo_sync #(</pre>
<pre>  parameter int unsigned Width       = 16,</pre>
<pre>  parameter bit Pass                 = 1'b1, // if == 1 allow requests to pass through empty FIFO</pre>
<pre>  parameter int unsigned Depth       = 4,</pre>
<pre>  localparam int unsigned DepthWNorm = $clog2(Depth+1),</pre>
<pre>  localparam int unsigned DepthW     = (DepthWNorm == 0) ? 1 : DepthWNorm</pre>
<pre>  input                   clk_i,</pre>
<pre>  input                   rst_ni,</pre>
<pre>  input                   clr_i,</pre>
<pre>  input                   wvalid,</pre>
<pre>  output                  wready,</pre>
<pre>  input   [Width-1:0]     wdata,</pre>
<pre>  output                  rvalid,</pre>
<pre>  input                   rready,</pre>
<pre>  output  [Width-1:0]     rdata,</pre>
<pre>  output  [DepthW-1:0]    depth</pre>
<pre>    `ASSERT_INIT(paramCheckPass, Pass == 1)</pre>
<pre></pre>
<pre>    assign rdata = wdata;</pre>
<pre></pre>
<pre></pre>
<pre>    assign unused_clr = clr_i;</pre>
<pre></pre>
<pre></pre>
<pre>    localparam int unsigned PTR_WIDTH = PTRV_W+1;</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    logic                 fifo_incr_wptr, fifo_incr_rptr, fifo_empty;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre style="background-color: #FF0000;">    logic  wptr_msb;</pre>
<pre style="background-color: #FF0000;">    logic  rptr_msb;</pre>
<pre style="background-color: #FF0000;">    logic  [PTRV_W-1:0] wptr_value;</pre>
<pre style="background-color: #FF0000;">    logic  [PTRV_W-1:0] rptr_value;</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>    assign rptr_msb = fifo_rptr[PTR_WIDTH-1];</pre>
<pre>    assign wptr_value = fifo_wptr[0+:PTRV_W];</pre>
<pre>    assign rptr_value = fifo_rptr[0+:PTRV_W];</pre>
<pre>    assign depth = (full)                 ? DepthW'(Depth) :</pre>
<pre>                   (wptr_msb == rptr_msb) ? DepthW'(wptr_value) - DepthW'(rptr_value) :</pre>
<pre>                   (DepthW'(Depth) - DepthW'(rptr_value) + DepthW'(wptr_value)) ;</pre>
<pre></pre>
<pre>    assign fifo_incr_rptr = rvalid & rready;</pre>
<pre></pre>
<pre>    assign rvalid = ~empty;</pre>
<pre></pre>
<pre>      if (!rst_ni) begin</pre>
<pre>        fifo_wptr <= {(PTR_WIDTH){1'b0}};</pre>
<pre>      end else if (clr_i) begin</pre>
<pre>        fifo_wptr <= {(PTR_WIDTH){1'b0}};</pre>
<pre>      end else if (fifo_incr_wptr) begin</pre>
<pre>        if (fifo_wptr[PTR_WIDTH-2:0] == (Depth-1)) begin</pre>
<pre>          fifo_wptr <= {~fifo_wptr[PTR_WIDTH-1],{(PTR_WIDTH-1){1'b0}}};</pre>
<pre>        end else begin</pre>
<pre>          fifo_wptr <= fifo_wptr + {{(PTR_WIDTH-1){1'b0}},1'b1};</pre>
<pre>        end</pre>
<pre>      if (!rst_ni) begin</pre>
<pre>        fifo_rptr <= {(PTR_WIDTH){1'b0}};</pre>
<pre>      end else if (clr_i) begin</pre>
<pre>        fifo_rptr <= {(PTR_WIDTH){1'b0}};</pre>
<pre>      end else if (fifo_incr_rptr) begin</pre>
<pre>        if (fifo_rptr[PTR_WIDTH-2:0] == (Depth-1)) begin</pre>
<pre>          fifo_rptr <= {~fifo_rptr[PTR_WIDTH-1],{(PTR_WIDTH-1){1'b0}}};</pre>
<pre>        end else begin</pre>
<pre>          fifo_rptr <= fifo_rptr + {{(PTR_WIDTH-1){1'b0}},1'b1};</pre>
<pre>        end</pre>
<pre>    assign  fifo_empty = (fifo_wptr ==  fifo_rptr);</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    logic [Width-1:0] storage_rdata;</pre>
<pre style="background-color: #FF0000;">    if (Depth == 1) begin : gen_depth_eq1</pre>
<pre>      assign storage_rdata = storage[0];</pre>
<pre></pre>
<pre>        if (fifo_incr_wptr) begin</pre>
<pre>          storage[0] <= wdata;</pre>
<pre>        end</pre>
<pre>      assign storage_rdata = storage[fifo_rptr[PTR_WIDTH-2:0]];</pre>
<pre></pre>
<pre>        if (fifo_incr_wptr) begin</pre>
<pre>          storage[fifo_wptr[PTR_WIDTH-2:0]] <= wdata;</pre>
<pre>        end</pre>
<pre>      assign rdata = (fifo_empty && wvalid) ? wdata : storage_rdata;</pre>
<pre>      assign empty = fifo_empty & ~wvalid;</pre>
<pre>    end else begin : gen_nopass</pre>
<pre>      assign rdata = storage_rdata;</pre>
<pre>      assign empty = fifo_empty;</pre>
<pre>    end</pre>
<h3>hw/ip/prim/rtl/prim_pulse_sync.sv</h3>
<pre>  input  logic clk_src_i,</pre>
<pre>  input  logic rst_src_ni,</pre>
<pre>  input  logic src_pulse_i,</pre>
<pre>  input  logic clk_dst_i,</pre>
<pre>  input  logic rst_dst_ni,</pre>
<pre>  output logic dst_pulse_o</pre>
<pre>  logic src_level;</pre>
<pre>  always_ff @(posedge clk_src_i or negedge rst_src_ni) begin</pre>
<pre>    if (!rst_src_ni) begin</pre>
<pre>      src_level <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      src_level <= src_level ^ src_pulse_i;</pre>
<pre>  logic dst_level;</pre>
<pre>  prim_flop_2sync #(.Width(1)) prim_flop_2sync (</pre>
<pre>    .d      (src_level),</pre>
<pre>    .clk_i  (clk_dst_i),</pre>
<pre>    .rst_ni (rst_dst_ni),</pre>
<pre>    .q      (dst_level)</pre>
<pre>  logic dst_level_q;</pre>
<pre>  always_ff @(posedge clk_dst_i or negedge rst_dst_ni) begin</pre>
<pre>    if (!rst_dst_ni) begin</pre>
<pre>      dst_level_q <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      dst_level_q <= dst_level;</pre>
<pre>  assign dst_pulse_o = dst_level_q ^ dst_level;</pre>
<h3>hw/ip/prim/rtl/prim_subreg.sv</h3>
<pre>module prim_subreg #(</pre>
<pre>  parameter int            DW       = 32  ,</pre>
<pre>  parameter                SWACCESS = "RW",  // {RW, RO, WO, W1C, W1S, W0C, RC}</pre>
<pre>  parameter logic [DW-1:0] RESVAL   = '0     // Reset value</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input          we,</pre>
<pre>  input [DW-1:0] wd,</pre>
<pre>  input          de,</pre>
<pre>  input [DW-1:0] d,</pre>
<pre>  output logic          qe,</pre>
<pre>  output logic [DW-1:0] q,</pre>
<pre>  output logic [DW-1:0] qs</pre>
<pre>  logic          wr_en ;</pre>
<pre>  logic [DW-1:0] wr_data;</pre>
<pre>  if ((SWACCESS == "RW") || (SWACCESS == "WO")) begin : gen_w</pre>
<pre>    assign wr_en   = we | de ;</pre>
<pre>    assign wr_data = (we == 1'b1) ? wd : d ; // SW higher priority</pre>
<pre style="background-color: #FF0000;">  end else if (SWACCESS == "RO") begin : gen_ro</pre>
<pre>    assign wr_en   = de ;</pre>
<pre>    assign wr_data = d  ;</pre>
<pre style="background-color: #FF0000;">  end else if (SWACCESS == "W1S") begin : gen_w1s</pre>
<pre style="background-color: #FF0000;">    assign wr_en   = we | de ;</pre>
<pre style="background-color: #FF0000;">    assign wr_data = (de ? d : q) | (we ? wd : '0);</pre>
<pre style="background-color: #FF0000;">  end else if (SWACCESS == "W1C") begin : gen_w1c</pre>
<pre>    assign wr_en   = we | de ;</pre>
<pre>    assign wr_data = (de ? d : q) & (we ? ~wd : '1);</pre>
<pre style="background-color: #FF0000;">  end else if (SWACCESS == "W0C") begin : gen_w0c</pre>
<pre>    assign wr_en   = we | de ;</pre>
<pre>    assign wr_data = (de ? d : q) & (we ? wd : '1);</pre>
<pre style="background-color: #FF0000;">  end else if (SWACCESS == "RC") begin : gen_rc</pre>
<pre style="background-color: #FF0000;">    assign wr_en  = we | de ;</pre>
<pre style="background-color: #FF0000;">    assign wr_data = (de ? d : q) & (we ? '0 : '1);</pre>
<pre style="background-color: #FF0000;">  end else begin : gen_hw</pre>
<pre style="background-color: #FF0000;">    assign wr_en   = de ;</pre>
<pre style="background-color: #FF0000;">    assign wr_data = d  ;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) qe <= 1'b0;</pre>
<pre>    else        qe <= we  ;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni)     q <= RESVAL ;</pre>
<pre>    else if (wr_en) q <= wr_data;</pre>
<pre>  assign qs = q;</pre>
<h3>hw/ip/prim/rtl/prim_filter_ctr.sv</h3>
<pre>  input  clk_i,</pre>
<pre>  input  rst_ni,</pre>
<pre>  input  enable_i,</pre>
<pre>  input  filter_i,</pre>
<pre>  output filter_o</pre>
<pre>  localparam int unsigned CTR_WIDTH = $clog2(Cycles);</pre>
<pre>  localparam logic [CTR_WIDTH-1:0] CYCLESM1 = (CTR_WIDTH)'(Cycles-1);</pre>
<pre>  logic [CTR_WIDTH-1:0] diff_ctr_q, diff_ctr_d;</pre>
<pre>  logic filter_q, stored_value_q, update_stored_value;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      filter_q <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      filter_q <= filter_i;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      stored_value_q <= 1'b0;</pre>
<pre>    end else if (update_stored_value) begin</pre>
<pre>      stored_value_q <= filter_i;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      diff_ctr_q <= {CTR_WIDTH{1'b0}};</pre>
<pre>    end else begin</pre>
<pre>      diff_ctr_q <= diff_ctr_d;</pre>
<pre>  assign diff_ctr_d =</pre>
<pre>             (filter_i != filter_q)           ? '0       : // restart</pre>
<pre>                     (diff_ctr_q == CYCLESM1) ? CYCLESM1 : // saturate</pre>
<pre>                         (diff_ctr_q + 1'b1);              // count up</pre>
<pre>  assign update_stored_value = (diff_ctr_d == CYCLESM1);</pre>
<pre>  assign filter_o = enable_i ? stored_value_q : filter_i;</pre>
<h3>hw/ip/prim/rtl/prim_sram_arbiter.sv</h3>
<pre>module prim_sram_arbiter #(</pre>
<pre>  parameter int N  = 4,</pre>
<pre>  parameter int SramDw = 32,</pre>
<pre>  parameter int SramAw = 12,</pre>
<pre>  parameter ArbiterImpl = "PPC"</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input        [     N-1:0] req,</pre>
<pre>  input        [SramAw-1:0] req_addr   [N],</pre>
<pre>  input                     req_write  [N],</pre>
<pre>  input        [SramDw-1:0] req_wdata  [N],</pre>
<pre>  output logic [     N-1:0] gnt,</pre>
<pre>  output logic [     N-1:0] rsp_rvalid,      // Pulse</pre>
<pre>  output logic [SramDw-1:0] rsp_rdata  [N],</pre>
<pre>  output logic [       1:0] rsp_error  [N],</pre>
<pre>  output logic              sram_req,</pre>
<pre>  output logic [SramAw-1:0] sram_addr,</pre>
<pre>  output logic              sram_write,</pre>
<pre>  output logic [SramDw-1:0] sram_wdata,</pre>
<pre>  input                     sram_rvalid,</pre>
<pre>  input        [SramDw-1:0] sram_rdata,</pre>
<pre>  input        [1:0]        sram_rerror</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic write;</pre>
<pre>    logic [SramAw-1:0] addr;</pre>
<pre>    logic [SramDw-1:0] wdata;</pre>
<pre style="background-color: #FF0000;">  } req_t;</pre>
<pre>  localparam int ARB_DW = $bits(req_t);</pre>
<pre>  req_t req_packed [N];</pre>
<pre>  for (genvar i = 0 ; i < N ; i++) begin : gen_reqs</pre>
<pre>    assign req_packed[i] = {req_write[i], req_addr[i], req_wdata[i]};</pre>
<pre>  req_t sram_packed;</pre>
<pre>  assign sram_write = sram_packed.write;</pre>
<pre>  assign sram_addr  = sram_packed.addr;</pre>
<pre>  assign sram_wdata = sram_packed.wdata;</pre>
<pre>  if (ArbiterImpl == "PPC") begin : gen_arb_ppc</pre>
<pre>    prim_arbiter_ppc #(</pre>
<pre>      .N (N),</pre>
<pre>      .DW(ARB_DW)</pre>
<pre style="background-color: #FF0000;">    ) u_reqarb (</pre>
<pre>      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .req_i   ( req         ),</pre>
<pre>      .data_i  ( req_packed  ),</pre>
<pre>      .gnt_o   ( gnt         ),</pre>
<pre>      .idx_o   (             ),</pre>
<pre>      .valid_o ( sram_req    ),</pre>
<pre>      .data_o  ( sram_packed ),</pre>
<pre>      .ready_i ( 1'b1        )</pre>
<pre style="background-color: #FF0000;">  end else if (ArbiterImpl == "BINTREE") begin : gen_tree_arb</pre>
<pre style="background-color: #FF0000;">    prim_arbiter_arb #(</pre>
<pre style="background-color: #FF0000;">      .N (N),</pre>
<pre style="background-color: #FF0000;">      .DW(ARB_DW)</pre>
<pre style="background-color: #FF0000;">    ) u_reqarb (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre style="background-color: #FF0000;">      .rst_ni,</pre>
<pre style="background-color: #FF0000;">      .req_i   ( req         ),</pre>
<pre style="background-color: #FF0000;">      .data_i  ( req_packed  ),</pre>
<pre style="background-color: #FF0000;">      .gnt_o   ( gnt         ),</pre>
<pre style="background-color: #FF0000;">      .idx_o   (             ),</pre>
<pre style="background-color: #FF0000;">      .valid_o ( sram_req    ),</pre>
<pre style="background-color: #FF0000;">      .data_o  ( sram_packed ),</pre>
<pre style="background-color: #FF0000;">      .ready_i ( 1'b1        )</pre>
<pre style="background-color: #FF0000;">    `ASSERT_INIT(UnknownArbImpl_A, 0)</pre>
<pre>  logic sram_ack;         // Ack for rvalid. |sram_rvalid</pre>
<pre></pre>
<pre></pre>
<pre>    .Width    (N),</pre>
<pre>    .Pass     (1'b0),</pre>
<pre>    .Depth    (4)        // Assume at most 4 pipelined</pre>
<pre>  ) u_req_fifo (</pre>
<pre style="background-color: #FF0000;">    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .clr_i    (1'b0),</pre>
<pre>    .wvalid   (sram_req && !sram_write),  // Push only for read</pre>
<pre>    .wready   (),     // TODO: Generate Error</pre>
<pre>    .wdata    (gnt),</pre>
<pre>    .depth    (),     // Not used</pre>
<pre>    .rvalid   (),     // TODO; Generate error if sram_rvalid but rvalid==0</pre>
<pre>    .rready   (sram_ack),</pre>
<pre>    .rdata    (steer)</pre>
<pre>  );</pre>
<pre></pre>
<pre>    assign rsp_rdata[i] = sram_rdata;</pre>
<pre>    assign rsp_error[i] = sram_rerror; // No SECDED yet</pre>
<pre>  end</pre>
<h3>hw/ip/prim/rtl/prim_alert_receiver.sv</h3>
<pre>module prim_alert_receiver import prim_pkg::*; #(</pre>
<pre>  parameter bit AsyncOn = 1'b0</pre>
<pre>  input             clk_i,</pre>
<pre>  input             rst_ni,</pre>
<pre>  input             ping_en_i,</pre>
<pre>  output logic      ping_ok_o,</pre>
<pre>  output logic      integ_fail_o,</pre>
<pre>  output logic      alert_o,</pre>
<pre>  output alert_rx_t alert_rx_o,</pre>
<pre>  input alert_tx_t  alert_tx_i</pre>
<pre>  logic alert_level, alert_sigint;</pre>
<pre style="background-color: #FF0000;">  prim_diff_decode #(</pre>
<pre style="background-color: #FF0000;">    .AsyncOn(AsyncOn)</pre>
<pre style="background-color: #FF0000;">  ) i_decode_alert (</pre>
<pre style="background-color: #FF0000;">    .clk_i,</pre>
<pre style="background-color: #FF0000;">    .rst_ni,</pre>
<pre style="background-color: #FF0000;">    .diff_pi  ( alert_tx_i.alert_p     ),</pre>
<pre style="background-color: #FF0000;">    .diff_ni  ( alert_tx_i.alert_n     ),</pre>
<pre style="background-color: #FF0000;">    .level_o  ( alert_level  ),</pre>
<pre style="background-color: #FF0000;">    .rise_o   (              ),</pre>
<pre style="background-color: #FF0000;">    .fall_o   (              ),</pre>
<pre style="background-color: #FF0000;">    .event_o  (              ),</pre>
<pre style="background-color: #FF0000;">    .sigint_o ( alert_sigint )</pre>
<pre>  typedef enum logic [1:0] {Idle, HsAckWait, Pause0, Pause1} state_e;</pre>
<pre>  state_e state_d, state_q;</pre>
<pre>  logic ping_rise;</pre>
<pre>  logic ping_tog_d, ping_tog_q, ack_d, ack_q;</pre>
<pre>  logic ping_en_d, ping_en_q;</pre>
<pre>  logic ping_pending_d, ping_pending_q;</pre>
<pre>  assign ping_en_d  = ping_en_i;</pre>
<pre>  assign ping_rise  = ping_en_i && !ping_en_q;</pre>
<pre>  assign ping_tog_d = (ping_rise) ? ~ping_tog_q : ping_tog_q;</pre>
<pre>  assign ping_pending_d = ping_rise | ((~ping_ok_o) & ping_en_i & ping_pending_q);</pre>
<pre>  assign alert_rx_o.ack_p  = ack_q;</pre>
<pre>  assign alert_rx_o.ack_n  = ~ack_q;</pre>
<pre>  assign alert_rx_o.ping_p = ping_tog_q;</pre>
<pre>  assign alert_rx_o.ping_n = ~ping_tog_q;</pre>
<pre>  always_comb begin : p_fsm</pre>
<pre>    state_d      = state_q;</pre>
<pre>    ack_d        = 1'b0;</pre>
<pre>    ping_ok_o    = 1'b0;</pre>
<pre>    integ_fail_o = 1'b0;</pre>
<pre>    alert_o      = 1'b0;</pre>
<pre>    unique case (state_q)</pre>
<pre>      Idle: begin</pre>
<pre>        if (alert_level) begin</pre>
<pre>          state_d = HsAckWait;</pre>
<pre>          ack_d   = 1'b1;</pre>
<pre>          if (ping_pending_q) begin</pre>
<pre>            ping_ok_o = 1'b1;</pre>
<pre>          end else begin</pre>
<pre>            alert_o   = 1'b1;</pre>
<pre>      HsAckWait: begin</pre>
<pre>        if (!alert_level) begin</pre>
<pre>          state_d  = Pause0;</pre>
<pre>        end else begin</pre>
<pre>          ack_d    = 1'b1;</pre>
<pre>      Pause0: state_d = Pause1;</pre>
<pre>      Pause1: state_d = Idle;</pre>
<pre>      default : ; // full case</pre>
<pre>    if (alert_sigint) begin</pre>
<pre>      state_d      = Idle;</pre>
<pre>      ack_d        = 1'b0;</pre>
<pre>      ping_ok_o    = 1'b0;</pre>
<pre>      integ_fail_o = 1'b1;</pre>
<pre>      alert_o      = 1'b0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : p_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      state_q        <= Idle;</pre>
<pre>      ack_q          <= 1'b0;</pre>
<pre>      ping_tog_q     <= 1'b0;</pre>
<pre>      ping_en_q      <= 1'b0;</pre>
<pre>      ping_pending_q <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      state_q        <= state_d;</pre>
<pre>      ack_q          <= ack_d;</pre>
<pre>      ping_tog_q     <= ping_tog_d;</pre>
<pre>      ping_en_q      <= ping_en_d;</pre>
<pre>      ping_pending_q <= ping_pending_d;</pre>
<pre style="background-color: #FF0000;">    // signal integrity check propagation</pre>
<pre style="background-color: #FF0000;">  end else begin : gen_sync_assert</pre>
<pre style="background-color: #FF0000;">endmodule : prim_alert_receiver</pre>
<h3>hw/ip/prim/abstract/prim_ram_2p.sv</h3>
<pre>  parameter prim_pkg::impl_e Impl = `PRIM_DEFAULT_IMPL,</pre>
<pre></pre>
<pre>  parameter int Depth = 128,</pre>
<pre></pre>
<pre>) (</pre>
<pre>  input clk_b_i,</pre>
<pre></pre>
<pre>  input                    a_write_i,</pre>
<pre>  input        [Aw-1:0]    a_addr_i,</pre>
<pre>  input        [Width-1:0] a_wdata_i,</pre>
<pre>  output logic [Width-1:0] a_rdata_o,</pre>
<pre></pre>
<pre>  input                    b_write_i,</pre>
<pre>  input        [Aw-1:0]    b_addr_i,</pre>
<pre>  input        [Width-1:0] b_wdata_i,</pre>
<pre>  output logic [Width-1:0] b_rdata_o</pre>
<pre>);</pre>
<pre>    prim_generic_ram_2p #(</pre>
<pre>      .Width(Width),</pre>
<pre>      .Depth(Depth)</pre>
<pre>    ) u_impl_generic (</pre>
<pre style="background-color: #FF0000;">      .clk_a_i,</pre>
<pre>      .clk_b_i,</pre>
<pre>      .a_req_i,</pre>
<pre>      .a_write_i,</pre>
<pre>      .a_addr_i,</pre>
<pre>      .a_wdata_i,</pre>
<pre>      .a_rdata_o,</pre>
<pre>      .b_req_i,</pre>
<pre>      .b_write_i,</pre>
<pre>      .b_addr_i,</pre>
<pre>      .b_wdata_i,</pre>
<pre>      .b_rdata_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">    prim_xilinx_ram_2p #(</pre>
<pre style="background-color: #FF0000;">      .Width(Width),</pre>
<pre style="background-color: #FF0000;">      .Depth(Depth)</pre>
<pre style="background-color: #FF0000;">    ) u_impl_xilinx (</pre>
<pre style="background-color: #FF0000;">      .clk_a_i,</pre>
<pre style="background-color: #FF0000;">      .clk_b_i,</pre>
<pre style="background-color: #FF0000;">      .a_req_i,</pre>
<pre style="background-color: #FF0000;">      .a_write_i,</pre>
<pre style="background-color: #FF0000;">      .a_addr_i,</pre>
<pre style="background-color: #FF0000;">      .a_wdata_i,</pre>
<pre style="background-color: #FF0000;">      .a_rdata_o,</pre>
<pre style="background-color: #FF0000;">      .b_req_i,</pre>
<pre style="background-color: #FF0000;">      .b_write_i,</pre>
<pre style="background-color: #FF0000;">      .b_addr_i,</pre>
<pre style="background-color: #FF0000;">      .b_wdata_i,</pre>
<pre style="background-color: #FF0000;">      .b_rdata_o</pre>
<pre style="background-color: #FF0000;">    );</pre>
<pre style="background-color: #FF0000;">    // TODO: Find code that works across tools and causes a compile failure</pre>
<h3>hw/ip/uart/rtl/uart_rx.sv</h3>
<pre>  input           clk_i,</pre>
<pre>  input           rst_ni,</pre>
<pre>  input           rx_enable,</pre>
<pre>  input           tick_baud_x16,</pre>
<pre>  input           parity_enable,</pre>
<pre>  input           parity_odd,</pre>
<pre>  output logic    tick_baud,</pre>
<pre>  output logic    rx_valid,</pre>
<pre>  output [7:0]    rx_data,</pre>
<pre>  output logic    idle,</pre>
<pre>  output          frame_err,</pre>
<pre>  output          rx_parity_err,</pre>
<pre>  input           rx</pre>
<pre>  logic            rx_valid_q;</pre>
<pre>  logic   [10:0]   sreg_q, sreg_d;</pre>
<pre>  logic    [3:0]   bit_cnt_q, bit_cnt_d;</pre>
<pre>  logic    [3:0]   baud_div_q, baud_div_d;</pre>
<pre>  logic            tick_baud_d, tick_baud_q;</pre>
<pre>  logic            idle_d, idle_q;</pre>
<pre>  assign tick_baud = tick_baud_q;</pre>
<pre>  assign idle      = idle_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      sreg_q      <= 11'h0;</pre>
<pre>      bit_cnt_q   <= 4'h0;</pre>
<pre>      baud_div_q  <= 4'h0;</pre>
<pre>      tick_baud_q <= 1'b0;</pre>
<pre>      idle_q      <= 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      sreg_q      <= sreg_d;</pre>
<pre>      bit_cnt_q   <= bit_cnt_d;</pre>
<pre>      baud_div_q  <= baud_div_d;</pre>
<pre>      tick_baud_q <= tick_baud_d;</pre>
<pre>      idle_q      <= idle_d;</pre>
<pre>  always_comb begin</pre>
<pre>    if (!rx_enable) begin</pre>
<pre>      sreg_d      = 11'h0;</pre>
<pre>      bit_cnt_d   = 4'h0;</pre>
<pre>      baud_div_d  = 4'h0;</pre>
<pre>      tick_baud_d = 1'b0;</pre>
<pre>      idle_d      = 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      tick_baud_d = 1'b0;</pre>
<pre>      sreg_d      = sreg_q;</pre>
<pre>      bit_cnt_d   = bit_cnt_q;</pre>
<pre>      baud_div_d  = baud_div_q;</pre>
<pre>      idle_d      = idle_q;</pre>
<pre>      if (tick_baud_x16) begin</pre>
<pre>        {tick_baud_d, baud_div_d} = {1'b0,baud_div_q} + 5'h1;</pre>
<pre>      if (idle_q && !rx) begin</pre>
<pre>        baud_div_d  = 4'd8;</pre>
<pre>        tick_baud_d = 1'b0;</pre>
<pre>        bit_cnt_d   = (parity_enable ? 4'd11 : 4'd10);</pre>
<pre>        sreg_d      = 11'h0;</pre>
<pre>        idle_d      = 1'b0;</pre>
<pre>      end else if (!idle_q && tick_baud_q) begin</pre>
<pre>        if ((bit_cnt_q == (parity_enable ? 4'd11 : 4'd10)) && rx) begin</pre>
<pre>          idle_d    = 1'b1;</pre>
<pre>          bit_cnt_d = 4'h0;</pre>
<pre>        end else begin</pre>
<pre>          sreg_d    = {rx, sreg_q[10:1]};</pre>
<pre>          bit_cnt_d = bit_cnt_q - 4'h1;</pre>
<pre>          idle_d    = (bit_cnt_q == 4'h1);</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) rx_valid_q <= 1'b0;</pre>
<pre>    else         rx_valid_q <= tick_baud_q & (bit_cnt_q == 4'h1);</pre>
<pre>  assign rx_valid      = rx_valid_q;</pre>
<pre>  assign rx_data       = parity_enable ? sreg_q[8:1] : sreg_q[9:2];</pre>
<pre>  assign frame_err     = rx_valid_q & ~sreg_q[10];</pre>
<pre>  assign rx_parity_err = parity_enable & rx_valid_q &</pre>
<pre>                         (^{sreg_q[9:1],parity_odd});</pre>
<h3>hw/ip/uart/rtl/uart_core.sv</h3>
<pre>  input                  clk_i,</pre>
<pre>  input                  rst_ni,</pre>
<pre>  input  uart_reg_pkg::uart_reg2hw_t reg2hw,</pre>
<pre>  output uart_reg_pkg::uart_hw2reg_t hw2reg,</pre>
<pre>  input                  rx,</pre>
<pre>  output logic           tx,</pre>
<pre>  output logic           intr_tx_watermark_o,</pre>
<pre>  output logic           intr_rx_watermark_o,</pre>
<pre>  output logic           intr_tx_empty_o,</pre>
<pre>  output logic           intr_rx_overflow_o,</pre>
<pre>  output logic           intr_rx_frame_err_o,</pre>
<pre>  output logic           intr_rx_break_err_o,</pre>
<pre>  output logic           intr_rx_timeout_o,</pre>
<pre>  output logic           intr_rx_parity_err_o</pre>
<pre>  logic   [15:0]  rx_val_q;</pre>
<pre>  logic   [7:0]   uart_rdata;</pre>
<pre>  logic           tick_baud_x16, rx_tick_baud;</pre>
<pre>  logic   [5:0]   tx_fifo_depth, rx_fifo_depth;</pre>
<pre>  logic   [5:0]   rx_fifo_depth_prev_q;</pre>
<pre>  logic   [23:0]  rx_timeout_count_d, rx_timeout_count_q, uart_rxto_val;</pre>
<pre>  logic           rx_fifo_depth_changed, uart_rxto_en;</pre>
<pre>  logic           tx_enable, rx_enable;</pre>
<pre>  logic           sys_loopback, line_loopback, rxnf_enable;</pre>
<pre>  logic           uart_fifo_rxrst, uart_fifo_txrst;</pre>
<pre>  logic   [2:0]   uart_fifo_rxilvl;</pre>
<pre>  logic   [1:0]   uart_fifo_txilvl;</pre>
<pre>  logic           ovrd_tx_en, ovrd_tx_val;</pre>
<pre>  logic   [7:0]   tx_fifo_data;</pre>
<pre>  logic           tx_fifo_rready, tx_fifo_rvalid;</pre>
<pre>  logic           tx_fifo_wready, tx_uart_idle;</pre>
<pre>  logic           tx_out;</pre>
<pre>  logic           tx_out_q;</pre>
<pre>  logic   [7:0]   rx_fifo_data;</pre>
<pre>  logic           rx_valid, rx_fifo_wvalid, rx_fifo_rvalid;</pre>
<pre>  logic           rx_fifo_wready, rx_uart_idle;</pre>
<pre>  logic           rx_sync;</pre>
<pre>  logic           rx_in;</pre>
<pre>  logic           break_err;</pre>
<pre>  logic   [4:0]   allzero_cnt_d, allzero_cnt_q;</pre>
<pre>  logic           allzero_err, not_allzero_char;</pre>
<pre>  logic           event_tx_watermark, event_rx_watermark, event_tx_empty, event_rx_overflow;</pre>
<pre>  logic           event_rx_frame_err, event_rx_break_err, event_rx_timeout, event_rx_parity_err;</pre>
<pre>  logic           tx_watermark_d, tx_watermark_prev_q;</pre>
<pre>  logic           tx_empty_d, tx_empty_prev_q;</pre>
<pre>  assign tx_enable        = reg2hw.ctrl.tx.q;</pre>
<pre>  assign rx_enable        = reg2hw.ctrl.rx.q;</pre>
<pre>  assign rxnf_enable      = reg2hw.ctrl.nf.q;</pre>
<pre>  assign sys_loopback     = reg2hw.ctrl.slpbk.q;</pre>
<pre>  assign line_loopback    = reg2hw.ctrl.llpbk.q;</pre>
<pre>  assign uart_fifo_rxrst  = reg2hw.fifo_ctrl.rxrst.q & reg2hw.fifo_ctrl.rxrst.qe;</pre>
<pre>  assign uart_fifo_txrst  = reg2hw.fifo_ctrl.txrst.q & reg2hw.fifo_ctrl.txrst.qe;</pre>
<pre>  assign uart_fifo_rxilvl = reg2hw.fifo_ctrl.rxilvl.q;</pre>
<pre>  assign uart_fifo_txilvl = reg2hw.fifo_ctrl.txilvl.q;</pre>
<pre>  assign ovrd_tx_en       = reg2hw.ovrd.txen.q;</pre>
<pre>  assign ovrd_tx_val      = reg2hw.ovrd.txval.q;</pre>
<pre>  typedef enum logic {</pre>
<pre>    BRK_CHK,</pre>
<pre>    BRK_WAIT</pre>
<pre>  } break_st_e ;</pre>
<pre>  break_st_e break_st_q;</pre>
<pre>  assign not_allzero_char = rx_valid & (~event_rx_frame_err | (rx_fifo_data != 8'h0));</pre>
<pre>  assign allzero_err = event_rx_frame_err & (rx_fifo_data == 8'h0);</pre>
<pre>  assign allzero_cnt_d = (break_st_q == BRK_WAIT || not_allzero_char) ? 5'h0 :</pre>
<pre>                          allzero_err ? allzero_cnt_q + 5'd1 :</pre>
<pre>                          allzero_cnt_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni)        allzero_cnt_q <= '0;</pre>
<pre>    else if (rx_enable) allzero_cnt_q <= allzero_cnt_d;</pre>
<pre>  always_comb begin</pre>
<pre>    unique case (reg2hw.ctrl.rxblvl.q)</pre>
<pre>      2'h0:    break_err = allzero_cnt_d >= 5'd2;</pre>
<pre>      2'h1:    break_err = allzero_cnt_d >= 5'd4;</pre>
<pre>      2'h2:    break_err = allzero_cnt_d >= 5'd8;</pre>
<pre>      default: break_err = allzero_cnt_d >= 5'd16;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) break_st_q <= BRK_CHK;</pre>
<pre>    else begin</pre>
<pre>      unique case (break_st_q)</pre>
<pre>        BRK_CHK: begin</pre>
<pre>          if (event_rx_break_err) break_st_q <= BRK_WAIT;</pre>
<pre>        BRK_WAIT: begin</pre>
<pre>          if (rx_in) break_st_q <= BRK_CHK;</pre>
<pre>        default: begin</pre>
<pre>          break_st_q <= BRK_CHK;</pre>
<pre>  assign hw2reg.val.d  = rx_val_q;</pre>
<pre>  assign hw2reg.rdata.d = uart_rdata;</pre>
<pre>  assign hw2reg.status.rxempty.d     = ~rx_fifo_rvalid;</pre>
<pre>  assign hw2reg.status.rxidle.d      = rx_uart_idle;</pre>
<pre>  assign hw2reg.status.txidle.d      = tx_uart_idle & ~tx_fifo_rvalid;</pre>
<pre>  assign hw2reg.status.txempty.d     = ~tx_fifo_rvalid;</pre>
<pre>  assign hw2reg.status.rxfull.d      = ~rx_fifo_wready;</pre>
<pre>  assign hw2reg.status.txfull.d      = ~tx_fifo_wready;</pre>
<pre>  assign hw2reg.fifo_status.txlvl.d  = tx_fifo_depth;</pre>
<pre>  assign hw2reg.fifo_status.rxlvl.d  = rx_fifo_depth;</pre>
<pre>  assign hw2reg.fifo_ctrl.rxilvl.de = 1'b0;</pre>
<pre>  assign hw2reg.fifo_ctrl.rxilvl.d  = 3'h0;</pre>
<pre>  assign hw2reg.fifo_ctrl.txilvl.de = 1'b0;</pre>
<pre>  assign hw2reg.fifo_ctrl.txilvl.d  = 2'h0;</pre>
<pre>  logic   [16:0]     nco_sum_q; // extra bit to get the carry</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      nco_sum_q <= 17'h0;</pre>
<pre>    end else if (tx_enable || rx_enable) begin</pre>
<pre>      nco_sum_q <= {1'b0,nco_sum_q[15:0]} + {1'b0,reg2hw.ctrl.nco.q};</pre>
<pre>  assign tick_baud_x16 = nco_sum_q[16];</pre>
<pre>  assign tx_fifo_rready = tx_uart_idle & tx_fifo_rvalid & tx_enable;</pre>
<pre>  prim_fifo_sync #(</pre>
<pre>    .Width(8),</pre>
<pre>    .Pass (1'b0),</pre>
<pre>    .Depth(32)</pre>
<pre style="background-color: #FF0000;">  ) u_uart_txfifo (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .clr_i  (uart_fifo_txrst),</pre>
<pre>    .wvalid (reg2hw.wdata.qe),</pre>
<pre>    .wready (tx_fifo_wready),</pre>
<pre>    .wdata  (reg2hw.wdata.q),</pre>
<pre>    .depth  (tx_fifo_depth),</pre>
<pre>    .rvalid (tx_fifo_rvalid),</pre>
<pre>    .rready (tx_fifo_rready),</pre>
<pre>    .rdata  (tx_fifo_data)</pre>
<pre>  uart_tx uart_tx (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tx_enable,</pre>
<pre>    .tick_baud_x16,</pre>
<pre>    .parity_enable  (reg2hw.ctrl.parity_en.q),</pre>
<pre>    .wr             (tx_fifo_rready),</pre>
<pre>    .wr_parity      ((^tx_fifo_data) ^ reg2hw.ctrl.parity_odd.q),</pre>
<pre>    .wr_data        (tx_fifo_data),</pre>
<pre>    .idle           (tx_uart_idle),</pre>
<pre>    .tx             (tx_out)</pre>
<pre>  assign tx = line_loopback ? rx : tx_out_q ;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      tx_out_q <= 1'b1;</pre>
<pre>    end else if (ovrd_tx_en) begin</pre>
<pre>      tx_out_q <= ovrd_tx_val ;</pre>
<pre>    end else if (sys_loopback) begin</pre>
<pre>      tx_out_q <= 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      tx_out_q <= tx_out;</pre>
<pre>  prim_flop_2sync #(</pre>
<pre>    .Width(1),</pre>
<pre>    .ResetValue(1)</pre>
<pre style="background-color: #FF0000;">  ) sync_rx (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .d(rx),</pre>
<pre>    .q(rx_sync)</pre>
<pre>  logic   rx_sync_q1, rx_sync_q2, rx_in_mx, rx_in_maj;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rx_sync_q1 <= 1'b1;</pre>
<pre>      rx_sync_q2 <= 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      rx_sync_q1 <= rx_sync;</pre>
<pre>      rx_sync_q2 <= rx_sync_q1;</pre>
<pre>  assign rx_in_maj = (rx_sync    & rx_sync_q1) |</pre>
<pre>                     (rx_sync    & rx_sync_q2) |</pre>
<pre>                     (rx_sync_q1 & rx_sync_q2);</pre>
<pre>  assign rx_in_mx  = rxnf_enable ? rx_in_maj : rx_sync;</pre>
<pre>  assign rx_in =  sys_loopback ? tx_out   :</pre>
<pre>                  line_loopback ? 1'b1 :</pre>
<pre>                  rx_in_mx;</pre>
<pre>  uart_rx uart_rx (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .rx_enable,</pre>
<pre>    .tick_baud_x16,</pre>
<pre>    .parity_enable  (reg2hw.ctrl.parity_en.q),</pre>
<pre>    .parity_odd     (reg2hw.ctrl.parity_odd.q),</pre>
<pre>    .tick_baud      (rx_tick_baud),</pre>
<pre>    .rx_valid,</pre>
<pre>    .rx_data        (rx_fifo_data),</pre>
<pre>    .idle           (rx_uart_idle),</pre>
<pre>    .frame_err      (event_rx_frame_err),</pre>
<pre>    .rx             (rx_in),</pre>
<pre>    .rx_parity_err  (event_rx_parity_err)</pre>
<pre>  assign rx_fifo_wvalid = rx_valid & ~event_rx_frame_err & ~event_rx_parity_err;</pre>
<pre>  prim_fifo_sync #(</pre>
<pre>    .Width (8),</pre>
<pre>    .Pass  (1'b0),</pre>
<pre>    .Depth (32)</pre>
<pre style="background-color: #FF0000;">  ) u_uart_rxfifo (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .clr_i  (uart_fifo_rxrst),</pre>
<pre>    .wvalid (rx_fifo_wvalid),</pre>
<pre>    .wready (rx_fifo_wready),</pre>
<pre>    .wdata  (rx_fifo_data),</pre>
<pre>    .depth  (rx_fifo_depth),</pre>
<pre>    .rvalid (rx_fifo_rvalid),</pre>
<pre>    .rready (reg2hw.rdata.re),</pre>
<pre>    .rdata  (uart_rdata)</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni)            rx_val_q <= 16'h0;</pre>
<pre>    else if (tick_baud_x16) rx_val_q <= {rx_val_q[14:0], rx_in};</pre>
<pre>  always_comb begin</pre>
<pre>    unique case(uart_fifo_txilvl)</pre>
<pre>      2'h0:    tx_watermark_d = (tx_fifo_depth < 6'd1);</pre>
<pre>      2'h1:    tx_watermark_d = (tx_fifo_depth < 6'd4);</pre>
<pre>      2'h2:    tx_watermark_d = (tx_fifo_depth < 6'd8);</pre>
<pre>      default: tx_watermark_d = (tx_fifo_depth < 6'd16);</pre>
<pre>  assign event_tx_watermark = tx_watermark_d & ~tx_watermark_prev_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      tx_watermark_prev_q   <= 1'd1;</pre>
<pre>    end else begin</pre>
<pre>      tx_watermark_prev_q   <= tx_watermark_d;</pre>
<pre>  always_comb begin</pre>
<pre>    unique case(uart_fifo_rxilvl)</pre>
<pre>      3'h0:    event_rx_watermark = (rx_fifo_depth >= 6'd1);</pre>
<pre>      3'h1:    event_rx_watermark = (rx_fifo_depth >= 6'd4);</pre>
<pre>      3'h2:    event_rx_watermark = (rx_fifo_depth >= 6'd8);</pre>
<pre>      3'h3:    event_rx_watermark = (rx_fifo_depth >= 6'd16);</pre>
<pre>      3'h4:    event_rx_watermark = (rx_fifo_depth >= 6'd30);</pre>
<pre>      default: event_rx_watermark = 1'b0;</pre>
<pre>  assign uart_rxto_en  = reg2hw.timeout_ctrl.en.q;</pre>
<pre>  assign uart_rxto_val = reg2hw.timeout_ctrl.val.q;</pre>
<pre>  assign rx_fifo_depth_changed = (rx_fifo_depth != rx_fifo_depth_prev_q);</pre>
<pre>  assign rx_timeout_count_d =</pre>
<pre>              (uart_rxto_en == 1'b0)              ? 24'd0 :</pre>
<pre>              event_rx_timeout                    ? 24'd0 :</pre>
<pre>              rx_fifo_depth_changed               ? 24'd0 :</pre>
<pre>              (rx_fifo_depth == 5'd0)             ? 24'd0 :</pre>
<pre>              rx_tick_baud                        ? (rx_timeout_count_q + 24'd1) :</pre>
<pre>              rx_timeout_count_q;</pre>
<pre>  assign event_rx_timeout = (rx_timeout_count_q == uart_rxto_val) & uart_rxto_en;</pre>
<pre>  assign tx_empty_d = tx_fifo_depth == 6'h0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rx_timeout_count_q   <= 24'd0;</pre>
<pre>      rx_fifo_depth_prev_q <= 6'd0;</pre>
<pre>      tx_empty_prev_q      <= 1'd0;</pre>
<pre>    end else begin</pre>
<pre>      rx_timeout_count_q    <= rx_timeout_count_d;</pre>
<pre>      rx_fifo_depth_prev_q  <= rx_fifo_depth;</pre>
<pre>      tx_empty_prev_q       <= tx_empty_d;</pre>
<pre>  assign event_rx_overflow  = rx_fifo_wvalid & ~rx_fifo_wready;</pre>
<pre>  assign event_rx_break_err = break_err & (break_st_q == BRK_CHK);</pre>
<pre>  assign event_tx_empty     = tx_empty_d & ~tx_empty_prev_q;</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_tx_watermark (</pre>
<pre>    .event_intr_i           (event_tx_watermark),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.tx_watermark.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.tx_watermark.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.tx_watermark.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.tx_watermark.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.tx_watermark.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.tx_watermark.d),</pre>
<pre>    .intr_o                 (intr_tx_watermark_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_rx_watermark (</pre>
<pre>    .event_intr_i           (event_rx_watermark),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_watermark.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.rx_watermark.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.rx_watermark.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.rx_watermark.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.rx_watermark.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.rx_watermark.d),</pre>
<pre>    .intr_o                 (intr_rx_watermark_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_tx_empty (</pre>
<pre>    .event_intr_i           (event_tx_empty),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.tx_empty.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.tx_empty.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.tx_empty.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.tx_empty.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.tx_empty.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.tx_empty.d),</pre>
<pre>    .intr_o                 (intr_tx_empty_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_rx_overflow (</pre>
<pre>    .event_intr_i           (event_rx_overflow),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_overflow.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.rx_overflow.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.rx_overflow.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.rx_overflow.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.rx_overflow.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.rx_overflow.d),</pre>
<pre>    .intr_o                 (intr_rx_overflow_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_rx_frame_err (</pre>
<pre>    .event_intr_i           (event_rx_frame_err),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_frame_err.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.rx_frame_err.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.rx_frame_err.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.rx_frame_err.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.rx_frame_err.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.rx_frame_err.d),</pre>
<pre>    .intr_o                 (intr_rx_frame_err_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_rx_break_err (</pre>
<pre>    .event_intr_i           (event_rx_break_err),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_break_err.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.rx_break_err.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.rx_break_err.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.rx_break_err.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.rx_break_err.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.rx_break_err.d),</pre>
<pre>    .intr_o                 (intr_rx_break_err_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_rx_timeout (</pre>
<pre>    .event_intr_i           (event_rx_timeout),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_timeout.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.rx_timeout.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.rx_timeout.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.rx_timeout.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.rx_timeout.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.rx_timeout.d),</pre>
<pre>    .intr_o                 (intr_rx_timeout_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_rx_parity_err (</pre>
<pre>    .event_intr_i           (event_rx_parity_err),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.rx_parity_err.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.rx_parity_err.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.rx_parity_err.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.rx_parity_err.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.rx_parity_err.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.rx_parity_err.d),</pre>
<pre>    .intr_o                 (intr_rx_parity_err_o)</pre>
<h3>hw/ip/uart/rtl/uart.sv</h3>
<pre>  input           clk_i,</pre>
<pre>  input           rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  input           cio_rx_i,</pre>
<pre>  output logic    cio_tx_o,</pre>
<pre>  output logic    cio_tx_en_o,</pre>
<pre>  output logic    intr_tx_watermark_o ,</pre>
<pre>  output logic    intr_rx_watermark_o ,</pre>
<pre>  output logic    intr_tx_empty_o  ,</pre>
<pre>  output logic    intr_rx_overflow_o  ,</pre>
<pre>  output logic    intr_rx_frame_err_o ,</pre>
<pre>  output logic    intr_rx_break_err_o ,</pre>
<pre>  output logic    intr_rx_timeout_o   ,</pre>
<pre>  output logic    intr_rx_parity_err_o</pre>
<pre>  uart_reg2hw_t reg2hw;</pre>
<pre>  uart_hw2reg_t hw2reg;</pre>
<pre>  uart_reg_top u_reg (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .tl_o,</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .devmode_i  (1'b1)</pre>
<pre>  uart_core uart_core (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .rx    (cio_rx_i   ),</pre>
<pre>    .tx    (cio_tx_o   ),</pre>
<pre>    .intr_tx_watermark_o,</pre>
<pre>    .intr_rx_watermark_o,</pre>
<pre>    .intr_tx_empty_o,</pre>
<pre>    .intr_rx_overflow_o,</pre>
<pre>    .intr_rx_frame_err_o,</pre>
<pre>    .intr_rx_break_err_o,</pre>
<pre>    .intr_rx_timeout_o,</pre>
<pre>    .intr_rx_parity_err_o</pre>
<pre>  assign cio_tx_en_o = 1'b1;</pre>
<h3>hw/ip/uart/rtl/uart_tx.sv</h3>
<pre>  input               clk_i,</pre>
<pre>  input               rst_ni,</pre>
<pre>  input               tx_enable,</pre>
<pre>  input               tick_baud_x16,</pre>
<pre>  input  logic        parity_enable,</pre>
<pre>  input               wr,</pre>
<pre>  input  logic        wr_parity,</pre>
<pre>  input   [7:0]       wr_data,</pre>
<pre>  output              idle,</pre>
<pre>  output logic        tx</pre>
<pre>  logic    [3:0] baud_div_q;</pre>
<pre>  logic          tick_baud_q;</pre>
<pre>  logic    [3:0] bit_cnt_q, bit_cnt_d;</pre>
<pre>  logic   [10:0] sreg_q, sreg_d;</pre>
<pre>  logic          tx_q, tx_d;</pre>
<pre>  assign tx = tx_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      baud_div_q  <= 4'h0;</pre>
<pre>      tick_baud_q <= 1'b0;</pre>
<pre>    end else if (tick_baud_x16) begin</pre>
<pre>      {tick_baud_q, baud_div_q} <= {1'b0,baud_div_q} + 5'h1;</pre>
<pre>    end else begin</pre>
<pre>      tick_baud_q <= 1'b0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      bit_cnt_q <= 4'h0;</pre>
<pre>      sreg_q    <= 11'h7ff;</pre>
<pre>      tx_q      <= 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      bit_cnt_q <= bit_cnt_d;</pre>
<pre>      sreg_q    <= sreg_d;</pre>
<pre>      tx_q      <= tx_d;</pre>
<pre>  always_comb begin</pre>
<pre>    if (!tx_enable) begin</pre>
<pre>      bit_cnt_d = 4'h0;</pre>
<pre>      sreg_d    = 11'h7ff;</pre>
<pre>      tx_d      = 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      bit_cnt_d = bit_cnt_q;</pre>
<pre>      sreg_d    = sreg_q;</pre>
<pre>      tx_d      = tx_q;</pre>
<pre>      if (wr) begin</pre>
<pre>        sreg_d    = {1'b1, (parity_enable ? wr_parity : 1'b1), wr_data, 1'b0};</pre>
<pre>        bit_cnt_d = (parity_enable ? 4'd11 : 4'd10);</pre>
<pre>      end else if (tick_baud_q && (bit_cnt_q != 4'h0)) begin</pre>
<pre>        sreg_d    = {1'b1, sreg_q[10:1]};</pre>
<pre>        tx_d      = sreg_q[0];</pre>
<pre>        bit_cnt_d = bit_cnt_q - 4'h1;</pre>
<pre>  assign idle = (tx_enable) ? (bit_cnt_q == 4'h0) : 1'b1;</pre>
<h3>hw/ip/uart/rtl/uart_reg_pkg.sv</h3>
<pre>package uart_reg_pkg;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } tx_watermark;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_watermark;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } tx_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_overflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_frame_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_break_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_timeout;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_parity_err;</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } tx_watermark;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_watermark;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } tx_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_overflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_frame_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_break_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_timeout;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_parity_err;</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_intr_enable_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } tx_watermark;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rx_watermark;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } tx_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rx_overflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rx_frame_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rx_break_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rx_timeout;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rx_parity_err;</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_intr_test_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } tx;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } nf;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } slpbk;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } llpbk;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } parity_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } parity_odd;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } rxblvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>    } nco;</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_ctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        re;</pre>
<pre>    } txfull;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        re;</pre>
<pre>    } rxfull;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        re;</pre>
<pre>    } txempty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        re;</pre>
<pre>    } txidle;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        re;</pre>
<pre>    } rxidle;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        re;</pre>
<pre>    } rxempty;</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_status_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [7:0]  q;</pre>
<pre>    logic        re;</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_rdata_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [7:0]  q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_wdata_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rxrst;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } txrst;</pre>
<pre>    struct packed {</pre>
<pre>      logic [2:0]  q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rxilvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>      logic        qe;</pre>
<pre>    } txilvl;</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_fifo_ctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } txen;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } txval;</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_ovrd_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [23:0] q;</pre>
<pre>    } val;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } en;</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_timeout_ctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } tx_watermark;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rx_watermark;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } tx_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rx_overflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rx_frame_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rx_break_err;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rx_timeout;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rx_parity_err;</pre>
<pre style="background-color: #FF0000;">  } uart_hw2reg_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } txfull;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } rxfull;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } txempty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } txidle;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } rxidle;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } rxempty;</pre>
<pre style="background-color: #FF0000;">  } uart_hw2reg_status_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [7:0]  d;</pre>
<pre style="background-color: #FF0000;">  } uart_hw2reg_rdata_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [2:0]  d;</pre>
<pre>      logic        de;</pre>
<pre>    } rxilvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  d;</pre>
<pre>      logic        de;</pre>
<pre>    } txilvl;</pre>
<pre style="background-color: #FF0000;">  } uart_hw2reg_fifo_ctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [5:0]  d;</pre>
<pre>    } txlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic [5:0]  d;</pre>
<pre>    } rxlvl;</pre>
<pre style="background-color: #FF0000;">  } uart_hw2reg_fifo_status_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [15:0] d;</pre>
<pre style="background-color: #FF0000;">  } uart_hw2reg_val_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    uart_reg2hw_intr_state_reg_t intr_state; // [124:117]</pre>
<pre>    uart_reg2hw_intr_enable_reg_t intr_enable; // [116:109]</pre>
<pre>    uart_reg2hw_intr_test_reg_t intr_test; // [108:93]</pre>
<pre>    uart_reg2hw_ctrl_reg_t ctrl; // [92:68]</pre>
<pre>    uart_reg2hw_status_reg_t status; // [67:56]</pre>
<pre>    uart_reg2hw_rdata_reg_t rdata; // [55:47]</pre>
<pre>    uart_reg2hw_wdata_reg_t wdata; // [46:38]</pre>
<pre>    uart_reg2hw_fifo_ctrl_reg_t fifo_ctrl; // [37:27]</pre>
<pre>    uart_reg2hw_ovrd_reg_t ovrd; // [26:25]</pre>
<pre>    uart_reg2hw_timeout_ctrl_reg_t timeout_ctrl; // [24:0]</pre>
<pre style="background-color: #FF0000;">  } uart_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    uart_hw2reg_intr_state_reg_t intr_state; // [64:57]</pre>
<pre>    uart_hw2reg_status_reg_t status; // [56:45]</pre>
<pre>    uart_hw2reg_rdata_reg_t rdata; // [44:36]</pre>
<pre>    uart_hw2reg_fifo_ctrl_reg_t fifo_ctrl; // [35:25]</pre>
<pre>    uart_hw2reg_fifo_status_reg_t fifo_status; // [24:25]</pre>
<pre>    uart_hw2reg_val_reg_t val; // [24:25]</pre>
<pre style="background-color: #FF0000;">  } uart_hw2reg_t;</pre>
<pre>  parameter logic [5:0] UART_INTR_STATE_OFFSET = 6'h 0;</pre>
<pre>  parameter logic [5:0] UART_INTR_ENABLE_OFFSET = 6'h 4;</pre>
<pre>  parameter logic [5:0] UART_INTR_TEST_OFFSET = 6'h 8;</pre>
<pre>  parameter logic [5:0] UART_CTRL_OFFSET = 6'h c;</pre>
<pre>  parameter logic [5:0] UART_STATUS_OFFSET = 6'h 10;</pre>
<pre>  parameter logic [5:0] UART_RDATA_OFFSET = 6'h 14;</pre>
<pre>  parameter logic [5:0] UART_WDATA_OFFSET = 6'h 18;</pre>
<pre>  parameter logic [5:0] UART_FIFO_CTRL_OFFSET = 6'h 1c;</pre>
<pre>  parameter logic [5:0] UART_FIFO_STATUS_OFFSET = 6'h 20;</pre>
<pre>  parameter logic [5:0] UART_OVRD_OFFSET = 6'h 24;</pre>
<pre>  parameter logic [5:0] UART_VAL_OFFSET = 6'h 28;</pre>
<pre>  parameter logic [5:0] UART_TIMEOUT_CTRL_OFFSET = 6'h 2c;</pre>
<pre>  typedef enum int {</pre>
<pre>    UART_INTR_STATE,</pre>
<pre>    UART_INTR_ENABLE,</pre>
<pre>    UART_INTR_TEST,</pre>
<pre>    UART_CTRL,</pre>
<pre>    UART_STATUS,</pre>
<pre>    UART_RDATA,</pre>
<pre>    UART_WDATA,</pre>
<pre>    UART_FIFO_CTRL,</pre>
<pre>    UART_FIFO_STATUS,</pre>
<pre>    UART_OVRD,</pre>
<pre>    UART_VAL,</pre>
<pre>    UART_TIMEOUT_CTRL</pre>
<pre>  } uart_id_e;</pre>
<pre>  parameter logic [3:0] UART_PERMIT [12] = '{</pre>
<pre>    4'b 0001, // index[ 0] UART_INTR_STATE</pre>
<pre>    4'b 0001, // index[ 1] UART_INTR_ENABLE</pre>
<pre>    4'b 0001, // index[ 2] UART_INTR_TEST</pre>
<pre>    4'b 1111, // index[ 3] UART_CTRL</pre>
<pre>    4'b 0001, // index[ 4] UART_STATUS</pre>
<pre>    4'b 0001, // index[ 5] UART_RDATA</pre>
<pre>    4'b 0001, // index[ 6] UART_WDATA</pre>
<pre>    4'b 0001, // index[ 7] UART_FIFO_CTRL</pre>
<pre>    4'b 0111, // index[ 8] UART_FIFO_STATUS</pre>
<pre>    4'b 0001, // index[ 9] UART_OVRD</pre>
<pre>    4'b 0011, // index[10] UART_VAL</pre>
<pre>    4'b 1111  // index[11] UART_TIMEOUT_CTRL</pre>
<h3>hw/ip/uart/rtl/uart_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output uart_reg_pkg::uart_reg2hw_t reg2hw, // Write</pre>
<pre>  input  uart_reg_pkg::uart_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam int AW = 6;</pre>
<pre>  localparam int DW = 32;</pre>
<pre>  localparam int DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  assign tl_reg_h2d = tl_i;</pre>
<pre>  assign tl_o       = tl_reg_d2h;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic intr_state_tx_watermark_qs;</pre>
<pre>  logic intr_state_tx_watermark_wd;</pre>
<pre>  logic intr_state_tx_watermark_we;</pre>
<pre>  logic intr_state_rx_watermark_qs;</pre>
<pre>  logic intr_state_rx_watermark_wd;</pre>
<pre>  logic intr_state_rx_watermark_we;</pre>
<pre>  logic intr_state_tx_empty_qs;</pre>
<pre>  logic intr_state_tx_empty_wd;</pre>
<pre>  logic intr_state_tx_empty_we;</pre>
<pre>  logic intr_state_rx_overflow_qs;</pre>
<pre>  logic intr_state_rx_overflow_wd;</pre>
<pre>  logic intr_state_rx_overflow_we;</pre>
<pre>  logic intr_state_rx_frame_err_qs;</pre>
<pre>  logic intr_state_rx_frame_err_wd;</pre>
<pre>  logic intr_state_rx_frame_err_we;</pre>
<pre>  logic intr_state_rx_break_err_qs;</pre>
<pre>  logic intr_state_rx_break_err_wd;</pre>
<pre>  logic intr_state_rx_break_err_we;</pre>
<pre>  logic intr_state_rx_timeout_qs;</pre>
<pre>  logic intr_state_rx_timeout_wd;</pre>
<pre>  logic intr_state_rx_timeout_we;</pre>
<pre>  logic intr_state_rx_parity_err_qs;</pre>
<pre>  logic intr_state_rx_parity_err_wd;</pre>
<pre>  logic intr_state_rx_parity_err_we;</pre>
<pre>  logic intr_enable_tx_watermark_qs;</pre>
<pre>  logic intr_enable_tx_watermark_wd;</pre>
<pre>  logic intr_enable_tx_watermark_we;</pre>
<pre>  logic intr_enable_rx_watermark_qs;</pre>
<pre>  logic intr_enable_rx_watermark_wd;</pre>
<pre>  logic intr_enable_rx_watermark_we;</pre>
<pre>  logic intr_enable_tx_empty_qs;</pre>
<pre>  logic intr_enable_tx_empty_wd;</pre>
<pre>  logic intr_enable_tx_empty_we;</pre>
<pre>  logic intr_enable_rx_overflow_qs;</pre>
<pre>  logic intr_enable_rx_overflow_wd;</pre>
<pre>  logic intr_enable_rx_overflow_we;</pre>
<pre>  logic intr_enable_rx_frame_err_qs;</pre>
<pre>  logic intr_enable_rx_frame_err_wd;</pre>
<pre>  logic intr_enable_rx_frame_err_we;</pre>
<pre>  logic intr_enable_rx_break_err_qs;</pre>
<pre>  logic intr_enable_rx_break_err_wd;</pre>
<pre>  logic intr_enable_rx_break_err_we;</pre>
<pre>  logic intr_enable_rx_timeout_qs;</pre>
<pre>  logic intr_enable_rx_timeout_wd;</pre>
<pre>  logic intr_enable_rx_timeout_we;</pre>
<pre>  logic intr_enable_rx_parity_err_qs;</pre>
<pre>  logic intr_enable_rx_parity_err_wd;</pre>
<pre>  logic intr_enable_rx_parity_err_we;</pre>
<pre>  logic intr_test_tx_watermark_wd;</pre>
<pre>  logic intr_test_tx_watermark_we;</pre>
<pre>  logic intr_test_rx_watermark_wd;</pre>
<pre>  logic intr_test_rx_watermark_we;</pre>
<pre>  logic intr_test_tx_empty_wd;</pre>
<pre>  logic intr_test_tx_empty_we;</pre>
<pre>  logic intr_test_rx_overflow_wd;</pre>
<pre>  logic intr_test_rx_overflow_we;</pre>
<pre>  logic intr_test_rx_frame_err_wd;</pre>
<pre>  logic intr_test_rx_frame_err_we;</pre>
<pre>  logic intr_test_rx_break_err_wd;</pre>
<pre>  logic intr_test_rx_break_err_we;</pre>
<pre>  logic intr_test_rx_timeout_wd;</pre>
<pre>  logic intr_test_rx_timeout_we;</pre>
<pre>  logic intr_test_rx_parity_err_wd;</pre>
<pre>  logic intr_test_rx_parity_err_we;</pre>
<pre>  logic ctrl_tx_qs;</pre>
<pre>  logic ctrl_tx_wd;</pre>
<pre>  logic ctrl_tx_we;</pre>
<pre>  logic ctrl_rx_qs;</pre>
<pre>  logic ctrl_rx_wd;</pre>
<pre>  logic ctrl_rx_we;</pre>
<pre>  logic ctrl_nf_qs;</pre>
<pre>  logic ctrl_nf_wd;</pre>
<pre>  logic ctrl_nf_we;</pre>
<pre>  logic ctrl_slpbk_qs;</pre>
<pre>  logic ctrl_slpbk_wd;</pre>
<pre>  logic ctrl_slpbk_we;</pre>
<pre>  logic ctrl_llpbk_qs;</pre>
<pre>  logic ctrl_llpbk_wd;</pre>
<pre>  logic ctrl_llpbk_we;</pre>
<pre>  logic ctrl_parity_en_qs;</pre>
<pre>  logic ctrl_parity_en_wd;</pre>
<pre>  logic ctrl_parity_en_we;</pre>
<pre>  logic ctrl_parity_odd_qs;</pre>
<pre>  logic ctrl_parity_odd_wd;</pre>
<pre>  logic ctrl_parity_odd_we;</pre>
<pre>  logic [1:0] ctrl_rxblvl_qs;</pre>
<pre>  logic [1:0] ctrl_rxblvl_wd;</pre>
<pre>  logic ctrl_rxblvl_we;</pre>
<pre>  logic [15:0] ctrl_nco_qs;</pre>
<pre>  logic [15:0] ctrl_nco_wd;</pre>
<pre>  logic ctrl_nco_we;</pre>
<pre>  logic status_txfull_qs;</pre>
<pre>  logic status_txfull_re;</pre>
<pre>  logic status_rxfull_qs;</pre>
<pre>  logic status_rxfull_re;</pre>
<pre>  logic status_txempty_qs;</pre>
<pre>  logic status_txempty_re;</pre>
<pre>  logic status_txidle_qs;</pre>
<pre>  logic status_txidle_re;</pre>
<pre>  logic status_rxidle_qs;</pre>
<pre>  logic status_rxidle_re;</pre>
<pre>  logic status_rxempty_qs;</pre>
<pre>  logic status_rxempty_re;</pre>
<pre>  logic [7:0] rdata_qs;</pre>
<pre>  logic rdata_re;</pre>
<pre>  logic [7:0] wdata_wd;</pre>
<pre>  logic wdata_we;</pre>
<pre>  logic fifo_ctrl_rxrst_wd;</pre>
<pre>  logic fifo_ctrl_rxrst_we;</pre>
<pre>  logic fifo_ctrl_txrst_wd;</pre>
<pre>  logic fifo_ctrl_txrst_we;</pre>
<pre>  logic [2:0] fifo_ctrl_rxilvl_qs;</pre>
<pre>  logic [2:0] fifo_ctrl_rxilvl_wd;</pre>
<pre>  logic fifo_ctrl_rxilvl_we;</pre>
<pre>  logic [1:0] fifo_ctrl_txilvl_qs;</pre>
<pre>  logic [1:0] fifo_ctrl_txilvl_wd;</pre>
<pre>  logic fifo_ctrl_txilvl_we;</pre>
<pre>  logic [5:0] fifo_status_txlvl_qs;</pre>
<pre>  logic fifo_status_txlvl_re;</pre>
<pre>  logic [5:0] fifo_status_rxlvl_qs;</pre>
<pre>  logic fifo_status_rxlvl_re;</pre>
<pre>  logic ovrd_txen_qs;</pre>
<pre>  logic ovrd_txen_wd;</pre>
<pre>  logic ovrd_txen_we;</pre>
<pre>  logic ovrd_txval_qs;</pre>
<pre>  logic ovrd_txval_wd;</pre>
<pre>  logic ovrd_txval_we;</pre>
<pre>  logic [15:0] val_qs;</pre>
<pre>  logic val_re;</pre>
<pre>  logic [23:0] timeout_ctrl_val_qs;</pre>
<pre>  logic [23:0] timeout_ctrl_val_wd;</pre>
<pre>  logic timeout_ctrl_val_we;</pre>
<pre>  logic timeout_ctrl_en_qs;</pre>
<pre>  logic timeout_ctrl_en_wd;</pre>
<pre>  logic timeout_ctrl_en_we;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_tx_watermark (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_tx_watermark_we),</pre>
<pre>    .wd     (intr_state_tx_watermark_wd),</pre>
<pre>    .de     (hw2reg.intr_state.tx_watermark.de),</pre>
<pre>    .d      (hw2reg.intr_state.tx_watermark.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.tx_watermark.q ),</pre>
<pre>    .qs     (intr_state_tx_watermark_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rx_watermark (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rx_watermark_we),</pre>
<pre>    .wd     (intr_state_rx_watermark_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rx_watermark.de),</pre>
<pre>    .d      (hw2reg.intr_state.rx_watermark.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rx_watermark.q ),</pre>
<pre>    .qs     (intr_state_rx_watermark_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_tx_empty (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_tx_empty_we),</pre>
<pre>    .wd     (intr_state_tx_empty_wd),</pre>
<pre>    .de     (hw2reg.intr_state.tx_empty.de),</pre>
<pre>    .d      (hw2reg.intr_state.tx_empty.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.tx_empty.q ),</pre>
<pre>    .qs     (intr_state_tx_empty_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rx_overflow (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rx_overflow_we),</pre>
<pre>    .wd     (intr_state_rx_overflow_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rx_overflow.de),</pre>
<pre>    .d      (hw2reg.intr_state.rx_overflow.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rx_overflow.q ),</pre>
<pre>    .qs     (intr_state_rx_overflow_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rx_frame_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rx_frame_err_we),</pre>
<pre>    .wd     (intr_state_rx_frame_err_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rx_frame_err.de),</pre>
<pre>    .d      (hw2reg.intr_state.rx_frame_err.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rx_frame_err.q ),</pre>
<pre>    .qs     (intr_state_rx_frame_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rx_break_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rx_break_err_we),</pre>
<pre>    .wd     (intr_state_rx_break_err_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rx_break_err.de),</pre>
<pre>    .d      (hw2reg.intr_state.rx_break_err.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rx_break_err.q ),</pre>
<pre>    .qs     (intr_state_rx_break_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rx_timeout (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rx_timeout_we),</pre>
<pre>    .wd     (intr_state_rx_timeout_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rx_timeout.de),</pre>
<pre>    .d      (hw2reg.intr_state.rx_timeout.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rx_timeout.q ),</pre>
<pre>    .qs     (intr_state_rx_timeout_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rx_parity_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rx_parity_err_we),</pre>
<pre>    .wd     (intr_state_rx_parity_err_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rx_parity_err.de),</pre>
<pre>    .d      (hw2reg.intr_state.rx_parity_err.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rx_parity_err.q ),</pre>
<pre>    .qs     (intr_state_rx_parity_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_tx_watermark (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_tx_watermark_we),</pre>
<pre>    .wd     (intr_enable_tx_watermark_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.tx_watermark.q ),</pre>
<pre>    .qs     (intr_enable_tx_watermark_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rx_watermark (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rx_watermark_we),</pre>
<pre>    .wd     (intr_enable_rx_watermark_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rx_watermark.q ),</pre>
<pre>    .qs     (intr_enable_rx_watermark_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_tx_empty (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_tx_empty_we),</pre>
<pre>    .wd     (intr_enable_tx_empty_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.tx_empty.q ),</pre>
<pre>    .qs     (intr_enable_tx_empty_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rx_overflow (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rx_overflow_we),</pre>
<pre>    .wd     (intr_enable_rx_overflow_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rx_overflow.q ),</pre>
<pre>    .qs     (intr_enable_rx_overflow_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rx_frame_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rx_frame_err_we),</pre>
<pre>    .wd     (intr_enable_rx_frame_err_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rx_frame_err.q ),</pre>
<pre>    .qs     (intr_enable_rx_frame_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rx_break_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rx_break_err_we),</pre>
<pre>    .wd     (intr_enable_rx_break_err_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rx_break_err.q ),</pre>
<pre>    .qs     (intr_enable_rx_break_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rx_timeout (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rx_timeout_we),</pre>
<pre>    .wd     (intr_enable_rx_timeout_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rx_timeout.q ),</pre>
<pre>    .qs     (intr_enable_rx_timeout_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rx_parity_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rx_parity_err_we),</pre>
<pre>    .wd     (intr_enable_rx_parity_err_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rx_parity_err.q ),</pre>
<pre>    .qs     (intr_enable_rx_parity_err_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_tx_watermark (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_tx_watermark_we),</pre>
<pre>    .wd     (intr_test_tx_watermark_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.tx_watermark.qe),</pre>
<pre>    .q      (reg2hw.intr_test.tx_watermark.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rx_watermark (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rx_watermark_we),</pre>
<pre>    .wd     (intr_test_rx_watermark_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rx_watermark.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rx_watermark.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_tx_empty (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_tx_empty_we),</pre>
<pre>    .wd     (intr_test_tx_empty_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.tx_empty.qe),</pre>
<pre>    .q      (reg2hw.intr_test.tx_empty.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rx_overflow (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rx_overflow_we),</pre>
<pre>    .wd     (intr_test_rx_overflow_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rx_overflow.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rx_overflow.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rx_frame_err (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rx_frame_err_we),</pre>
<pre>    .wd     (intr_test_rx_frame_err_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rx_frame_err.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rx_frame_err.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rx_break_err (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rx_break_err_we),</pre>
<pre>    .wd     (intr_test_rx_break_err_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rx_break_err.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rx_break_err.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rx_timeout (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rx_timeout_we),</pre>
<pre>    .wd     (intr_test_rx_timeout_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rx_timeout.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rx_timeout.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rx_parity_err (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rx_parity_err_we),</pre>
<pre>    .wd     (intr_test_rx_parity_err_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rx_parity_err.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rx_parity_err.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_tx (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_tx_we),</pre>
<pre>    .wd     (ctrl_tx_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl.tx.q ),</pre>
<pre>    .qs     (ctrl_tx_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_rx (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_rx_we),</pre>
<pre>    .wd     (ctrl_rx_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl.rx.q ),</pre>
<pre>    .qs     (ctrl_rx_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_nf (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_nf_we),</pre>
<pre>    .wd     (ctrl_nf_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl.nf.q ),</pre>
<pre>    .qs     (ctrl_nf_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_slpbk (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_slpbk_we),</pre>
<pre>    .wd     (ctrl_slpbk_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl.slpbk.q ),</pre>
<pre>    .qs     (ctrl_slpbk_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_llpbk (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_llpbk_we),</pre>
<pre>    .wd     (ctrl_llpbk_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl.llpbk.q ),</pre>
<pre>    .qs     (ctrl_llpbk_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_parity_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_parity_en_we),</pre>
<pre>    .wd     (ctrl_parity_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl.parity_en.q ),</pre>
<pre>    .qs     (ctrl_parity_en_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_parity_odd (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_parity_odd_we),</pre>
<pre>    .wd     (ctrl_parity_odd_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl.parity_odd.q ),</pre>
<pre>    .qs     (ctrl_parity_odd_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_rxblvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_rxblvl_we),</pre>
<pre>    .wd     (ctrl_rxblvl_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl.rxblvl.q ),</pre>
<pre>    .qs     (ctrl_rxblvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_nco (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_nco_we),</pre>
<pre>    .wd     (ctrl_nco_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl.nco.q ),</pre>
<pre>    .qs     (ctrl_nco_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_txfull (</pre>
<pre>    .re     (status_txfull_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.txfull.d),</pre>
<pre>    .qre    (reg2hw.status.txfull.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.status.txfull.q ),</pre>
<pre>    .qs     (status_txfull_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_rxfull (</pre>
<pre>    .re     (status_rxfull_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.rxfull.d),</pre>
<pre>    .qre    (reg2hw.status.rxfull.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.status.rxfull.q ),</pre>
<pre>    .qs     (status_rxfull_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_txempty (</pre>
<pre>    .re     (status_txempty_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.txempty.d),</pre>
<pre>    .qre    (reg2hw.status.txempty.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.status.txempty.q ),</pre>
<pre>    .qs     (status_txempty_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_txidle (</pre>
<pre>    .re     (status_txidle_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.txidle.d),</pre>
<pre>    .qre    (reg2hw.status.txidle.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.status.txidle.q ),</pre>
<pre>    .qs     (status_txidle_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_rxidle (</pre>
<pre>    .re     (status_rxidle_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.rxidle.d),</pre>
<pre>    .qre    (reg2hw.status.rxidle.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.status.rxidle.q ),</pre>
<pre>    .qs     (status_rxidle_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_rxempty (</pre>
<pre>    .re     (status_rxempty_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.rxempty.d),</pre>
<pre>    .qre    (reg2hw.status.rxempty.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.status.rxempty.q ),</pre>
<pre>    .qs     (status_rxempty_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (8)</pre>
<pre style="background-color: #FF0000;">  ) u_rdata (</pre>
<pre>    .re     (rdata_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.rdata.d),</pre>
<pre>    .qre    (reg2hw.rdata.re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rdata.q ),</pre>
<pre>    .qs     (rdata_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (8),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (8'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_wdata (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (wdata_we),</pre>
<pre>    .wd     (wdata_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.wdata.qe),</pre>
<pre>    .q      (reg2hw.wdata.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_fifo_ctrl_rxrst (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (fifo_ctrl_rxrst_we),</pre>
<pre>    .wd     (fifo_ctrl_rxrst_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.fifo_ctrl.rxrst.qe),</pre>
<pre>    .q      (reg2hw.fifo_ctrl.rxrst.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_fifo_ctrl_txrst (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (fifo_ctrl_txrst_we),</pre>
<pre>    .wd     (fifo_ctrl_txrst_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (reg2hw.fifo_ctrl.txrst.qe),</pre>
<pre>    .q      (reg2hw.fifo_ctrl.txrst.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (3),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (3'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_fifo_ctrl_rxilvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (fifo_ctrl_rxilvl_we),</pre>
<pre>    .wd     (fifo_ctrl_rxilvl_wd),</pre>
<pre>    .de     (hw2reg.fifo_ctrl.rxilvl.de),</pre>
<pre>    .d      (hw2reg.fifo_ctrl.rxilvl.d ),</pre>
<pre>    .qe     (reg2hw.fifo_ctrl.rxilvl.qe),</pre>
<pre>    .q      (reg2hw.fifo_ctrl.rxilvl.q ),</pre>
<pre>    .qs     (fifo_ctrl_rxilvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_fifo_ctrl_txilvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (fifo_ctrl_txilvl_we),</pre>
<pre>    .wd     (fifo_ctrl_txilvl_wd),</pre>
<pre>    .de     (hw2reg.fifo_ctrl.txilvl.de),</pre>
<pre>    .d      (hw2reg.fifo_ctrl.txilvl.d ),</pre>
<pre>    .qe     (reg2hw.fifo_ctrl.txilvl.qe),</pre>
<pre>    .q      (reg2hw.fifo_ctrl.txilvl.q ),</pre>
<pre>    .qs     (fifo_ctrl_txilvl_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (6)</pre>
<pre style="background-color: #FF0000;">  ) u_fifo_status_txlvl (</pre>
<pre>    .re     (fifo_status_txlvl_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.fifo_status.txlvl.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (fifo_status_txlvl_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (6)</pre>
<pre style="background-color: #FF0000;">  ) u_fifo_status_rxlvl (</pre>
<pre>    .re     (fifo_status_rxlvl_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.fifo_status.rxlvl.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (fifo_status_rxlvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ovrd_txen (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ovrd_txen_we),</pre>
<pre>    .wd     (ovrd_txen_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ovrd.txen.q ),</pre>
<pre>    .qs     (ovrd_txen_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ovrd_txval (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ovrd_txval_we),</pre>
<pre>    .wd     (ovrd_txval_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ovrd.txval.q ),</pre>
<pre>    .qs     (ovrd_txval_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_val (</pre>
<pre>    .re     (val_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.val.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (val_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (24),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (24'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_timeout_ctrl_val (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (timeout_ctrl_val_we),</pre>
<pre>    .wd     (timeout_ctrl_val_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.timeout_ctrl.val.q ),</pre>
<pre>    .qs     (timeout_ctrl_val_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_timeout_ctrl_en (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (timeout_ctrl_en_we),</pre>
<pre>    .wd     (timeout_ctrl_en_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.timeout_ctrl.en.q ),</pre>
<pre>    .qs     (timeout_ctrl_en_qs)</pre>
<pre>  logic [11:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[ 0] = (reg_addr == UART_INTR_STATE_OFFSET);</pre>
<pre>    addr_hit[ 1] = (reg_addr == UART_INTR_ENABLE_OFFSET);</pre>
<pre>    addr_hit[ 2] = (reg_addr == UART_INTR_TEST_OFFSET);</pre>
<pre>    addr_hit[ 3] = (reg_addr == UART_CTRL_OFFSET);</pre>
<pre>    addr_hit[ 4] = (reg_addr == UART_STATUS_OFFSET);</pre>
<pre>    addr_hit[ 5] = (reg_addr == UART_RDATA_OFFSET);</pre>
<pre>    addr_hit[ 6] = (reg_addr == UART_WDATA_OFFSET);</pre>
<pre>    addr_hit[ 7] = (reg_addr == UART_FIFO_CTRL_OFFSET);</pre>
<pre>    addr_hit[ 8] = (reg_addr == UART_FIFO_STATUS_OFFSET);</pre>
<pre>    addr_hit[ 9] = (reg_addr == UART_OVRD_OFFSET);</pre>
<pre>    addr_hit[10] = (reg_addr == UART_VAL_OFFSET);</pre>
<pre>    addr_hit[11] = (reg_addr == UART_TIMEOUT_CTRL_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[ 0] && reg_we && (UART_PERMIT[ 0] != (UART_PERMIT[ 0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 1] && reg_we && (UART_PERMIT[ 1] != (UART_PERMIT[ 1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 2] && reg_we && (UART_PERMIT[ 2] != (UART_PERMIT[ 2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 3] && reg_we && (UART_PERMIT[ 3] != (UART_PERMIT[ 3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 4] && reg_we && (UART_PERMIT[ 4] != (UART_PERMIT[ 4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 5] && reg_we && (UART_PERMIT[ 5] != (UART_PERMIT[ 5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 6] && reg_we && (UART_PERMIT[ 6] != (UART_PERMIT[ 6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 7] && reg_we && (UART_PERMIT[ 7] != (UART_PERMIT[ 7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 8] && reg_we && (UART_PERMIT[ 8] != (UART_PERMIT[ 8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 9] && reg_we && (UART_PERMIT[ 9] != (UART_PERMIT[ 9] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[10] && reg_we && (UART_PERMIT[10] != (UART_PERMIT[10] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[11] && reg_we && (UART_PERMIT[11] != (UART_PERMIT[11] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign intr_state_tx_watermark_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_tx_watermark_wd = reg_wdata[0];</pre>
<pre>  assign intr_state_rx_watermark_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rx_watermark_wd = reg_wdata[1];</pre>
<pre>  assign intr_state_tx_empty_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_tx_empty_wd = reg_wdata[2];</pre>
<pre>  assign intr_state_rx_overflow_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rx_overflow_wd = reg_wdata[3];</pre>
<pre>  assign intr_state_rx_frame_err_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rx_frame_err_wd = reg_wdata[4];</pre>
<pre>  assign intr_state_rx_break_err_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rx_break_err_wd = reg_wdata[5];</pre>
<pre>  assign intr_state_rx_timeout_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rx_timeout_wd = reg_wdata[6];</pre>
<pre>  assign intr_state_rx_parity_err_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rx_parity_err_wd = reg_wdata[7];</pre>
<pre>  assign intr_enable_tx_watermark_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_tx_watermark_wd = reg_wdata[0];</pre>
<pre>  assign intr_enable_rx_watermark_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rx_watermark_wd = reg_wdata[1];</pre>
<pre>  assign intr_enable_tx_empty_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_tx_empty_wd = reg_wdata[2];</pre>
<pre>  assign intr_enable_rx_overflow_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rx_overflow_wd = reg_wdata[3];</pre>
<pre>  assign intr_enable_rx_frame_err_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rx_frame_err_wd = reg_wdata[4];</pre>
<pre>  assign intr_enable_rx_break_err_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rx_break_err_wd = reg_wdata[5];</pre>
<pre>  assign intr_enable_rx_timeout_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rx_timeout_wd = reg_wdata[6];</pre>
<pre>  assign intr_enable_rx_parity_err_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rx_parity_err_wd = reg_wdata[7];</pre>
<pre>  assign intr_test_tx_watermark_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_tx_watermark_wd = reg_wdata[0];</pre>
<pre>  assign intr_test_rx_watermark_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rx_watermark_wd = reg_wdata[1];</pre>
<pre>  assign intr_test_tx_empty_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_tx_empty_wd = reg_wdata[2];</pre>
<pre>  assign intr_test_rx_overflow_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rx_overflow_wd = reg_wdata[3];</pre>
<pre>  assign intr_test_rx_frame_err_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rx_frame_err_wd = reg_wdata[4];</pre>
<pre>  assign intr_test_rx_break_err_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rx_break_err_wd = reg_wdata[5];</pre>
<pre>  assign intr_test_rx_timeout_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rx_timeout_wd = reg_wdata[6];</pre>
<pre>  assign intr_test_rx_parity_err_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rx_parity_err_wd = reg_wdata[7];</pre>
<pre>  assign ctrl_tx_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_tx_wd = reg_wdata[0];</pre>
<pre>  assign ctrl_rx_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_rx_wd = reg_wdata[1];</pre>
<pre>  assign ctrl_nf_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_nf_wd = reg_wdata[2];</pre>
<pre>  assign ctrl_slpbk_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_slpbk_wd = reg_wdata[4];</pre>
<pre>  assign ctrl_llpbk_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_llpbk_wd = reg_wdata[5];</pre>
<pre>  assign ctrl_parity_en_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_parity_en_wd = reg_wdata[6];</pre>
<pre>  assign ctrl_parity_odd_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_parity_odd_wd = reg_wdata[7];</pre>
<pre>  assign ctrl_rxblvl_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_rxblvl_wd = reg_wdata[9:8];</pre>
<pre>  assign ctrl_nco_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_nco_wd = reg_wdata[31:16];</pre>
<pre>  assign status_txfull_re = addr_hit[4] && reg_re;</pre>
<pre>  assign status_rxfull_re = addr_hit[4] && reg_re;</pre>
<pre>  assign status_txempty_re = addr_hit[4] && reg_re;</pre>
<pre>  assign status_txidle_re = addr_hit[4] && reg_re;</pre>
<pre>  assign status_rxidle_re = addr_hit[4] && reg_re;</pre>
<pre>  assign status_rxempty_re = addr_hit[4] && reg_re;</pre>
<pre>  assign rdata_re = addr_hit[5] && reg_re;</pre>
<pre>  assign wdata_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign wdata_wd = reg_wdata[7:0];</pre>
<pre>  assign fifo_ctrl_rxrst_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign fifo_ctrl_rxrst_wd = reg_wdata[0];</pre>
<pre>  assign fifo_ctrl_txrst_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign fifo_ctrl_txrst_wd = reg_wdata[1];</pre>
<pre>  assign fifo_ctrl_rxilvl_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign fifo_ctrl_rxilvl_wd = reg_wdata[4:2];</pre>
<pre>  assign fifo_ctrl_txilvl_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign fifo_ctrl_txilvl_wd = reg_wdata[6:5];</pre>
<pre>  assign fifo_status_txlvl_re = addr_hit[8] && reg_re;</pre>
<pre>  assign fifo_status_rxlvl_re = addr_hit[8] && reg_re;</pre>
<pre>  assign ovrd_txen_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign ovrd_txen_wd = reg_wdata[0];</pre>
<pre>  assign ovrd_txval_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign ovrd_txval_wd = reg_wdata[1];</pre>
<pre>  assign val_re = addr_hit[10] && reg_re;</pre>
<pre>  assign timeout_ctrl_val_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign timeout_ctrl_val_wd = reg_wdata[23:0];</pre>
<pre>  assign timeout_ctrl_en_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign timeout_ctrl_en_wd = reg_wdata[31];</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[0] = intr_state_tx_watermark_qs;</pre>
<pre>        reg_rdata_next[1] = intr_state_rx_watermark_qs;</pre>
<pre>        reg_rdata_next[2] = intr_state_tx_empty_qs;</pre>
<pre>        reg_rdata_next[3] = intr_state_rx_overflow_qs;</pre>
<pre>        reg_rdata_next[4] = intr_state_rx_frame_err_qs;</pre>
<pre>        reg_rdata_next[5] = intr_state_rx_break_err_qs;</pre>
<pre>        reg_rdata_next[6] = intr_state_rx_timeout_qs;</pre>
<pre>        reg_rdata_next[7] = intr_state_rx_parity_err_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[0] = intr_enable_tx_watermark_qs;</pre>
<pre>        reg_rdata_next[1] = intr_enable_rx_watermark_qs;</pre>
<pre>        reg_rdata_next[2] = intr_enable_tx_empty_qs;</pre>
<pre>        reg_rdata_next[3] = intr_enable_rx_overflow_qs;</pre>
<pre>        reg_rdata_next[4] = intr_enable_rx_frame_err_qs;</pre>
<pre>        reg_rdata_next[5] = intr_enable_rx_break_err_qs;</pre>
<pre>        reg_rdata_next[6] = intr_enable_rx_timeout_qs;</pre>
<pre>        reg_rdata_next[7] = intr_enable_rx_parity_err_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>        reg_rdata_next[2] = '0;</pre>
<pre>        reg_rdata_next[3] = '0;</pre>
<pre>        reg_rdata_next[4] = '0;</pre>
<pre>        reg_rdata_next[5] = '0;</pre>
<pre>        reg_rdata_next[6] = '0;</pre>
<pre>        reg_rdata_next[7] = '0;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[0] = ctrl_tx_qs;</pre>
<pre>        reg_rdata_next[1] = ctrl_rx_qs;</pre>
<pre>        reg_rdata_next[2] = ctrl_nf_qs;</pre>
<pre>        reg_rdata_next[4] = ctrl_slpbk_qs;</pre>
<pre>        reg_rdata_next[5] = ctrl_llpbk_qs;</pre>
<pre>        reg_rdata_next[6] = ctrl_parity_en_qs;</pre>
<pre>        reg_rdata_next[7] = ctrl_parity_odd_qs;</pre>
<pre>        reg_rdata_next[9:8] = ctrl_rxblvl_qs;</pre>
<pre>        reg_rdata_next[31:16] = ctrl_nco_qs;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[0] = status_txfull_qs;</pre>
<pre>        reg_rdata_next[1] = status_rxfull_qs;</pre>
<pre>        reg_rdata_next[2] = status_txempty_qs;</pre>
<pre>        reg_rdata_next[3] = status_txidle_qs;</pre>
<pre>        reg_rdata_next[4] = status_rxidle_qs;</pre>
<pre>        reg_rdata_next[5] = status_rxempty_qs;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[7:0] = rdata_qs;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[7:0] = '0;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>        reg_rdata_next[4:2] = fifo_ctrl_rxilvl_qs;</pre>
<pre>        reg_rdata_next[6:5] = fifo_ctrl_txilvl_qs;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[5:0] = fifo_status_txlvl_qs;</pre>
<pre>        reg_rdata_next[21:16] = fifo_status_rxlvl_qs;</pre>
<pre>      addr_hit[9]: begin</pre>
<pre>        reg_rdata_next[0] = ovrd_txen_qs;</pre>
<pre>        reg_rdata_next[1] = ovrd_txval_qs;</pre>
<pre>      addr_hit[10]: begin</pre>
<pre>        reg_rdata_next[15:0] = val_qs;</pre>
<pre>      addr_hit[11]: begin</pre>
<pre>        reg_rdata_next[23:0] = timeout_ctrl_val_qs;</pre>
<pre>        reg_rdata_next[31] = timeout_ctrl_en_qs;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/ip/prim_xilinx/rtl/prim_xilinx_clock_gating.sv</h3>
<pre>  input        clk_i,</pre>
<pre>  input        en_i,</pre>
<pre>  input        test_en_i,</pre>
<pre>  output logic clk_o</pre>
<pre style="background-color: #FF0000;">  BUFGCE u_bufgce (</pre>
<pre style="background-color: #FF0000;">    .I  (clk_i),</pre>
<pre style="background-color: #FF0000;">    .CE (en_i | test_en_i),</pre>
<pre style="background-color: #FF0000;">    .O  (clk_o)</pre>
<h3>hw/ip/prim/abstract/prim_flash.sv</h3>
<pre>  parameter prim_pkg::impl_e Impl = `PRIM_DEFAULT_IMPL,</pre>
<pre></pre>
<pre>  parameter int WordsPerPage = 256, // words per page</pre>
<pre>  parameter int DataWidth   = 32, // bits per word</pre>
<pre></pre>
<pre>  parameter int WordW = $clog2(WordsPerPage),</pre>
<pre>  parameter int AddrW = PageW + WordW</pre>
<pre>) (</pre>
<pre>  input                        rst_ni,</pre>
<pre>  input                        req_i,</pre>
<pre>  input                        host_req_i,</pre>
<pre>  input [AddrW-1:0]            host_addr_i,</pre>
<pre>  input                        rd_i,</pre>
<pre>  input                        prog_i,</pre>
<pre>  input                        pg_erase_i,</pre>
<pre>  input                        bk_erase_i,</pre>
<pre>  input [AddrW-1:0]            addr_i,</pre>
<pre>  input [DataWidth-1:0]        prog_data_i,</pre>
<pre>  output logic                 host_req_rdy_o,</pre>
<pre>  output logic                 host_req_done_o,</pre>
<pre>  output logic                 rd_done_o,</pre>
<pre>  output logic                 prog_done_o,</pre>
<pre>  output logic                 erase_done_o,</pre>
<pre>  output logic [DataWidth-1:0] rd_data_o,</pre>
<pre>  output logic                 init_busy_o</pre>
<pre>);</pre>
<pre>    prim_generic_flash #(</pre>
<pre>      .PagesPerBank(PagesPerBank),</pre>
<pre>      .WordsPerPage(WordsPerPage),</pre>
<pre>      .DataWidth(DataWidth)</pre>
<pre>    ) u_impl_generic (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .req_i,</pre>
<pre>      .host_req_i,</pre>
<pre>      .host_addr_i,</pre>
<pre>      .rd_i,</pre>
<pre>      .prog_i,</pre>
<pre>      .pg_erase_i,</pre>
<pre>      .bk_erase_i,</pre>
<pre>      .addr_i,</pre>
<pre>      .prog_data_i,</pre>
<pre>      .host_req_rdy_o,</pre>
<pre>      .host_req_done_o,</pre>
<pre>      .rd_done_o,</pre>
<pre>      .prog_done_o,</pre>
<pre>      .erase_done_o,</pre>
<pre>      .rd_data_o,</pre>
<pre>      .init_busy_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">    // TODO: Find code that works across tools and causes a compile failure</pre>
<h3>hw/ip/prim_xilinx/rtl/prim_xilinx_clock_mux2.sv</h3>
<pre>  input        clk0_i,</pre>
<pre>  input        clk1_i,</pre>
<pre>  input        sel_i,</pre>
<pre>  output logic clk_o</pre>
<pre style="background-color: #FF0000;">  BUFGMUX bufgmux_i (</pre>
<pre style="background-color: #FF0000;">    .S  ( sel_i  ),</pre>
<pre style="background-color: #FF0000;">    .I0 ( clk0_i ),</pre>
<pre style="background-color: #FF0000;">    .I1 ( clk1_i ),</pre>
<pre style="background-color: #FF0000;">    .O  ( clk_o  )</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>hw/ip/tlul/rtl/sram2tlul.sv</h3>
<pre>module sram2tlul #(</pre>
<pre>  parameter int                        SramAw = 12,</pre>
<pre>  parameter int                        SramDw = 32,</pre>
<pre>  parameter logic [top_pkg::TL_AW-1:0] TlBaseAddr = 'h0  // Base address of SRAM request</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_i,</pre>
<pre>  input                     mem_req,</pre>
<pre>  input                     mem_write,</pre>
<pre>  input        [SramAw-1:0] mem_addr,</pre>
<pre>  input        [SramDw-1:0] mem_wdata,</pre>
<pre>  output logic              mem_rvalid,</pre>
<pre>  output logic [SramDw-1:0] mem_rdata,</pre>
<pre>  output logic        [1:0] mem_error</pre>
<pre>  localparam int unsigned SRAM_DWB = $clog2(SramDw/8);</pre>
<pre>  assign tl_o.a_valid   = mem_req;</pre>
<pre>  assign tl_o.a_opcode  = (mem_write) ? PutFullData : Get;</pre>
<pre>  assign tl_o.a_param   = '0;</pre>
<pre>  assign tl_o.a_size    = top_pkg::TL_SZW'(SRAM_DWB); // Max Size always</pre>
<pre>  assign tl_o.a_source  = '0;</pre>
<pre>  assign tl_o.a_address = TlBaseAddr |</pre>
<pre>                          {{(top_pkg::TL_AW-SramAw-SRAM_DWB){1'b0}},mem_addr,{(SRAM_DWB){1'b0}}};</pre>
<pre>  assign tl_o.a_mask    = '1;</pre>
<pre>  assign tl_o.a_data    = mem_wdata;</pre>
<pre>  assign tl_o.a_user    = '0;</pre>
<pre>  assign tl_o.d_ready   = 1'b1;</pre>
<pre>  assign mem_rvalid     = tl_i.d_valid && (tl_i.d_opcode == AccessAckData);</pre>
<pre>  assign mem_rdata      = tl_i.d_data;</pre>
<pre>  assign mem_error      = {2{tl_i.d_error}};</pre>
<h3>hw/top_earlgrey/rtl/clkgen_xil7series.sv</h3>
<pre>  input IO_CLK,</pre>
<pre>  input IO_RST_N,</pre>
<pre>  output clk_sys,</pre>
<pre>  output clk_48MHz,</pre>
<pre>  output rst_sys_n</pre>
<pre>  logic locked_pll;</pre>
<pre>  logic io_clk_buf;</pre>
<pre>  logic clk_50_buf;</pre>
<pre>  logic clk_50_unbuf;</pre>
<pre>  logic clk_fb_buf;</pre>
<pre>  logic clk_fb_unbuf;</pre>
<pre>  logic clk_48_buf;</pre>
<pre>  logic clk_48_unbuf;</pre>
<pre>  IBUF io_clk_ibuf (</pre>
<pre>    .I (IO_CLK),</pre>
<pre>    .O (io_clk_buf)</pre>
<pre>  PLLE2_ADV #(</pre>
<pre style="background-color: #FF0000;">    .BANDWIDTH            ("OPTIMIZED"),</pre>
<pre style="background-color: #FF0000;">    .COMPENSATION         ("ZHOLD"),</pre>
<pre style="background-color: #FF0000;">    .STARTUP_WAIT         ("FALSE"),</pre>
<pre style="background-color: #FF0000;">    .DIVCLK_DIVIDE        (1),</pre>
<pre style="background-color: #FF0000;">    .CLKFBOUT_MULT        (12),</pre>
<pre style="background-color: #FF0000;">    .CLKFBOUT_PHASE       (0.000),</pre>
<pre style="background-color: #FF0000;">    .CLKOUT0_DIVIDE       (24),</pre>
<pre style="background-color: #FF0000;">    .CLKOUT0_PHASE        (0.000),</pre>
<pre style="background-color: #FF0000;">    .CLKOUT0_DUTY_CYCLE   (0.500),</pre>
<pre style="background-color: #FF0000;">    .CLKOUT1_DIVIDE       (25),</pre>
<pre style="background-color: #FF0000;">    .CLKOUT1_PHASE        (0.000),</pre>
<pre style="background-color: #FF0000;">    .CLKOUT1_DUTY_CYCLE   (0.500),</pre>
<pre style="background-color: #FF0000;">    .CLKIN1_PERIOD        (10.000)</pre>
<pre style="background-color: #FF0000;">  ) pll (</pre>
<pre>    .CLKFBOUT            (clk_fb_unbuf),</pre>
<pre>    .CLKOUT0             (clk_50_unbuf),</pre>
<pre>    .CLKOUT1             (clk_48_unbuf),</pre>
<pre>    .CLKOUT2             (),</pre>
<pre>    .CLKOUT3             (),</pre>
<pre>    .CLKOUT4             (),</pre>
<pre>    .CLKOUT5             (),</pre>
<pre>    .CLKFBIN             (clk_fb_buf),</pre>
<pre>    .CLKIN1              (io_clk_buf),</pre>
<pre>    .CLKIN2              (1'b0),</pre>
<pre>    .CLKINSEL            (1'b1),</pre>
<pre>    .DADDR               (7'h0),</pre>
<pre>    .DCLK                (1'b0),</pre>
<pre>    .DEN                 (1'b0),</pre>
<pre>    .DI                  (16'h0),</pre>
<pre>    .DO                  (),</pre>
<pre>    .DRDY                (),</pre>
<pre>    .DWE                 (1'b0),</pre>
<pre>    .LOCKED              (locked_pll),</pre>
<pre>    .PWRDWN              (1'b0),</pre>
<pre>    .RST                 (1'b0));</pre>
<pre>  BUFG clk_fb_bufg (</pre>
<pre>    .I (clk_fb_unbuf),</pre>
<pre>    .O (clk_fb_buf)</pre>
<pre>  BUFG clk_50_bufg (</pre>
<pre>    .I (clk_50_unbuf),</pre>
<pre>    .O (clk_50_buf)</pre>
<pre>  BUFG clk_48_bufg (</pre>
<pre>    .I (clk_48_unbuf),</pre>
<pre>    .O (clk_48_buf)</pre>
<pre>  assign clk_sys = clk_50_buf; // TODO: choose 50 MHz clock as sysclock for now</pre>
<pre>  assign clk_48MHz = clk_48_buf;</pre>
<pre>  assign rst_sys_n = locked_pll & IO_RST_N;</pre>
<h3>hw/top_earlgrey/rtl/top_earlgrey_nexysvideo.sv</h3>
<pre>  input               IO_CLK,</pre>
<pre>  input               IO_RST_N,</pre>
<pre>  input               IO_DPS0, // IO_JTCK,    IO_SDCK</pre>
<pre>  input               IO_DPS3, // IO_JTMS,    IO_SDCSB</pre>
<pre>  input               IO_DPS1, // IO_JTDI,    IO_SDMOSI</pre>
<pre>  input               IO_DPS4, // IO_JTRST_N,</pre>
<pre>  input               IO_DPS5, // IO_JSRST_N,</pre>
<pre>  output              IO_DPS2, // IO_JTDO,    IO_MISO</pre>
<pre>  input               IO_DPS6, // JTAG=0,     SPI=1</pre>
<pre>  input               IO_DPS7, // BOOTSTRAP=1</pre>
<pre>  input               IO_URX,</pre>
<pre>  output              IO_UTX,</pre>
<pre>  inout               IO_GP0,</pre>
<pre>  inout               IO_GP1,</pre>
<pre>  inout               IO_GP2,</pre>
<pre>  inout               IO_GP3,</pre>
<pre>  inout               IO_GP4,</pre>
<pre>  inout               IO_GP5,</pre>
<pre>  inout               IO_GP6,</pre>
<pre>  inout               IO_GP7,</pre>
<pre>  inout               IO_GP8,</pre>
<pre>  inout               IO_GP9,</pre>
<pre>  inout               IO_GP10,</pre>
<pre>  inout               IO_GP11,</pre>
<pre>  inout               IO_GP12,</pre>
<pre>  inout               IO_GP13,</pre>
<pre>  inout               IO_GP14,</pre>
<pre>  inout               IO_GP15</pre>
<pre>  logic clk_sys, rst_sys_n;</pre>
<pre>  logic [31:0]  cio_gpio_p2d, cio_gpio_d2p, cio_gpio_en_d2p;</pre>
<pre>  logic cio_uart_rx_p2d, cio_uart_tx_d2p, cio_uart_tx_en_d2p;</pre>
<pre>  logic cio_spi_device_sck_p2d, cio_spi_device_csb_p2d, cio_spi_device_mosi_p2d,</pre>
<pre>        cio_spi_device_miso_d2p, cio_spi_device_miso_en_d2p;</pre>
<pre>  logic cio_jtag_tck_p2d, cio_jtag_tms_p2d, cio_jtag_tdi_p2d, cio_jtag_tdo_d2p;</pre>
<pre>  logic cio_jtag_trst_n_p2d, cio_jtag_srst_n_p2d;</pre>
<pre>  top_earlgrey #(</pre>
<pre>    .IbexPipeLine(1)</pre>
<pre style="background-color: #FF0000;">  ) top_earlgrey (</pre>
<pre>    .clk_i                    (clk_sys),</pre>
<pre>    .rst_ni                   (rst_sys_n),</pre>
<pre>    .jtag_tck_i               (cio_jtag_tck_p2d),</pre>
<pre>    .jtag_tms_i               (cio_jtag_tms_p2d),</pre>
<pre>    .jtag_trst_ni             (cio_jtag_trst_n_p2d),</pre>
<pre>    .jtag_td_i                (cio_jtag_tdi_p2d),</pre>
<pre>    .jtag_td_o                (cio_jtag_tdo_d2p),</pre>
<pre>    .mio_in_i                 (cio_gpio_p2d),</pre>
<pre>    .mio_out_o                (cio_gpio_d2p),</pre>
<pre>    .mio_oe_o                 (cio_gpio_en_d2p),</pre>
<pre>    .dio_uart_rx_i            (cio_uart_rx_p2d),</pre>
<pre>    .dio_uart_tx_o            (cio_uart_tx_d2p),</pre>
<pre>    .dio_uart_tx_en_o         (cio_uart_tx_en_d2p),</pre>
<pre>    .dio_spi_device_sck_i     (cio_spi_device_sck_p2d),</pre>
<pre>    .dio_spi_device_csb_i     (cio_spi_device_csb_p2d),</pre>
<pre>    .dio_spi_device_mosi_i    (cio_spi_device_mosi_p2d),</pre>
<pre>    .dio_spi_device_miso_o    (cio_spi_device_miso_d2p),</pre>
<pre>    .dio_spi_device_miso_en_o (cio_spi_device_miso_en_d2p),</pre>
<pre>    .scanmode_i                   (1'b0) // 1 for Scan</pre>
<pre>  clkgen_xil7series clkgen (</pre>
<pre>    .IO_CLK(IO_CLK),</pre>
<pre>    .IO_RST_N(IO_RST_N & cio_jtag_srst_n_p2d),</pre>
<pre>    .clk_sys(clk_sys),</pre>
<pre>    .rst_sys_n(rst_sys_n)</pre>
<pre>  padctl padctl (</pre>
<pre>    .cio_uart_rx_p2d,</pre>
<pre>    .cio_uart_tx_d2p,</pre>
<pre>    .cio_uart_tx_en_d2p,</pre>
<pre>    .cio_gpio_p2d,</pre>
<pre>    .cio_gpio_d2p,</pre>
<pre>    .cio_gpio_en_d2p,</pre>
<pre>    .IO_URX,</pre>
<pre>    .IO_UTX,</pre>
<pre>    .IO_GP0,</pre>
<pre>    .IO_GP1,</pre>
<pre>    .IO_GP2,</pre>
<pre>    .IO_GP3,</pre>
<pre>    .IO_GP4,</pre>
<pre>    .IO_GP5,</pre>
<pre>    .IO_GP6,</pre>
<pre>    .IO_GP7,</pre>
<pre>    .IO_GP8,</pre>
<pre>    .IO_GP9,</pre>
<pre>    .IO_GP10,</pre>
<pre>    .IO_GP11,</pre>
<pre>    .IO_GP12,</pre>
<pre>    .IO_GP13,</pre>
<pre>    .IO_GP14,</pre>
<pre>    .IO_GP15,</pre>
<pre>    .cio_spi_device_sck_p2d,</pre>
<pre>    .cio_spi_device_csb_p2d,</pre>
<pre>    .cio_spi_device_mosi_p2d,</pre>
<pre>    .cio_spi_device_miso_d2p,</pre>
<pre>    .cio_spi_device_miso_en_d2p,</pre>
<pre>    .cio_jtag_tck_p2d,</pre>
<pre>    .cio_jtag_tms_p2d,</pre>
<pre>    .cio_jtag_trst_n_p2d,</pre>
<pre>    .cio_jtag_srst_n_p2d,</pre>
<pre>    .cio_jtag_tdi_p2d,</pre>
<pre>    .cio_jtag_tdo_d2p,</pre>
<pre>    .IO_DPS0,</pre>
<pre>    .IO_DPS1,</pre>
<pre>    .IO_DPS2,</pre>
<pre>    .IO_DPS3,</pre>
<pre>    .IO_DPS4,</pre>
<pre>    .IO_DPS5,</pre>
<pre>    .IO_DPS6,</pre>
<pre>    .IO_DPS7</pre>
<h3>hw/ip/prim_generic/rtl/prim_generic_flash.sv</h3>
<pre>module prim_generic_flash #(</pre>
<pre>  parameter int PagesPerBank = 256, // pages per bank</pre>
<pre>  parameter int WordsPerPage = 256, // words per page</pre>
<pre>  parameter int DataWidth   = 32,   // bits per word</pre>
<pre>  parameter bit SkipInit = 1,       // this is an option to reset flash to all F's at reset</pre>
<pre>  localparam int PageW = $clog2(PagesPerBank),</pre>
<pre>  localparam int WordW = $clog2(WordsPerPage),</pre>
<pre>  localparam int AddrW = PageW + WordW</pre>
<pre>  input                        clk_i,</pre>
<pre>  input                        rst_ni,</pre>
<pre>  input                        req_i,</pre>
<pre>  input                        host_req_i,</pre>
<pre>  input [AddrW-1:0]            host_addr_i,</pre>
<pre>  input                        rd_i,</pre>
<pre>  input                        prog_i,</pre>
<pre>  input                        pg_erase_i,</pre>
<pre>  input                        bk_erase_i,</pre>
<pre>  input [AddrW-1:0]            addr_i,</pre>
<pre>  input [DataWidth-1:0]        prog_data_i,</pre>
<pre>  output logic                 host_req_rdy_o,</pre>
<pre>  output logic                 host_req_done_o,</pre>
<pre>  output logic                 rd_done_o,</pre>
<pre>  output logic                 prog_done_o,</pre>
<pre>  output logic                 erase_done_o,</pre>
<pre>  output logic [DataWidth-1:0] rd_data_o,</pre>
<pre>  output logic                 init_busy_o</pre>
<pre>  localparam int ReadCycles = 1;</pre>
<pre>  localparam int ProgCycles = 50;</pre>
<pre>  localparam int PgEraseCycles = 200;</pre>
<pre>  localparam int BkEraseCycles = 2000;</pre>
<pre>  localparam int WordsPerBank  = PagesPerBank * WordsPerPage;</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    StReset    = 'h0,</pre>
<pre>    StInit     = 'h1,</pre>
<pre>    StIdle     = 'h2,</pre>
<pre>    StHostRead = 'h3,</pre>
<pre>    StRead     = 'h4,</pre>
<pre>    StProg     = 'h5,</pre>
<pre>    StErase    = 'h6</pre>
<pre>  } state_e;</pre>
<pre>  state_e st_next, st;</pre>
<pre>  logic [31:0]              time_cnt;</pre>
<pre>  logic [31:0]              index_cnt;</pre>
<pre>  logic                     time_cnt_inc ,time_cnt_clr, time_cnt_set1;</pre>
<pre>  logic                     index_cnt_inc, index_cnt_clr;</pre>
<pre>  logic [31:0]              index_limit, index_limit_next;</pre>
<pre>  logic [31:0]              time_limit, time_limit_next;</pre>
<pre>  logic                     prog_pend, prog_pend_next;</pre>
<pre>  logic                     mem_req;</pre>
<pre>  logic                     mem_wr;</pre>
<pre>  logic [AddrW-1:0]         mem_addr;</pre>
<pre>  logic [DataWidth-1:0]     held_data;</pre>
<pre>  logic [DataWidth-1:0]     mem_wdata;</pre>
<pre>  logic                     hold_rd_cmd;</pre>
<pre>  logic [AddrW-1:0]         held_rd_addr;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) st <= StReset;</pre>
<pre>    else st <= st_next;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) held_rd_addr <= '0;</pre>
<pre>    else if (hold_rd_cmd) held_rd_addr <= host_addr_i;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      time_cnt <= 32'h0;</pre>
<pre>      index_cnt <= 32'h0;</pre>
<pre>      time_limit <= 32'h0;</pre>
<pre>      index_limit <= 32'h0;</pre>
<pre>      held_data <= 'h0;</pre>
<pre>      prog_pend <= 1'h0;</pre>
<pre>    end else begin</pre>
<pre>      time_limit <= time_limit_next;</pre>
<pre>      index_limit <= index_limit_next;</pre>
<pre>      prog_pend <= prog_pend_next;</pre>
<pre>      if (time_cnt_inc) time_cnt <= time_cnt + 1'b1;</pre>
<pre>      else if (time_cnt_set1) time_cnt <= 32'h1;</pre>
<pre>      else if (time_cnt_clr) time_cnt <= 32'h0;</pre>
<pre>      if (index_cnt_inc) index_cnt <= index_cnt + 1'b1;</pre>
<pre>      else if (index_cnt_clr) index_cnt <= 32'h0;</pre>
<pre>      if (prog_pend) held_data <= rd_data_o;</pre>
<pre>  always_comb begin</pre>
<pre>    st_next          = st;</pre>
<pre>    index_limit_next = index_limit;</pre>
<pre>    time_limit_next  = time_limit;</pre>
<pre>    prog_pend_next   = prog_pend;</pre>
<pre>    mem_req          = 'h0;</pre>
<pre>    mem_wr           = 'h0;</pre>
<pre>    mem_addr         = 'h0;</pre>
<pre>    mem_wdata        = 'h0;</pre>
<pre>    time_cnt_inc     = 1'h0;</pre>
<pre>    time_cnt_clr     = 1'h0;</pre>
<pre>    time_cnt_set1    = 1'h0;</pre>
<pre>    index_cnt_inc    = 1'h0;</pre>
<pre>    index_cnt_clr    = 1'h0;</pre>
<pre>    rd_done_o        = 1'h0;</pre>
<pre>    prog_done_o      = 1'h0;</pre>
<pre>    erase_done_o     = 1'h0;</pre>
<pre>    init_busy_o      = 1'h0;</pre>
<pre>    host_req_rdy_o   = 1'h1;</pre>
<pre>    host_req_done_o  = 1'h0;</pre>
<pre>    hold_rd_cmd      = 1'h0;</pre>
<pre>    unique case (st)</pre>
<pre>      StReset: begin</pre>
<pre>        host_req_rdy_o = 1'b0;</pre>
<pre>        init_busy_o = 1'h1;</pre>
<pre>        st_next = StInit;</pre>
<pre>      StInit: begin</pre>
<pre>        host_req_rdy_o = 1'b0;</pre>
<pre>        init_busy_o = 1'h1;</pre>
<pre>        if (index_cnt < WordsPerBank && !SkipInit) begin</pre>
<pre>          st_next = StInit;</pre>
<pre>          index_cnt_inc = 1'b1;</pre>
<pre>          mem_req = 1'h0;</pre>
<pre>          mem_wr  = 1'h0;</pre>
<pre>          mem_addr = index_cnt[AddrW-1:0];</pre>
<pre>          mem_wdata = {DataWidth{1'b1}};</pre>
<pre>        end else begin</pre>
<pre>          st_next = StIdle;</pre>
<pre>          index_cnt_clr = 1'b1;</pre>
<pre>      StIdle: begin</pre>
<pre>        if (host_req_i) begin</pre>
<pre>          hold_rd_cmd = 1'b1;</pre>
<pre>          mem_addr = host_addr_i;</pre>
<pre>          mem_req = 1'b1;</pre>
<pre>          time_cnt_inc = 1'b1;</pre>
<pre>          st_next = StHostRead;</pre>
<pre>        end else if (req_i && rd_i) begin</pre>
<pre>          st_next = StRead;</pre>
<pre>        end else if (req_i && prog_i) begin</pre>
<pre>          st_next = StRead;</pre>
<pre>          prog_pend_next = 1'b1;</pre>
<pre>        end else if (req_i && pg_erase_i) begin</pre>
<pre>          st_next = StErase;</pre>
<pre>          index_limit_next = WordsPerPage;</pre>
<pre>          time_limit_next = PgEraseCycles;</pre>
<pre>        end else if (req_i && bk_erase_i) begin</pre>
<pre>          st_next = StErase;</pre>
<pre>          index_limit_next = WordsPerBank;</pre>
<pre>          time_limit_next = BkEraseCycles;</pre>
<pre>      StHostRead: begin</pre>
<pre>        mem_addr = held_rd_addr;</pre>
<pre>        if (time_cnt < ReadCycles) begin</pre>
<pre>          mem_req = 1'b1;</pre>
<pre>          time_cnt_inc = 1'b1;</pre>
<pre>          host_req_rdy_o = 1'b0;</pre>
<pre>        end else begin</pre>
<pre>          host_req_done_o = 1'b1; //finish up transaction</pre>
<pre>          if (host_req_i) begin</pre>
<pre>            hold_rd_cmd = 1'b1;</pre>
<pre>            mem_addr = host_addr_i;</pre>
<pre>            mem_req = 1'b1;</pre>
<pre>            time_cnt_set1 = 1'b1;</pre>
<pre>            st_next = StHostRead;</pre>
<pre>          end else begin</pre>
<pre>            time_cnt_clr = 1'b1;</pre>
<pre>            st_next = StIdle;</pre>
<pre>      StRead: begin</pre>
<pre>        host_req_rdy_o = 1'b0;</pre>
<pre>        mem_addr = addr_i;</pre>
<pre>        if (time_cnt < ReadCycles) begin</pre>
<pre>          mem_req = 1'b1;</pre>
<pre>          time_cnt_inc = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          prog_pend_next = 1'b0;</pre>
<pre>          rd_done_o  = 1'b1;</pre>
<pre>          time_cnt_clr = 1'b1;</pre>
<pre>          st_next = prog_pend ? StProg : StIdle;</pre>
<pre>      StProg: begin</pre>
<pre>        host_req_rdy_o = 1'b0;</pre>
<pre>        mem_addr = addr_i;</pre>
<pre>        mem_wdata = prog_data_i & held_data;</pre>
<pre>        if (time_cnt < ProgCycles) begin</pre>
<pre>          mem_req = 1'b1;</pre>
<pre>          mem_wr = 1'b1;</pre>
<pre>          time_cnt_inc = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          st_next = StIdle;</pre>
<pre>          prog_done_o  = 1'b1;</pre>
<pre>          time_cnt_clr = 1'b1;</pre>
<pre>      StErase: begin</pre>
<pre>        host_req_rdy_o = 1'b0;</pre>
<pre>        if (index_cnt < index_limit || time_cnt < time_limit) begin</pre>
<pre>          mem_req = 1'b1;</pre>
<pre>          mem_wr = 1'b1;</pre>
<pre>          mem_wdata = {DataWidth{1'b1}};</pre>
<pre>          mem_addr = addr_i + index_cnt[AddrW-1:0];</pre>
<pre>          time_cnt_inc = (time_cnt < time_limit);</pre>
<pre>          index_cnt_inc = (index_cnt < index_limit);</pre>
<pre>        end else begin</pre>
<pre>          st_next = StIdle;</pre>
<pre>          erase_done_o = 1'b1;</pre>
<pre>          time_cnt_clr = 1'b1;</pre>
<pre>          index_cnt_clr = 1'b1;</pre>
<pre>      default: begin</pre>
<pre>        host_req_rdy_o = 1'b0;</pre>
<pre>        st_next = StIdle;</pre>
<pre>  prim_ram_1p #(</pre>
<pre>    .Width(DataWidth),</pre>
<pre>    .Depth(WordsPerBank),</pre>
<pre>    .DataBitsPerMask(DataWidth)</pre>
<pre style="background-color: #FF0000;">  ) u_mem (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .req_i    (mem_req),</pre>
<pre>    .write_i  (mem_wr),</pre>
<pre>    .addr_i   (mem_addr),</pre>
<pre>    .wdata_i  (mem_wdata),</pre>
<pre>    .wmask_i  ({DataWidth{1'b1}}),</pre>
<pre>    .rvalid_o (),</pre>
<pre>    .rdata_o  (rd_data_o)</pre>
<h3>hw/ip/rv_plic/rtl/rv_plic_target.sv</h3>
<pre>module rv_plic_target #(</pre>
<pre>  parameter int N_SOURCE = 32,</pre>
<pre>  parameter int MAX_PRIO = 7,</pre>
<pre>  localparam int unsigned SRCW  = $clog2(N_SOURCE+1),  // derived parameter</pre>
<pre>  localparam int unsigned PRIOW = $clog2(MAX_PRIO+1)   // derived parameter</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input [N_SOURCE-1:0] ip,</pre>
<pre>  input [N_SOURCE-1:0] ie,</pre>
<pre>  input [PRIOW-1:0] prio [N_SOURCE],</pre>
<pre>  input [PRIOW-1:0] threshold,</pre>
<pre>  output logic            irq,</pre>
<pre>  output logic [SRCW-1:0] irq_id</pre>
<pre>  logic [2**(N_LEVELS+1)-2:0]            is_tree;</pre>
<pre>  logic [2**(N_LEVELS+1)-2:0][SRCW-1:0]  id_tree;</pre>
<pre>  logic [2**(N_LEVELS+1)-2:0][PRIOW-1:0] max_tree;</pre>
<pre></pre>
<pre>    //</pre>
<pre>    localparam int unsigned base1 = (2**(level+1))-1;</pre>
<pre></pre>
<pre>      localparam int unsigned pa = base0 + offset;</pre>
<pre>      localparam int unsigned c0 = base1 + 2*offset;</pre>
<pre>      localparam int unsigned c1 = base1 + 2*offset + 1;</pre>
<pre></pre>
<pre>        if (offset < N_SOURCE) begin : gen_assign</pre>
<pre>          assign is_tree[pa]  = ip[offset] & ie[offset];</pre>
<pre>          assign id_tree[pa]  = offset+1'b1;</pre>
<pre>          assign max_tree[pa] = prio[offset];</pre>
<pre>        end else begin : gen_tie_off</pre>
<pre style="background-color: #FF0000;">          assign is_tree[pa]  = '0;</pre>
<pre style="background-color: #FF0000;">          assign id_tree[pa]  = '0;</pre>
<pre style="background-color: #FF0000;">          assign max_tree[pa] = '0;</pre>
<pre style="background-color: #FF0000;">        end</pre>
<pre>        // NOTE: the code below has been written in this way in order to work</pre>
<pre style="background-color: #FF0000;">        // in case only one of the parent has a pending irq, forward that one</pre>
<pre>                     (is_tree[c0] & is_tree[c1] & logic'(max_tree[c1] > max_tree[c0]));</pre>
<pre>        // forwarding muxes</pre>
<pre>        assign id_tree[pa]  = ({SRCW{sel}}  & id_tree[c1])  | ({SRCW{~sel}}  & id_tree[c0]);</pre>
<pre>        assign max_tree[pa] = ({PRIOW{sel}} & max_tree[c1]) | ({PRIOW{~sel}} & max_tree[c0]);</pre>
<pre>      end</pre>
<pre style="background-color: #FF0000;">  end : gen_tree</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>  logic [SRCW-1:0] irq_id_d, irq_id_q;</pre>
<pre></pre>
<pre>  assign irq_id_d = (is_tree[0]) ? id_tree[0] : '0;</pre>
<pre></pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      irq_q    <= 1'b0;</pre>
<pre>      irq_id_q <= '0;</pre>
<pre>    end else begin</pre>
<pre>      irq_q    <= irq_d;</pre>
<pre>      irq_id_q <= irq_id_d;</pre>
<pre>    end</pre>
<pre>  assign irq_id = irq_id_q;</pre>
<pre></pre>
<h3>hw/ip/rv_plic/rtl/rv_plic_gateway.sv</h3>
<pre>module rv_plic_gateway #(</pre>
<pre>  parameter int N_SOURCE = 32</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input [N_SOURCE-1:0] src,</pre>
<pre>  input [N_SOURCE-1:0] le,      // Level0 Edge1</pre>
<pre>  input [N_SOURCE-1:0] claim, // $onehot0(claim)</pre>
<pre>  input [N_SOURCE-1:0] complete, // $onehot0(complete)</pre>
<pre>  output logic [N_SOURCE-1:0] ip</pre>
<pre>  logic [N_SOURCE-1:0] ia;    // Interrupt Active</pre>
<pre>  logic [N_SOURCE-1:0] set;   // Set: (le) ? src & ~src_d : src ;</pre>
<pre>  logic [N_SOURCE-1:0] src_d;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) src_d <= '0;</pre>
<pre>    else         src_d <= src;</pre>
<pre>  always_comb begin</pre>
<pre>    for (int i = 0 ; i < N_SOURCE; i++) begin</pre>
<pre>      set[i] = (le[i]) ? src[i] & ~src_d[i] : src[i] ;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      ip <= '0;</pre>
<pre>    end else begin</pre>
<pre>      ip <= (ip | (set & ~ia & ~ip)) & (~(ip & claim));</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      ia <= '0;</pre>
<pre>    end else begin</pre>
<pre>      ia <= (ia | (set & ~ia)) & (~(ia & complete & ~ip));</pre>
<h3>hw/ip/prim/rtl/prim_pkg.sv</h3>
<pre>package prim_pkg;</pre>
<pre>  typedef enum integer {</pre>
<pre>    ImplGeneric = 1,</pre>
<pre>    ImplXilinx  = 0</pre>
<pre>  } impl_e;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic alert_p;</pre>
<pre>    logic alert_n;</pre>
<pre style="background-color: #FF0000;">  } alert_tx_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic ping_p;</pre>
<pre>    logic ping_n;</pre>
<pre>    logic ack_p;</pre>
<pre>    logic ack_n;</pre>
<pre style="background-color: #FF0000;">  } alert_rx_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic esc_p;</pre>
<pre>    logic esc_n;</pre>
<pre style="background-color: #FF0000;">  } esc_tx_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic resp_p;</pre>
<pre>    logic resp_n;</pre>
<pre style="background-color: #FF0000;">  } esc_rx_t;</pre>
<pre style="background-color: #FF0000;">endpackage : prim_pkg</pre>
<h3>hw/ip/prim/abstract/prim_ram_1p.sv</h3>
<pre>  parameter prim_pkg::impl_e Impl = `PRIM_DEFAULT_IMPL,</pre>
<pre></pre>
<pre>  parameter int Depth           = 128,</pre>
<pre>  parameter int DataBitsPerMask = 1, // Number of data bits per bit of write mask</pre>
<pre>  localparam int Aw             = $clog2(Depth) // derived parameter</pre>
<pre>) (</pre>
<pre>  input rst_ni,       // Memory content reset</pre>
<pre></pre>
<pre>  input                    write_i,</pre>
<pre>  input        [Aw-1:0]    addr_i,</pre>
<pre>  input        [Width-1:0] wdata_i,</pre>
<pre>  input        [Width-1:0] wmask_i,</pre>
<pre>  output logic             rvalid_o,</pre>
<pre>  output logic [Width-1:0] rdata_o</pre>
<pre>);</pre>
<pre>    prim_generic_ram_1p #(</pre>
<pre>      .Width(Width),</pre>
<pre>      .Depth(Depth),</pre>
<pre>      .DataBitsPerMask(DataBitsPerMask)</pre>
<pre>    ) u_impl_generic (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .req_i,</pre>
<pre>      .write_i,</pre>
<pre>      .addr_i,</pre>
<pre>      .wdata_i,</pre>
<pre>      .wmask_i,</pre>
<pre>      .rvalid_o,</pre>
<pre>      .rdata_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">    // TODO: Find code that works across tools and causes a compile failure</pre>
<h3>hw/ip/rv_core_ibex/rtl/rv_core_ibex.sv</h3>
<pre>module rv_core_ibex #(</pre>
<pre>  parameter bit          PMPEnable        = 1'b0,</pre>
<pre>  parameter int unsigned PMPGranularity   = 0,</pre>
<pre>  parameter int unsigned PMPNumRegions    = 4,</pre>
<pre>  parameter int unsigned MHPMCounterNum   = 8,</pre>
<pre>  parameter int unsigned MHPMCounterWidth = 40,</pre>
<pre>  parameter bit          RV32E            = 0,</pre>
<pre>  parameter bit          RV32M            = 1,</pre>
<pre>  parameter int unsigned DmHaltAddr       = 32'h1A110800,</pre>
<pre>  parameter int unsigned DmExceptionAddr  = 32'h1A110808,</pre>
<pre>  parameter bit          PipeLine         = 0</pre>
<pre>  input  logic        clk_i,</pre>
<pre>  input  logic        rst_ni,</pre>
<pre>  input  logic        test_en_i,     // enable all clock gates for testing</pre>
<pre>  input  logic [31:0] hart_id_i,</pre>
<pre>  input  logic [31:0] boot_addr_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t     tl_i_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t     tl_i_i,</pre>
<pre>  output tlul_pkg::tl_h2d_t     tl_d_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t     tl_d_i,</pre>
<pre>  input  logic        irq_software_i,</pre>
<pre>  input  logic        irq_timer_i,</pre>
<pre>  input  logic        irq_external_i,</pre>
<pre>  input  logic [14:0] irq_fast_i,</pre>
<pre>  input  logic        irq_nm_i,</pre>
<pre>  input  logic        debug_req_i,</pre>
<pre>  input  logic        fetch_enable_i,</pre>
<pre>  output logic        core_sleep_o</pre>
<pre>  localparam int FifoPass = PipeLine ? 1'b0 : 1'b1;</pre>
<pre>  localparam int FifoDepth = PipeLine ? 4'h2 : 4'h0;</pre>
<pre>  localparam int WordSize = $clog2(TL_DW / 8);</pre>
<pre>  logic        instr_req_o;</pre>
<pre>  logic        instr_gnt_i;</pre>
<pre>  logic        instr_rvalid_i;</pre>
<pre>  logic [31:0] instr_addr_o;</pre>
<pre>  logic [31:0] instr_rdata_i;</pre>
<pre>  logic        instr_err_i;</pre>
<pre>  logic        data_req_o;</pre>
<pre>  logic        data_gnt_i;</pre>
<pre>  logic        data_rvalid_i;</pre>
<pre>  logic        data_we_o;</pre>
<pre>  logic [3:0]  data_be_o;</pre>
<pre>  logic [31:0] data_addr_o;</pre>
<pre>  logic [31:0] data_wdata_o;</pre>
<pre>  logic [31:0] data_rdata_i;</pre>
<pre>  logic        data_err_i;</pre>
<pre>  tl_h2d_t tl_i_ibex2fifo;</pre>
<pre>  tl_d2h_t tl_i_fifo2ibex;</pre>
<pre>  tl_h2d_t tl_d_ibex2fifo;</pre>
<pre>  tl_d2h_t tl_d_fifo2ibex;</pre>
<pre>  ibex_core #(</pre>
<pre>     .PMPEnable        ( PMPEnable         ),</pre>
<pre>     .PMPGranularity   ( PMPGranularity    ),</pre>
<pre>     .PMPNumRegions    ( PMPNumRegions     ),</pre>
<pre>     .MHPMCounterNum   ( MHPMCounterNum    ),</pre>
<pre>     .MHPMCounterWidth ( MHPMCounterWidth  ),</pre>
<pre>     .RV32E            ( RV32E             ),</pre>
<pre>     .RV32M            ( RV32M             ),</pre>
<pre>     .DmHaltAddr       ( DmHaltAddr        ),</pre>
<pre>     .DmExceptionAddr  ( DmExceptionAddr   )</pre>
<pre style="background-color: #FF0000;">  ) u_core (</pre>
<pre>     .clk_i,</pre>
<pre>     .rst_ni,</pre>
<pre>     .test_en_i,</pre>
<pre>     .hart_id_i,</pre>
<pre>     .boot_addr_i,</pre>
<pre>     .instr_req_o,</pre>
<pre>     .instr_gnt_i,</pre>
<pre>     .instr_rvalid_i,</pre>
<pre>     .instr_addr_o,</pre>
<pre>     .instr_rdata_i,</pre>
<pre>     .instr_err_i,</pre>
<pre>     .data_req_o,</pre>
<pre>     .data_gnt_i,</pre>
<pre>     .data_rvalid_i,</pre>
<pre>     .data_we_o,</pre>
<pre>     .data_be_o,</pre>
<pre>     .data_addr_o,</pre>
<pre>     .data_wdata_o,</pre>
<pre>     .data_rdata_i,</pre>
<pre>     .data_err_i,</pre>
<pre>     .irq_software_i,</pre>
<pre>     .irq_timer_i,</pre>
<pre>     .irq_external_i,</pre>
<pre>     .irq_fast_i,</pre>
<pre>     .irq_nm_i,</pre>
<pre>     .debug_req_i,</pre>
<pre>     .fetch_enable_i,</pre>
<pre>     .core_sleep_o</pre>
<pre>  logic tl_i_source, tl_d_source;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      {tl_i_source, tl_d_source} <= '0;</pre>
<pre>    end else begin</pre>
<pre>      if (instr_req_o && instr_gnt_i) tl_i_source <= !tl_i_source;</pre>
<pre>      if (data_req_o && data_gnt_i)  tl_d_source <= !tl_d_source;</pre>
<pre>  assign tl_i_ibex2fifo = '{</pre>
<pre>    a_valid:   instr_req_o,</pre>
<pre>    a_opcode:  tlul_pkg::Get,</pre>
<pre>    a_param:   3'h0,</pre>
<pre>    a_size:    2'(WordSize),</pre>
<pre>    a_mask:    {TL_DBW{1'b1}},</pre>
<pre>    a_source:  TL_AIW'(tl_i_source),</pre>
<pre>    a_address: {instr_addr_o[31:WordSize], {WordSize{1'b0}}},</pre>
<pre>    a_data:    {TL_DW{1'b0}},</pre>
<pre>    a_user:    '{default:'0},</pre>
<pre>    d_ready:   1'b1</pre>
<pre>  assign instr_gnt_i    = tl_i_fifo2ibex.a_ready & tl_i_ibex2fifo.a_valid;</pre>
<pre>  assign instr_rvalid_i = tl_i_fifo2ibex.d_valid;</pre>
<pre>  assign instr_rdata_i  = tl_i_fifo2ibex.d_data;</pre>
<pre>  assign instr_err_i    = tl_i_fifo2ibex.d_error;</pre>
<pre>  tlul_fifo_sync #(</pre>
<pre>    .ReqPass(FifoPass),</pre>
<pre>    .RspPass(FifoPass),</pre>
<pre>    .ReqDepth(FifoDepth),</pre>
<pre>    .RspDepth(FifoDepth)</pre>
<pre style="background-color: #FF0000;">  ) fifo_i (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_h_i      (tl_i_ibex2fifo),</pre>
<pre>    .tl_h_o      (tl_i_fifo2ibex),</pre>
<pre>    .tl_d_o      (tl_i_o),</pre>
<pre>    .tl_d_i      (tl_i_i),</pre>
<pre>    .spare_req_i (1'b0),</pre>
<pre>    .spare_req_o (),</pre>
<pre>    .spare_rsp_i (1'b0),</pre>
<pre>    .spare_rsp_o ());</pre>
<pre>  assign tl_d_ibex2fifo = '{</pre>
<pre>    a_valid:   data_req_o,</pre>
<pre>    a_opcode:  (~data_we_o)        ? tlul_pkg::Get           :</pre>
<pre>               (data_be_o == 4'hf) ? tlul_pkg::PutFullData   :</pre>
<pre>                                     tlul_pkg::PutPartialData,</pre>
<pre>    a_param:   3'h0,</pre>
<pre>    a_size:    2'(WordSize),</pre>
<pre>    a_mask:    data_be_o,</pre>
<pre>    a_source:  TL_AIW'(tl_d_source),</pre>
<pre>    a_address: {data_addr_o[31:WordSize], {WordSize{1'b0}}},</pre>
<pre>    a_data:    data_wdata_o,</pre>
<pre>    a_user:    '{default:'0},</pre>
<pre>    d_ready:   1'b1</pre>
<pre>  assign data_gnt_i    = tl_d_fifo2ibex.a_ready & tl_d_ibex2fifo.a_valid;</pre>
<pre>  assign data_rvalid_i = tl_d_fifo2ibex.d_valid;</pre>
<pre>  assign data_rdata_i  = tl_d_fifo2ibex.d_data;</pre>
<pre>  assign data_err_i    = tl_d_fifo2ibex.d_error;</pre>
<pre>  tlul_fifo_sync #(</pre>
<pre>    .ReqPass(FifoPass),</pre>
<pre>    .RspPass(FifoPass),</pre>
<pre>    .ReqDepth(FifoDepth),</pre>
<pre>    .RspDepth(FifoDepth)</pre>
<pre style="background-color: #FF0000;">  ) fifo_d (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_h_i      (tl_d_ibex2fifo),</pre>
<pre>    .tl_h_o      (tl_d_fifo2ibex),</pre>
<pre>    .tl_d_o      (tl_d_o),</pre>
<pre>    .tl_d_i      (tl_d_i),</pre>
<pre>    .spare_req_i (1'b0),</pre>
<pre>    .spare_req_o (),</pre>
<pre>    .spare_rsp_i (1'b0),</pre>
<pre>    .spare_rsp_o ());</pre>
<h3>hw/ip/aes/rtl/aes.sv</h3>
<pre>module aes #(</pre>
<pre>  parameter bit AES192Enable = 1,    // Can be 0 (disable), or 1 (enable).</pre>
<pre>  parameter     SBoxImpl     = "lut" // Can be "lut" (LUT-based SBox), or "canright".</pre>
<pre>  input                     clk_i,</pre>
<pre>  input                     rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o</pre>
<pre>  aes_reg2hw_t reg2hw;</pre>
<pre>  aes_hw2reg_t hw2reg;</pre>
<pre>  aes_reg_top u_reg (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .tl_o,</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .devmode_i(1'b1)</pre>
<pre>  aes_core #(</pre>
<pre>    .AES192Enable ( AES192Enable ),</pre>
<pre>    .SBoxImpl     ( SBoxImpl     )</pre>
<pre style="background-color: #FF0000;">  ) aes_core (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg</pre>
<h3>hw/ip/aes/rtl/aes_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output aes_reg_pkg::aes_reg2hw_t reg2hw, // Write</pre>
<pre>  input  aes_reg_pkg::aes_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam int AW = 7;</pre>
<pre>  localparam int DW = 32;</pre>
<pre>  localparam int DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  assign tl_reg_h2d = tl_i;</pre>
<pre>  assign tl_o       = tl_reg_d2h;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic [31:0] key0_wd;</pre>
<pre>  logic key0_we;</pre>
<pre>  logic [31:0] key1_wd;</pre>
<pre>  logic key1_we;</pre>
<pre>  logic [31:0] key2_wd;</pre>
<pre>  logic key2_we;</pre>
<pre>  logic [31:0] key3_wd;</pre>
<pre>  logic key3_we;</pre>
<pre>  logic [31:0] key4_wd;</pre>
<pre>  logic key4_we;</pre>
<pre>  logic [31:0] key5_wd;</pre>
<pre>  logic key5_we;</pre>
<pre>  logic [31:0] key6_wd;</pre>
<pre>  logic key6_we;</pre>
<pre>  logic [31:0] key7_wd;</pre>
<pre>  logic key7_we;</pre>
<pre>  logic [31:0] data_in0_wd;</pre>
<pre>  logic data_in0_we;</pre>
<pre>  logic [31:0] data_in1_wd;</pre>
<pre>  logic data_in1_we;</pre>
<pre>  logic [31:0] data_in2_wd;</pre>
<pre>  logic data_in2_we;</pre>
<pre>  logic [31:0] data_in3_wd;</pre>
<pre>  logic data_in3_we;</pre>
<pre>  logic [31:0] data_out0_qs;</pre>
<pre>  logic data_out0_re;</pre>
<pre>  logic [31:0] data_out1_qs;</pre>
<pre>  logic data_out1_re;</pre>
<pre>  logic [31:0] data_out2_qs;</pre>
<pre>  logic data_out2_re;</pre>
<pre>  logic [31:0] data_out3_qs;</pre>
<pre>  logic data_out3_re;</pre>
<pre>  logic ctrl_mode_qs;</pre>
<pre>  logic ctrl_mode_wd;</pre>
<pre>  logic ctrl_mode_we;</pre>
<pre>  logic ctrl_mode_re;</pre>
<pre>  logic [2:0] ctrl_key_len_qs;</pre>
<pre>  logic [2:0] ctrl_key_len_wd;</pre>
<pre>  logic ctrl_key_len_we;</pre>
<pre>  logic ctrl_key_len_re;</pre>
<pre>  logic ctrl_manual_start_trigger_qs;</pre>
<pre>  logic ctrl_manual_start_trigger_wd;</pre>
<pre>  logic ctrl_manual_start_trigger_we;</pre>
<pre>  logic ctrl_manual_start_trigger_re;</pre>
<pre>  logic ctrl_force_data_overwrite_qs;</pre>
<pre>  logic ctrl_force_data_overwrite_wd;</pre>
<pre>  logic ctrl_force_data_overwrite_we;</pre>
<pre>  logic ctrl_force_data_overwrite_re;</pre>
<pre>  logic trigger_start_wd;</pre>
<pre>  logic trigger_start_we;</pre>
<pre>  logic trigger_key_clear_wd;</pre>
<pre>  logic trigger_key_clear_we;</pre>
<pre>  logic trigger_data_in_clear_wd;</pre>
<pre>  logic trigger_data_in_clear_we;</pre>
<pre>  logic trigger_data_out_clear_wd;</pre>
<pre>  logic trigger_data_out_clear_we;</pre>
<pre>  logic status_idle_qs;</pre>
<pre>  logic status_stall_qs;</pre>
<pre>  logic status_output_valid_qs;</pre>
<pre>  logic status_input_ready_qs;</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key0 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key0_we),</pre>
<pre>    .wd     (key0_wd),</pre>
<pre>    .d      (hw2reg.key[0].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[0].qe),</pre>
<pre>    .q      (reg2hw.key[0].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key1 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key1_we),</pre>
<pre>    .wd     (key1_wd),</pre>
<pre>    .d      (hw2reg.key[1].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[1].qe),</pre>
<pre>    .q      (reg2hw.key[1].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key2 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key2_we),</pre>
<pre>    .wd     (key2_wd),</pre>
<pre>    .d      (hw2reg.key[2].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[2].qe),</pre>
<pre>    .q      (reg2hw.key[2].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key3 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key3_we),</pre>
<pre>    .wd     (key3_wd),</pre>
<pre>    .d      (hw2reg.key[3].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[3].qe),</pre>
<pre>    .q      (reg2hw.key[3].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key4 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key4_we),</pre>
<pre>    .wd     (key4_wd),</pre>
<pre>    .d      (hw2reg.key[4].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[4].qe),</pre>
<pre>    .q      (reg2hw.key[4].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key5 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key5_we),</pre>
<pre>    .wd     (key5_wd),</pre>
<pre>    .d      (hw2reg.key[5].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[5].qe),</pre>
<pre>    .q      (reg2hw.key[5].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key6 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key6_we),</pre>
<pre>    .wd     (key6_wd),</pre>
<pre>    .d      (hw2reg.key[6].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[6].qe),</pre>
<pre>    .q      (reg2hw.key[6].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key7 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key7_we),</pre>
<pre>    .wd     (key7_wd),</pre>
<pre>    .d      (hw2reg.key[7].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[7].qe),</pre>
<pre>    .q      (reg2hw.key[7].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_in0 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_in0_we),</pre>
<pre>    .wd     (data_in0_wd),</pre>
<pre>    .de     (hw2reg.data_in[0].de),</pre>
<pre>    .d      (hw2reg.data_in[0].d ),</pre>
<pre>    .qe     (reg2hw.data_in[0].qe),</pre>
<pre>    .q      (reg2hw.data_in[0].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_in1 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_in1_we),</pre>
<pre>    .wd     (data_in1_wd),</pre>
<pre>    .de     (hw2reg.data_in[1].de),</pre>
<pre>    .d      (hw2reg.data_in[1].d ),</pre>
<pre>    .qe     (reg2hw.data_in[1].qe),</pre>
<pre>    .q      (reg2hw.data_in[1].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_in2 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_in2_we),</pre>
<pre>    .wd     (data_in2_wd),</pre>
<pre>    .de     (hw2reg.data_in[2].de),</pre>
<pre>    .d      (hw2reg.data_in[2].d ),</pre>
<pre>    .qe     (reg2hw.data_in[2].qe),</pre>
<pre>    .q      (reg2hw.data_in[2].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_in3 (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (data_in3_we),</pre>
<pre>    .wd     (data_in3_wd),</pre>
<pre>    .de     (hw2reg.data_in[3].de),</pre>
<pre>    .d      (hw2reg.data_in[3].d ),</pre>
<pre>    .qe     (reg2hw.data_in[3].qe),</pre>
<pre>    .q      (reg2hw.data_in[3].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_data_out0 (</pre>
<pre>    .re     (data_out0_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.data_out[0].d),</pre>
<pre>    .qre    (reg2hw.data_out[0].re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.data_out[0].q ),</pre>
<pre>    .qs     (data_out0_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_data_out1 (</pre>
<pre>    .re     (data_out1_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.data_out[1].d),</pre>
<pre>    .qre    (reg2hw.data_out[1].re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.data_out[1].q ),</pre>
<pre>    .qs     (data_out1_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_data_out2 (</pre>
<pre>    .re     (data_out2_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.data_out[2].d),</pre>
<pre>    .qre    (reg2hw.data_out[2].re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.data_out[2].q ),</pre>
<pre>    .qs     (data_out2_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_data_out3 (</pre>
<pre>    .re     (data_out3_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.data_out[3].d),</pre>
<pre>    .qre    (reg2hw.data_out[3].re),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.data_out[3].q ),</pre>
<pre>    .qs     (data_out3_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_mode (</pre>
<pre>    .re     (ctrl_mode_re),</pre>
<pre>    .we     (ctrl_mode_we),</pre>
<pre>    .wd     (ctrl_mode_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.ctrl.mode.qe),</pre>
<pre>    .q      (reg2hw.ctrl.mode.q ),</pre>
<pre>    .qs     (ctrl_mode_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (3)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_key_len (</pre>
<pre>    .re     (ctrl_key_len_re),</pre>
<pre>    .we     (ctrl_key_len_we),</pre>
<pre>    .wd     (ctrl_key_len_wd),</pre>
<pre>    .d      (hw2reg.ctrl.key_len.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.ctrl.key_len.qe),</pre>
<pre>    .q      (reg2hw.ctrl.key_len.q ),</pre>
<pre>    .qs     (ctrl_key_len_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_manual_start_trigger (</pre>
<pre>    .re     (ctrl_manual_start_trigger_re),</pre>
<pre>    .we     (ctrl_manual_start_trigger_we),</pre>
<pre>    .wd     (ctrl_manual_start_trigger_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.ctrl.manual_start_trigger.qe),</pre>
<pre>    .q      (reg2hw.ctrl.manual_start_trigger.q ),</pre>
<pre>    .qs     (ctrl_manual_start_trigger_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_force_data_overwrite (</pre>
<pre>    .re     (ctrl_force_data_overwrite_re),</pre>
<pre>    .we     (ctrl_force_data_overwrite_we),</pre>
<pre>    .wd     (ctrl_force_data_overwrite_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.ctrl.force_data_overwrite.qe),</pre>
<pre>    .q      (reg2hw.ctrl.force_data_overwrite.q ),</pre>
<pre>    .qs     (ctrl_force_data_overwrite_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_trigger_start (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (trigger_start_we),</pre>
<pre>    .wd     (trigger_start_wd),</pre>
<pre>    .de     (hw2reg.trigger.start.de),</pre>
<pre>    .d      (hw2reg.trigger.start.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.trigger.start.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_trigger_key_clear (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (trigger_key_clear_we),</pre>
<pre>    .wd     (trigger_key_clear_wd),</pre>
<pre>    .de     (hw2reg.trigger.key_clear.de),</pre>
<pre>    .d      (hw2reg.trigger.key_clear.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.trigger.key_clear.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_trigger_data_in_clear (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (trigger_data_in_clear_we),</pre>
<pre>    .wd     (trigger_data_in_clear_wd),</pre>
<pre>    .de     (hw2reg.trigger.data_in_clear.de),</pre>
<pre>    .d      (hw2reg.trigger.data_in_clear.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.trigger.data_in_clear.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("WO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_trigger_data_out_clear (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (trigger_data_out_clear_we),</pre>
<pre>    .wd     (trigger_data_out_clear_wd),</pre>
<pre>    .de     (hw2reg.trigger.data_out_clear.de),</pre>
<pre>    .d      (hw2reg.trigger.data_out_clear.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.trigger.data_out_clear.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_idle (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.status.idle.de),</pre>
<pre>    .d      (hw2reg.status.idle.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_idle_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_status_stall (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.status.stall.de),</pre>
<pre>    .d      (hw2reg.status.stall.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_stall_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_status_output_valid (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.status.output_valid.de),</pre>
<pre>    .d      (hw2reg.status.output_valid.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_output_valid_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (1'h1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_input_ready (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.status.input_ready.de),</pre>
<pre>    .d      (hw2reg.status.input_ready.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_input_ready_qs)</pre>
<pre>  logic [18:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[ 0] = (reg_addr == AES_KEY0_OFFSET);</pre>
<pre>    addr_hit[ 1] = (reg_addr == AES_KEY1_OFFSET);</pre>
<pre>    addr_hit[ 2] = (reg_addr == AES_KEY2_OFFSET);</pre>
<pre>    addr_hit[ 3] = (reg_addr == AES_KEY3_OFFSET);</pre>
<pre>    addr_hit[ 4] = (reg_addr == AES_KEY4_OFFSET);</pre>
<pre>    addr_hit[ 5] = (reg_addr == AES_KEY5_OFFSET);</pre>
<pre>    addr_hit[ 6] = (reg_addr == AES_KEY6_OFFSET);</pre>
<pre>    addr_hit[ 7] = (reg_addr == AES_KEY7_OFFSET);</pre>
<pre>    addr_hit[ 8] = (reg_addr == AES_DATA_IN0_OFFSET);</pre>
<pre>    addr_hit[ 9] = (reg_addr == AES_DATA_IN1_OFFSET);</pre>
<pre>    addr_hit[10] = (reg_addr == AES_DATA_IN2_OFFSET);</pre>
<pre>    addr_hit[11] = (reg_addr == AES_DATA_IN3_OFFSET);</pre>
<pre>    addr_hit[12] = (reg_addr == AES_DATA_OUT0_OFFSET);</pre>
<pre>    addr_hit[13] = (reg_addr == AES_DATA_OUT1_OFFSET);</pre>
<pre>    addr_hit[14] = (reg_addr == AES_DATA_OUT2_OFFSET);</pre>
<pre>    addr_hit[15] = (reg_addr == AES_DATA_OUT3_OFFSET);</pre>
<pre>    addr_hit[16] = (reg_addr == AES_CTRL_OFFSET);</pre>
<pre>    addr_hit[17] = (reg_addr == AES_TRIGGER_OFFSET);</pre>
<pre>    addr_hit[18] = (reg_addr == AES_STATUS_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[ 0] && reg_we && (AES_PERMIT[ 0] != (AES_PERMIT[ 0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 1] && reg_we && (AES_PERMIT[ 1] != (AES_PERMIT[ 1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 2] && reg_we && (AES_PERMIT[ 2] != (AES_PERMIT[ 2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 3] && reg_we && (AES_PERMIT[ 3] != (AES_PERMIT[ 3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 4] && reg_we && (AES_PERMIT[ 4] != (AES_PERMIT[ 4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 5] && reg_we && (AES_PERMIT[ 5] != (AES_PERMIT[ 5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 6] && reg_we && (AES_PERMIT[ 6] != (AES_PERMIT[ 6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 7] && reg_we && (AES_PERMIT[ 7] != (AES_PERMIT[ 7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 8] && reg_we && (AES_PERMIT[ 8] != (AES_PERMIT[ 8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 9] && reg_we && (AES_PERMIT[ 9] != (AES_PERMIT[ 9] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[10] && reg_we && (AES_PERMIT[10] != (AES_PERMIT[10] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[11] && reg_we && (AES_PERMIT[11] != (AES_PERMIT[11] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[12] && reg_we && (AES_PERMIT[12] != (AES_PERMIT[12] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[13] && reg_we && (AES_PERMIT[13] != (AES_PERMIT[13] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[14] && reg_we && (AES_PERMIT[14] != (AES_PERMIT[14] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[15] && reg_we && (AES_PERMIT[15] != (AES_PERMIT[15] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[16] && reg_we && (AES_PERMIT[16] != (AES_PERMIT[16] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[17] && reg_we && (AES_PERMIT[17] != (AES_PERMIT[17] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[18] && reg_we && (AES_PERMIT[18] != (AES_PERMIT[18] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign key0_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign key0_wd = reg_wdata[31:0];</pre>
<pre>  assign key1_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign key1_wd = reg_wdata[31:0];</pre>
<pre>  assign key2_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign key2_wd = reg_wdata[31:0];</pre>
<pre>  assign key3_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign key3_wd = reg_wdata[31:0];</pre>
<pre>  assign key4_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign key4_wd = reg_wdata[31:0];</pre>
<pre>  assign key5_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign key5_wd = reg_wdata[31:0];</pre>
<pre>  assign key6_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign key6_wd = reg_wdata[31:0];</pre>
<pre>  assign key7_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign key7_wd = reg_wdata[31:0];</pre>
<pre>  assign data_in0_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign data_in0_wd = reg_wdata[31:0];</pre>
<pre>  assign data_in1_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign data_in1_wd = reg_wdata[31:0];</pre>
<pre>  assign data_in2_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign data_in2_wd = reg_wdata[31:0];</pre>
<pre>  assign data_in3_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign data_in3_wd = reg_wdata[31:0];</pre>
<pre>  assign data_out0_re = addr_hit[12] && reg_re;</pre>
<pre>  assign data_out1_re = addr_hit[13] && reg_re;</pre>
<pre>  assign data_out2_re = addr_hit[14] && reg_re;</pre>
<pre>  assign data_out3_re = addr_hit[15] && reg_re;</pre>
<pre>  assign ctrl_mode_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_mode_wd = reg_wdata[0];</pre>
<pre>  assign ctrl_mode_re = addr_hit[16] && reg_re;</pre>
<pre>  assign ctrl_key_len_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_key_len_wd = reg_wdata[3:1];</pre>
<pre>  assign ctrl_key_len_re = addr_hit[16] && reg_re;</pre>
<pre>  assign ctrl_manual_start_trigger_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_manual_start_trigger_wd = reg_wdata[4];</pre>
<pre>  assign ctrl_manual_start_trigger_re = addr_hit[16] && reg_re;</pre>
<pre>  assign ctrl_force_data_overwrite_we = addr_hit[16] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_force_data_overwrite_wd = reg_wdata[5];</pre>
<pre>  assign ctrl_force_data_overwrite_re = addr_hit[16] && reg_re;</pre>
<pre>  assign trigger_start_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign trigger_start_wd = reg_wdata[0];</pre>
<pre>  assign trigger_key_clear_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign trigger_key_clear_wd = reg_wdata[1];</pre>
<pre>  assign trigger_data_in_clear_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign trigger_data_in_clear_wd = reg_wdata[2];</pre>
<pre>  assign trigger_data_out_clear_we = addr_hit[17] & reg_we & ~wr_err;</pre>
<pre>  assign trigger_data_out_clear_wd = reg_wdata[3];</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[9]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[10]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[11]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[12]: begin</pre>
<pre>        reg_rdata_next[31:0] = data_out0_qs;</pre>
<pre>      addr_hit[13]: begin</pre>
<pre>        reg_rdata_next[31:0] = data_out1_qs;</pre>
<pre>      addr_hit[14]: begin</pre>
<pre>        reg_rdata_next[31:0] = data_out2_qs;</pre>
<pre>      addr_hit[15]: begin</pre>
<pre>        reg_rdata_next[31:0] = data_out3_qs;</pre>
<pre>      addr_hit[16]: begin</pre>
<pre>        reg_rdata_next[0] = ctrl_mode_qs;</pre>
<pre>        reg_rdata_next[3:1] = ctrl_key_len_qs;</pre>
<pre>        reg_rdata_next[4] = ctrl_manual_start_trigger_qs;</pre>
<pre>        reg_rdata_next[5] = ctrl_force_data_overwrite_qs;</pre>
<pre>      addr_hit[17]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>        reg_rdata_next[2] = '0;</pre>
<pre>        reg_rdata_next[3] = '0;</pre>
<pre>      addr_hit[18]: begin</pre>
<pre>        reg_rdata_next[0] = status_idle_qs;</pre>
<pre>        reg_rdata_next[1] = status_stall_qs;</pre>
<pre>        reg_rdata_next[2] = status_output_valid_qs;</pre>
<pre>        reg_rdata_next[3] = status_input_ready_qs;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/ip/aes/rtl/aes_key_expand.sv</h3>
<pre>module aes_key_expand #(</pre>
<pre>  parameter bit AES192Enable = 1,</pre>
<pre>  parameter     SBoxImpl     = "lut"</pre>
<pre>  input  logic              clk_i,</pre>
<pre>  input  logic              rst_ni,</pre>
<pre>  input  aes_pkg::mode_e    mode_i,</pre>
<pre>  input  logic              step_i,</pre>
<pre>  input  logic              clear_i,</pre>
<pre>  input  logic        [3:0] round_i,</pre>
<pre>  input  aes_pkg::key_len_e key_len_i,</pre>
<pre>  input  logic  [7:0][31:0] key_i,</pre>
<pre>  output logic  [7:0][31:0] key_o</pre>
<pre>  logic       [7:0] rcon_d, rcon_q;</pre>
<pre>  logic             rcon_we;</pre>
<pre>  logic             use_rcon;</pre>
<pre>  logic       [3:0] rnd;</pre>
<pre>  logic       [3:0] rnd_type;</pre>
<pre>  logic      [31:0] spec_in_128, spec_in_192;</pre>
<pre>  logic      [31:0] rot_word_in, rot_word_out;</pre>
<pre>  logic             use_rot_word;</pre>
<pre>  logic      [31:0] sub_word_in, sub_word_out;</pre>
<pre>  logic       [7:0] rcon_add_in, rcon_add_out;</pre>
<pre>  logic      [31:0] rcon_added;</pre>
<pre>  logic      [31:0] irregular;</pre>
<pre>  logic [7:0][31:0] regular;</pre>
<pre>  assign rnd = round_i;</pre>
<pre>  always_comb begin : get_rnd_type</pre>
<pre>    if (AES192Enable) begin</pre>
<pre>      rnd_type[0] = (rnd == 0);</pre>
<pre>      rnd_type[1] = (rnd == 1 || rnd == 4 || rnd == 7 || rnd == 10);</pre>
<pre>      rnd_type[2] = (rnd == 2 || rnd == 5 || rnd == 8 || rnd == 11);</pre>
<pre>      rnd_type[3] = (rnd == 3 || rnd == 6 || rnd == 9 || rnd == 12);</pre>
<pre>    end else begin</pre>
<pre>      rnd_type = '0;</pre>
<pre>  assign use_rot_word = (key_len_i == AES_256 && rnd[0] == 1'b0) ? 1'b0 : 1'b1;</pre>
<pre>  always_comb begin : rcon_usage</pre>
<pre>    use_rcon = 1'b1;</pre>
<pre>    if (AES192Enable) begin</pre>
<pre>      if (key_len_i == AES_192 &&</pre>
<pre>          ((mode_i == AES_ENC &&  rnd_type[1]) ||</pre>
<pre>           (mode_i == AES_DEC && (rnd_type[0] || rnd_type[3])))) begin</pre>
<pre>        use_rcon = 1'b0;</pre>
<pre>    if (key_len_i == AES_256 && rnd[0] == 1'b0) begin</pre>
<pre>      use_rcon = 1'b0;</pre>
<pre>  always_comb begin : rcon_update</pre>
<pre>    rcon_d = rcon_q;</pre>
<pre>    if (clear_i) begin</pre>
<pre>      rcon_d =  (mode_i == AES_ENC)                            ? 8'h01 :</pre>
<pre>               ((mode_i == AES_DEC) && (key_len_i == AES_128)) ? 8'h36 :</pre>
<pre>               ((mode_i == AES_DEC) && (key_len_i == AES_192)) ? 8'h80 :</pre>
<pre>               ((mode_i == AES_DEC) && (key_len_i == AES_256)) ? 8'h40 : 8'h01;</pre>
<pre>    end else begin</pre>
<pre>      rcon_d =  (mode_i == AES_ENC) ? aes_mul2(rcon_q) :</pre>
<pre>                (mode_i == AES_DEC) ? aes_div2(rcon_q) : 8'h01;</pre>
<pre>  assign rcon_we = clear_i | (step_i & use_rcon);</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : reg_rcon</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rcon_q <= '0;</pre>
<pre>    end else if (rcon_we) begin</pre>
<pre>      rcon_q <= rcon_d;</pre>
<pre>  assign spec_in_128 = key_i[3] ^ key_i[2];</pre>
<pre>  assign spec_in_192 = AES192Enable ? key_i[5] ^ key_i[1] ^ key_i[0] : '0;</pre>
<pre>  always_comb begin : rot_word_in_mux</pre>
<pre>    unique case (key_len_i)</pre>
<pre>      AES_128: begin</pre>
<pre>        unique case (mode_i)</pre>
<pre>          AES_ENC: rot_word_in = key_i[3];</pre>
<pre>          AES_DEC: rot_word_in = spec_in_128;</pre>
<pre>          default: rot_word_in = key_i[3];</pre>
<pre>      AES_192: begin</pre>
<pre>        if (AES192Enable) begin</pre>
<pre>          unique case (mode_i)</pre>
<pre>            AES_ENC: begin</pre>
<pre>              rot_word_in = rnd_type[0] ? key_i[5]    :</pre>
<pre>                            rnd_type[2] ? key_i[5]    :</pre>
<pre>                            rnd_type[3] ? spec_in_192 : key_i[3];</pre>
<pre>            AES_DEC: begin</pre>
<pre>              rot_word_in = rnd_type[1] ? key_i[3] :</pre>
<pre>                            rnd_type[2] ? key_i[1] : key_i[3];</pre>
<pre>            default: rot_word_in = key_i[3];</pre>
<pre>        end else begin</pre>
<pre>          rot_word_in = key_i[3];</pre>
<pre>      AES_256: begin</pre>
<pre>        unique case (mode_i)</pre>
<pre>          AES_ENC: rot_word_in = key_i[7];</pre>
<pre>          AES_DEC: rot_word_in = key_i[3];</pre>
<pre>          default: rot_word_in = key_i[7];</pre>
<pre>      default: rot_word_in = key_i[3];</pre>
<pre>  assign rot_word_out = aes_circ_byte_shift(rot_word_in, 3);</pre>
<pre>  assign sub_word_in = use_rot_word ? rot_word_out : rot_word_in;</pre>
<pre>  for (genvar i = 0; i < 4; i++) begin : gen_sbox</pre>
<pre>    aes_sbox #(</pre>
<pre>      .SBoxImpl ( SBoxImpl )</pre>
<pre style="background-color: #FF0000;">    ) aes_sbox_i (</pre>
<pre>      .mode_i ( AES_ENC   ),</pre>
<pre>      .data_i ( sub_word_in[8*i +: 8]  ),</pre>
<pre>      .data_o ( sub_word_out[8*i +: 8] )</pre>
<pre>  assign rcon_add_in  = sub_word_out[7:0];</pre>
<pre>  assign rcon_add_out = rcon_add_in ^ rcon_q;</pre>
<pre>  assign rcon_added   = {sub_word_out[31:8], rcon_add_out};</pre>
<pre>  assign irregular = use_rcon ? rcon_added : sub_word_out;</pre>
<pre>  always_comb begin : drive_regular</pre>
<pre>    unique case (key_len_i)</pre>
<pre>      AES_128: begin</pre>
<pre>        regular[7:4] = key_i[3:0];</pre>
<pre>        regular[0] = irregular ^ key_i[0];</pre>
<pre>        unique case (mode_i)</pre>
<pre>          AES_ENC: begin</pre>
<pre>            for (int i=1; i<4; i++) begin</pre>
<pre>              regular[i] = regular[i-1] ^ key_i[i];</pre>
<pre>          AES_DEC: begin</pre>
<pre>            for (int i=1; i<4; i++) begin</pre>
<pre>              regular[i] = key_i[i-1] ^ key_i[i];</pre>
<pre>          default: regular = {key_i[3:0], key_i[7:4]};</pre>
<pre>      AES_192: begin</pre>
<pre>        regular[7:6] = key_i[3:2];</pre>
<pre>        if (AES192Enable) begin</pre>
<pre>          unique case (mode_i)</pre>
<pre>            AES_ENC: begin</pre>
<pre>              if (rnd_type[0]) begin</pre>
<pre>                regular[3:0] = key_i[5:2];</pre>
<pre>                regular[4]   = irregular  ^ key_i[0];</pre>
<pre>                regular[5]   = regular[4] ^ key_i[1];</pre>
<pre>              end else begin</pre>
<pre>                regular[1:0] = key_i[5:4];</pre>
<pre>                for (int i=0; i<4; i++) begin</pre>
<pre>                  if ((i == 0 && rnd_type[2]) ||</pre>
<pre>                      (i == 2 && rnd_type[3])) begin</pre>
<pre>                    regular[i+2] = irregular    ^ key_i[i];</pre>
<pre>                  end else begin</pre>
<pre>                    regular[i+2] = regular[i+1] ^ key_i[i];</pre>
<pre>            AES_DEC: begin</pre>
<pre>              if (rnd_type[0]) begin</pre>
<pre>                regular[5:2] = key_i[3:0];</pre>
<pre>                for (int i=0; i<2; i++) begin</pre>
<pre>                  regular[i] = key_i[3+i] ^ key_i[3+i+1];</pre>
<pre>              end else begin</pre>
<pre>                regular[5:4] = key_i[1:0];</pre>
<pre>                for (int i=0; i<4; i++) begin</pre>
<pre>                  if ((i == 2 && rnd_type[1]) ||</pre>
<pre>                      (i == 0 && rnd_type[2])) begin</pre>
<pre>                    regular[i] = irregular  ^ key_i[i+2];</pre>
<pre>                  end else begin</pre>
<pre>                    regular[i] = key_i[i+1] ^ key_i[i+2];</pre>
<pre>            default: regular = {key_i[3:0], key_i[7:4]};</pre>
<pre>        end else begin</pre>
<pre>          regular = {key_i[3:0], key_i[7:4]};</pre>
<pre>      AES_256: begin</pre>
<pre>        unique case (mode_i)</pre>
<pre>          AES_ENC: begin</pre>
<pre>            if (rnd == 0) begin</pre>
<pre>              regular = {key_i[3:0], key_i[7:4]};</pre>
<pre>            end else begin</pre>
<pre>              regular[3:0] = key_i[7:4];</pre>
<pre>              regular[4]   = irregular ^ key_i[0];</pre>
<pre>              for (int i=1; i<4; i++) begin</pre>
<pre>                regular[i+4] = regular[i+4-1] ^ key_i[i];</pre>
<pre>          AES_DEC: begin</pre>
<pre>            if (rnd == 0) begin</pre>
<pre>              regular = {key_i[3:0], key_i[7:4]};</pre>
<pre>            end else begin</pre>
<pre>              regular[7:4] = key_i[3:0];</pre>
<pre>              regular[0]   = irregular ^ key_i[4];</pre>
<pre>              for (int i=0; i<3; i++) begin</pre>
<pre>                regular[i+1] = key_i[4+i] ^ key_i[4+i+1];</pre>
<pre>          default: regular = {key_i[3:0], key_i[7:4]};</pre>
<pre>      default: regular = {key_i[3:0], key_i[7:4]};</pre>
<pre>  assign key_o = regular;</pre>
<h3>hw/ip/aes/rtl/aes_reg_pkg.sv</h3>
<pre>package aes_reg_pkg;</pre>
<pre>  parameter int NumRegsKey = 8;</pre>
<pre>  parameter int NumRegsData = 4;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } aes_reg2hw_key_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } aes_reg2hw_data_in_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre>    logic        re;</pre>
<pre style="background-color: #FF0000;">  } aes_reg2hw_data_out_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } mode;</pre>
<pre>    struct packed {</pre>
<pre>      logic [2:0]  q;</pre>
<pre>      logic        qe;</pre>
<pre>    } key_len;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } manual_start_trigger;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } force_data_overwrite;</pre>
<pre style="background-color: #FF0000;">  } aes_reg2hw_ctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } start;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } key_clear;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } data_in_clear;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } data_out_clear;</pre>
<pre style="background-color: #FF0000;">  } aes_reg2hw_trigger_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre style="background-color: #FF0000;">  } aes_hw2reg_key_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } aes_hw2reg_data_in_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre style="background-color: #FF0000;">  } aes_hw2reg_data_out_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [2:0]  d;</pre>
<pre>    } key_len;</pre>
<pre style="background-color: #FF0000;">  } aes_hw2reg_ctrl_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } start;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } key_clear;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } data_in_clear;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } data_out_clear;</pre>
<pre style="background-color: #FF0000;">  } aes_hw2reg_trigger_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } idle;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } stall;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } output_valid;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } input_ready;</pre>
<pre style="background-color: #FF0000;">  } aes_hw2reg_status_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    aes_reg2hw_key_mreg_t [7:0] key; // [541:278]</pre>
<pre>    aes_reg2hw_data_in_mreg_t [3:0] data_in; // [277:146]</pre>
<pre>    aes_reg2hw_data_out_mreg_t [3:0] data_out; // [145:14]</pre>
<pre>    aes_reg2hw_ctrl_reg_t ctrl; // [13:4]</pre>
<pre>    aes_reg2hw_trigger_reg_t trigger; // [3:0]</pre>
<pre style="background-color: #FF0000;">  } aes_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    aes_hw2reg_key_mreg_t [7:0] key; // [534:279]</pre>
<pre>    aes_hw2reg_data_in_mreg_t [3:0] data_in; // [278:147]</pre>
<pre>    aes_hw2reg_data_out_mreg_t [3:0] data_out; // [146:19]</pre>
<pre>    aes_hw2reg_ctrl_reg_t ctrl; // [18:9]</pre>
<pre>    aes_hw2reg_trigger_reg_t trigger; // [8:5]</pre>
<pre>    aes_hw2reg_status_reg_t status; // [4:5]</pre>
<pre style="background-color: #FF0000;">  } aes_hw2reg_t;</pre>
<pre>  parameter logic [6:0] AES_KEY0_OFFSET = 7'h 0;</pre>
<pre>  parameter logic [6:0] AES_KEY1_OFFSET = 7'h 4;</pre>
<pre>  parameter logic [6:0] AES_KEY2_OFFSET = 7'h 8;</pre>
<pre>  parameter logic [6:0] AES_KEY3_OFFSET = 7'h c;</pre>
<pre>  parameter logic [6:0] AES_KEY4_OFFSET = 7'h 10;</pre>
<pre>  parameter logic [6:0] AES_KEY5_OFFSET = 7'h 14;</pre>
<pre>  parameter logic [6:0] AES_KEY6_OFFSET = 7'h 18;</pre>
<pre>  parameter logic [6:0] AES_KEY7_OFFSET = 7'h 1c;</pre>
<pre>  parameter logic [6:0] AES_DATA_IN0_OFFSET = 7'h 20;</pre>
<pre>  parameter logic [6:0] AES_DATA_IN1_OFFSET = 7'h 24;</pre>
<pre>  parameter logic [6:0] AES_DATA_IN2_OFFSET = 7'h 28;</pre>
<pre>  parameter logic [6:0] AES_DATA_IN3_OFFSET = 7'h 2c;</pre>
<pre>  parameter logic [6:0] AES_DATA_OUT0_OFFSET = 7'h 30;</pre>
<pre>  parameter logic [6:0] AES_DATA_OUT1_OFFSET = 7'h 34;</pre>
<pre>  parameter logic [6:0] AES_DATA_OUT2_OFFSET = 7'h 38;</pre>
<pre>  parameter logic [6:0] AES_DATA_OUT3_OFFSET = 7'h 3c;</pre>
<pre>  parameter logic [6:0] AES_CTRL_OFFSET = 7'h 40;</pre>
<pre>  parameter logic [6:0] AES_TRIGGER_OFFSET = 7'h 44;</pre>
<pre>  parameter logic [6:0] AES_STATUS_OFFSET = 7'h 48;</pre>
<pre>  typedef enum int {</pre>
<pre>    AES_KEY0,</pre>
<pre>    AES_KEY1,</pre>
<pre>    AES_KEY2,</pre>
<pre>    AES_KEY3,</pre>
<pre>    AES_KEY4,</pre>
<pre>    AES_KEY5,</pre>
<pre>    AES_KEY6,</pre>
<pre>    AES_KEY7,</pre>
<pre>    AES_DATA_IN0,</pre>
<pre>    AES_DATA_IN1,</pre>
<pre>    AES_DATA_IN2,</pre>
<pre>    AES_DATA_IN3,</pre>
<pre>    AES_DATA_OUT0,</pre>
<pre>    AES_DATA_OUT1,</pre>
<pre>    AES_DATA_OUT2,</pre>
<pre>    AES_DATA_OUT3,</pre>
<pre>    AES_CTRL,</pre>
<pre>    AES_TRIGGER,</pre>
<pre>    AES_STATUS</pre>
<pre>  } aes_id_e;</pre>
<pre>  parameter logic [3:0] AES_PERMIT [19] = '{</pre>
<pre>    4'b 1111, // index[ 0] AES_KEY0</pre>
<pre>    4'b 1111, // index[ 1] AES_KEY1</pre>
<pre>    4'b 1111, // index[ 2] AES_KEY2</pre>
<pre>    4'b 1111, // index[ 3] AES_KEY3</pre>
<pre>    4'b 1111, // index[ 4] AES_KEY4</pre>
<pre>    4'b 1111, // index[ 5] AES_KEY5</pre>
<pre>    4'b 1111, // index[ 6] AES_KEY6</pre>
<pre>    4'b 1111, // index[ 7] AES_KEY7</pre>
<pre>    4'b 1111, // index[ 8] AES_DATA_IN0</pre>
<pre>    4'b 1111, // index[ 9] AES_DATA_IN1</pre>
<pre>    4'b 1111, // index[10] AES_DATA_IN2</pre>
<pre>    4'b 1111, // index[11] AES_DATA_IN3</pre>
<pre>    4'b 1111, // index[12] AES_DATA_OUT0</pre>
<pre>    4'b 1111, // index[13] AES_DATA_OUT1</pre>
<pre>    4'b 1111, // index[14] AES_DATA_OUT2</pre>
<pre>    4'b 1111, // index[15] AES_DATA_OUT3</pre>
<pre>    4'b 0001, // index[16] AES_CTRL</pre>
<pre>    4'b 0001, // index[17] AES_TRIGGER</pre>
<pre>    4'b 0001  // index[18] AES_STATUS</pre>
<h3>hw/ip/aes/rtl/aes_sbox_lut.sv</h3>
<pre>  input  aes_pkg::mode_e mode_i,</pre>
<pre>  input  logic [7:0]     data_i,</pre>
<pre>  output logic [7:0]     data_o</pre>
<pre>  const logic [7:0] sbox_enc [256] = '{</pre>
<pre>    8'h63, 8'h7C, 8'h77, 8'h7B, 8'hF2, 8'h6B, 8'h6F, 8'hC5,</pre>
<pre>    8'h30, 8'h01, 8'h67, 8'h2B, 8'hFE, 8'hD7, 8'hAB, 8'h76,</pre>
<pre>    8'hCA, 8'h82, 8'hC9, 8'h7D, 8'hFA, 8'h59, 8'h47, 8'hF0,</pre>
<pre>    8'hAD, 8'hD4, 8'hA2, 8'hAF, 8'h9C, 8'hA4, 8'h72, 8'hC0,</pre>
<pre>    8'hB7, 8'hFD, 8'h93, 8'h26, 8'h36, 8'h3F, 8'hF7, 8'hCC,</pre>
<pre>    8'h34, 8'hA5, 8'hE5, 8'hF1, 8'h71, 8'hD8, 8'h31, 8'h15,</pre>
<pre>    8'h04, 8'hC7, 8'h23, 8'hC3, 8'h18, 8'h96, 8'h05, 8'h9A,</pre>
<pre>    8'h07, 8'h12, 8'h80, 8'hE2, 8'hEB, 8'h27, 8'hB2, 8'h75,</pre>
<pre>    8'h09, 8'h83, 8'h2C, 8'h1A, 8'h1B, 8'h6E, 8'h5A, 8'hA0,</pre>
<pre>    8'h52, 8'h3B, 8'hD6, 8'hB3, 8'h29, 8'hE3, 8'h2F, 8'h84,</pre>
<pre>    8'h53, 8'hD1, 8'h00, 8'hED, 8'h20, 8'hFC, 8'hB1, 8'h5B,</pre>
<pre>    8'h6A, 8'hCB, 8'hBE, 8'h39, 8'h4A, 8'h4C, 8'h58, 8'hCF,</pre>
<pre>    8'hD0, 8'hEF, 8'hAA, 8'hFB, 8'h43, 8'h4D, 8'h33, 8'h85,</pre>
<pre>    8'h45, 8'hF9, 8'h02, 8'h7F, 8'h50, 8'h3C, 8'h9F, 8'hA8,</pre>
<pre>    8'h51, 8'hA3, 8'h40, 8'h8F, 8'h92, 8'h9D, 8'h38, 8'hF5,</pre>
<pre>    8'hBC, 8'hB6, 8'hDA, 8'h21, 8'h10, 8'hFF, 8'hF3, 8'hD2,</pre>
<pre>    8'hCD, 8'h0C, 8'h13, 8'hEC, 8'h5F, 8'h97, 8'h44, 8'h17,</pre>
<pre>    8'hC4, 8'hA7, 8'h7E, 8'h3D, 8'h64, 8'h5D, 8'h19, 8'h73,</pre>
<pre>    8'h60, 8'h81, 8'h4F, 8'hDC, 8'h22, 8'h2A, 8'h90, 8'h88,</pre>
<pre>    8'h46, 8'hEE, 8'hB8, 8'h14, 8'hDE, 8'h5E, 8'h0B, 8'hDB,</pre>
<pre>    8'hE0, 8'h32, 8'h3A, 8'h0A, 8'h49, 8'h06, 8'h24, 8'h5C,</pre>
<pre>    8'hC2, 8'hD3, 8'hAC, 8'h62, 8'h91, 8'h95, 8'hE4, 8'h79,</pre>
<pre>    8'hE7, 8'hC8, 8'h37, 8'h6D, 8'h8D, 8'hD5, 8'h4E, 8'hA9,</pre>
<pre>    8'h6C, 8'h56, 8'hF4, 8'hEA, 8'h65, 8'h7A, 8'hAE, 8'h08,</pre>
<pre>    8'hBA, 8'h78, 8'h25, 8'h2E, 8'h1C, 8'hA6, 8'hB4, 8'hC6,</pre>
<pre>    8'hE8, 8'hDD, 8'h74, 8'h1F, 8'h4B, 8'hBD, 8'h8B, 8'h8A,</pre>
<pre>    8'h70, 8'h3E, 8'hB5, 8'h66, 8'h48, 8'h03, 8'hF6, 8'h0E,</pre>
<pre>    8'h61, 8'h35, 8'h57, 8'hB9, 8'h86, 8'hC1, 8'h1D, 8'h9E,</pre>
<pre>    8'hE1, 8'hF8, 8'h98, 8'h11, 8'h69, 8'hD9, 8'h8E, 8'h94,</pre>
<pre>    8'h9B, 8'h1E, 8'h87, 8'hE9, 8'hCE, 8'h55, 8'h28, 8'hDF,</pre>
<pre>    8'h8C, 8'hA1, 8'h89, 8'h0D, 8'hBF, 8'hE6, 8'h42, 8'h68,</pre>
<pre>    8'h41, 8'h99, 8'h2D, 8'h0F, 8'hB0, 8'h54, 8'hBB, 8'h16</pre>
<pre>  const logic [7:0] sbox_dec [256] = '{</pre>
<pre>    8'h52, 8'h09, 8'h6a, 8'hd5, 8'h30, 8'h36, 8'ha5, 8'h38,</pre>
<pre>    8'hbf, 8'h40, 8'ha3, 8'h9e, 8'h81, 8'hf3, 8'hd7, 8'hfb,</pre>
<pre>    8'h7c, 8'he3, 8'h39, 8'h82, 8'h9b, 8'h2f, 8'hff, 8'h87,</pre>
<pre>    8'h34, 8'h8e, 8'h43, 8'h44, 8'hc4, 8'hde, 8'he9, 8'hcb,</pre>
<pre>    8'h54, 8'h7b, 8'h94, 8'h32, 8'ha6, 8'hc2, 8'h23, 8'h3d,</pre>
<pre>    8'hee, 8'h4c, 8'h95, 8'h0b, 8'h42, 8'hfa, 8'hc3, 8'h4e,</pre>
<pre>    8'h08, 8'h2e, 8'ha1, 8'h66, 8'h28, 8'hd9, 8'h24, 8'hb2,</pre>
<pre>    8'h76, 8'h5b, 8'ha2, 8'h49, 8'h6d, 8'h8b, 8'hd1, 8'h25,</pre>
<pre>    8'h72, 8'hf8, 8'hf6, 8'h64, 8'h86, 8'h68, 8'h98, 8'h16,</pre>
<pre>    8'hd4, 8'ha4, 8'h5c, 8'hcc, 8'h5d, 8'h65, 8'hb6, 8'h92,</pre>
<pre>    8'h6c, 8'h70, 8'h48, 8'h50, 8'hfd, 8'hed, 8'hb9, 8'hda,</pre>
<pre>    8'h5e, 8'h15, 8'h46, 8'h57, 8'ha7, 8'h8d, 8'h9d, 8'h84,</pre>
<pre>    8'h90, 8'hd8, 8'hab, 8'h00, 8'h8c, 8'hbc, 8'hd3, 8'h0a,</pre>
<pre>    8'hf7, 8'he4, 8'h58, 8'h05, 8'hb8, 8'hb3, 8'h45, 8'h06,</pre>
<pre>    8'hd0, 8'h2c, 8'h1e, 8'h8f, 8'hca, 8'h3f, 8'h0f, 8'h02,</pre>
<pre>    8'hc1, 8'haf, 8'hbd, 8'h03, 8'h01, 8'h13, 8'h8a, 8'h6b,</pre>
<pre>    8'h3a, 8'h91, 8'h11, 8'h41, 8'h4f, 8'h67, 8'hdc, 8'hea,</pre>
<pre>    8'h97, 8'hf2, 8'hcf, 8'hce, 8'hf0, 8'hb4, 8'he6, 8'h73,</pre>
<pre>    8'h96, 8'hac, 8'h74, 8'h22, 8'he7, 8'had, 8'h35, 8'h85,</pre>
<pre>    8'he2, 8'hf9, 8'h37, 8'he8, 8'h1c, 8'h75, 8'hdf, 8'h6e,</pre>
<pre>    8'h47, 8'hf1, 8'h1a, 8'h71, 8'h1d, 8'h29, 8'hc5, 8'h89,</pre>
<pre>    8'h6f, 8'hb7, 8'h62, 8'h0e, 8'haa, 8'h18, 8'hbe, 8'h1b,</pre>
<pre>    8'hfc, 8'h56, 8'h3e, 8'h4b, 8'hc6, 8'hd2, 8'h79, 8'h20,</pre>
<pre>    8'h9a, 8'hdb, 8'hc0, 8'hfe, 8'h78, 8'hcd, 8'h5a, 8'hf4,</pre>
<pre>    8'h1f, 8'hdd, 8'ha8, 8'h33, 8'h88, 8'h07, 8'hc7, 8'h31,</pre>
<pre>    8'hb1, 8'h12, 8'h10, 8'h59, 8'h27, 8'h80, 8'hec, 8'h5f,</pre>
<pre>    8'h60, 8'h51, 8'h7f, 8'ha9, 8'h19, 8'hb5, 8'h4a, 8'h0d,</pre>
<pre>    8'h2d, 8'he5, 8'h7a, 8'h9f, 8'h93, 8'hc9, 8'h9c, 8'hef,</pre>
<pre>    8'ha0, 8'he0, 8'h3b, 8'h4d, 8'hae, 8'h2a, 8'hf5, 8'hb0,</pre>
<pre>    8'hc8, 8'heb, 8'hbb, 8'h3c, 8'h83, 8'h53, 8'h99, 8'h61,</pre>
<pre>    8'h17, 8'h2b, 8'h04, 8'h7e, 8'hba, 8'h77, 8'hd6, 8'h26,</pre>
<pre>    8'he1, 8'h69, 8'h14, 8'h63, 8'h55, 8'h21, 8'h0c, 8'h7d</pre>
<pre>  assign data_o = (mode_i == AES_ENC) ? sbox_enc[data_i] : sbox_dec[data_i];</pre>
<h3>hw/ip/aes/rtl/aes_mix_columns.sv</h3>
<pre>  input  aes_pkg::mode_e       mode_i,</pre>
<pre>  input  logic [3:0][3:0][7:0] data_i,</pre>
<pre>  output logic [3:0][3:0][7:0] data_o</pre>
<pre>  logic [3:0][3:0][7:0] data_i_transposed;</pre>
<pre>  logic [3:0][3:0][7:0] data_o_transposed;</pre>
<pre>  assign data_i_transposed = aes_transpose(data_i);</pre>
<pre>  for (genvar i = 0; i < 4; i++) begin : gen_mix_column</pre>
<pre>    aes_mix_single_column aes_mix_column_i (</pre>
<pre>      .mode_i ( mode_i               ),</pre>
<pre>      .data_i ( data_i_transposed[i] ),</pre>
<pre>      .data_o ( data_o_transposed[i] )</pre>
<pre>  assign data_o = aes_transpose(data_o_transposed);</pre>
<h3>hw/ip/aes/rtl/aes_shift_rows.sv</h3>
<pre>  input  aes_pkg::mode_e       mode_i,</pre>
<pre>  input  logic [3:0][3:0][7:0] data_i,</pre>
<pre>  output logic [3:0][3:0][7:0] data_o</pre>
<pre>  assign data_o[0] = data_i[0];</pre>
<pre>  assign data_o[2] = aes_circ_byte_shift(data_i[2], 2);</pre>
<pre>  assign data_o[1] = (mode_i == AES_ENC) ? aes_circ_byte_shift(data_i[1], -1)</pre>
<pre>                                         : aes_circ_byte_shift(data_i[1],  1);</pre>
<pre>  assign data_o[3] = (mode_i == AES_ENC) ? aes_circ_byte_shift(data_i[3],  1)</pre>
<pre>                                         : aes_circ_byte_shift(data_i[3], -1);</pre>
<h3>hw/ip/aes/rtl/aes_sbox_canright.sv</h3>
<pre>  input  aes_pkg::mode_e mode_i,</pre>
<pre>  input  logic [7:0]     data_i,</pre>
<pre>  output logic [7:0]     data_o</pre>
<pre>  function automatic logic [1:0] aes_mul_gf2p2(input logic [1:0] g, input logic [1:0] d);</pre>
<pre>    logic [1:0] f;</pre>
<pre>    logic       a, b, c;</pre>
<pre>    a    = g[1] & d[1];</pre>
<pre>    b    = (^g) & (^d);</pre>
<pre>    c    = g[0] & d[0];</pre>
<pre>    f[1] = a ^ b;</pre>
<pre>    f[0] = c ^ b;</pre>
<pre>    return f;</pre>
<pre>  function automatic logic [1:0] aes_scale_omega2_gf2p2(input logic [1:0] g);</pre>
<pre>    logic [1:0] d;</pre>
<pre>    d[1] = g[0];</pre>
<pre>    d[0] = g[1] ^ g[0];</pre>
<pre>    return d;</pre>
<pre>  function automatic logic [1:0] aes_scale_omega_gf2p2(input logic [1:0] g);</pre>
<pre>    logic [1:0] d;</pre>
<pre>    d[1] = g[1] ^ g[0];</pre>
<pre>    d[0] = g[1];</pre>
<pre>    return d;</pre>
<pre>  function automatic logic [1:0] aes_square_gf2p2(input logic [1:0] g);</pre>
<pre>    logic [1:0] d;</pre>
<pre>    d[1] = g[0];</pre>
<pre>    d[0] = g[1];</pre>
<pre>    return d;</pre>
<pre>  function automatic logic [3:0] aes_mul_gf2p4(input logic [3:0] gamma, input logic [3:0] delta);</pre>
<pre>    logic [3:0] theta;</pre>
<pre>    logic [1:0] a, b, c;</pre>
<pre>    a          = aes_mul_gf2p2(gamma[3:2], delta[3:2]);</pre>
<pre>    b          = aes_mul_gf2p2(gamma[3:2] ^ gamma[1:0], delta[3:2] ^ delta[1:0]);</pre>
<pre>    c          = aes_mul_gf2p2(gamma[1:0], delta[1:0]);</pre>
<pre>    theta[3:2] = a ^ aes_scale_omega2_gf2p2(b);</pre>
<pre>    theta[1:0] = c ^ aes_scale_omega2_gf2p2(b);</pre>
<pre>    return theta;</pre>
<pre>  function automatic logic [3:0] aes_square_scale_gf2p4_gf2p2(input logic [3:0] gamma);</pre>
<pre>    logic [3:0] delta;</pre>
<pre>    logic [1:0] a, b;</pre>
<pre>    a          = gamma[3:2] ^ gamma[1:0];</pre>
<pre>    b          = aes_square_gf2p2(gamma[1:0]);</pre>
<pre>    delta[3:2] = aes_square_gf2p2(a);</pre>
<pre>    delta[1:0] = aes_scale_omega_gf2p2(b);</pre>
<pre>    return delta;</pre>
<pre>  function automatic logic [3:0] aes_inverse_gf2p4(input logic [3:0] gamma);</pre>
<pre>    logic [3:0] delta;</pre>
<pre>    logic [1:0] a, b, c, d;</pre>
<pre>    a          = gamma[3:2] ^ gamma[1:0];</pre>
<pre>    b          = aes_mul_gf2p2(gamma[3:2], gamma[1:0]);</pre>
<pre>    c          = aes_scale_omega2_gf2p2(aes_square_gf2p2(a));</pre>
<pre>    d          = aes_square_gf2p2(c ^ b);</pre>
<pre>    delta[3:2] = aes_mul_gf2p2(d, gamma[1:0]);</pre>
<pre>    delta[1:0] = aes_mul_gf2p2(d, gamma[3:2]);</pre>
<pre>    return delta;</pre>
<pre>  function automatic logic [7:0] aes_inverse_gf2p8(input logic [7:0] gamma);</pre>
<pre>    logic [7:0] delta;</pre>
<pre>    logic [3:0] a, b, c, d;</pre>
<pre>    a          = gamma[7:4] ^ gamma[3:0];</pre>
<pre>    b          = aes_mul_gf2p4(gamma[7:4], gamma[3:0]);</pre>
<pre>    c          = aes_square_scale_gf2p4_gf2p2(a);</pre>
<pre>    d          = aes_inverse_gf2p4(c ^ b);</pre>
<pre>    delta[7:4] = aes_mul_gf2p4(d, gamma[3:0]);</pre>
<pre>    delta[3:0] = aes_mul_gf2p4(d, gamma[7:4]);</pre>
<pre>    return delta;</pre>
<pre>  const logic [7:0] a2x [8] = '{8'h98, 8'hf3, 8'hf2, 8'h48, 8'h09, 8'h81, 8'ha9, 8'hff};</pre>
<pre>  const logic [7:0] x2a [8] = '{8'h64, 8'h78, 8'h6e, 8'h8c, 8'h68, 8'h29, 8'hde, 8'h60};</pre>
<pre>  const logic [7:0] x2s [8] = '{8'h58, 8'h2d, 8'h9e, 8'h0b, 8'hdc, 8'h04, 8'h03, 8'h24};</pre>
<pre>  const logic [7:0] s2x [8] = '{8'h8c, 8'h79, 8'h05, 8'heb, 8'h12, 8'h04, 8'h51, 8'h53};</pre>
<pre>  logic [7:0] data_basis_x, data_inverse;</pre>
<pre>  assign data_basis_x = (mode_i == AES_ENC) ? aes_mvm(data_i, a2x) :</pre>
<pre>                                              aes_mvm(data_i ^ 8'h63, s2x);</pre>
<pre>  assign data_inverse = aes_inverse_gf2p8(data_basis_x);</pre>
<pre>  assign data_o       = (mode_i == AES_ENC) ? aes_mvm(data_inverse, x2s) ^ 8'h63 :</pre>
<pre>                                              aes_mvm(data_inverse, x2a);</pre>
<h3>hw/ip/aes/rtl/aes_mix_single_column.sv</h3>
<pre>  input  aes_pkg::mode_e  mode_i,</pre>
<pre>  input  logic [3:0][7:0] data_i,</pre>
<pre>  output logic [3:0][7:0] data_o</pre>
<pre>  logic [3:0][7:0] x;</pre>
<pre>  logic [1:0][7:0] y;</pre>
<pre>  logic [1:0][7:0] z;</pre>
<pre>  logic [3:0][7:0] x_mul2;</pre>
<pre>  logic [1:0][7:0] y_pre_mul4;</pre>
<pre>  logic      [7:0] y2, y2_pre_mul2;</pre>
<pre>  logic [1:0][7:0] z_muxed;</pre>
<pre>  assign x[0] = data_i[0] ^ data_i[3];</pre>
<pre>  assign x[1] = data_i[3] ^ data_i[2];</pre>
<pre>  assign x[2] = data_i[2] ^ data_i[1];</pre>
<pre>  assign x[3] = data_i[1] ^ data_i[0];</pre>
<pre>  for (genvar i = 0; i < 4; i++) begin : gen_x_mul2</pre>
<pre>    assign x_mul2[i] = aes_mul2(x[i]);</pre>
<pre>  assign y_pre_mul4[0] = data_i[3] ^ data_i[1];</pre>
<pre>  assign y_pre_mul4[1] = data_i[2] ^ data_i[0];</pre>
<pre>  for (genvar i = 0; i < 2; i++) begin : gen_mul4</pre>
<pre>    assign y[i] = aes_mul4(y_pre_mul4[i]);</pre>
<pre>  assign y2_pre_mul2 = y[0] ^ y[1];</pre>
<pre>  assign y2 = aes_mul2(y2_pre_mul2);</pre>
<pre>  assign z[0] = y2 ^ y[0];</pre>
<pre>  assign z[1] = y2 ^ y[1];</pre>
<pre>  assign z_muxed[0] = (mode_i == AES_ENC) ? 8'b0 : z[0];</pre>
<pre>  assign z_muxed[1] = (mode_i == AES_ENC) ? 8'b0 : z[1];</pre>
<pre>  assign data_o[0] = data_i[1] ^ x_mul2[3] ^ x[1] ^ z_muxed[1];</pre>
<pre>  assign data_o[1] = data_i[0] ^ x_mul2[2] ^ x[1] ^ z_muxed[0];</pre>
<pre>  assign data_o[2] = data_i[3] ^ x_mul2[1] ^ x[3] ^ z_muxed[1];</pre>
<pre>  assign data_o[3] = data_i[2] ^ x_mul2[0] ^ x[3] ^ z_muxed[0];</pre>
<h3>hw/ip/aes/rtl/aes_sbox.sv</h3>
<pre>module aes_sbox #(</pre>
<pre>  parameter SBoxImpl = "lut"</pre>
<pre>  input  aes_pkg::mode_e mode_i,</pre>
<pre>  input  logic [7:0]     data_i,</pre>
<pre>  output logic [7:0]     data_o</pre>
<pre>  if (SBoxImpl == "lut") begin : gen_sbox_lut</pre>
<pre>    aes_sbox_lut aes_sbox (</pre>
<pre>      .mode_i,</pre>
<pre>      .data_i,</pre>
<pre>      .data_o</pre>
<pre style="background-color: #FF0000;">  end else if (SBoxImpl == "canright") begin : gen_sbox_canright</pre>
<pre style="background-color: #FF0000;">    aes_sbox_canright aes_sbox (</pre>
<pre style="background-color: #FF0000;">      .mode_i,</pre>
<pre style="background-color: #FF0000;">      .data_i,</pre>
<pre style="background-color: #FF0000;">      .data_o</pre>
<h3>hw/ip/aes/rtl/aes_sub_bytes.sv</h3>
<pre>module aes_sub_bytes #(</pre>
<pre>  parameter SBoxImpl = "lut"</pre>
<pre>  input  aes_pkg::mode_e       mode_i,</pre>
<pre>  input  logic [3:0][3:0][7:0] data_i,</pre>
<pre>  output logic [3:0][3:0][7:0] data_o</pre>
<pre>  for (genvar j = 0; j < 4; j++) begin : gen_sbox_j</pre>
<pre>    for (genvar i = 0; i < 4; i++) begin : gen_sbox_i</pre>
<pre>      aes_sbox #(</pre>
<pre>        .SBoxImpl ( SBoxImpl )</pre>
<pre style="background-color: #FF0000;">      ) aes_sbox_ij (</pre>
<pre>        .mode_i ( mode_i       ),</pre>
<pre>        .data_i ( data_i[i][j] ),</pre>
<pre>        .data_o ( data_o[i][j] )</pre>
<h3>hw/ip/aes/rtl/aes_core.sv</h3>
<pre>module aes_core #(</pre>
<pre>  parameter bit AES192Enable = 1,</pre>
<pre>  parameter     SBoxImpl     = "lut"</pre>
<pre>  input                            clk_i,</pre>
<pre>  input                            rst_ni,</pre>
<pre>  input  aes_reg_pkg::aes_reg2hw_t reg2hw,</pre>
<pre>  output aes_reg_pkg::aes_hw2reg_t hw2reg</pre>
<pre>  logic     [3:0][31:0] data_in;</pre>
<pre>  logic     [3:0]       data_in_qe;</pre>
<pre>  logic                 data_in_we;</pre>
<pre>  logic     [7:0][31:0] key_init;</pre>
<pre>  logic     [7:0]       key_init_qe;</pre>
<pre>  logic                 ctrl_qe;</pre>
<pre>  logic                 ctrl_we;</pre>
<pre>  mode_e                mode_d, mode_q;</pre>
<pre>  key_len_e             key_len;</pre>
<pre>  key_len_e             key_len_d, key_len_q;</pre>
<pre>  logic                 manual_start_trigger_q;</pre>
<pre>  logic                 force_data_overwrite_q;</pre>
<pre>  logic [3:0][3:0][7:0] state_init;</pre>
<pre>  logic [3:0][3:0][7:0] state_d;</pre>
<pre>  logic [3:0][3:0][7:0] state_q;</pre>
<pre>  logic                 state_we;</pre>
<pre>  state_sel_e           state_sel;</pre>
<pre>  logic [3:0][3:0][7:0] sub_bytes_out;</pre>
<pre>  logic [3:0][3:0][7:0] shift_rows_out;</pre>
<pre>  logic [3:0][3:0][7:0] mix_columns_out;</pre>
<pre>  logic [3:0][3:0][7:0] add_round_key_in;</pre>
<pre>  logic [3:0][3:0][7:0] add_round_key_out;</pre>
<pre>  add_rk_sel_e          add_round_key_in_sel;</pre>
<pre>  logic     [7:0][31:0] key_init_d;</pre>
<pre>  logic     [7:0][31:0] key_init_q;</pre>
<pre>  logic     [7:0]       key_init_we;</pre>
<pre>  key_init_sel_e        key_init_sel;</pre>
<pre>  logic     [7:0][31:0] key_full_d;</pre>
<pre>  logic     [7:0][31:0] key_full_q;</pre>
<pre>  logic                 key_full_we;</pre>
<pre>  key_full_sel_e        key_full_sel;</pre>
<pre>  logic     [7:0][31:0] key_dec_d;</pre>
<pre>  logic     [7:0][31:0] key_dec_q;</pre>
<pre>  logic                 key_dec_we;</pre>
<pre>  key_dec_sel_e         key_dec_sel;</pre>
<pre>  logic     [7:0][31:0] key_expand_out;</pre>
<pre>  mode_e                key_expand_mode;</pre>
<pre>  logic                 key_expand_step;</pre>
<pre>  logic                 key_expand_clear;</pre>
<pre>  logic           [3:0] key_expand_round;</pre>
<pre>  key_words_sel_e       key_words_sel;</pre>
<pre>  logic     [3:0][31:0] key_words;</pre>
<pre>  logic [3:0][3:0][7:0] key_bytes;</pre>
<pre>  logic [3:0][3:0][7:0] key_mix_columns_out;</pre>
<pre>  logic [3:0][3:0][7:0] round_key;</pre>
<pre>  round_key_sel_e       round_key_sel;</pre>
<pre>  logic     [3:0][31:0] data_out_d;</pre>
<pre>  logic     [3:0][31:0] data_out_q;</pre>
<pre>  logic                 data_out_we;</pre>
<pre>  logic           [3:0] data_out_re;</pre>
<pre>  logic     [3:0][31:0] unused_data_out_q;</pre>
<pre>  always_comb begin : key_init_get</pre>
<pre>    for (int i=0; i<8; i++) begin</pre>
<pre>      key_init[i]    = reg2hw.key[i].q;</pre>
<pre>      key_init_qe[i] = reg2hw.key[i].qe;</pre>
<pre>  always_comb begin : data_in_get</pre>
<pre>    for (int i=0; i<4; i++) begin</pre>
<pre>      data_in[i]    = reg2hw.data_in[i].q;</pre>
<pre>      data_in_qe[i] = reg2hw.data_in[i].qe;</pre>
<pre>  always_comb begin : data_out_get</pre>
<pre>    for (int i=0; i<4; i++) begin</pre>
<pre>      unused_data_out_q[i] = reg2hw.data_out[i].q;</pre>
<pre>      data_out_re[i]       = reg2hw.data_out[i].re;</pre>
<pre>  assign mode_d = mode_e'(reg2hw.ctrl.mode.q);</pre>
<pre>  assign key_len = key_len_e'(reg2hw.ctrl.key_len.q);</pre>
<pre>  always_comb begin : get_key_len</pre>
<pre>    unique case (key_len)</pre>
<pre>      AES_128: key_len_d = AES_128;</pre>
<pre>      AES_256: key_len_d = AES_256;</pre>
<pre>      AES_192: key_len_d = AES192Enable ? AES_192 : AES_128;</pre>
<pre>      default: key_len_d = AES_128; // unsupported values are mapped to AES_128</pre>
<pre>  assign ctrl_qe = reg2hw.ctrl.mode.qe & reg2hw.ctrl.key_len.qe &</pre>
<pre>      reg2hw.ctrl.manual_start_trigger.qe & reg2hw.ctrl.force_data_overwrite.qe;</pre>
<pre>  assign state_init = aes_transpose(data_in);</pre>
<pre>  always_comb begin : state_mux</pre>
<pre>    unique case (state_sel)</pre>
<pre>      STATE_INIT:  state_d = state_init;</pre>
<pre>      STATE_ROUND: state_d = add_round_key_out;</pre>
<pre>      STATE_CLEAR: state_d = '0;</pre>
<pre>      default:     state_d = state_init;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : state_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      state_q <= '0;</pre>
<pre>    end else if (state_we) begin</pre>
<pre>      state_q <= state_d;</pre>
<pre>  aes_sub_bytes #(</pre>
<pre>  .SBoxImpl     ( SBoxImpl )</pre>
<pre style="background-color: #FF0000;">  ) aes_sub_bytes (</pre>
<pre>    .mode_i ( mode_q        ),</pre>
<pre>    .data_i ( state_q       ),</pre>
<pre>    .data_o ( sub_bytes_out )</pre>
<pre>  aes_shift_rows aes_shift_rows (</pre>
<pre>    .mode_i ( mode_q         ),</pre>
<pre>    .data_i ( sub_bytes_out  ),</pre>
<pre>    .data_o ( shift_rows_out )</pre>
<pre>  aes_mix_columns aes_mix_columns (</pre>
<pre>    .mode_i ( mode_q          ),</pre>
<pre>    .data_i ( shift_rows_out  ),</pre>
<pre>    .data_o ( mix_columns_out )</pre>
<pre>  always_comb begin : add_round_key_in_mux</pre>
<pre>    unique case (add_round_key_in_sel)</pre>
<pre>      ADD_RK_INIT:  add_round_key_in = state_q;</pre>
<pre>      ADD_RK_ROUND: add_round_key_in = mix_columns_out;</pre>
<pre>      ADD_RK_FINAL: add_round_key_in = shift_rows_out;</pre>
<pre>      default:      add_round_key_in = state_q;</pre>
<pre>  assign add_round_key_out = add_round_key_in ^ round_key;</pre>
<pre>  always_comb begin : key_init_mux</pre>
<pre>    unique case (key_init_sel)</pre>
<pre>      KEY_INIT_INPUT: key_init_d = key_init;</pre>
<pre>      KEY_INIT_CLEAR: key_init_d = '0;</pre>
<pre>      default:        key_init_d = key_init;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : key_init_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      key_init_q <= '0;</pre>
<pre>    end else begin</pre>
<pre>      for (int i=0; i<8; i++) begin</pre>
<pre>        if (key_init_we[i]) begin</pre>
<pre>          key_init_q[i] <= key_init_d[i];</pre>
<pre>  always_comb begin : key_full_mux</pre>
<pre>    unique case (key_full_sel)</pre>
<pre>      KEY_FULL_ENC_INIT: key_full_d = key_init_q;</pre>
<pre>      KEY_FULL_DEC_INIT: key_full_d = key_dec_q;</pre>
<pre>      KEY_FULL_ROUND:    key_full_d = key_expand_out;</pre>
<pre>      KEY_FULL_CLEAR:    key_full_d = '0;</pre>
<pre>      default:           key_full_d = key_init_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : key_full_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      key_full_q <= '0;</pre>
<pre>    end else if (key_full_we) begin</pre>
<pre>      key_full_q <= key_full_d;</pre>
<pre>  always_comb begin : key_dec_mux</pre>
<pre>    unique case (key_dec_sel)</pre>
<pre>      KEY_DEC_EXPAND: key_dec_d = key_expand_out;</pre>
<pre>      KEY_DEC_CLEAR:  key_dec_d = '0;</pre>
<pre>      default:        key_dec_d = key_expand_out;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : key_dec_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      key_dec_q <= '0;</pre>
<pre>    end else if (key_dec_we) begin</pre>
<pre>      key_dec_q <= key_dec_d;</pre>
<pre>  aes_key_expand #(</pre>
<pre>  .AES192Enable ( AES192Enable ),</pre>
<pre>  .SBoxImpl     ( SBoxImpl     )</pre>
<pre style="background-color: #FF0000;">  ) aes_key_expand (</pre>
<pre>    .clk_i     ( clk_i            ),</pre>
<pre>    .rst_ni    ( rst_ni           ),</pre>
<pre>    .mode_i    ( key_expand_mode  ),</pre>
<pre>    .step_i    ( key_expand_step  ),</pre>
<pre>    .clear_i   ( key_expand_clear ),</pre>
<pre>    .round_i   ( key_expand_round ),</pre>
<pre>    .key_len_i ( key_len_q        ),</pre>
<pre>    .key_i     ( key_full_q       ),</pre>
<pre>    .key_o     ( key_expand_out   )</pre>
<pre>  always_comb begin : key_words_mux</pre>
<pre>    unique case (key_words_sel)</pre>
<pre>      KEY_WORDS_0123: key_words = key_full_q[3:0];</pre>
<pre>      KEY_WORDS_2345: key_words = AES192Enable ? key_full_q[5:2] : key_full_q[3:0];</pre>
<pre>      KEY_WORDS_4567: key_words = key_full_q[7:4];</pre>
<pre>      KEY_WORDS_ZERO: key_words = '0;</pre>
<pre>      default:        key_words = key_full_q[3:0];</pre>
<pre>  assign key_bytes = aes_transpose(key_words);</pre>
<pre>  aes_mix_columns aes_key_mix_columns (</pre>
<pre>    .mode_i ( AES_DEC             ),</pre>
<pre>    .data_i ( key_bytes           ),</pre>
<pre>    .data_o ( key_mix_columns_out )</pre>
<pre>  always_comb begin : round_key_mux</pre>
<pre>    unique case (round_key_sel)</pre>
<pre>      ROUND_KEY_DIRECT: round_key = key_bytes;</pre>
<pre>      ROUND_KEY_MIXED:  round_key = key_mix_columns_out;</pre>
<pre>      default:          round_key = key_bytes;</pre>
<pre>  aes_control aes_control (</pre>
<pre>    .clk_i                  ( clk_i                              ),</pre>
<pre>    .rst_ni                 ( rst_ni                             ),</pre>
<pre>    .mode_i                 ( mode_q                             ),</pre>
<pre>    .key_len_i              ( key_len_q                          ),</pre>
<pre>    .manual_start_trigger_i ( manual_start_trigger_q             ),</pre>
<pre>    .force_data_overwrite_i ( force_data_overwrite_q             ),</pre>
<pre>    .start_i                ( reg2hw.trigger.start.q             ),</pre>
<pre>    .key_clear_i            ( reg2hw.trigger.key_clear.q         ),</pre>
<pre>    .data_in_clear_i        ( reg2hw.trigger.data_in_clear.q     ),</pre>
<pre>    .data_out_clear_i       ( reg2hw.trigger.data_out_clear.q    ),</pre>
<pre>    .data_in_qe_i           ( data_in_qe                         ),</pre>
<pre>    .key_init_qe_i          ( key_init_qe                        ),</pre>
<pre>    .data_out_re_i          ( data_out_re                        ),</pre>
<pre>    .state_sel_o            ( state_sel                          ),</pre>
<pre>    .state_we_o             ( state_we                           ),</pre>
<pre>    .add_rk_sel_o           ( add_round_key_in_sel               ),</pre>
<pre>    .key_expand_mode_o      ( key_expand_mode                    ),</pre>
<pre>    .key_init_sel_o         ( key_init_sel                       ),</pre>
<pre>    .key_init_we_o          ( key_init_we                        ),</pre>
<pre>    .key_full_sel_o         ( key_full_sel                       ),</pre>
<pre>    .key_full_we_o          ( key_full_we                        ),</pre>
<pre>    .key_dec_sel_o          ( key_dec_sel                        ),</pre>
<pre>    .key_dec_we_o           ( key_dec_we                         ),</pre>
<pre>    .key_expand_step_o      ( key_expand_step                    ),</pre>
<pre>    .key_expand_clear_o     ( key_expand_clear                   ),</pre>
<pre>    .key_expand_round_o     ( key_expand_round                   ),</pre>
<pre>    .key_words_sel_o        ( key_words_sel                      ),</pre>
<pre>    .round_key_sel_o        ( round_key_sel                      ),</pre>
<pre>    .data_in_we_o           ( data_in_we                         ),</pre>
<pre>    .data_out_we_o          ( data_out_we                        ),</pre>
<pre>    .start_o                ( hw2reg.trigger.start.d             ),</pre>
<pre>    .start_we_o             ( hw2reg.trigger.start.de            ),</pre>
<pre>    .key_clear_o            ( hw2reg.trigger.key_clear.d         ),</pre>
<pre>    .key_clear_we_o         ( hw2reg.trigger.key_clear.de        ),</pre>
<pre>    .data_in_clear_o        ( hw2reg.trigger.data_in_clear.d     ),</pre>
<pre>    .data_in_clear_we_o     ( hw2reg.trigger.data_in_clear.de    ),</pre>
<pre>    .data_out_clear_o       ( hw2reg.trigger.data_out_clear.d    ),</pre>
<pre>    .data_out_clear_we_o    ( hw2reg.trigger.data_out_clear.de   ),</pre>
<pre>    .output_valid_o         ( hw2reg.status.output_valid.d       ),</pre>
<pre>    .output_valid_we_o      ( hw2reg.status.output_valid.de      ),</pre>
<pre>    .input_ready_o          ( hw2reg.status.input_ready.d        ),</pre>
<pre>    .input_ready_we_o       ( hw2reg.status.input_ready.de       ),</pre>
<pre>    .idle_o                 ( hw2reg.status.idle.d               ),</pre>
<pre>    .idle_we_o              ( hw2reg.status.idle.de              ),</pre>
<pre>    .stall_o                ( hw2reg.status.stall.d              ),</pre>
<pre>    .stall_we_o             ( hw2reg.status.stall.de             )</pre>
<pre>  always_comb begin : data_in_reg_clear</pre>
<pre>    for (int i=0; i<4; i++) begin</pre>
<pre>      hw2reg.data_in[i].d  = '0;</pre>
<pre>      hw2reg.data_in[i].de = data_in_we;</pre>
<pre>  assign ctrl_we = ctrl_qe & hw2reg.status.idle.d;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : ctrl_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      mode_q                 <= AES_ENC;</pre>
<pre>      key_len_q              <= AES_128;</pre>
<pre>      manual_start_trigger_q <= '0;</pre>
<pre>      force_data_overwrite_q <= '0;</pre>
<pre>    end else if (ctrl_we) begin</pre>
<pre>      mode_q                 <= mode_d;</pre>
<pre>      key_len_q              <= key_len_d;</pre>
<pre>      manual_start_trigger_q <= reg2hw.ctrl.manual_start_trigger.q;</pre>
<pre>      force_data_overwrite_q <= reg2hw.ctrl.force_data_overwrite.q;</pre>
<pre>  assign data_out_d = aes_transpose(add_round_key_out);</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : data_out_reg</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      data_out_q <= '0;</pre>
<pre>    end else if (data_out_we) begin</pre>
<pre>      data_out_q <= data_out_d;</pre>
<pre>  always_comb begin : key_reg_put</pre>
<pre>    for (int i=0; i<8; i++) begin</pre>
<pre>      hw2reg.key[i].d  = key_init_q[i];</pre>
<pre>  always_comb begin : data_out_put</pre>
<pre>    for (int i=0; i<4; i++) begin</pre>
<pre>      hw2reg.data_out[i].d = data_out_q[i];</pre>
<pre>  assign hw2reg.ctrl.key_len.d  = {key_len_q};</pre>
<h3>hw/ip/aes/rtl/aes_control.sv</h3>
<pre>  input  logic                    clk_i,</pre>
<pre>  input  logic                    rst_ni,</pre>
<pre>  input  aes_pkg::mode_e          mode_i,</pre>
<pre>  input  aes_pkg::key_len_e       key_len_i,</pre>
<pre>  input  logic                    manual_start_trigger_i,</pre>
<pre>  input  logic                    force_data_overwrite_i,</pre>
<pre>  input  logic                    start_i,</pre>
<pre>  input  logic                    key_clear_i,</pre>
<pre>  input  logic                    data_in_clear_i,</pre>
<pre>  input  logic                    data_out_clear_i,</pre>
<pre>  input  logic [3:0]              data_in_qe_i,</pre>
<pre>  input  logic [7:0]              key_init_qe_i,</pre>
<pre>  input  logic [3:0]              data_out_re_i,</pre>
<pre>  output aes_pkg::state_sel_e     state_sel_o,</pre>
<pre>  output logic                    state_we_o,</pre>
<pre>  output aes_pkg::add_rk_sel_e    add_rk_sel_o,</pre>
<pre>  output aes_pkg::mode_e          key_expand_mode_o,</pre>
<pre>  output aes_pkg::key_init_sel_e  key_init_sel_o,</pre>
<pre>  output logic [7:0]              key_init_we_o,</pre>
<pre>  output aes_pkg::key_full_sel_e  key_full_sel_o,</pre>
<pre>  output logic                    key_full_we_o,</pre>
<pre>  output aes_pkg::key_dec_sel_e   key_dec_sel_o,</pre>
<pre>  output logic                    key_dec_we_o,</pre>
<pre>  output logic                    key_expand_step_o,</pre>
<pre>  output logic                    key_expand_clear_o,</pre>
<pre>  output logic [3:0]              key_expand_round_o,</pre>
<pre>  output aes_pkg::key_words_sel_e key_words_sel_o,</pre>
<pre>  output aes_pkg::round_key_sel_e round_key_sel_o,</pre>
<pre>  output logic                    data_in_we_o,</pre>
<pre>  output logic                    data_out_we_o,</pre>
<pre>  output logic                    start_o,</pre>
<pre>  output logic                    start_we_o,</pre>
<pre>  output logic                    key_clear_o,</pre>
<pre>  output logic                    key_clear_we_o,</pre>
<pre>  output logic                    data_in_clear_o,</pre>
<pre>  output logic                    data_in_clear_we_o,</pre>
<pre>  output logic                    data_out_clear_o,</pre>
<pre>  output logic                    data_out_clear_we_o,</pre>
<pre>  output logic                    output_valid_o,</pre>
<pre>  output logic                    output_valid_we_o,</pre>
<pre>  output logic                    input_ready_o,</pre>
<pre>  output logic                    input_ready_we_o,</pre>
<pre>  output logic                    idle_o,</pre>
<pre>  output logic                    idle_we_o,</pre>
<pre>  output logic                    stall_o,</pre>
<pre>  output logic                    stall_we_o</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    IDLE, INIT, ROUND, FINISH, CLEAR</pre>
<pre>  } aes_ctrl_e;</pre>
<pre>  aes_ctrl_e aes_ctrl_ns, aes_ctrl_cs;</pre>
<pre>  logic [3:0] data_in_new_d, data_in_new_q;</pre>
<pre>  logic       data_in_new;</pre>
<pre>  logic       data_in_load;</pre>
<pre>  logic       key_init_clear;</pre>
<pre>  logic [7:0] key_init_new_d, key_init_new_q;</pre>
<pre>  logic       key_init_new;</pre>
<pre>  logic       dec_key_gen;</pre>
<pre>  logic [3:0] data_out_read_d, data_out_read_q;</pre>
<pre>  logic       data_out_read;</pre>
<pre>  logic       output_valid_q;</pre>
<pre>  logic [3:0] round_d, round_q;</pre>
<pre>  logic [3:0] num_rounds_d, num_rounds_q;</pre>
<pre>  logic [3:0] num_rounds_regular;</pre>
<pre>  logic       dec_key_gen_d, dec_key_gen_q;</pre>
<pre>  logic       start, finish;</pre>
<pre>  assign start = manual_start_trigger_i ? start_i : data_in_new;</pre>
<pre>  assign finish = force_data_overwrite_i ? 1'b1 : ~output_valid_q;</pre>
<pre>  always_comb begin : aes_ctrl_fsm</pre>
<pre>    state_sel_o  = STATE_ROUND;</pre>
<pre>    state_we_o   = 1'b0;</pre>
<pre>    add_rk_sel_o = ADD_RK_ROUND;</pre>
<pre>    key_init_sel_o     = KEY_INIT_INPUT;</pre>
<pre>    key_init_we_o      = 8'h00;</pre>
<pre>    key_full_sel_o     = KEY_FULL_ROUND;</pre>
<pre>    key_full_we_o      = 1'b0;</pre>
<pre>    key_dec_sel_o      = KEY_DEC_EXPAND;</pre>
<pre>    key_dec_we_o       = 1'b0;</pre>
<pre>    key_expand_step_o  = 1'b0;</pre>
<pre>    key_expand_clear_o = 1'b0;</pre>
<pre>    key_words_sel_o    = KEY_WORDS_ZERO;</pre>
<pre>    round_key_sel_o    = ROUND_KEY_DIRECT;</pre>
<pre>    start_we_o          = 1'b0;</pre>
<pre>    key_clear_we_o      = 1'b0;</pre>
<pre>    data_in_clear_we_o  = 1'b0;</pre>
<pre>    data_out_clear_we_o = 1'b0;</pre>
<pre>    idle_o     = 1'b0;</pre>
<pre>    idle_we_o  = 1'b0;</pre>
<pre>    stall_o    = 1'b0;</pre>
<pre>    stall_we_o = 1'b0;</pre>
<pre>    dec_key_gen   = 1'b0;</pre>
<pre>    data_in_load  = 1'b0;</pre>
<pre>    data_in_we_o  = 1'b0;</pre>
<pre>    data_out_we_o = 1'b0;</pre>
<pre>    aes_ctrl_ns   = aes_ctrl_cs;</pre>
<pre>    round_d       = round_q;</pre>
<pre>    num_rounds_d  = num_rounds_q;</pre>
<pre>    dec_key_gen_d = dec_key_gen_q;</pre>
<pre>    unique case (aes_ctrl_cs)</pre>
<pre>      IDLE: begin</pre>
<pre>        idle_o        = 1'b1;</pre>
<pre>        idle_we_o     = 1'b1;</pre>
<pre>        stall_o       = 1'b0;</pre>
<pre>        stall_we_o    = 1'b1;</pre>
<pre>        dec_key_gen_d = 1'b0;</pre>
<pre>        if (start) begin</pre>
<pre>          dec_key_gen_d = key_init_new & (mode_i == AES_DEC);</pre>
<pre>          state_sel_o = dec_key_gen_d ? STATE_CLEAR : STATE_INIT;</pre>
<pre>          state_we_o  = 1'b1;</pre>
<pre>          key_expand_clear_o = 1'b1;</pre>
<pre>          key_full_sel_o = dec_key_gen_d ? KEY_FULL_ENC_INIT :</pre>
<pre>                     (mode_i == AES_ENC) ? KEY_FULL_ENC_INIT :</pre>
<pre>                                           KEY_FULL_DEC_INIT;</pre>
<pre>          key_full_we_o  = 1'b1;</pre>
<pre>          round_d      = '0;</pre>
<pre>          num_rounds_d = (key_len_i == AES_128) ? 4'd10 :</pre>
<pre>                         (key_len_i == AES_192) ? 4'd12 :</pre>
<pre>                                                  4'd14;</pre>
<pre>          idle_o      = 1'b0;</pre>
<pre>          idle_we_o   = 1'b1;</pre>
<pre>          start_we_o  = 1'b1;</pre>
<pre>          aes_ctrl_ns = INIT;</pre>
<pre>        end else if (key_clear_i || data_in_clear_i || data_out_clear_i) begin</pre>
<pre>          idle_o      = 1'b0;</pre>
<pre>          idle_we_o   = 1'b1;</pre>
<pre>          aes_ctrl_ns = CLEAR;</pre>
<pre>        key_init_we_o = idle_o ? key_init_qe_i : 8'h00;</pre>
<pre>      INIT: begin</pre>
<pre>        state_we_o   = ~dec_key_gen_q;</pre>
<pre>        add_rk_sel_o = ADD_RK_INIT;</pre>
<pre>        key_words_sel_o = dec_key_gen_q                 ? KEY_WORDS_ZERO :</pre>
<pre>            (key_len_i == AES_128)                      ? KEY_WORDS_0123 :</pre>
<pre>            (key_len_i == AES_192 && mode_i == AES_ENC) ? KEY_WORDS_0123 :</pre>
<pre>            (key_len_i == AES_192 && mode_i == AES_DEC) ? KEY_WORDS_2345 :</pre>
<pre>            (key_len_i == AES_256 && mode_i == AES_ENC) ? KEY_WORDS_0123 :</pre>
<pre>            (key_len_i == AES_256 && mode_i == AES_DEC) ? KEY_WORDS_4567 : KEY_WORDS_ZERO;</pre>
<pre>        if (key_len_i != AES_256) begin</pre>
<pre>          key_expand_step_o = 1'b1;</pre>
<pre>          key_full_we_o     = 1'b1;</pre>
<pre>        data_in_load = ~dec_key_gen_q;</pre>
<pre>        dec_key_gen  =  dec_key_gen_q;</pre>
<pre>        aes_ctrl_ns = ROUND;</pre>
<pre>      ROUND: begin</pre>
<pre>        state_we_o = ~dec_key_gen_q;</pre>
<pre>        key_words_sel_o = dec_key_gen_q                 ? KEY_WORDS_ZERO :</pre>
<pre>            (key_len_i == AES_128)                      ? KEY_WORDS_0123 :</pre>
<pre>            (key_len_i == AES_192 && mode_i == AES_ENC) ? KEY_WORDS_2345 :</pre>
<pre>            (key_len_i == AES_192 && mode_i == AES_DEC) ? KEY_WORDS_0123 :</pre>
<pre>            (key_len_i == AES_256 && mode_i == AES_ENC) ? KEY_WORDS_4567 :</pre>
<pre>            (key_len_i == AES_256 && mode_i == AES_DEC) ? KEY_WORDS_0123 : KEY_WORDS_ZERO;</pre>
<pre>        key_expand_step_o = 1'b1;</pre>
<pre>        key_full_we_o     = 1'b1;</pre>
<pre>        round_key_sel_o = (mode_i == AES_ENC) ? ROUND_KEY_DIRECT : ROUND_KEY_MIXED;</pre>
<pre>        round_d = round_q+1;</pre>
<pre>        if (round_q == num_rounds_regular) begin</pre>
<pre>          if (dec_key_gen_q) begin</pre>
<pre>            key_dec_we_o  = 1'b1;</pre>
<pre>            dec_key_gen_d = 1'b0;</pre>
<pre>            aes_ctrl_ns   = IDLE;</pre>
<pre>          end else begin</pre>
<pre>            aes_ctrl_ns   = FINISH;</pre>
<pre>      FINISH: begin</pre>
<pre>        key_words_sel_o = dec_key_gen_q                 ? KEY_WORDS_ZERO :</pre>
<pre>            (key_len_i == AES_128)                      ? KEY_WORDS_0123 :</pre>
<pre>            (key_len_i == AES_192 && mode_i == AES_ENC) ? KEY_WORDS_2345 :</pre>
<pre>            (key_len_i == AES_192 && mode_i == AES_DEC) ? KEY_WORDS_0123 :</pre>
<pre>            (key_len_i == AES_256 && mode_i == AES_ENC) ? KEY_WORDS_4567 :</pre>
<pre>            (key_len_i == AES_256 && mode_i == AES_DEC) ? KEY_WORDS_0123 : KEY_WORDS_ZERO;</pre>
<pre>        add_rk_sel_o = ADD_RK_FINAL;</pre>
<pre>        if (!finish) begin</pre>
<pre>          stall_o       = 1'b1;</pre>
<pre>          stall_we_o    = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          stall_o       = 1'b0;</pre>
<pre>          stall_we_o    = 1'b1;</pre>
<pre>          data_out_we_o = 1'b1;</pre>
<pre>          aes_ctrl_ns   = IDLE;</pre>
<pre>          state_we_o    = 1'b1;</pre>
<pre>          state_sel_o   = STATE_CLEAR;</pre>
<pre>      CLEAR: begin</pre>
<pre>        if (key_clear_i) begin</pre>
<pre>          key_init_sel_o = KEY_INIT_CLEAR;</pre>
<pre>          key_init_we_o  = 8'hFF;</pre>
<pre>          key_full_sel_o = KEY_FULL_CLEAR;</pre>
<pre>          key_full_we_o  = 1'b1;</pre>
<pre>          key_dec_sel_o  = KEY_DEC_CLEAR;</pre>
<pre>          key_dec_we_o   = 1'b1;</pre>
<pre>          key_clear_we_o = 1'b1;</pre>
<pre>        if (data_in_clear_i) begin</pre>
<pre>          data_in_we_o       = 1'b1;</pre>
<pre>          data_in_clear_we_o = 1'b1;</pre>
<pre>        if (data_out_clear_i) begin</pre>
<pre>          add_rk_sel_o        = ADD_RK_INIT;</pre>
<pre>          key_words_sel_o     = KEY_WORDS_ZERO;</pre>
<pre>          round_key_sel_o     = ROUND_KEY_DIRECT;</pre>
<pre>          data_out_we_o       = 1'b1;</pre>
<pre>          data_out_clear_we_o = 1'b1;</pre>
<pre>        aes_ctrl_ns = IDLE;</pre>
<pre>      default: aes_ctrl_ns = IDLE;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : reg_fsm</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      aes_ctrl_cs   <= IDLE;</pre>
<pre>      round_q       <= '0;</pre>
<pre>      num_rounds_q  <= '0;</pre>
<pre>      dec_key_gen_q <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      aes_ctrl_cs   <= aes_ctrl_ns;</pre>
<pre>      round_q       <= round_d;</pre>
<pre>      num_rounds_q  <= num_rounds_d;</pre>
<pre>      dec_key_gen_q <= dec_key_gen_d;</pre>
<pre>  assign num_rounds_regular = num_rounds_q - 4'd2;</pre>
<pre>  assign key_init_clear = (key_init_sel_o == KEY_INIT_CLEAR) & (&key_init_we_o);</pre>
<pre>  assign key_init_new_d = (dec_key_gen | key_init_clear) ? '0 : (key_init_new_q | key_init_qe_i);</pre>
<pre>  assign key_init_new   = &key_init_new_d;</pre>
<pre>  assign data_in_new_d = (data_in_load | data_in_we_o) ? '0 : (data_in_new_q | data_in_qe_i);</pre>
<pre>  assign data_in_new   = &data_in_new_d;</pre>
<pre>  assign data_out_read_d = data_out_we_o ? '0 : data_out_read_q | data_out_re_i;</pre>
<pre>  assign data_out_read   = &data_out_read_d;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : reg_edge_detection</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      key_init_new_q  <= '0;</pre>
<pre>      data_in_new_q   <= '0;</pre>
<pre>      data_out_read_q <= '0;</pre>
<pre>    end else begin</pre>
<pre>      key_init_new_q  <= key_init_new_d;</pre>
<pre>      data_in_new_q   <= data_in_new_d;</pre>
<pre>      data_out_read_q <= data_out_read_d;</pre>
<pre>  assign output_valid_o    = data_out_we_o & ~data_out_clear_we_o;</pre>
<pre>  assign output_valid_we_o = data_out_we_o | data_out_read | data_out_clear_we_o;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : reg_output_valid</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      output_valid_q <= '0;</pre>
<pre>    end else if (output_valid_we_o) begin</pre>
<pre>      output_valid_q <= output_valid_o;</pre>
<pre>  assign input_ready_o     = ~data_in_new;</pre>
<pre>  assign input_ready_we_o  =  data_in_new | data_in_load | data_in_we_o;</pre>
<pre>  assign key_expand_mode_o  = (dec_key_gen_d || dec_key_gen_q) ? AES_ENC : mode_i;</pre>
<pre>  assign key_expand_round_o = round_d;</pre>
<pre>  assign start_o             = 1'b0;</pre>
<pre>  assign key_clear_o         = 1'b0;</pre>
<pre>  assign data_in_clear_o     = 1'b0;</pre>
<pre>  assign data_out_clear_o    = 1'b0;</pre>
<h3>hw/ip/aes/rtl/aes_pkg.sv</h3>
<pre>package aes_pkg;</pre>
<pre>typedef enum logic {</pre>
<pre>  AES_ENC = 1'b0,</pre>
<pre>  AES_DEC = 1'b1</pre>
<pre>} mode_e;</pre>
<pre>typedef enum logic [2:0] {</pre>
<pre>  AES_128 = 3'b001,</pre>
<pre>  AES_192 = 3'b010,</pre>
<pre>  AES_256 = 3'b100</pre>
<pre>} key_len_e;</pre>
<pre>typedef enum logic [1:0] {</pre>
<pre>  STATE_INIT,</pre>
<pre>  STATE_ROUND,</pre>
<pre>  STATE_CLEAR</pre>
<pre>} state_sel_e;</pre>
<pre>typedef enum logic [1:0] {</pre>
<pre>  ADD_RK_INIT,</pre>
<pre>  ADD_RK_ROUND,</pre>
<pre>  ADD_RK_FINAL</pre>
<pre>} add_rk_sel_e;</pre>
<pre>typedef enum logic {</pre>
<pre>  KEY_INIT_INPUT,</pre>
<pre>  KEY_INIT_CLEAR</pre>
<pre>} key_init_sel_e;</pre>
<pre>typedef enum logic [1:0] {</pre>
<pre>  KEY_FULL_ENC_INIT,</pre>
<pre>  KEY_FULL_DEC_INIT,</pre>
<pre>  KEY_FULL_ROUND,</pre>
<pre>  KEY_FULL_CLEAR</pre>
<pre>} key_full_sel_e;</pre>
<pre>typedef enum logic {</pre>
<pre>  KEY_DEC_EXPAND,</pre>
<pre>  KEY_DEC_CLEAR</pre>
<pre>} key_dec_sel_e;</pre>
<pre>typedef enum logic [1:0] {</pre>
<pre>  KEY_WORDS_0123,</pre>
<pre>  KEY_WORDS_2345,</pre>
<pre>  KEY_WORDS_4567,</pre>
<pre>  KEY_WORDS_ZERO</pre>
<pre>} key_words_sel_e;</pre>
<pre>typedef enum logic {</pre>
<pre>  ROUND_KEY_DIRECT,</pre>
<pre>  ROUND_KEY_MIXED</pre>
<pre>} round_key_sel_e;</pre>
<pre>function automatic logic [7:0] aes_mul2(input logic [7:0] in);</pre>
<pre>  aes_mul2[7] = in[6];</pre>
<pre>  aes_mul2[6] = in[5];</pre>
<pre>  aes_mul2[5] = in[4];</pre>
<pre>  aes_mul2[4] = in[3] ^ in[7];</pre>
<pre>  aes_mul2[3] = in[2] ^ in[7];</pre>
<pre>  aes_mul2[2] = in[1];</pre>
<pre>  aes_mul2[1] = in[0] ^ in[7];</pre>
<pre>  aes_mul2[0] = in[7];</pre>
<pre>function automatic logic [7:0] aes_mul4(input logic [7:0] in);</pre>
<pre>  aes_mul4 = aes_mul2(aes_mul2(in));</pre>
<pre>function automatic logic [7:0] aes_div2(input logic [7:0] in);</pre>
<pre>  aes_div2[7] = in[0];</pre>
<pre>  aes_div2[6] = in[7];</pre>
<pre>  aes_div2[5] = in[6];</pre>
<pre>  aes_div2[4] = in[5];</pre>
<pre>  aes_div2[3] = in[4] ^ in[0];</pre>
<pre>  aes_div2[2] = in[3] ^ in[0];</pre>
<pre>  aes_div2[1] = in[2];</pre>
<pre>  aes_div2[0] = in[1] ^ in[0];</pre>
<pre>function automatic logic [31:0] aes_circ_byte_shift(input logic [31:0] in, integer shift);</pre>
<pre>  integer s = shift % 4;</pre>
<pre>  aes_circ_byte_shift = {in[8*((7-s)%4) +: 8], in[8*((6-s)%4) +: 8],</pre>
<pre>                         in[8*((5-s)%4) +: 8], in[8*((4-s)%4) +: 8]};</pre>
<pre>function automatic logic [3:0][3:0][7:0] aes_transpose(input logic [3:0][3:0][7:0] in);</pre>
<pre>  logic [3:0][3:0][7:0] transpose;</pre>
<pre>  transpose = '0;</pre>
<pre>  for (int j=0; j<4; j++) begin</pre>
<pre>    for (int i=0; i<4; i++) begin</pre>
<pre>      transpose[i][j] = in[j][i];</pre>
<pre>  return transpose;</pre>
<pre>function automatic logic [3:0][7:0] aes_col_get(input logic [3:0][3:0][7:0] in, int idx);</pre>
<pre>  for (int i=0; i<4; i++) begin</pre>
<pre>    aes_col_get[i] = in[i][idx];</pre>
<pre>function automatic logic [7:0] aes_mvm(</pre>
<pre>  input logic [7:0] vec_b,</pre>
<pre>  input logic [7:0] mat_a [8]</pre>
<pre>  logic [7:0] vec_c;</pre>
<pre>  vec_c = '0;</pre>
<pre>  for (int i=0; i<8; i++) begin</pre>
<pre>    for (int j=0; j<8; j++) begin</pre>
<pre>      vec_c[i] = vec_c[i] ^ (mat_a[j][i] & vec_b[7-j]);</pre>
<pre>  return vec_c;</pre>
<h3>hw/ip/prim_generic/rtl/prim_generic_ram_1p.sv</h3>
<pre>module prim_generic_ram_1p #(</pre>
<pre>  parameter  int Width           = 32, // bit</pre>
<pre>  parameter  int Depth           = 128,</pre>
<pre>  parameter  int DataBitsPerMask = 1, // Number of data bits per bit of write mask</pre>
<pre>  localparam int Aw              = $clog2(Depth)  // derived parameter</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,       // Memory content reset</pre>
<pre>  input                    req_i,</pre>
<pre>  input                    write_i,</pre>
<pre>  input        [Aw-1:0]    addr_i,</pre>
<pre>  input        [Width-1:0] wdata_i,</pre>
<pre>  input        [Width-1:0] wmask_i,</pre>
<pre>  output logic             rvalid_o,</pre>
<pre>  output logic [Width-1:0] rdata_o</pre>
<pre>  localparam int MaskWidth = Width / DataBitsPerMask;</pre>
<pre>  logic [Width-1:0] mem [Depth];</pre>
<pre>  logic [MaskWidth-1:0] wmask;</pre>
<pre>  always_comb begin</pre>
<pre>    for (int i=0; i < MaskWidth; i = i + 1) begin : create_wmask</pre>
<pre>      wmask[i] = &wmask_i[i*DataBitsPerMask +: DataBitsPerMask];</pre>
<pre>  always @(posedge clk_i) begin</pre>
<pre>    if (req_i) begin</pre>
<pre>      if (write_i) begin</pre>
<pre>        for (int i=0; i < MaskWidth; i = i + 1) begin</pre>
<pre>          if (wmask[i]) begin</pre>
<pre>            mem[addr_i][i*DataBitsPerMask +: DataBitsPerMask] <=</pre>
<pre>              wdata_i[i*DataBitsPerMask +: DataBitsPerMask];</pre>
<pre>      end else begin</pre>
<pre>        rdata_o <= mem[addr_i];</pre>
<pre>  always_ff @(posedge clk_i, negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rvalid_o <= '0;</pre>
<pre>    end else begin</pre>
<pre>      rvalid_o <= req_i & ~write_i;</pre>
<h3>hw/ip/hmac/rtl/hmac.sv</h3>
<pre>module hmac</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output logic intr_hmac_done_o,</pre>
<pre>  output logic intr_fifo_full_o,</pre>
<pre>  output logic intr_hmac_err_o,</pre>
<pre>  input  alert_rx_t [NumAlerts-1:0] alert_rx_i,</pre>
<pre>  output alert_tx_t [NumAlerts-1:0] alert_tx_o</pre>
<pre>  hmac_reg2hw_t reg2hw;</pre>
<pre>  hmac_hw2reg_t hw2reg;</pre>
<pre>  tlul_pkg::tl_h2d_t  tl_win_h2d[1];</pre>
<pre>  tlul_pkg::tl_d2h_t  tl_win_d2h[1];</pre>
<pre>  logic [255:0] secret_key;</pre>
<pre>  logic        wipe_secret;</pre>
<pre>  logic [31:0] wipe_v;</pre>
<pre>  logic        fifo_rvalid;</pre>
<pre>  logic        fifo_rready;</pre>
<pre>  sha_fifo_t   fifo_rdata;</pre>
<pre>  logic        fifo_wvalid, fifo_wready;</pre>
<pre>  sha_fifo_t   fifo_wdata;</pre>
<pre>  logic        fifo_full;</pre>
<pre>  logic        fifo_empty;</pre>
<pre>  logic [4:0]  fifo_depth;</pre>
<pre>  logic        msg_fifo_req;</pre>
<pre>  logic        msg_fifo_gnt;</pre>
<pre>  logic        msg_fifo_we;</pre>
<pre>  logic [8:0]  msg_fifo_addr;   // NOT_READ</pre>
<pre>  logic [31:0] msg_fifo_wdata;</pre>
<pre>  logic [31:0] msg_fifo_wmask;</pre>
<pre>  logic [31:0] msg_fifo_rdata;</pre>
<pre>  logic        msg_fifo_rvalid;</pre>
<pre>  logic [1:0]  msg_fifo_rerror;</pre>
<pre>  logic [31:0] msg_fifo_wdata_endian;</pre>
<pre>  logic [31:0] msg_fifo_wmask_endian;</pre>
<pre>  logic        packer_ready;</pre>
<pre>  logic        packer_flush_done;</pre>
<pre>  logic        reg_fifo_wvalid;</pre>
<pre>  sha_word_t   reg_fifo_wdata;</pre>
<pre>  sha_word_t   reg_fifo_wmask;</pre>
<pre>  logic        hmac_fifo_wsel;</pre>
<pre>  logic        hmac_fifo_wvalid;</pre>
<pre>  logic [2:0]  hmac_fifo_wdata_sel;</pre>
<pre>  logic        shaf_rvalid;</pre>
<pre>  sha_fifo_t   shaf_rdata;</pre>
<pre>  logic        shaf_rready;</pre>
<pre>  logic        sha_en;</pre>
<pre>  logic        hmac_en;</pre>
<pre>  logic        endian_swap;</pre>
<pre>  logic        digest_swap;</pre>
<pre>  logic        reg_hash_start;</pre>
<pre>  logic        sha_hash_start;</pre>
<pre>  logic        hash_start;      // Valid hash_start_signal</pre>
<pre>  logic        reg_hash_process;</pre>
<pre>  logic        sha_hash_process;</pre>
<pre>  logic        reg_hash_done;</pre>
<pre>  logic        sha_hash_done;</pre>
<pre>  logic [63:0] message_length;</pre>
<pre>  logic [63:0] sha_message_length;</pre>
<pre>  err_code_e   err_code;</pre>
<pre>  logic        err_valid;</pre>
<pre>  sha_word_t [7:0] digest;</pre>
<pre>  hmac_reg2hw_cfg_reg_t cfg_reg;</pre>
<pre>  logic                 cfg_block;  // Prevent changing config</pre>
<pre>  assign hw2reg.status.fifo_full.d  = fifo_full;</pre>
<pre>  assign hw2reg.status.fifo_empty.d = fifo_empty;</pre>
<pre>  assign hw2reg.status.fifo_depth.d = fifo_depth;</pre>
<pre>  assign wipe_secret = reg2hw.wipe_secret.qe;</pre>
<pre>  assign wipe_v      = reg2hw.wipe_secret.q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      secret_key <= '0;</pre>
<pre>    end else if (wipe_secret) begin</pre>
<pre>      secret_key <= secret_key ^ {8{wipe_v}};</pre>
<pre>    end else if (!cfg_block) begin</pre>
<pre>      for (int i = 0; i < 8; i++) begin</pre>
<pre>        if (reg2hw.key[7-i].qe) begin</pre>
<pre>          secret_key[32*i+:32] <= reg2hw.key[7-i].q;</pre>
<pre>  for (genvar i = 0; i < 8; i++) begin : gen_key_digest</pre>
<pre>    assign hw2reg.key[7-i].d      = '0;</pre>
<pre>    assign hw2reg.digest[i].d = conv_endian(digest[i], digest_swap);</pre>
<pre>  logic [3:0] unused_cfg_qe;</pre>
<pre>  assign unused_cfg_qe = {cfg_reg.sha_en.qe,      cfg_reg.hmac_en.qe,</pre>
<pre>                          cfg_reg.endian_swap.qe, cfg_reg.digest_swap.qe};</pre>
<pre>  assign sha_en      = cfg_reg.sha_en.q;</pre>
<pre>  assign hmac_en     = cfg_reg.hmac_en.q;</pre>
<pre>  assign endian_swap = cfg_reg.endian_swap.q;</pre>
<pre>  assign digest_swap = cfg_reg.digest_swap.q;</pre>
<pre>  assign hw2reg.cfg.hmac_en.d     = cfg_reg.hmac_en.q;</pre>
<pre>  assign hw2reg.cfg.sha_en.d      = cfg_reg.sha_en.q;</pre>
<pre>  assign hw2reg.cfg.endian_swap.d = cfg_reg.endian_swap.q;</pre>
<pre>  assign hw2reg.cfg.digest_swap.d = cfg_reg.digest_swap.q;</pre>
<pre>  assign reg_hash_start   = reg2hw.cmd.hash_start.qe   & reg2hw.cmd.hash_start.q;</pre>
<pre>  assign reg_hash_process = reg2hw.cmd.hash_process.qe & reg2hw.cmd.hash_process.q;</pre>
<pre>  assign hw2reg.err_code.de = err_valid;</pre>
<pre>  assign hw2reg.err_code.d  = err_code;</pre>
<pre>  assign hash_start = reg_hash_start & sha_en;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      cfg_block <= '0;</pre>
<pre>    end else if (hash_start) begin</pre>
<pre>      cfg_block <= 1'b 1;</pre>
<pre>    end else if (reg_hash_done) begin</pre>
<pre>      cfg_block <= 1'b 0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      cfg_reg <= '{endian_swap: '{q: 1'b1, qe: 1'b0}, default:'0};</pre>
<pre>    end else if (!cfg_block && reg2hw.cfg.hmac_en.qe) begin</pre>
<pre>      cfg_reg <= reg2hw.cfg ;</pre>
<pre>  logic fifo_full_q;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) fifo_full_q <= 1'b0;</pre>
<pre>    else fifo_full_q <= fifo_full;</pre>
<pre>  logic fifo_full_event;</pre>
<pre>  assign fifo_full_event = fifo_full & !fifo_full_q;</pre>
<pre>  logic [2:0] event_intr;</pre>
<pre>  assign event_intr = {err_valid, fifo_full_event, reg_hash_done};</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_hmac_done (</pre>
<pre>    .event_intr_i           (event_intr[0]),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.hmac_done.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.hmac_done.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.hmac_done.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.hmac_done.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.hmac_done.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.hmac_done.d),</pre>
<pre>    .intr_o                 (intr_hmac_done_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_fifo_full (</pre>
<pre>    .event_intr_i           (event_intr[1]),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.fifo_full.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.fifo_full.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.fifo_full.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.fifo_full.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.fifo_full.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.fifo_full.d),</pre>
<pre>    .intr_o                 (intr_fifo_full_o)</pre>
<pre>  prim_intr_hw #(.Width(1)) intr_hw_hmac_err (</pre>
<pre>    .event_intr_i           (event_intr[2]),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.hmac_err.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.hmac_err.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.hmac_err.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.hmac_err.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.hmac_err.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.hmac_err.d),</pre>
<pre>    .intr_o                 (intr_hmac_err_o)</pre>
<pre>  assign msg_fifo_rvalid = msg_fifo_req & ~msg_fifo_we;</pre>
<pre>  assign msg_fifo_rdata  = '1;  // Return all F</pre>
<pre>  assign msg_fifo_rerror = '1;  // Return error for read access</pre>
<pre>  assign msg_fifo_gnt    = msg_fifo_req & ~hmac_fifo_wsel & packer_ready;</pre>
<pre>  sha_fifo_t reg_fifo_wentry;</pre>
<pre>  assign reg_fifo_wentry.data = conv_endian(reg_fifo_wdata, 1'b1); // always convert</pre>
<pre>  assign reg_fifo_wentry.mask = {reg_fifo_wmask[0],  reg_fifo_wmask[8],</pre>
<pre>                                 reg_fifo_wmask[16], reg_fifo_wmask[24]};</pre>
<pre>  assign fifo_full   = ~fifo_wready;</pre>
<pre>  assign fifo_empty  = ~fifo_rvalid;</pre>
<pre>  assign fifo_wvalid = (hmac_fifo_wsel && fifo_wready) ? hmac_fifo_wvalid : reg_fifo_wvalid;</pre>
<pre>  assign fifo_wdata  = (hmac_fifo_wsel) ? '{data: digest[hmac_fifo_wdata_sel], mask: '1}</pre>
<pre>                                       : reg_fifo_wentry;</pre>
<pre>  prim_fifo_sync #(</pre>
<pre>    .Width ($bits(sha_fifo_t)),</pre>
<pre>    .Pass  (1'b0),</pre>
<pre>    .Depth (MsgFifoDepth)</pre>
<pre style="background-color: #FF0000;">  ) u_msg_fifo (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .clr_i  (1'b0),</pre>
<pre>    .wvalid (fifo_wvalid & sha_en),</pre>
<pre>    .wready (fifo_wready),</pre>
<pre>    .wdata  (fifo_wdata),</pre>
<pre>    .depth  (fifo_depth),</pre>
<pre>    .rvalid (fifo_rvalid),</pre>
<pre>    .rready (fifo_rready),</pre>
<pre>    .rdata  (fifo_rdata)</pre>
<pre>  tlul_adapter_sram #(</pre>
<pre>    .SramAw (9),</pre>
<pre>    .SramDw (32),</pre>
<pre>    .Outstanding (1),</pre>
<pre>    .ByteAccess  (1),</pre>
<pre>    .ErrOnRead   (1)</pre>
<pre style="background-color: #FF0000;">  ) u_tlul_adapter (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i   (tl_win_h2d[0]),</pre>
<pre>    .tl_o   (tl_win_d2h[0]),</pre>
<pre>    .req_o    (msg_fifo_req   ),</pre>
<pre>    .gnt_i    (msg_fifo_gnt   ),</pre>
<pre>    .we_o     (msg_fifo_we    ),</pre>
<pre>    .addr_o   (msg_fifo_addr  ), // Doesn't care the address other than sub-word</pre>
<pre>    .wdata_o  (msg_fifo_wdata ),</pre>
<pre>    .wmask_o  (msg_fifo_wmask ),</pre>
<pre>    .rdata_i  (msg_fifo_rdata ),</pre>
<pre>    .rvalid_i (msg_fifo_rvalid),</pre>
<pre>    .rerror_i (msg_fifo_rerror)</pre>
<pre>  logic msg_write;</pre>
<pre>  assign msg_write = msg_fifo_req & msg_fifo_we & ~hmac_fifo_wsel;</pre>
<pre>  logic [$clog2(32+1)-1:0] wmask_ones;</pre>
<pre>  always_comb begin</pre>
<pre>    wmask_ones = '0;</pre>
<pre>    for (int i = 0 ; i < 32 ; i++) begin</pre>
<pre>      wmask_ones = wmask_ones + reg_fifo_wmask[i];</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      message_length <= '0;</pre>
<pre>    end else if (hash_start) begin</pre>
<pre>      message_length <= '0;</pre>
<pre>    end else if (reg_fifo_wvalid && fifo_wready && !hmac_fifo_wsel) begin</pre>
<pre>      message_length <= message_length + 64'(wmask_ones);</pre>
<pre>  assign hw2reg.msg_length_upper.de = 1'b1;</pre>
<pre>  assign hw2reg.msg_length_upper.d = message_length[63:32];</pre>
<pre>  assign hw2reg.msg_length_lower.de = 1'b1;</pre>
<pre>  assign hw2reg.msg_length_lower.d = message_length[31:0];</pre>
<pre>  assign msg_fifo_wdata_endian = conv_endian(msg_fifo_wdata, ~endian_swap);</pre>
<pre>  assign msg_fifo_wmask_endian = conv_endian(msg_fifo_wmask, ~endian_swap);</pre>
<pre>  prim_packer #(</pre>
<pre>    .InW      (32),</pre>
<pre>    .OutW     (32)</pre>
<pre style="background-color: #FF0000;">  ) u_packer (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .valid_i      (msg_write & sha_en),</pre>
<pre>    .data_i       (msg_fifo_wdata_endian),</pre>
<pre>    .mask_i       (msg_fifo_wmask_endian),</pre>
<pre>    .ready_o      (packer_ready),</pre>
<pre>    .valid_o      (reg_fifo_wvalid),</pre>
<pre>    .data_o       (reg_fifo_wdata),</pre>
<pre>    .mask_o       (reg_fifo_wmask),</pre>
<pre>    .ready_i      (fifo_wready & ~hmac_fifo_wsel),</pre>
<pre>    .flush_i      (reg_hash_process),</pre>
<pre>    .flush_done_o (packer_flush_done) // ignore at this moment</pre>
<pre>  hmac_core u_hmac (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .secret_key,</pre>
<pre>    .wipe_secret,</pre>
<pre>    .wipe_v,</pre>
<pre>    .hmac_en,</pre>
<pre>    .reg_hash_start   (hash_start),</pre>
<pre>    .reg_hash_process (packer_flush_done), // Trigger after all msg written</pre>
<pre>    .hash_done      (reg_hash_done),</pre>
<pre>    .sha_hash_start,</pre>
<pre>    .sha_hash_process,</pre>
<pre>    .sha_hash_done,</pre>
<pre>    .sha_rvalid     (shaf_rvalid),</pre>
<pre>    .sha_rdata      (shaf_rdata),</pre>
<pre>    .sha_rready     (shaf_rready),</pre>
<pre>    .fifo_rvalid,</pre>
<pre>    .fifo_rdata,</pre>
<pre>    .fifo_rready,</pre>
<pre>    .fifo_wsel      (hmac_fifo_wsel),</pre>
<pre>    .fifo_wvalid    (hmac_fifo_wvalid),</pre>
<pre>    .fifo_wdata_sel (hmac_fifo_wdata_sel),</pre>
<pre>    .fifo_wready,</pre>
<pre>    .message_length,</pre>
<pre>    .sha_message_length</pre>
<pre>  sha2 u_sha2 (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .wipe_secret,</pre>
<pre>    .wipe_v,</pre>
<pre>    .fifo_rvalid      (shaf_rvalid),</pre>
<pre>    .fifo_rdata       (shaf_rdata),</pre>
<pre>    .fifo_rready      (shaf_rready),</pre>
<pre>    .sha_en,</pre>
<pre>    .hash_start       (sha_hash_start),</pre>
<pre>    .hash_process     (sha_hash_process),</pre>
<pre>    .hash_done        (sha_hash_done),</pre>
<pre>    .message_length   (sha_message_length),</pre>
<pre>    .digest</pre>
<pre>  hmac_reg_top u_reg (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .tl_o,</pre>
<pre>    .tl_win_o   (tl_win_h2d),</pre>
<pre>    .tl_win_i   (tl_win_d2h),</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .devmode_i  (1'b1)</pre>
<pre>  logic msg_push_sha_disabled, hash_start_sha_disabled, update_seckey_inprocess;</pre>
<pre>  assign msg_push_sha_disabled = msg_write & ~sha_en;</pre>
<pre>  assign hash_start_sha_disabled = reg_hash_start & ~sha_en;</pre>
<pre>  always_comb begin</pre>
<pre>    update_seckey_inprocess = 1'b0;</pre>
<pre>    if (cfg_block) begin</pre>
<pre>      for (int i = 0 ; i < 8 ; i++) begin</pre>
<pre>        if (reg2hw.key[i].qe) begin</pre>
<pre>          update_seckey_inprocess = update_seckey_inprocess | 1'b1;</pre>
<pre>    end else begin</pre>
<pre>      update_seckey_inprocess = 1'b0;</pre>
<pre>  assign err_valid = ~reg2hw.intr_state.hmac_err.q &</pre>
<pre>                   ( msg_push_sha_disabled | hash_start_sha_disabled</pre>
<pre>                   | update_seckey_inprocess);</pre>
<pre>  always_comb begin</pre>
<pre>    err_code = NoError;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      msg_push_sha_disabled: begin</pre>
<pre>        err_code = SwPushMsgWhenShaDisabled;</pre>
<pre>      hash_start_sha_disabled: begin</pre>
<pre>        err_code = SwHashStartWhenShaDisabled;</pre>
<pre>      update_seckey_inprocess: begin</pre>
<pre>        err_code = SwUpdateSecretKeyInProcess;</pre>
<pre>      default: begin</pre>
<pre>        err_code = NoError;</pre>
<pre>  logic [NumAlerts-1:0] alerts;</pre>
<pre>  assign alerts = {msg_push_sha_disabled};</pre>
<pre>  for (genvar j = 0; j < hmac_pkg::NumAlerts; j++) begin : gen_alert_tx</pre>
<pre>    prim_alert_sender #(</pre>
<pre>      .AsyncOn(hmac_pkg::AlertAsyncOn[j])</pre>
<pre style="background-color: #FF0000;">    ) i_prim_alert_sender (</pre>
<pre>      .clk_i      ( clk_i         ),</pre>
<pre>      .rst_ni     ( rst_ni        ),</pre>
<pre>      .alert_i    ( alerts[j]     ),</pre>
<pre>      .alert_rx_i ( alert_rx_i[j] ),</pre>
<pre>      .alert_tx_o ( alert_tx_o[j] )</pre>
<pre style="background-color: #FF0000;">  end : gen_alert_tx</pre>
<h3>hw/ip/hmac/rtl/hmac_reg_pkg.sv</h3>
<pre>package hmac_reg_pkg;</pre>
<pre>  parameter int NumWords = 8;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } hmac_done;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } fifo_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } hmac_err;</pre>
<pre style="background-color: #FF0000;">  } hmac_reg2hw_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } hmac_done;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } fifo_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } hmac_err;</pre>
<pre style="background-color: #FF0000;">  } hmac_reg2hw_intr_enable_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } hmac_done;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } fifo_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } hmac_err;</pre>
<pre style="background-color: #FF0000;">  } hmac_reg2hw_intr_test_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } hmac_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } sha_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } endian_swap;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } digest_swap;</pre>
<pre style="background-color: #FF0000;">  } hmac_reg2hw_cfg_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } hash_start;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } hash_process;</pre>
<pre style="background-color: #FF0000;">  } hmac_reg2hw_cmd_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } hmac_reg2hw_wipe_secret_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } hmac_reg2hw_key_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } hmac_done;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } fifo_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } hmac_err;</pre>
<pre style="background-color: #FF0000;">  } hmac_hw2reg_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } hmac_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } sha_en;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } endian_swap;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } digest_swap;</pre>
<pre style="background-color: #FF0000;">  } hmac_hw2reg_cfg_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } fifo_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } fifo_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic [4:0]  d;</pre>
<pre>    } fifo_depth;</pre>
<pre style="background-color: #FF0000;">  } hmac_hw2reg_status_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } hmac_hw2reg_err_code_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre style="background-color: #FF0000;">  } hmac_hw2reg_key_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre style="background-color: #FF0000;">  } hmac_hw2reg_digest_mreg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } hmac_hw2reg_msg_length_lower_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } hmac_hw2reg_msg_length_upper_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    hmac_reg2hw_intr_state_reg_t intr_state; // [320:318]</pre>
<pre>    hmac_reg2hw_intr_enable_reg_t intr_enable; // [317:315]</pre>
<pre>    hmac_reg2hw_intr_test_reg_t intr_test; // [314:309]</pre>
<pre>    hmac_reg2hw_cfg_reg_t cfg; // [308:301]</pre>
<pre>    hmac_reg2hw_cmd_reg_t cmd; // [300:297]</pre>
<pre>    hmac_reg2hw_wipe_secret_reg_t wipe_secret; // [296:264]</pre>
<pre>    hmac_reg2hw_key_mreg_t [7:0] key; // [263:0]</pre>
<pre style="background-color: #FF0000;">  } hmac_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    hmac_hw2reg_intr_state_reg_t intr_state; // [627:625]</pre>
<pre>    hmac_hw2reg_cfg_reg_t cfg; // [624:617]</pre>
<pre>    hmac_hw2reg_status_reg_t status; // [616:617]</pre>
<pre>    hmac_hw2reg_err_code_reg_t err_code; // [616:617]</pre>
<pre>    hmac_hw2reg_key_mreg_t [7:0] key; // [616:361]</pre>
<pre>    hmac_hw2reg_digest_mreg_t [7:0] digest; // [360:105]</pre>
<pre>    hmac_hw2reg_msg_length_lower_reg_t msg_length_lower; // [104:105]</pre>
<pre>    hmac_hw2reg_msg_length_upper_reg_t msg_length_upper; // [104:105]</pre>
<pre style="background-color: #FF0000;">  } hmac_hw2reg_t;</pre>
<pre>  parameter logic [11:0] HMAC_INTR_STATE_OFFSET = 12'h 0;</pre>
<pre>  parameter logic [11:0] HMAC_INTR_ENABLE_OFFSET = 12'h 4;</pre>
<pre>  parameter logic [11:0] HMAC_INTR_TEST_OFFSET = 12'h 8;</pre>
<pre>  parameter logic [11:0] HMAC_CFG_OFFSET = 12'h c;</pre>
<pre>  parameter logic [11:0] HMAC_CMD_OFFSET = 12'h 10;</pre>
<pre>  parameter logic [11:0] HMAC_STATUS_OFFSET = 12'h 14;</pre>
<pre>  parameter logic [11:0] HMAC_ERR_CODE_OFFSET = 12'h 18;</pre>
<pre>  parameter logic [11:0] HMAC_WIPE_SECRET_OFFSET = 12'h 1c;</pre>
<pre>  parameter logic [11:0] HMAC_KEY0_OFFSET = 12'h 20;</pre>
<pre>  parameter logic [11:0] HMAC_KEY1_OFFSET = 12'h 24;</pre>
<pre>  parameter logic [11:0] HMAC_KEY2_OFFSET = 12'h 28;</pre>
<pre>  parameter logic [11:0] HMAC_KEY3_OFFSET = 12'h 2c;</pre>
<pre>  parameter logic [11:0] HMAC_KEY4_OFFSET = 12'h 30;</pre>
<pre>  parameter logic [11:0] HMAC_KEY5_OFFSET = 12'h 34;</pre>
<pre>  parameter logic [11:0] HMAC_KEY6_OFFSET = 12'h 38;</pre>
<pre>  parameter logic [11:0] HMAC_KEY7_OFFSET = 12'h 3c;</pre>
<pre>  parameter logic [11:0] HMAC_DIGEST0_OFFSET = 12'h 40;</pre>
<pre>  parameter logic [11:0] HMAC_DIGEST1_OFFSET = 12'h 44;</pre>
<pre>  parameter logic [11:0] HMAC_DIGEST2_OFFSET = 12'h 48;</pre>
<pre>  parameter logic [11:0] HMAC_DIGEST3_OFFSET = 12'h 4c;</pre>
<pre>  parameter logic [11:0] HMAC_DIGEST4_OFFSET = 12'h 50;</pre>
<pre>  parameter logic [11:0] HMAC_DIGEST5_OFFSET = 12'h 54;</pre>
<pre>  parameter logic [11:0] HMAC_DIGEST6_OFFSET = 12'h 58;</pre>
<pre>  parameter logic [11:0] HMAC_DIGEST7_OFFSET = 12'h 5c;</pre>
<pre>  parameter logic [11:0] HMAC_MSG_LENGTH_LOWER_OFFSET = 12'h 60;</pre>
<pre>  parameter logic [11:0] HMAC_MSG_LENGTH_UPPER_OFFSET = 12'h 64;</pre>
<pre>  parameter logic [11:0] HMAC_MSG_FIFO_OFFSET = 12'h 800;</pre>
<pre>  parameter logic [11:0] HMAC_MSG_FIFO_SIZE   = 12'h 800;</pre>
<pre>  typedef enum int {</pre>
<pre>    HMAC_INTR_STATE,</pre>
<pre>    HMAC_INTR_ENABLE,</pre>
<pre>    HMAC_INTR_TEST,</pre>
<pre>    HMAC_CFG,</pre>
<pre>    HMAC_CMD,</pre>
<pre>    HMAC_STATUS,</pre>
<pre>    HMAC_ERR_CODE,</pre>
<pre>    HMAC_WIPE_SECRET,</pre>
<pre>    HMAC_KEY0,</pre>
<pre>    HMAC_KEY1,</pre>
<pre>    HMAC_KEY2,</pre>
<pre>    HMAC_KEY3,</pre>
<pre>    HMAC_KEY4,</pre>
<pre>    HMAC_KEY5,</pre>
<pre>    HMAC_KEY6,</pre>
<pre>    HMAC_KEY7,</pre>
<pre>    HMAC_DIGEST0,</pre>
<pre>    HMAC_DIGEST1,</pre>
<pre>    HMAC_DIGEST2,</pre>
<pre>    HMAC_DIGEST3,</pre>
<pre>    HMAC_DIGEST4,</pre>
<pre>    HMAC_DIGEST5,</pre>
<pre>    HMAC_DIGEST6,</pre>
<pre>    HMAC_DIGEST7,</pre>
<pre>    HMAC_MSG_LENGTH_LOWER,</pre>
<pre>    HMAC_MSG_LENGTH_UPPER</pre>
<pre>  } hmac_id_e;</pre>
<pre>  parameter logic [3:0] HMAC_PERMIT [26] = '{</pre>
<pre>    4'b 0001, // index[ 0] HMAC_INTR_STATE</pre>
<pre>    4'b 0001, // index[ 1] HMAC_INTR_ENABLE</pre>
<pre>    4'b 0001, // index[ 2] HMAC_INTR_TEST</pre>
<pre>    4'b 0001, // index[ 3] HMAC_CFG</pre>
<pre>    4'b 0001, // index[ 4] HMAC_CMD</pre>
<pre>    4'b 0011, // index[ 5] HMAC_STATUS</pre>
<pre>    4'b 1111, // index[ 6] HMAC_ERR_CODE</pre>
<pre>    4'b 1111, // index[ 7] HMAC_WIPE_SECRET</pre>
<pre>    4'b 1111, // index[ 8] HMAC_KEY0</pre>
<pre>    4'b 1111, // index[ 9] HMAC_KEY1</pre>
<pre>    4'b 1111, // index[10] HMAC_KEY2</pre>
<pre>    4'b 1111, // index[11] HMAC_KEY3</pre>
<pre>    4'b 1111, // index[12] HMAC_KEY4</pre>
<pre>    4'b 1111, // index[13] HMAC_KEY5</pre>
<pre>    4'b 1111, // index[14] HMAC_KEY6</pre>
<pre>    4'b 1111, // index[15] HMAC_KEY7</pre>
<pre>    4'b 1111, // index[16] HMAC_DIGEST0</pre>
<pre>    4'b 1111, // index[17] HMAC_DIGEST1</pre>
<pre>    4'b 1111, // index[18] HMAC_DIGEST2</pre>
<pre>    4'b 1111, // index[19] HMAC_DIGEST3</pre>
<pre>    4'b 1111, // index[20] HMAC_DIGEST4</pre>
<pre>    4'b 1111, // index[21] HMAC_DIGEST5</pre>
<pre>    4'b 1111, // index[22] HMAC_DIGEST6</pre>
<pre>    4'b 1111, // index[23] HMAC_DIGEST7</pre>
<pre>    4'b 1111, // index[24] HMAC_MSG_LENGTH_LOWER</pre>
<pre>    4'b 1111  // index[25] HMAC_MSG_LENGTH_UPPER</pre>
<h3>hw/ip/hmac/rtl/hmac_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_win_o  [1],</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_win_i  [1],</pre>
<pre>  output hmac_reg_pkg::hmac_reg2hw_t reg2hw, // Write</pre>
<pre>  input  hmac_reg_pkg::hmac_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam int AW = 12;</pre>
<pre>  localparam int DW = 32;</pre>
<pre>  localparam int DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_socket_h2d [2];</pre>
<pre>  tlul_pkg::tl_d2h_t tl_socket_d2h [2];</pre>
<pre>  logic [1:0] reg_steer;</pre>
<pre>  assign tl_reg_h2d = tl_socket_h2d[1];</pre>
<pre>  assign tl_socket_d2h[1] = tl_reg_d2h;</pre>
<pre>  assign tl_win_o[0] = tl_socket_h2d[0];</pre>
<pre>  assign tl_socket_d2h[0] = tl_win_i[0];</pre>
<pre>  tlul_socket_1n #(</pre>
<pre>    .N          (2),</pre>
<pre>    .HReqPass   (1'b1),</pre>
<pre>    .HRspPass   (1'b1),</pre>
<pre>    .DReqPass   ({2{1'b1}}),</pre>
<pre>    .DRspPass   ({2{1'b1}}),</pre>
<pre>    .HReqDepth  (4'h0),</pre>
<pre>    .HRspDepth  (4'h0),</pre>
<pre>    .DReqDepth  ({2{4'h0}}),</pre>
<pre>    .DRspDepth  ({2{4'h0}})</pre>
<pre style="background-color: #FF0000;">  ) u_socket (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_h_i (tl_i),</pre>
<pre>    .tl_h_o (tl_o),</pre>
<pre>    .tl_d_o (tl_socket_h2d),</pre>
<pre>    .tl_d_i (tl_socket_d2h),</pre>
<pre>    .dev_select (reg_steer)</pre>
<pre>  always_comb begin</pre>
<pre>    reg_steer = 1;       // Default set to register</pre>
<pre>    if (tl_i.a_address[AW-1:0] >= 2048) begin</pre>
<pre>      reg_steer = 0;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic intr_state_hmac_done_qs;</pre>
<pre>  logic intr_state_hmac_done_wd;</pre>
<pre>  logic intr_state_hmac_done_we;</pre>
<pre>  logic intr_state_fifo_full_qs;</pre>
<pre>  logic intr_state_fifo_full_wd;</pre>
<pre>  logic intr_state_fifo_full_we;</pre>
<pre>  logic intr_state_hmac_err_qs;</pre>
<pre>  logic intr_state_hmac_err_wd;</pre>
<pre>  logic intr_state_hmac_err_we;</pre>
<pre>  logic intr_enable_hmac_done_qs;</pre>
<pre>  logic intr_enable_hmac_done_wd;</pre>
<pre>  logic intr_enable_hmac_done_we;</pre>
<pre>  logic intr_enable_fifo_full_qs;</pre>
<pre>  logic intr_enable_fifo_full_wd;</pre>
<pre>  logic intr_enable_fifo_full_we;</pre>
<pre>  logic intr_enable_hmac_err_qs;</pre>
<pre>  logic intr_enable_hmac_err_wd;</pre>
<pre>  logic intr_enable_hmac_err_we;</pre>
<pre>  logic intr_test_hmac_done_wd;</pre>
<pre>  logic intr_test_hmac_done_we;</pre>
<pre>  logic intr_test_fifo_full_wd;</pre>
<pre>  logic intr_test_fifo_full_we;</pre>
<pre>  logic intr_test_hmac_err_wd;</pre>
<pre>  logic intr_test_hmac_err_we;</pre>
<pre>  logic cfg_hmac_en_qs;</pre>
<pre>  logic cfg_hmac_en_wd;</pre>
<pre>  logic cfg_hmac_en_we;</pre>
<pre>  logic cfg_hmac_en_re;</pre>
<pre>  logic cfg_sha_en_qs;</pre>
<pre>  logic cfg_sha_en_wd;</pre>
<pre>  logic cfg_sha_en_we;</pre>
<pre>  logic cfg_sha_en_re;</pre>
<pre>  logic cfg_endian_swap_qs;</pre>
<pre>  logic cfg_endian_swap_wd;</pre>
<pre>  logic cfg_endian_swap_we;</pre>
<pre>  logic cfg_endian_swap_re;</pre>
<pre>  logic cfg_digest_swap_qs;</pre>
<pre>  logic cfg_digest_swap_wd;</pre>
<pre>  logic cfg_digest_swap_we;</pre>
<pre>  logic cfg_digest_swap_re;</pre>
<pre>  logic cmd_hash_start_wd;</pre>
<pre>  logic cmd_hash_start_we;</pre>
<pre>  logic cmd_hash_process_wd;</pre>
<pre>  logic cmd_hash_process_we;</pre>
<pre>  logic status_fifo_empty_qs;</pre>
<pre>  logic status_fifo_empty_re;</pre>
<pre>  logic status_fifo_full_qs;</pre>
<pre>  logic status_fifo_full_re;</pre>
<pre>  logic [4:0] status_fifo_depth_qs;</pre>
<pre>  logic status_fifo_depth_re;</pre>
<pre>  logic [31:0] err_code_qs;</pre>
<pre>  logic [31:0] wipe_secret_wd;</pre>
<pre>  logic wipe_secret_we;</pre>
<pre>  logic [31:0] key0_wd;</pre>
<pre>  logic key0_we;</pre>
<pre>  logic [31:0] key1_wd;</pre>
<pre>  logic key1_we;</pre>
<pre>  logic [31:0] key2_wd;</pre>
<pre>  logic key2_we;</pre>
<pre>  logic [31:0] key3_wd;</pre>
<pre>  logic key3_we;</pre>
<pre>  logic [31:0] key4_wd;</pre>
<pre>  logic key4_we;</pre>
<pre>  logic [31:0] key5_wd;</pre>
<pre>  logic key5_we;</pre>
<pre>  logic [31:0] key6_wd;</pre>
<pre>  logic key6_we;</pre>
<pre>  logic [31:0] key7_wd;</pre>
<pre>  logic key7_we;</pre>
<pre>  logic [31:0] digest0_qs;</pre>
<pre>  logic digest0_re;</pre>
<pre>  logic [31:0] digest1_qs;</pre>
<pre>  logic digest1_re;</pre>
<pre>  logic [31:0] digest2_qs;</pre>
<pre>  logic digest2_re;</pre>
<pre>  logic [31:0] digest3_qs;</pre>
<pre>  logic digest3_re;</pre>
<pre>  logic [31:0] digest4_qs;</pre>
<pre>  logic digest4_re;</pre>
<pre>  logic [31:0] digest5_qs;</pre>
<pre>  logic digest5_re;</pre>
<pre>  logic [31:0] digest6_qs;</pre>
<pre>  logic digest6_re;</pre>
<pre>  logic [31:0] digest7_qs;</pre>
<pre>  logic digest7_re;</pre>
<pre>  logic [31:0] msg_length_lower_qs;</pre>
<pre>  logic [31:0] msg_length_upper_qs;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_hmac_done (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_hmac_done_we),</pre>
<pre>    .wd     (intr_state_hmac_done_wd),</pre>
<pre>    .de     (hw2reg.intr_state.hmac_done.de),</pre>
<pre>    .d      (hw2reg.intr_state.hmac_done.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.hmac_done.q ),</pre>
<pre>    .qs     (intr_state_hmac_done_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_fifo_full (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_fifo_full_we),</pre>
<pre>    .wd     (intr_state_fifo_full_wd),</pre>
<pre>    .de     (hw2reg.intr_state.fifo_full.de),</pre>
<pre>    .d      (hw2reg.intr_state.fifo_full.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.fifo_full.q ),</pre>
<pre>    .qs     (intr_state_fifo_full_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_hmac_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_hmac_err_we),</pre>
<pre>    .wd     (intr_state_hmac_err_wd),</pre>
<pre>    .de     (hw2reg.intr_state.hmac_err.de),</pre>
<pre>    .d      (hw2reg.intr_state.hmac_err.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.hmac_err.q ),</pre>
<pre>    .qs     (intr_state_hmac_err_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_hmac_done (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_hmac_done_we),</pre>
<pre>    .wd     (intr_enable_hmac_done_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.hmac_done.q ),</pre>
<pre>    .qs     (intr_enable_hmac_done_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_fifo_full (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_fifo_full_we),</pre>
<pre>    .wd     (intr_enable_fifo_full_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.fifo_full.q ),</pre>
<pre>    .qs     (intr_enable_fifo_full_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_hmac_err (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_hmac_err_we),</pre>
<pre>    .wd     (intr_enable_hmac_err_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.hmac_err.q ),</pre>
<pre>    .qs     (intr_enable_hmac_err_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_hmac_done (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_hmac_done_we),</pre>
<pre>    .wd     (intr_test_hmac_done_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.hmac_done.qe),</pre>
<pre>    .q      (reg2hw.intr_test.hmac_done.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_fifo_full (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_fifo_full_we),</pre>
<pre>    .wd     (intr_test_fifo_full_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.fifo_full.qe),</pre>
<pre>    .q      (reg2hw.intr_test.fifo_full.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_hmac_err (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_hmac_err_we),</pre>
<pre>    .wd     (intr_test_hmac_err_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.hmac_err.qe),</pre>
<pre>    .q      (reg2hw.intr_test.hmac_err.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg_hmac_en (</pre>
<pre>    .re     (cfg_hmac_en_re),</pre>
<pre>    .we     (cfg_hmac_en_we),</pre>
<pre>    .wd     (cfg_hmac_en_wd),</pre>
<pre>    .d      (hw2reg.cfg.hmac_en.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.cfg.hmac_en.qe),</pre>
<pre>    .q      (reg2hw.cfg.hmac_en.q ),</pre>
<pre>    .qs     (cfg_hmac_en_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg_sha_en (</pre>
<pre>    .re     (cfg_sha_en_re),</pre>
<pre>    .we     (cfg_sha_en_we),</pre>
<pre>    .wd     (cfg_sha_en_wd),</pre>
<pre>    .d      (hw2reg.cfg.sha_en.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.cfg.sha_en.qe),</pre>
<pre>    .q      (reg2hw.cfg.sha_en.q ),</pre>
<pre>    .qs     (cfg_sha_en_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg_endian_swap (</pre>
<pre>    .re     (cfg_endian_swap_re),</pre>
<pre>    .we     (cfg_endian_swap_we),</pre>
<pre>    .wd     (cfg_endian_swap_wd),</pre>
<pre>    .d      (hw2reg.cfg.endian_swap.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.cfg.endian_swap.qe),</pre>
<pre>    .q      (reg2hw.cfg.endian_swap.q ),</pre>
<pre>    .qs     (cfg_endian_swap_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg_digest_swap (</pre>
<pre>    .re     (cfg_digest_swap_re),</pre>
<pre>    .we     (cfg_digest_swap_we),</pre>
<pre>    .wd     (cfg_digest_swap_wd),</pre>
<pre>    .d      (hw2reg.cfg.digest_swap.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.cfg.digest_swap.qe),</pre>
<pre>    .q      (reg2hw.cfg.digest_swap.q ),</pre>
<pre>    .qs     (cfg_digest_swap_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_cmd_hash_start (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (cmd_hash_start_we),</pre>
<pre>    .wd     (cmd_hash_start_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.cmd.hash_start.qe),</pre>
<pre>    .q      (reg2hw.cmd.hash_start.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_cmd_hash_process (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (cmd_hash_process_we),</pre>
<pre>    .wd     (cmd_hash_process_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.cmd.hash_process.qe),</pre>
<pre>    .q      (reg2hw.cmd.hash_process.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_fifo_empty (</pre>
<pre>    .re     (status_fifo_empty_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.fifo_empty.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_fifo_empty_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_fifo_full (</pre>
<pre>    .re     (status_fifo_full_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.fifo_full.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_fifo_full_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (5)</pre>
<pre style="background-color: #FF0000;">  ) u_status_fifo_depth (</pre>
<pre>    .re     (status_fifo_depth_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.fifo_depth.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_fifo_depth_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_err_code (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.err_code.de),</pre>
<pre>    .d      (hw2reg.err_code.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (err_code_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_wipe_secret (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (wipe_secret_we),</pre>
<pre>    .wd     (wipe_secret_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.wipe_secret.qe),</pre>
<pre>    .q      (reg2hw.wipe_secret.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key0 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key0_we),</pre>
<pre>    .wd     (key0_wd),</pre>
<pre>    .d      (hw2reg.key[0].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[0].qe),</pre>
<pre>    .q      (reg2hw.key[0].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key1 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key1_we),</pre>
<pre>    .wd     (key1_wd),</pre>
<pre>    .d      (hw2reg.key[1].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[1].qe),</pre>
<pre>    .q      (reg2hw.key[1].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key2 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key2_we),</pre>
<pre>    .wd     (key2_wd),</pre>
<pre>    .d      (hw2reg.key[2].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[2].qe),</pre>
<pre>    .q      (reg2hw.key[2].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key3 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key3_we),</pre>
<pre>    .wd     (key3_wd),</pre>
<pre>    .d      (hw2reg.key[3].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[3].qe),</pre>
<pre>    .q      (reg2hw.key[3].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key4 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key4_we),</pre>
<pre>    .wd     (key4_wd),</pre>
<pre>    .d      (hw2reg.key[4].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[4].qe),</pre>
<pre>    .q      (reg2hw.key[4].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key5 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key5_we),</pre>
<pre>    .wd     (key5_wd),</pre>
<pre>    .d      (hw2reg.key[5].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[5].qe),</pre>
<pre>    .q      (reg2hw.key[5].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key6 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key6_we),</pre>
<pre>    .wd     (key6_wd),</pre>
<pre>    .d      (hw2reg.key[6].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[6].qe),</pre>
<pre>    .q      (reg2hw.key[6].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_key7 (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (key7_we),</pre>
<pre>    .wd     (key7_wd),</pre>
<pre>    .d      (hw2reg.key[7].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.key[7].qe),</pre>
<pre>    .q      (reg2hw.key[7].q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_digest0 (</pre>
<pre>    .re     (digest0_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.digest[0].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (digest0_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_digest1 (</pre>
<pre>    .re     (digest1_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.digest[1].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (digest1_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_digest2 (</pre>
<pre>    .re     (digest2_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.digest[2].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (digest2_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_digest3 (</pre>
<pre>    .re     (digest3_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.digest[3].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (digest3_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_digest4 (</pre>
<pre>    .re     (digest4_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.digest[4].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (digest4_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_digest5 (</pre>
<pre>    .re     (digest5_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.digest[5].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (digest5_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_digest6 (</pre>
<pre>    .re     (digest6_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.digest[6].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (digest6_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_digest7 (</pre>
<pre>    .re     (digest7_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.digest[7].d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (digest7_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_msg_length_lower (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.msg_length_lower.de),</pre>
<pre>    .d      (hw2reg.msg_length_lower.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (msg_length_lower_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_msg_length_upper (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.msg_length_upper.de),</pre>
<pre>    .d      (hw2reg.msg_length_upper.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (msg_length_upper_qs)</pre>
<pre>  logic [25:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[ 0] = (reg_addr == HMAC_INTR_STATE_OFFSET);</pre>
<pre>    addr_hit[ 1] = (reg_addr == HMAC_INTR_ENABLE_OFFSET);</pre>
<pre>    addr_hit[ 2] = (reg_addr == HMAC_INTR_TEST_OFFSET);</pre>
<pre>    addr_hit[ 3] = (reg_addr == HMAC_CFG_OFFSET);</pre>
<pre>    addr_hit[ 4] = (reg_addr == HMAC_CMD_OFFSET);</pre>
<pre>    addr_hit[ 5] = (reg_addr == HMAC_STATUS_OFFSET);</pre>
<pre>    addr_hit[ 6] = (reg_addr == HMAC_ERR_CODE_OFFSET);</pre>
<pre>    addr_hit[ 7] = (reg_addr == HMAC_WIPE_SECRET_OFFSET);</pre>
<pre>    addr_hit[ 8] = (reg_addr == HMAC_KEY0_OFFSET);</pre>
<pre>    addr_hit[ 9] = (reg_addr == HMAC_KEY1_OFFSET);</pre>
<pre>    addr_hit[10] = (reg_addr == HMAC_KEY2_OFFSET);</pre>
<pre>    addr_hit[11] = (reg_addr == HMAC_KEY3_OFFSET);</pre>
<pre>    addr_hit[12] = (reg_addr == HMAC_KEY4_OFFSET);</pre>
<pre>    addr_hit[13] = (reg_addr == HMAC_KEY5_OFFSET);</pre>
<pre>    addr_hit[14] = (reg_addr == HMAC_KEY6_OFFSET);</pre>
<pre>    addr_hit[15] = (reg_addr == HMAC_KEY7_OFFSET);</pre>
<pre>    addr_hit[16] = (reg_addr == HMAC_DIGEST0_OFFSET);</pre>
<pre>    addr_hit[17] = (reg_addr == HMAC_DIGEST1_OFFSET);</pre>
<pre>    addr_hit[18] = (reg_addr == HMAC_DIGEST2_OFFSET);</pre>
<pre>    addr_hit[19] = (reg_addr == HMAC_DIGEST3_OFFSET);</pre>
<pre>    addr_hit[20] = (reg_addr == HMAC_DIGEST4_OFFSET);</pre>
<pre>    addr_hit[21] = (reg_addr == HMAC_DIGEST5_OFFSET);</pre>
<pre>    addr_hit[22] = (reg_addr == HMAC_DIGEST6_OFFSET);</pre>
<pre>    addr_hit[23] = (reg_addr == HMAC_DIGEST7_OFFSET);</pre>
<pre>    addr_hit[24] = (reg_addr == HMAC_MSG_LENGTH_LOWER_OFFSET);</pre>
<pre>    addr_hit[25] = (reg_addr == HMAC_MSG_LENGTH_UPPER_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[ 0] && reg_we && (HMAC_PERMIT[ 0] != (HMAC_PERMIT[ 0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 1] && reg_we && (HMAC_PERMIT[ 1] != (HMAC_PERMIT[ 1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 2] && reg_we && (HMAC_PERMIT[ 2] != (HMAC_PERMIT[ 2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 3] && reg_we && (HMAC_PERMIT[ 3] != (HMAC_PERMIT[ 3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 4] && reg_we && (HMAC_PERMIT[ 4] != (HMAC_PERMIT[ 4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 5] && reg_we && (HMAC_PERMIT[ 5] != (HMAC_PERMIT[ 5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 6] && reg_we && (HMAC_PERMIT[ 6] != (HMAC_PERMIT[ 6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 7] && reg_we && (HMAC_PERMIT[ 7] != (HMAC_PERMIT[ 7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 8] && reg_we && (HMAC_PERMIT[ 8] != (HMAC_PERMIT[ 8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 9] && reg_we && (HMAC_PERMIT[ 9] != (HMAC_PERMIT[ 9] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[10] && reg_we && (HMAC_PERMIT[10] != (HMAC_PERMIT[10] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[11] && reg_we && (HMAC_PERMIT[11] != (HMAC_PERMIT[11] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[12] && reg_we && (HMAC_PERMIT[12] != (HMAC_PERMIT[12] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[13] && reg_we && (HMAC_PERMIT[13] != (HMAC_PERMIT[13] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[14] && reg_we && (HMAC_PERMIT[14] != (HMAC_PERMIT[14] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[15] && reg_we && (HMAC_PERMIT[15] != (HMAC_PERMIT[15] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[16] && reg_we && (HMAC_PERMIT[16] != (HMAC_PERMIT[16] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[17] && reg_we && (HMAC_PERMIT[17] != (HMAC_PERMIT[17] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[18] && reg_we && (HMAC_PERMIT[18] != (HMAC_PERMIT[18] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[19] && reg_we && (HMAC_PERMIT[19] != (HMAC_PERMIT[19] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[20] && reg_we && (HMAC_PERMIT[20] != (HMAC_PERMIT[20] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[21] && reg_we && (HMAC_PERMIT[21] != (HMAC_PERMIT[21] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[22] && reg_we && (HMAC_PERMIT[22] != (HMAC_PERMIT[22] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[23] && reg_we && (HMAC_PERMIT[23] != (HMAC_PERMIT[23] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[24] && reg_we && (HMAC_PERMIT[24] != (HMAC_PERMIT[24] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[25] && reg_we && (HMAC_PERMIT[25] != (HMAC_PERMIT[25] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign intr_state_hmac_done_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_hmac_done_wd = reg_wdata[0];</pre>
<pre>  assign intr_state_fifo_full_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_fifo_full_wd = reg_wdata[1];</pre>
<pre>  assign intr_state_hmac_err_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_hmac_err_wd = reg_wdata[2];</pre>
<pre>  assign intr_enable_hmac_done_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_hmac_done_wd = reg_wdata[0];</pre>
<pre>  assign intr_enable_fifo_full_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_fifo_full_wd = reg_wdata[1];</pre>
<pre>  assign intr_enable_hmac_err_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_hmac_err_wd = reg_wdata[2];</pre>
<pre>  assign intr_test_hmac_done_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_hmac_done_wd = reg_wdata[0];</pre>
<pre>  assign intr_test_fifo_full_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_fifo_full_wd = reg_wdata[1];</pre>
<pre>  assign intr_test_hmac_err_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_hmac_err_wd = reg_wdata[2];</pre>
<pre>  assign cfg_hmac_en_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign cfg_hmac_en_wd = reg_wdata[0];</pre>
<pre>  assign cfg_hmac_en_re = addr_hit[3] && reg_re;</pre>
<pre>  assign cfg_sha_en_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign cfg_sha_en_wd = reg_wdata[1];</pre>
<pre>  assign cfg_sha_en_re = addr_hit[3] && reg_re;</pre>
<pre>  assign cfg_endian_swap_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign cfg_endian_swap_wd = reg_wdata[2];</pre>
<pre>  assign cfg_endian_swap_re = addr_hit[3] && reg_re;</pre>
<pre>  assign cfg_digest_swap_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign cfg_digest_swap_wd = reg_wdata[3];</pre>
<pre>  assign cfg_digest_swap_re = addr_hit[3] && reg_re;</pre>
<pre>  assign cmd_hash_start_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign cmd_hash_start_wd = reg_wdata[0];</pre>
<pre>  assign cmd_hash_process_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign cmd_hash_process_wd = reg_wdata[1];</pre>
<pre>  assign status_fifo_empty_re = addr_hit[5] && reg_re;</pre>
<pre>  assign status_fifo_full_re = addr_hit[5] && reg_re;</pre>
<pre>  assign status_fifo_depth_re = addr_hit[5] && reg_re;</pre>
<pre>  assign wipe_secret_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign wipe_secret_wd = reg_wdata[31:0];</pre>
<pre>  assign key0_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign key0_wd = reg_wdata[31:0];</pre>
<pre>  assign key1_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign key1_wd = reg_wdata[31:0];</pre>
<pre>  assign key2_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign key2_wd = reg_wdata[31:0];</pre>
<pre>  assign key3_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign key3_wd = reg_wdata[31:0];</pre>
<pre>  assign key4_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign key4_wd = reg_wdata[31:0];</pre>
<pre>  assign key5_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign key5_wd = reg_wdata[31:0];</pre>
<pre>  assign key6_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign key6_wd = reg_wdata[31:0];</pre>
<pre>  assign key7_we = addr_hit[15] & reg_we & ~wr_err;</pre>
<pre>  assign key7_wd = reg_wdata[31:0];</pre>
<pre>  assign digest0_re = addr_hit[16] && reg_re;</pre>
<pre>  assign digest1_re = addr_hit[17] && reg_re;</pre>
<pre>  assign digest2_re = addr_hit[18] && reg_re;</pre>
<pre>  assign digest3_re = addr_hit[19] && reg_re;</pre>
<pre>  assign digest4_re = addr_hit[20] && reg_re;</pre>
<pre>  assign digest5_re = addr_hit[21] && reg_re;</pre>
<pre>  assign digest6_re = addr_hit[22] && reg_re;</pre>
<pre>  assign digest7_re = addr_hit[23] && reg_re;</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[0] = intr_state_hmac_done_qs;</pre>
<pre>        reg_rdata_next[1] = intr_state_fifo_full_qs;</pre>
<pre>        reg_rdata_next[2] = intr_state_hmac_err_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[0] = intr_enable_hmac_done_qs;</pre>
<pre>        reg_rdata_next[1] = intr_enable_fifo_full_qs;</pre>
<pre>        reg_rdata_next[2] = intr_enable_hmac_err_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>        reg_rdata_next[2] = '0;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[0] = cfg_hmac_en_qs;</pre>
<pre>        reg_rdata_next[1] = cfg_sha_en_qs;</pre>
<pre>        reg_rdata_next[2] = cfg_endian_swap_qs;</pre>
<pre>        reg_rdata_next[3] = cfg_digest_swap_qs;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[0] = status_fifo_empty_qs;</pre>
<pre>        reg_rdata_next[1] = status_fifo_full_qs;</pre>
<pre>        reg_rdata_next[8:4] = status_fifo_depth_qs;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[31:0] = err_code_qs;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[9]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[10]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[11]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[12]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[13]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[14]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[15]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[16]: begin</pre>
<pre>        reg_rdata_next[31:0] = digest0_qs;</pre>
<pre>      addr_hit[17]: begin</pre>
<pre>        reg_rdata_next[31:0] = digest1_qs;</pre>
<pre>      addr_hit[18]: begin</pre>
<pre>        reg_rdata_next[31:0] = digest2_qs;</pre>
<pre>      addr_hit[19]: begin</pre>
<pre>        reg_rdata_next[31:0] = digest3_qs;</pre>
<pre>      addr_hit[20]: begin</pre>
<pre>        reg_rdata_next[31:0] = digest4_qs;</pre>
<pre>      addr_hit[21]: begin</pre>
<pre>        reg_rdata_next[31:0] = digest5_qs;</pre>
<pre>      addr_hit[22]: begin</pre>
<pre>        reg_rdata_next[31:0] = digest6_qs;</pre>
<pre>      addr_hit[23]: begin</pre>
<pre>        reg_rdata_next[31:0] = digest7_qs;</pre>
<pre>      addr_hit[24]: begin</pre>
<pre>        reg_rdata_next[31:0] = msg_length_lower_qs;</pre>
<pre>      addr_hit[25]: begin</pre>
<pre>        reg_rdata_next[31:0] = msg_length_upper_qs;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/ip/hmac/rtl/sha2_pad.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input            wipe_secret,</pre>
<pre>  input sha_word_t wipe_v,</pre>
<pre>  input                 fifo_rvalid,</pre>
<pre>  input  sha_fifo_t     fifo_rdata,</pre>
<pre>  output logic          fifo_rready,</pre>
<pre>  output logic          shaf_rvalid,</pre>
<pre>  output sha_word_t     shaf_rdata,</pre>
<pre>  input                 shaf_rready,</pre>
<pre>  input sha_en,</pre>
<pre>  input hash_start,</pre>
<pre>  input hash_process,</pre>
<pre>  input hash_done,</pre>
<pre>  input        [63:0] message_length, // # of bytes in bits (8 bits granularity)</pre>
<pre>  output logic        msg_feed_complete // Indicates, all message is feeded</pre>
<pre>  logic [63:0] tx_count;    // fin received data count.</pre>
<pre>  logic inc_txcount;</pre>
<pre>  logic fifo_partial;</pre>
<pre>  logic txcnt_eq_1a0;</pre>
<pre>  logic hash_process_flag; // Set by hash_process, clear by hash_done</pre>
<pre>  assign fifo_partial = ~&fifo_rdata.mask;</pre>
<pre>  assign txcnt_eq_1a0 = (tx_count[8:0] == 9'h1a0);</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      hash_process_flag <= 1'b0;</pre>
<pre>    end else if (hash_process) begin</pre>
<pre>      hash_process_flag <= 1'b1;</pre>
<pre>    end else if (hash_done || hash_start) begin</pre>
<pre>      hash_process_flag <= 1'b0;</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    FifoIn,         // fin_wdata, fin_wstrb</pre>
<pre>    Pad80,          // {8'h80, 8'h00} , strb (calc based on len[4:3])</pre>
<pre>    Pad00,          // 32'h0, full strb</pre>
<pre>    LenHi,          // len[63:32], full strb</pre>
<pre>    LenLo           // len[31:0], full strb</pre>
<pre>  } sel_data_e;</pre>
<pre>  sel_data_e sel_data;</pre>
<pre>  always_comb begin</pre>
<pre>    unique case (sel_data)</pre>
<pre>      FifoIn: begin</pre>
<pre>        shaf_rdata = fifo_rdata.data;</pre>
<pre>      Pad80: begin</pre>
<pre>        unique case (message_length[4:3])</pre>
<pre>          2'b 00: shaf_rdata = 32'h 8000_0000;</pre>
<pre>          2'b 01: shaf_rdata = {fifo_rdata.data[31:24], 24'h 8000_00};</pre>
<pre>          2'b 10: shaf_rdata = {fifo_rdata.data[31:16], 16'h 8000};</pre>
<pre>          2'b 11: shaf_rdata = {fifo_rdata.data[31: 8],  8'h 80};</pre>
<pre>          default: shaf_rdata = 32'h0;</pre>
<pre>      Pad00: begin</pre>
<pre>        shaf_rdata = '0;</pre>
<pre>      LenHi: begin</pre>
<pre>        shaf_rdata = message_length[63:32];</pre>
<pre>      LenLo: begin</pre>
<pre>        shaf_rdata = message_length[31:0];</pre>
<pre>      default: begin</pre>
<pre>        shaf_rdata = '0;</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    StIdle,        // fin_full to prevent unwanted FIFO write</pre>
<pre>    StFifoReceive, // Check tx_count == message_length</pre>
<pre>    StPad80,       // 8'h 80 + 8'h 00 X N</pre>
<pre>    StPad00,</pre>
<pre>    StLenHi,</pre>
<pre>    StLenLo</pre>
<pre>  } pad_st_e;</pre>
<pre>  pad_st_e st_q, st_d;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      st_q <= StIdle;</pre>
<pre>    end else begin</pre>
<pre>      st_q <= st_d;</pre>
<pre>  always_comb begin</pre>
<pre>    shaf_rvalid = 1'b0;</pre>
<pre>    inc_txcount = 1'b0;</pre>
<pre>    sel_data = FifoIn;</pre>
<pre>    fifo_rready = 1'b0;</pre>
<pre>    st_d = StIdle;</pre>
<pre>    unique case (st_q)</pre>
<pre>      StIdle: begin</pre>
<pre>        sel_data = FifoIn;</pre>
<pre>        shaf_rvalid = 1'b0;</pre>
<pre>        if (sha_en && hash_start) begin</pre>
<pre>          inc_txcount = 1'b0;</pre>
<pre>          st_d = StFifoReceive;</pre>
<pre>        end else begin</pre>
<pre>          st_d = StIdle;</pre>
<pre>      StFifoReceive: begin</pre>
<pre>        sel_data = FifoIn;</pre>
<pre>        if (fifo_partial && fifo_rvalid) begin</pre>
<pre>          shaf_rvalid  = 1'b0; // Update entry at StPad80</pre>
<pre>          inc_txcount = 1'b0;</pre>
<pre>          fifo_rready = 1'b0;</pre>
<pre>          st_d = StPad80;</pre>
<pre>        end else if (!hash_process_flag) begin</pre>
<pre>          fifo_rready = shaf_rready;</pre>
<pre>          shaf_rvalid  = fifo_rvalid;</pre>
<pre>          inc_txcount = shaf_rready;</pre>
<pre>          st_d = StFifoReceive;</pre>
<pre>        end else if (tx_count == message_length) begin</pre>
<pre>          shaf_rvalid  = 1'b0;</pre>
<pre>          inc_txcount = 1'b0;</pre>
<pre>          fifo_rready = 1'b0;</pre>
<pre>          st_d = StPad80;</pre>
<pre>        end else begin</pre>
<pre>          shaf_rvalid  = fifo_rvalid;</pre>
<pre>          fifo_rready = shaf_rready; // 0 always</pre>
<pre>          inc_txcount = shaf_rready; // 0 always</pre>
<pre>          st_d = StFifoReceive;</pre>
<pre>      StPad80: begin</pre>
<pre>        sel_data = Pad80;</pre>
<pre>        shaf_rvalid = 1'b1;</pre>
<pre>        fifo_rready = shaf_rready && |message_length[4:3]; // Only when partial</pre>
<pre>        if (shaf_rready && txcnt_eq_1a0) begin</pre>
<pre>          st_d = StLenHi;</pre>
<pre>          inc_txcount = 1'b1;</pre>
<pre>        end else if (shaf_rready && !txcnt_eq_1a0) begin</pre>
<pre>          st_d = StPad00;</pre>
<pre>          inc_txcount = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          st_d = StPad80;</pre>
<pre>          inc_txcount = 1'b0;</pre>
<pre>      StPad00: begin</pre>
<pre>        sel_data = Pad00;</pre>
<pre>        shaf_rvalid = 1'b1;</pre>
<pre>        if (shaf_rready) begin</pre>
<pre>          inc_txcount = 1'b1;</pre>
<pre>          if (txcnt_eq_1a0) begin</pre>
<pre>            st_d = StLenHi;</pre>
<pre>          end else begin</pre>
<pre>            st_d = StPad00;</pre>
<pre>        end else begin</pre>
<pre>          st_d = StPad00;</pre>
<pre>      StLenHi: begin</pre>
<pre>        sel_data = LenHi;</pre>
<pre>        shaf_rvalid = 1'b1;</pre>
<pre>        if (shaf_rready) begin</pre>
<pre>          st_d = StLenLo;</pre>
<pre>          inc_txcount = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          st_d = StLenHi;</pre>
<pre>          inc_txcount = 1'b0;</pre>
<pre>      StLenLo: begin</pre>
<pre>        sel_data = LenLo;</pre>
<pre>        shaf_rvalid = 1'b1;</pre>
<pre>        if (shaf_rready) begin</pre>
<pre>          st_d = StIdle;</pre>
<pre>          inc_txcount = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          st_d = StLenLo;</pre>
<pre>          inc_txcount = 1'b0;</pre>
<pre>      default: begin</pre>
<pre>        st_d = StIdle;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      tx_count <= '0;</pre>
<pre>    end else if (hash_start) begin</pre>
<pre>      tx_count <= '0;</pre>
<pre>    end else if (inc_txcount) begin</pre>
<pre>      tx_count[63:5] <= tx_count[63:5] + 1'b1;</pre>
<pre>  assign msg_feed_complete = hash_process_flag && (st_q == StIdle);</pre>
<h3>hw/ip/hmac/rtl/sha2.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input            wipe_secret,</pre>
<pre>  input sha_word_t wipe_v,</pre>
<pre>  input             fifo_rvalid,</pre>
<pre>  input  sha_fifo_t fifo_rdata,</pre>
<pre>  output logic      fifo_rready,</pre>
<pre>  input        sha_en,   // If disabled, it clears internal content.</pre>
<pre>  input        hash_start,</pre>
<pre>  input        hash_process,</pre>
<pre>  output logic hash_done,</pre>
<pre>  input        [63:0] message_length,   // bits but byte based</pre>
<pre>  output sha_word_t [7:0] digest</pre>
<pre>  logic msg_feed_complete;</pre>
<pre>  logic      shaf_rready;</pre>
<pre>  sha_word_t shaf_rdata;</pre>
<pre>  logic      shaf_rvalid;</pre>
<pre>  logic [$clog2(NumRound)-1:0] round;</pre>
<pre>  logic      [3:0]  w_index;</pre>
<pre>  sha_word_t [15:0] w;</pre>
<pre>  logic update_w_from_fifo, calculate_next_w;</pre>
<pre>  logic init_hash, run_hash, complete_one_chunk;</pre>
<pre>  logic update_digest, clear_digest;</pre>
<pre>  logic hash_done_next; // to meet the phase with digest value.</pre>
<pre>  sha_word_t [7:0] hash;    // a,b,c,d,e,f,g,h</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : fill_w</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      w <= '0;</pre>
<pre>    end else if (wipe_secret) begin</pre>
<pre>      w <= w ^ {16{wipe_v}};</pre>
<pre>    end else if (!sha_en) begin</pre>
<pre>      w <= '0;</pre>
<pre>    end else if (!run_hash && update_w_from_fifo) begin</pre>
<pre>      w <= {shaf_rdata, w[15:1]};</pre>
<pre>    end else if (calculate_next_w) begin</pre>
<pre>      w <= {calc_w(w[0], w[1], w[9], w[14]), w[15:1]};</pre>
<pre>    end else if (run_hash) begin</pre>
<pre>      w <= {sha_word_t'(0), w[15:1]};</pre>
<pre style="background-color: #FF0000;">  end : fill_w</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : compress_round</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      hash <= '{default:'0};</pre>
<pre>    end else if (wipe_secret) begin</pre>
<pre>      for (int i = 0 ; i < 8 ; i++) begin</pre>
<pre>        hash[i] <= hash[i] ^ wipe_v;</pre>
<pre>    end else if (init_hash) begin</pre>
<pre>      hash <= digest;</pre>
<pre>    end else if (run_hash) begin</pre>
<pre>      hash <= compress( w[0], CubicRootPrime[round], hash);</pre>
<pre style="background-color: #FF0000;">  end : compress_round</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      digest <= '{default: '0};</pre>
<pre>    end else if (wipe_secret) begin</pre>
<pre>      for (int i = 0 ; i < 8 ; i++) begin</pre>
<pre>        digest[i] <= digest[i] ^ wipe_v;</pre>
<pre>    end else if (hash_start) begin</pre>
<pre>      for (int i = 0 ; i < 8 ; i++) begin</pre>
<pre>        digest[i] <= InitHash[i];</pre>
<pre>    end else if (!sha_en || clear_digest) begin</pre>
<pre>      digest <= '0;</pre>
<pre>    end else if (update_digest) begin</pre>
<pre>      for (int i = 0 ; i < 8 ; i++) begin</pre>
<pre>        digest[i] <= digest[i] + hash[i];</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      round <= '0;</pre>
<pre>    end else if (!sha_en) begin</pre>
<pre>      round <= '0;</pre>
<pre>    end else if (run_hash) begin</pre>
<pre>      if (round == (NumRound-1)) begin</pre>
<pre>        round <= '0;</pre>
<pre>      end else begin</pre>
<pre>        round <= round + 1;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      w_index <= '0;</pre>
<pre>    end else if (!sha_en) begin</pre>
<pre>      w_index <= '0;</pre>
<pre>    end else if (update_w_from_fifo) begin</pre>
<pre>      w_index <= w_index + 1;</pre>
<pre>  assign shaf_rready = update_w_from_fifo;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) hash_done <= 1'b0;</pre>
<pre>    else         hash_done <= hash_done_next;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    FifoIdle,</pre>
<pre>    FifoLoadFromFifo,</pre>
<pre>    FifoWait</pre>
<pre>  } fifoctl_state_e;</pre>
<pre>  fifoctl_state_e fifo_st_q, fifo_st_d;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      fifo_st_q <= FifoIdle;</pre>
<pre>    end else begin</pre>
<pre>      fifo_st_q <= fifo_st_d;</pre>
<pre>  always_comb begin</pre>
<pre>    fifo_st_d = FifoIdle;</pre>
<pre>    update_w_from_fifo = 1'b0;</pre>
<pre>    hash_done_next = 1'b0;</pre>
<pre>    unique case (fifo_st_q)</pre>
<pre>      FifoIdle: begin</pre>
<pre>        if (hash_start) begin</pre>
<pre>          fifo_st_d = FifoLoadFromFifo;</pre>
<pre>        end else begin</pre>
<pre>          fifo_st_d = FifoIdle;</pre>
<pre>      FifoLoadFromFifo: begin</pre>
<pre>        if (!sha_en) begin</pre>
<pre>          fifo_st_d = FifoIdle;</pre>
<pre>          update_w_from_fifo = 1'b0;</pre>
<pre>        end else if (!shaf_rvalid) begin</pre>
<pre>          fifo_st_d = FifoLoadFromFifo;</pre>
<pre>          update_w_from_fifo = 1'b0;</pre>
<pre>        end else if (w_index == 4'd 15) begin</pre>
<pre>          fifo_st_d = FifoWait;</pre>
<pre>          update_w_from_fifo = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          fifo_st_d = FifoLoadFromFifo;</pre>
<pre>          update_w_from_fifo = 1'b1;</pre>
<pre>      FifoWait: begin</pre>
<pre>        if (msg_feed_complete && complete_one_chunk) begin</pre>
<pre>          fifo_st_d = FifoIdle;</pre>
<pre>          hash_done_next = 1'b1;</pre>
<pre>        end else if (complete_one_chunk) begin</pre>
<pre>          fifo_st_d = FifoLoadFromFifo;</pre>
<pre>        end else begin</pre>
<pre>          fifo_st_d = FifoWait;</pre>
<pre>      default: begin</pre>
<pre>        fifo_st_d = FifoIdle;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    ShaIdle,</pre>
<pre>    ShaCompress,</pre>
<pre>    ShaUpdateDigest</pre>
<pre>  } sha_st_t;</pre>
<pre>  sha_st_t sha_st_q, sha_st_d;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      sha_st_q <= ShaIdle;</pre>
<pre>    end else begin</pre>
<pre>      sha_st_q <= sha_st_d;</pre>
<pre>  assign clear_digest = hash_start;</pre>
<pre>  always_comb begin</pre>
<pre>    update_digest    = 1'b0;</pre>
<pre>    calculate_next_w = 1'b0;</pre>
<pre>    init_hash        = 1'b0;</pre>
<pre>    run_hash         = 1'b0;</pre>
<pre>    unique case (sha_st_q)</pre>
<pre>      ShaIdle: begin</pre>
<pre>        if (fifo_st_q == FifoWait) begin</pre>
<pre>          init_hash = 1'b1;</pre>
<pre>          sha_st_d = ShaCompress;</pre>
<pre>        end else begin</pre>
<pre>          sha_st_d = ShaIdle;</pre>
<pre>      ShaCompress: begin</pre>
<pre>        run_hash = 1'b1;</pre>
<pre>        if (round < 48) begin</pre>
<pre>          calculate_next_w = 1'b1;</pre>
<pre>        if (complete_one_chunk) begin</pre>
<pre>          sha_st_d = ShaUpdateDigest;</pre>
<pre>        end else begin</pre>
<pre>          sha_st_d = ShaCompress;</pre>
<pre>      ShaUpdateDigest: begin</pre>
<pre>        update_digest = 1'b1;</pre>
<pre>        if (fifo_st_q == FifoWait) begin</pre>
<pre>          init_hash = 1'b1;</pre>
<pre>          sha_st_d = ShaCompress;</pre>
<pre>        end else begin</pre>
<pre>          sha_st_d = ShaIdle;</pre>
<pre>      default: begin</pre>
<pre>        sha_st_d = ShaIdle;</pre>
<pre>  assign complete_one_chunk = (round == 6'd63);</pre>
<pre>  sha2_pad u_pad (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .wipe_secret,</pre>
<pre>    .wipe_v,</pre>
<pre>    .fifo_rvalid,</pre>
<pre>    .fifo_rdata,</pre>
<pre>    .fifo_rready,</pre>
<pre>    .shaf_rvalid,</pre>
<pre>    .shaf_rdata,</pre>
<pre>    .shaf_rready,</pre>
<pre>    .sha_en,</pre>
<pre>    .hash_start,</pre>
<pre>    .hash_process,</pre>
<pre>    .hash_done,</pre>
<pre>    .message_length,</pre>
<pre>    .msg_feed_complete</pre>
<pre style="background-color: #FF0000;">endmodule : sha2</pre>
<h3>hw/ip/hmac/rtl/hmac_pkg.sv</h3>
<pre>package hmac_pkg;</pre>
<pre>  localparam int NumAlerts = 1;</pre>
<pre>  localparam logic [NumAlerts-1:0] AlertAsyncOn = NumAlerts'(1'b1);</pre>
<pre>  localparam int MsgFifoDepth = 16;</pre>
<pre>  localparam int NumRound = 64;   // SHA-224, SHA-256</pre>
<pre>  typedef logic [31:0] sha_word_t;</pre>
<pre>  localparam int WordByte = $bits(sha_word_t)/8;</pre>
<pre>  typedef struct packed {</pre>
<pre>    sha_word_t           data;</pre>
<pre>    logic [WordByte-1:0] mask;</pre>
<pre style="background-color: #FF0000;">  } sha_fifo_t;</pre>
<pre>  localparam sha_word_t InitHash [8]= '{</pre>
<pre>    32'h 6a09_e667, 32'h bb67_ae85, 32'h 3c6e_f372, 32'h a54f_f53a,</pre>
<pre>    32'h 510e_527f, 32'h 9b05_688c, 32'h 1f83_d9ab, 32'h 5be0_cd19</pre>
<pre>  localparam sha_word_t CubicRootPrime [64] = '{</pre>
<pre>    32'h 428a_2f98, 32'h 7137_4491, 32'h b5c0_fbcf, 32'h e9b5_dba5,</pre>
<pre>    32'h 3956_c25b, 32'h 59f1_11f1, 32'h 923f_82a4, 32'h ab1c_5ed5,</pre>
<pre>    32'h d807_aa98, 32'h 1283_5b01, 32'h 2431_85be, 32'h 550c_7dc3,</pre>
<pre>    32'h 72be_5d74, 32'h 80de_b1fe, 32'h 9bdc_06a7, 32'h c19b_f174,</pre>
<pre>    32'h e49b_69c1, 32'h efbe_4786, 32'h 0fc1_9dc6, 32'h 240c_a1cc,</pre>
<pre>    32'h 2de9_2c6f, 32'h 4a74_84aa, 32'h 5cb0_a9dc, 32'h 76f9_88da,</pre>
<pre>    32'h 983e_5152, 32'h a831_c66d, 32'h b003_27c8, 32'h bf59_7fc7,</pre>
<pre>    32'h c6e0_0bf3, 32'h d5a7_9147, 32'h 06ca_6351, 32'h 1429_2967,</pre>
<pre>    32'h 27b7_0a85, 32'h 2e1b_2138, 32'h 4d2c_6dfc, 32'h 5338_0d13,</pre>
<pre>    32'h 650a_7354, 32'h 766a_0abb, 32'h 81c2_c92e, 32'h 9272_2c85,</pre>
<pre>    32'h a2bf_e8a1, 32'h a81a_664b, 32'h c24b_8b70, 32'h c76c_51a3,</pre>
<pre>    32'h d192_e819, 32'h d699_0624, 32'h f40e_3585, 32'h 106a_a070,</pre>
<pre>    32'h 19a4_c116, 32'h 1e37_6c08, 32'h 2748_774c, 32'h 34b0_bcb5,</pre>
<pre>    32'h 391c_0cb3, 32'h 4ed8_aa4a, 32'h 5b9c_ca4f, 32'h 682e_6ff3,</pre>
<pre>    32'h 748f_82ee, 32'h 78a5_636f, 32'h 84c8_7814, 32'h 8cc7_0208,</pre>
<pre>    32'h 90be_fffa, 32'h a450_6ceb, 32'h bef9_a3f7, 32'h c671_78f2</pre>
<pre>  function automatic sha_word_t conv_endian( input sha_word_t v, input logic swap);</pre>
<pre>    sha_word_t conv_data = {<<8{v}};</pre>
<pre>    conv_endian = (swap) ? conv_data : v ;</pre>
<pre style="background-color: #FF0000;">  endfunction : conv_endian</pre>
<pre>  function automatic sha_word_t rotr( input sha_word_t v , input int amt );</pre>
<pre>    rotr = (v >> amt) | (v << (32-amt));</pre>
<pre style="background-color: #FF0000;">  endfunction : rotr</pre>
<pre>  function automatic sha_word_t shiftr( input sha_word_t v, input int amt );</pre>
<pre>    shiftr = (v >> amt);</pre>
<pre style="background-color: #FF0000;">  endfunction : shiftr</pre>
<pre>  function automatic sha_word_t [7:0] compress( input sha_word_t w, input sha_word_t k,</pre>
<pre>                                                input sha_word_t [7:0] h_i);</pre>
<pre>    automatic sha_word_t sigma_0, sigma_1, ch, maj, temp1, temp2;</pre>
<pre>    sigma_1 = rotr(h_i[4], 6) ^ rotr(h_i[4], 11) ^ rotr(h_i[4], 25);</pre>
<pre>    ch = (h_i[4] & h_i[5]) ^ (~h_i[4] & h_i[6]);</pre>
<pre>    temp1 = (h_i[7] + sigma_1 + ch + k + w);</pre>
<pre>    sigma_0 = rotr(h_i[0], 2) ^ rotr(h_i[0], 13) ^ rotr(h_i[0], 22);</pre>
<pre>    maj = (h_i[0] & h_i[1]) ^ (h_i[0] & h_i[2]) ^ (h_i[1] & h_i[2]);</pre>
<pre>    temp2 = (sigma_0 + maj);</pre>
<pre>    compress[7] = h_i[6];          // h = g</pre>
<pre>    compress[6] = h_i[5];          // g = f</pre>
<pre>    compress[5] = h_i[4];          // f = e</pre>
<pre>    compress[4] = h_i[3] + temp1;  // e = (d + temp1)</pre>
<pre>    compress[3] = h_i[2];          // d = c</pre>
<pre>    compress[2] = h_i[1];          // c = b</pre>
<pre>    compress[1] = h_i[0];          // b = a</pre>
<pre>    compress[0] = (temp1 + temp2); // a = (temp1 + temp2)</pre>
<pre style="background-color: #FF0000;">  endfunction : compress</pre>
<pre>  function automatic sha_word_t calc_w(input sha_word_t w_0,</pre>
<pre>                                       input sha_word_t w_1,</pre>
<pre>                                       input sha_word_t w_9,</pre>
<pre>                                       input sha_word_t w_14);</pre>
<pre>    automatic sha_word_t sum0, sum1;</pre>
<pre>    sum0 = rotr(w_1,   7) ^ rotr(w_1,  18) ^ shiftr(w_1,   3);</pre>
<pre>    sum1 = rotr(w_14, 17) ^ rotr(w_14, 19) ^ shiftr(w_14, 10);</pre>
<pre>    calc_w = w_0 + sum0 + w_9 + sum1;</pre>
<pre style="background-color: #FF0000;">  endfunction : calc_w</pre>
<pre>  typedef enum logic [31:0] {</pre>
<pre>    NoError                    = 32'h 0000_0000,</pre>
<pre>    SwPushMsgWhenShaDisabled   = 32'h 0000_0001,</pre>
<pre>    SwHashStartWhenShaDisabled = 32'h 0000_0002,</pre>
<pre>    SwUpdateSecretKeyInProcess = 32'h 0000_0003</pre>
<pre>  } err_code_e;</pre>
<pre style="background-color: #FF0000;">endpackage : hmac_pkg</pre>
<h3>hw/ip/hmac/rtl/hmac_core.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input [255:0] secret_key, // {word0, word1, ..., word7}</pre>
<pre>  input        wipe_secret,</pre>
<pre>  input [31:0] wipe_v,</pre>
<pre>  input        hmac_en,</pre>
<pre>  input        reg_hash_start,</pre>
<pre>  input        reg_hash_process,</pre>
<pre>  output logic hash_done,</pre>
<pre>  output logic sha_hash_start,</pre>
<pre>  output logic sha_hash_process,</pre>
<pre>  input        sha_hash_done,</pre>
<pre>  output logic      sha_rvalid,</pre>
<pre>  output sha_fifo_t sha_rdata,</pre>
<pre>  input             sha_rready,</pre>
<pre>  input             fifo_rvalid,</pre>
<pre>  input  sha_fifo_t fifo_rdata,</pre>
<pre>  output logic      fifo_rready,</pre>
<pre>  output logic       fifo_wsel,    // 0: from reg, 1: from digest</pre>
<pre>  output logic       fifo_wvalid,</pre>
<pre>  output logic [2:0] fifo_wdata_sel, // 0: digest[0] .. 7: digest[7]</pre>
<pre>  input              fifo_wready,</pre>
<pre>  input  [63:0] message_length,</pre>
<pre>  output [63:0] sha_message_length</pre>
<pre>  localparam int unsigned BlockSize = 512;</pre>
<pre>  localparam int unsigned BlockSizeBits = $clog2(BlockSize);</pre>
<pre>  localparam int unsigned HashWordBits = $clog2($bits(sha_word_t));</pre>
<pre>  logic hash_start; // generated from internal state machine</pre>
<pre>  logic hash_process; // generated from internal state machine to trigger hash</pre>
<pre>  logic hmac_hash_done;</pre>
<pre>  logic [BlockSize-1:0] i_pad ;</pre>
<pre>  logic [BlockSize-1:0] o_pad ;</pre>
<pre>  logic [63:0] txcount;</pre>
<pre>  logic [BlockSizeBits-HashWordBits-1:0] pad_index;</pre>
<pre>  logic clr_txcount, inc_txcount;</pre>
<pre>  logic hmac_sha_rvalid;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    SelIPad,</pre>
<pre>    SelOPad,</pre>
<pre>    SelFifo</pre>
<pre>  } sel_rdata_t;</pre>
<pre>  sel_rdata_t sel_rdata;</pre>
<pre>  typedef enum logic {</pre>
<pre>    SelIPadMsg,</pre>
<pre>    SelOPadMsg</pre>
<pre>  } sel_msglen_t;</pre>
<pre>  sel_msglen_t sel_msglen;</pre>
<pre>  typedef enum logic {</pre>
<pre>    Inner,  // Update when state goes to StIPad</pre>
<pre>    Outer   // Update when state enters StOPad</pre>
<pre>  } round_t ;</pre>
<pre>  logic update_round ;</pre>
<pre>  round_t round_q, round_d;</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    StIdle,</pre>
<pre>    StIPad,</pre>
<pre>    StMsg,              // Actual Msg, and Digest both</pre>
<pre>    StPushToMsgFifo,    // Digest --> Msg Fifo</pre>
<pre>    StWaitResp,         // Hash done( by checking processed_length? or hash_done)</pre>
<pre>    StOPad,</pre>
<pre>    StDone              // hmac_done</pre>
<pre>  } st_e ;</pre>
<pre>  st_e st_q, st_d;</pre>
<pre>  logic clr_fifo_wdata_sel;</pre>
<pre>  logic txcnt_eq_blksz ;</pre>
<pre>  logic reg_hash_process_flag;</pre>
<pre>  assign sha_hash_start   = (hmac_en) ? hash_start                       : reg_hash_start ;</pre>
<pre>  assign sha_hash_process = (hmac_en) ? reg_hash_process | hash_process  : reg_hash_process ;</pre>
<pre>  assign hash_done        = (hmac_en) ? hmac_hash_done                   : sha_hash_done  ;</pre>
<pre>  assign pad_index = txcount[BlockSizeBits-1:HashWordBits];</pre>
<pre>  assign i_pad = {secret_key, {(BlockSize-256){1'b0}}} ^ {(BlockSize/8){8'h36}};</pre>
<pre>  assign o_pad = {secret_key, {(BlockSize-256){1'b0}}} ^ {(BlockSize/8){8'h5c}};</pre>
<pre>  assign fifo_rready  = (hmac_en) ? (st_q == StMsg) & sha_rready : sha_rready ;</pre>
<pre>  assign sha_rvalid = (!hmac_en) ? fifo_rvalid : hmac_sha_rvalid ;</pre>
<pre>  assign sha_rdata =</pre>
<pre>    (!hmac_en)             ? fifo_rdata                                               :</pre>
<pre>    (sel_rdata == SelIPad) ? '{data: i_pad[(BlockSize-1)-32*pad_index-:32], mask: '1} :</pre>
<pre>    (sel_rdata == SelOPad) ? '{data: o_pad[(BlockSize-1)-32*pad_index-:32], mask: '1} :</pre>
<pre>    (sel_rdata == SelFifo) ? fifo_rdata                                               :</pre>
<pre>    '{default: '0};</pre>
<pre>  assign sha_message_length = (!hmac_en)                 ? message_length             :</pre>
<pre>                              (sel_msglen == SelIPadMsg) ? message_length + BlockSize :</pre>
<pre>                              (sel_msglen == SelOPadMsg) ? BlockSize + 256            :</pre>
<pre>                              '0 ;</pre>
<pre>  assign txcnt_eq_blksz = (txcount[BlockSizeBits:0] == BlockSize);</pre>
<pre>  assign inc_txcount = sha_rready && sha_rvalid;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      txcount <= '0;</pre>
<pre>    end else if (clr_txcount) begin</pre>
<pre>      txcount <= '0;</pre>
<pre>    end else if (inc_txcount) begin</pre>
<pre>      txcount[63:5] <= txcount[63:5] + 1'b1;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      reg_hash_process_flag <= 1'b0;</pre>
<pre>    end else if (reg_hash_process) begin</pre>
<pre>      reg_hash_process_flag <= 1'b1;</pre>
<pre>    end else if (hmac_hash_done || reg_hash_start) begin</pre>
<pre>      reg_hash_process_flag <= 1'b0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      round_q <= Inner;</pre>
<pre>    end else if (update_round) begin</pre>
<pre>      round_q <= round_d;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      fifo_wdata_sel <= 3'h 0;</pre>
<pre>    end else if (clr_fifo_wdata_sel) begin</pre>
<pre>      fifo_wdata_sel <= 3'h 0;</pre>
<pre>    end else if (fifo_wsel && fifo_wvalid) begin</pre>
<pre>      fifo_wdata_sel <= fifo_wdata_sel + 1'b1;</pre>
<pre>  assign sel_msglen = (round_q == Inner) ? SelIPadMsg : SelOPadMsg ;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin : state_ff</pre>
<pre>    if (!rst_ni) st_q <= StIdle;</pre>
<pre>    else         st_q <= st_d;</pre>
<pre>  always_comb begin : next_state</pre>
<pre>    hmac_hash_done  = 1'b0;</pre>
<pre>    hmac_sha_rvalid = 1'b0;</pre>
<pre>    clr_txcount = 1'b0;</pre>
<pre>    update_round = 1'b0;</pre>
<pre>    round_d      = Inner;</pre>
<pre>    fifo_wsel    = 1'b0;   // from register</pre>
<pre>    fifo_wvalid  = 1'b0;</pre>
<pre>    clr_fifo_wdata_sel = 1'b1;</pre>
<pre>    sel_rdata = SelFifo;</pre>
<pre>    hash_start   = 1'b0;</pre>
<pre>    hash_process = 1'b0;</pre>
<pre>    unique case (st_q)</pre>
<pre>      StIdle: begin</pre>
<pre>        if (hmac_en && reg_hash_start) begin</pre>
<pre>          st_d = StIPad;</pre>
<pre>          clr_txcount  = 1'b1;</pre>
<pre>          update_round = 1'b1;</pre>
<pre>          round_d      = Inner;</pre>
<pre>          hash_start   = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          st_d = StIdle;</pre>
<pre>      StIPad: begin</pre>
<pre>        sel_rdata = SelIPad;</pre>
<pre>        if (txcnt_eq_blksz) begin</pre>
<pre>          st_d = StMsg;</pre>
<pre>          hmac_sha_rvalid = 1'b0; // block new read request</pre>
<pre>        end else begin</pre>
<pre>          st_d = StIPad;</pre>
<pre>          hmac_sha_rvalid = 1'b1;</pre>
<pre>      StMsg: begin</pre>
<pre>        sel_rdata = SelFifo;</pre>
<pre>        if ( (((round_q == Inner) && reg_hash_process_flag) || (round_q == Outer))</pre>
<pre>            && (txcount >= sha_message_length)) begin</pre>
<pre>          st_d = StWaitResp;</pre>
<pre>          hmac_sha_rvalid = 1'b0; // block</pre>
<pre>          hash_process = (round_q == Outer);</pre>
<pre>        end else begin</pre>
<pre>          st_d = StMsg;</pre>
<pre>          hmac_sha_rvalid = fifo_rvalid;</pre>
<pre>      StWaitResp: begin</pre>
<pre>        hmac_sha_rvalid = 1'b0;</pre>
<pre>        if (sha_hash_done) begin</pre>
<pre>          if (round_q == Outer) begin</pre>
<pre>            st_d = StDone;</pre>
<pre>          end else begin // round_q == Inner</pre>
<pre>            st_d = StPushToMsgFifo;</pre>
<pre>        end else begin</pre>
<pre>          st_d = StWaitResp;</pre>
<pre>      StPushToMsgFifo: begin</pre>
<pre>        hmac_sha_rvalid    = 1'b0;</pre>
<pre>        fifo_wsel          = 1'b1;</pre>
<pre>        fifo_wvalid        = 1'b1;</pre>
<pre>        clr_fifo_wdata_sel = 1'b0;</pre>
<pre>        if (fifo_wready && fifo_wdata_sel == 3'h7) begin</pre>
<pre>          st_d = StOPad;</pre>
<pre>          clr_txcount  = 1'b1;</pre>
<pre>          update_round = 1'b1;</pre>
<pre>          round_d      = Outer;</pre>
<pre>          hash_start   = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          st_d = StPushToMsgFifo;</pre>
<pre>      StOPad: begin</pre>
<pre>        sel_rdata = SelOPad;</pre>
<pre>        if (txcnt_eq_blksz) begin</pre>
<pre>          st_d = StMsg;</pre>
<pre>          hmac_sha_rvalid = 1'b0; // block new read request</pre>
<pre>        end else begin</pre>
<pre>          st_d = StOPad;</pre>
<pre>          hmac_sha_rvalid = 1'b1;</pre>
<pre>      StDone: begin</pre>
<pre>        st_d = StIdle;</pre>
<pre>        hmac_hash_done = 1'b1;</pre>
<pre>      default: begin</pre>
<pre>        st_d = StIdle;</pre>
<h3>hw/ip/prim_generic/rtl/prim_generic_clock_gating.sv</h3>
<pre>  input        clk_i,</pre>
<pre>  input        en_i,</pre>
<pre>  input        test_en_i,</pre>
<pre>  output logic clk_o</pre>
<pre>  logic en_latch;</pre>
<pre>  always_latch begin</pre>
<pre>    if (!clk_i) begin</pre>
<pre>      en_latch = en_i | test_en_i;</pre>
<pre>  assign clk_o = en_latch & clk_i;</pre>
<h3>hw/ip/prim_generic/rtl/prim_generic_ram_2p.sv</h3>
<pre>module prim_generic_ram_2p #(</pre>
<pre>  parameter  int Width = 32, // bit</pre>
<pre>  parameter  int Depth = 128,</pre>
<pre>  localparam int Aw    = $clog2(Depth)  // derived parameter</pre>
<pre>  input clk_a_i,</pre>
<pre>  input clk_b_i,</pre>
<pre>  input                    a_req_i,</pre>
<pre>  input                    a_write_i,</pre>
<pre>  input        [Aw-1:0]    a_addr_i,</pre>
<pre>  input        [Width-1:0] a_wdata_i,</pre>
<pre>  output logic [Width-1:0] a_rdata_o,</pre>
<pre>  input                    b_req_i,</pre>
<pre>  input                    b_write_i,</pre>
<pre>  input        [Aw-1:0]    b_addr_i,</pre>
<pre>  input        [Width-1:0] b_wdata_i,</pre>
<pre>  output logic [Width-1:0] b_rdata_o</pre>
<pre>  logic [Width-1:0] mem [Depth];</pre>
<pre>  always @(posedge clk_a_i) begin</pre>
<pre>    if (a_req_i) begin</pre>
<pre>      if (a_write_i) begin</pre>
<pre>        mem[a_addr_i] <= a_wdata_i;</pre>
<pre>      a_rdata_o <= mem[a_addr_i];</pre>
<pre>  always @(posedge clk_b_i) begin</pre>
<pre>    if (b_req_i) begin</pre>
<pre>      if (b_write_i) begin</pre>
<pre>        mem[b_addr_i] <= b_wdata_i;</pre>
<pre>      b_rdata_o <= mem[b_addr_i];</pre>
<h3>hw/ip/prim_xilinx/rtl/prim_xilinx_rom.sv</h3>
<pre>module prim_xilinx_rom #(</pre>
<pre>  parameter  int Width     = 32,</pre>
<pre>  parameter  int Depth     = 2048, // 8kB default</pre>
<pre>  parameter  int Aw        = $clog2(Depth)</pre>
<pre>  input                        clk_i,</pre>
<pre>  input        [Aw-1:0]        addr_i,</pre>
<pre>  input                        cs_i,</pre>
<pre>  output logic [Width-1:0]     dout_o,</pre>
<pre>  output logic                 dvalid_o</pre>
<pre>    if (cs_i) begin</pre>
<pre>      dout_o <= mem[addr_i];</pre>
<pre>    // ROM is not initialized</pre>
<pre>    always_ff @(posedge clk_i) begin</pre>
<h3>hw/ip/prim/rtl/prim_diff_decode.sv</h3>
<pre>module prim_diff_decode #(</pre>
<pre>  parameter bit AsyncOn = 1'b0</pre>
<pre>  input        clk_i,</pre>
<pre>  input        rst_ni,</pre>
<pre>  input        diff_pi,</pre>
<pre>  input        diff_ni,</pre>
<pre>  output logic level_o,</pre>
<pre>  output logic rise_o,</pre>
<pre>  output logic fall_o,</pre>
<pre>  output logic event_o,</pre>
<pre>  output logic sigint_o</pre>
<pre>  logic level_d, level_q;</pre>
<pre style="background-color: #FF0000;">  if (AsyncOn) begin : gen_async</pre>
<pre style="background-color: #FF0000;">    typedef enum logic [1:0] {IsStd, IsSkewed, SigInt} state_e;</pre>
<pre style="background-color: #FF0000;">    state_e state_d, state_q;</pre>
<pre style="background-color: #FF0000;">    logic diff_p_edge, diff_n_edge, diff_check_ok, level;</pre>
<pre style="background-color: #FF0000;">    logic diff_pq, diff_nq, diff_pd, diff_nd;</pre>
<pre style="background-color: #FF0000;">    prim_flop_2sync #(</pre>
<pre style="background-color: #FF0000;">      .Width(1),</pre>
<pre style="background-color: #FF0000;">      .ResetValue(0)</pre>
<pre style="background-color: #FF0000;">    ) i_sync_p (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre style="background-color: #FF0000;">      .rst_ni,</pre>
<pre style="background-color: #FF0000;">      .d(diff_pi),</pre>
<pre style="background-color: #FF0000;">      .q(diff_pd)</pre>
<pre style="background-color: #FF0000;">    prim_flop_2sync #(</pre>
<pre style="background-color: #FF0000;">      .Width(1),</pre>
<pre style="background-color: #FF0000;">      .ResetValue(1)</pre>
<pre style="background-color: #FF0000;">    ) i_sync_n (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre style="background-color: #FF0000;">      .rst_ni,</pre>
<pre style="background-color: #FF0000;">      .d(diff_ni),</pre>
<pre style="background-color: #FF0000;">      .q(diff_nd)</pre>
<pre style="background-color: #FF0000;">    assign diff_p_edge   = diff_pq ^ diff_pd;</pre>
<pre style="background-color: #FF0000;">    assign diff_n_edge   = diff_nq ^ diff_nd;</pre>
<pre style="background-color: #FF0000;">    assign diff_check_ok = diff_pd ^ diff_nd;</pre>
<pre style="background-color: #FF0000;">    assign level         = diff_pd;</pre>
<pre style="background-color: #FF0000;">    assign level_o  = level_d;</pre>
<pre style="background-color: #FF0000;">    assign event_o = rise_o | fall_o;</pre>
<pre style="background-color: #FF0000;">    always_comb begin : p_diff_fsm</pre>
<pre style="background-color: #FF0000;">      state_d  = state_q;</pre>
<pre style="background-color: #FF0000;">      level_d  = level_q;</pre>
<pre style="background-color: #FF0000;">      rise_o   = 1'b0;</pre>
<pre style="background-color: #FF0000;">      fall_o   = 1'b0;</pre>
<pre style="background-color: #FF0000;">      sigint_o = 1'b0;</pre>
<pre style="background-color: #FF0000;">      unique case (state_q)</pre>
<pre style="background-color: #FF0000;">        IsStd: begin</pre>
<pre style="background-color: #FF0000;">          if (diff_check_ok) begin</pre>
<pre style="background-color: #FF0000;">            level_d = level;</pre>
<pre style="background-color: #FF0000;">            if (diff_p_edge && diff_n_edge) begin</pre>
<pre style="background-color: #FF0000;">              if (level) begin</pre>
<pre style="background-color: #FF0000;">                rise_o = 1'b1;</pre>
<pre style="background-color: #FF0000;">              end else begin</pre>
<pre style="background-color: #FF0000;">                fall_o = 1'b1;</pre>
<pre style="background-color: #FF0000;">          end else begin</pre>
<pre style="background-color: #FF0000;">            if (diff_p_edge || diff_n_edge) begin</pre>
<pre style="background-color: #FF0000;">              state_d = IsSkewed;</pre>
<pre style="background-color: #FF0000;">            end else begin</pre>
<pre style="background-color: #FF0000;">              state_d = SigInt;</pre>
<pre style="background-color: #FF0000;">              sigint_o = 1'b1;</pre>
<pre style="background-color: #FF0000;">        IsSkewed: begin</pre>
<pre style="background-color: #FF0000;">          if (diff_check_ok) begin</pre>
<pre style="background-color: #FF0000;">            state_d = IsStd;</pre>
<pre style="background-color: #FF0000;">            level_d = level;</pre>
<pre style="background-color: #FF0000;">            if (level) rise_o = 1'b1;</pre>
<pre style="background-color: #FF0000;">            else       fall_o = 1'b1;</pre>
<pre style="background-color: #FF0000;">          end else begin</pre>
<pre style="background-color: #FF0000;">            state_d  = SigInt;</pre>
<pre style="background-color: #FF0000;">            sigint_o = 1'b1;</pre>
<pre style="background-color: #FF0000;">        SigInt: begin</pre>
<pre style="background-color: #FF0000;">          sigint_o = 1'b1;</pre>
<pre style="background-color: #FF0000;">          if (diff_check_ok) begin</pre>
<pre style="background-color: #FF0000;">            state_d  = IsStd;</pre>
<pre style="background-color: #FF0000;">            sigint_o = 1'b0;</pre>
<pre style="background-color: #FF0000;">        default : ;</pre>
<pre style="background-color: #FF0000;">    always_ff @(posedge clk_i or negedge rst_ni) begin : p_sync_reg</pre>
<pre style="background-color: #FF0000;">      if (!rst_ni) begin</pre>
<pre style="background-color: #FF0000;">        state_q  <= IsStd;</pre>
<pre style="background-color: #FF0000;">        diff_pq  <= 1'b0;</pre>
<pre style="background-color: #FF0000;">        diff_nq  <= 1'b1;</pre>
<pre style="background-color: #FF0000;">        level_q  <= 1'b0;</pre>
<pre style="background-color: #FF0000;">      end else begin</pre>
<pre style="background-color: #FF0000;">        state_q  <= state_d;</pre>
<pre style="background-color: #FF0000;">        diff_pq  <= diff_pd;</pre>
<pre style="background-color: #FF0000;">        diff_nq  <= diff_nd;</pre>
<pre style="background-color: #FF0000;">        level_q  <= level_d;</pre>
<pre>  end else begin : gen_no_async</pre>
<pre style="background-color: #FF0000;">    logic diff_pq, diff_pd;</pre>
<pre>    assign diff_pd = diff_pi;</pre>
<pre>    assign sigint_o = ~(diff_pi ^ diff_ni);</pre>
<pre>    assign level_o = (sigint_o) ? level_q : diff_pi;</pre>
<pre>    assign level_d = level_o;</pre>
<pre>    assign rise_o  = (~diff_pq &  diff_pi) & ~sigint_o;</pre>
<pre>    assign fall_o  = ( diff_pq & ~diff_pi) & ~sigint_o;</pre>
<pre>    assign event_o = rise_o | fall_o;</pre>
<pre>    always_ff @(posedge clk_i or negedge rst_ni) begin : p_edge_reg</pre>
<pre>      if (!rst_ni) begin</pre>
<pre>        diff_pq  <= 1'b0;</pre>
<pre>        level_q  <= 1'b0;</pre>
<pre>      end else begin</pre>
<pre>        diff_pq  <= diff_pd;</pre>
<pre>        level_q  <= level_d;</pre>
<pre style="background-color: #FF0000;">    // assertions for asynchronous case</pre>
<pre>  end else begin : gen_sync_assert</pre>
<pre style="background-color: #FF0000;"></pre>
<h3>hw/ip/gpio/rtl/gpio.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  input        [31:0] cio_gpio_i,</pre>
<pre>  output logic [31:0] cio_gpio_o,</pre>
<pre>  output logic [31:0] cio_gpio_en_o,</pre>
<pre>  output logic [31:0] intr_gpio_o</pre>
<pre>  gpio_reg2hw_t reg2hw;</pre>
<pre>  gpio_hw2reg_t hw2reg;</pre>
<pre>  logic [31:0] cio_gpio_q;</pre>
<pre>  logic [31:0] cio_gpio_en_q;</pre>
<pre>  logic [31:0] data_in_d;</pre>
<pre>  for (genvar i = 0 ; i < 32 ; i++) begin : gen_filter</pre>
<pre>    prim_filter_ctr #(.Cycles(16)) filter (</pre>
<pre>      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .enable_i(reg2hw.ctrl_en_input_filter.q[i]),</pre>
<pre>      .filter_i(cio_gpio_i[i]),</pre>
<pre>      .filter_o(data_in_d[i])</pre>
<pre>  assign hw2reg.data_in.de = 1'b1;</pre>
<pre>  assign hw2reg.data_in.d  = data_in_d;</pre>
<pre>  assign cio_gpio_o                     = cio_gpio_q;</pre>
<pre>  assign cio_gpio_en_o                  = cio_gpio_en_q;</pre>
<pre>  assign hw2reg.direct_out.d            = cio_gpio_q;</pre>
<pre>  assign hw2reg.masked_out_upper.data.d = cio_gpio_q[31:16];</pre>
<pre>  assign hw2reg.masked_out_upper.mask.d = 16'h 0;</pre>
<pre>  assign hw2reg.masked_out_lower.data.d = cio_gpio_q[15:0];</pre>
<pre>  assign hw2reg.masked_out_lower.mask.d = 16'h 0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      cio_gpio_q  <= '0;</pre>
<pre>    end else if (reg2hw.direct_out.qe) begin</pre>
<pre>      cio_gpio_q <= reg2hw.direct_out.q;</pre>
<pre>    end else if (reg2hw.masked_out_upper.data.qe) begin</pre>
<pre>      cio_gpio_q[31:16] <=</pre>
<pre>        ( reg2hw.masked_out_upper.mask.q & reg2hw.masked_out_upper.data.q) |</pre>
<pre>        (~reg2hw.masked_out_upper.mask.q & cio_gpio_q[31:16]);</pre>
<pre>    end else if (reg2hw.masked_out_lower.data.qe) begin</pre>
<pre>      cio_gpio_q[15:0] <=</pre>
<pre>        ( reg2hw.masked_out_lower.mask.q & reg2hw.masked_out_lower.data.q) |</pre>
<pre>        (~reg2hw.masked_out_lower.mask.q & cio_gpio_q[15:0]);</pre>
<pre>  assign hw2reg.direct_oe.d = cio_gpio_en_q;</pre>
<pre>  assign hw2reg.masked_oe_upper.data.d = cio_gpio_en_q[31:16];</pre>
<pre>  assign hw2reg.masked_oe_upper.mask.d = 16'h 0;</pre>
<pre>  assign hw2reg.masked_oe_lower.data.d = cio_gpio_en_q[15:0];</pre>
<pre>  assign hw2reg.masked_oe_lower.mask.d = 16'h 0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      cio_gpio_en_q  <= '0;</pre>
<pre>    end else if (reg2hw.direct_oe.qe) begin</pre>
<pre>      cio_gpio_en_q <= reg2hw.direct_oe.q;</pre>
<pre>    end else if (reg2hw.masked_oe_upper.data.qe) begin</pre>
<pre>      cio_gpio_en_q[31:16] <=</pre>
<pre>        ( reg2hw.masked_oe_upper.mask.q & reg2hw.masked_oe_upper.data.q) |</pre>
<pre>        (~reg2hw.masked_oe_upper.mask.q & cio_gpio_en_q[31:16]);</pre>
<pre>    end else if (reg2hw.masked_oe_lower.data.qe) begin</pre>
<pre>      cio_gpio_en_q[15:0] <=</pre>
<pre>        ( reg2hw.masked_oe_lower.mask.q & reg2hw.masked_oe_lower.data.q) |</pre>
<pre>        (~reg2hw.masked_oe_lower.mask.q & cio_gpio_en_q[15:0]);</pre>
<pre>  logic [31:0] data_in_q;</pre>
<pre>  always_ff @(posedge clk_i) begin</pre>
<pre>    data_in_q <= data_in_d;</pre>
<pre>  logic [31:0] event_intr_rise, event_intr_fall, event_intr_actlow, event_intr_acthigh;</pre>
<pre>  logic [31:0] event_intr_combined;</pre>
<pre>  prim_intr_hw #(.Width(32)) intr_hw (</pre>
<pre>    .event_intr_i           (event_intr_combined),</pre>
<pre>    .reg2hw_intr_enable_q_i (reg2hw.intr_enable.q),</pre>
<pre>    .reg2hw_intr_test_q_i   (reg2hw.intr_test.q),</pre>
<pre>    .reg2hw_intr_test_qe_i  (reg2hw.intr_test.qe),</pre>
<pre>    .reg2hw_intr_state_q_i  (reg2hw.intr_state.q),</pre>
<pre>    .hw2reg_intr_state_de_o (hw2reg.intr_state.de),</pre>
<pre>    .hw2reg_intr_state_d_o  (hw2reg.intr_state.d),</pre>
<pre>    .intr_o                 (intr_gpio_o)</pre>
<pre>  assign event_intr_rise    = (~data_in_q &  data_in_d) & reg2hw.intr_ctrl_en_rising.q;</pre>
<pre>  assign event_intr_fall    = ( data_in_q & ~data_in_d) & reg2hw.intr_ctrl_en_falling.q;</pre>
<pre>  assign event_intr_acthigh =                data_in_d  & reg2hw.intr_ctrl_en_lvlhigh.q;</pre>
<pre>  assign event_intr_actlow  =               ~data_in_d  & reg2hw.intr_ctrl_en_lvllow.q;</pre>
<pre>  assign event_intr_combined = event_intr_rise   |</pre>
<pre>                               event_intr_fall   |</pre>
<pre>                               event_intr_actlow |</pre>
<pre>                               event_intr_acthigh;</pre>
<pre>  gpio_reg_top u_reg (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i,</pre>
<pre>    .tl_o,</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .devmode_i  (1'b1)</pre>
<h3>hw/ip/gpio/rtl/gpio_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output gpio_reg_pkg::gpio_reg2hw_t reg2hw, // Write</pre>
<pre>  input  gpio_reg_pkg::gpio_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam int AW = 6;</pre>
<pre>  localparam int DW = 32;</pre>
<pre>  localparam int DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  assign tl_reg_h2d = tl_i;</pre>
<pre>  assign tl_o       = tl_reg_d2h;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic [31:0] intr_state_qs;</pre>
<pre>  logic [31:0] intr_state_wd;</pre>
<pre>  logic intr_state_we;</pre>
<pre>  logic [31:0] intr_enable_qs;</pre>
<pre>  logic [31:0] intr_enable_wd;</pre>
<pre>  logic intr_enable_we;</pre>
<pre>  logic [31:0] intr_test_wd;</pre>
<pre>  logic intr_test_we;</pre>
<pre>  logic [31:0] data_in_qs;</pre>
<pre>  logic [31:0] direct_out_qs;</pre>
<pre>  logic [31:0] direct_out_wd;</pre>
<pre>  logic direct_out_we;</pre>
<pre>  logic direct_out_re;</pre>
<pre>  logic [15:0] masked_out_lower_data_qs;</pre>
<pre>  logic [15:0] masked_out_lower_data_wd;</pre>
<pre>  logic masked_out_lower_data_we;</pre>
<pre>  logic masked_out_lower_data_re;</pre>
<pre>  logic [15:0] masked_out_lower_mask_wd;</pre>
<pre>  logic masked_out_lower_mask_we;</pre>
<pre>  logic [15:0] masked_out_upper_data_qs;</pre>
<pre>  logic [15:0] masked_out_upper_data_wd;</pre>
<pre>  logic masked_out_upper_data_we;</pre>
<pre>  logic masked_out_upper_data_re;</pre>
<pre>  logic [15:0] masked_out_upper_mask_wd;</pre>
<pre>  logic masked_out_upper_mask_we;</pre>
<pre>  logic [31:0] direct_oe_qs;</pre>
<pre>  logic [31:0] direct_oe_wd;</pre>
<pre>  logic direct_oe_we;</pre>
<pre>  logic direct_oe_re;</pre>
<pre>  logic [15:0] masked_oe_lower_data_qs;</pre>
<pre>  logic [15:0] masked_oe_lower_data_wd;</pre>
<pre>  logic masked_oe_lower_data_we;</pre>
<pre>  logic masked_oe_lower_data_re;</pre>
<pre>  logic [15:0] masked_oe_lower_mask_qs;</pre>
<pre>  logic [15:0] masked_oe_lower_mask_wd;</pre>
<pre>  logic masked_oe_lower_mask_we;</pre>
<pre>  logic masked_oe_lower_mask_re;</pre>
<pre>  logic [15:0] masked_oe_upper_data_qs;</pre>
<pre>  logic [15:0] masked_oe_upper_data_wd;</pre>
<pre>  logic masked_oe_upper_data_we;</pre>
<pre>  logic masked_oe_upper_data_re;</pre>
<pre>  logic [15:0] masked_oe_upper_mask_qs;</pre>
<pre>  logic [15:0] masked_oe_upper_mask_wd;</pre>
<pre>  logic masked_oe_upper_mask_we;</pre>
<pre>  logic masked_oe_upper_mask_re;</pre>
<pre>  logic [31:0] intr_ctrl_en_rising_qs;</pre>
<pre>  logic [31:0] intr_ctrl_en_rising_wd;</pre>
<pre>  logic intr_ctrl_en_rising_we;</pre>
<pre>  logic [31:0] intr_ctrl_en_falling_qs;</pre>
<pre>  logic [31:0] intr_ctrl_en_falling_wd;</pre>
<pre>  logic intr_ctrl_en_falling_we;</pre>
<pre>  logic [31:0] intr_ctrl_en_lvlhigh_qs;</pre>
<pre>  logic [31:0] intr_ctrl_en_lvlhigh_wd;</pre>
<pre>  logic intr_ctrl_en_lvlhigh_we;</pre>
<pre>  logic [31:0] intr_ctrl_en_lvllow_qs;</pre>
<pre>  logic [31:0] intr_ctrl_en_lvllow_wd;</pre>
<pre>  logic intr_ctrl_en_lvllow_we;</pre>
<pre>  logic [31:0] ctrl_en_input_filter_qs;</pre>
<pre>  logic [31:0] ctrl_en_input_filter_wd;</pre>
<pre>  logic ctrl_en_input_filter_we;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_we),</pre>
<pre>    .wd     (intr_state_wd),</pre>
<pre>    .de     (hw2reg.intr_state.de),</pre>
<pre>    .d      (hw2reg.intr_state.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.q ),</pre>
<pre>    .qs     (intr_state_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_we),</pre>
<pre>    .wd     (intr_enable_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.q ),</pre>
<pre>    .qs     (intr_enable_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_we),</pre>
<pre>    .wd     (intr_test_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.qe),</pre>
<pre>    .q      (reg2hw.intr_test.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_data_in (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.data_in.de),</pre>
<pre>    .d      (hw2reg.data_in.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (data_in_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_direct_out (</pre>
<pre>    .re     (direct_out_re),</pre>
<pre>    .we     (direct_out_we),</pre>
<pre>    .wd     (direct_out_wd),</pre>
<pre>    .d      (hw2reg.direct_out.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.direct_out.qe),</pre>
<pre>    .q      (reg2hw.direct_out.q ),</pre>
<pre>    .qs     (direct_out_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_masked_out_lower_data (</pre>
<pre>    .re     (masked_out_lower_data_re),</pre>
<pre>    .we     (masked_out_lower_data_we),</pre>
<pre>    .wd     (masked_out_lower_data_wd),</pre>
<pre>    .d      (hw2reg.masked_out_lower.data.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.masked_out_lower.data.qe),</pre>
<pre>    .q      (reg2hw.masked_out_lower.data.q ),</pre>
<pre>    .qs     (masked_out_lower_data_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_masked_out_lower_mask (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (masked_out_lower_mask_we),</pre>
<pre>    .wd     (masked_out_lower_mask_wd),</pre>
<pre>    .d      (hw2reg.masked_out_lower.mask.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.masked_out_lower.mask.qe),</pre>
<pre>    .q      (reg2hw.masked_out_lower.mask.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_masked_out_upper_data (</pre>
<pre>    .re     (masked_out_upper_data_re),</pre>
<pre>    .we     (masked_out_upper_data_we),</pre>
<pre>    .wd     (masked_out_upper_data_wd),</pre>
<pre>    .d      (hw2reg.masked_out_upper.data.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.masked_out_upper.data.qe),</pre>
<pre>    .q      (reg2hw.masked_out_upper.data.q ),</pre>
<pre>    .qs     (masked_out_upper_data_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_masked_out_upper_mask (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (masked_out_upper_mask_we),</pre>
<pre>    .wd     (masked_out_upper_mask_wd),</pre>
<pre>    .d      (hw2reg.masked_out_upper.mask.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.masked_out_upper.mask.qe),</pre>
<pre>    .q      (reg2hw.masked_out_upper.mask.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (32)</pre>
<pre style="background-color: #FF0000;">  ) u_direct_oe (</pre>
<pre>    .re     (direct_oe_re),</pre>
<pre>    .we     (direct_oe_we),</pre>
<pre>    .wd     (direct_oe_wd),</pre>
<pre>    .d      (hw2reg.direct_oe.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.direct_oe.qe),</pre>
<pre>    .q      (reg2hw.direct_oe.q ),</pre>
<pre>    .qs     (direct_oe_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_masked_oe_lower_data (</pre>
<pre>    .re     (masked_oe_lower_data_re),</pre>
<pre>    .we     (masked_oe_lower_data_we),</pre>
<pre>    .wd     (masked_oe_lower_data_wd),</pre>
<pre>    .d      (hw2reg.masked_oe_lower.data.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.masked_oe_lower.data.qe),</pre>
<pre>    .q      (reg2hw.masked_oe_lower.data.q ),</pre>
<pre>    .qs     (masked_oe_lower_data_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_masked_oe_lower_mask (</pre>
<pre>    .re     (masked_oe_lower_mask_re),</pre>
<pre>    .we     (masked_oe_lower_mask_we),</pre>
<pre>    .wd     (masked_oe_lower_mask_wd),</pre>
<pre>    .d      (hw2reg.masked_oe_lower.mask.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.masked_oe_lower.mask.qe),</pre>
<pre>    .q      (reg2hw.masked_oe_lower.mask.q ),</pre>
<pre>    .qs     (masked_oe_lower_mask_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_masked_oe_upper_data (</pre>
<pre>    .re     (masked_oe_upper_data_re),</pre>
<pre>    .we     (masked_oe_upper_data_we),</pre>
<pre>    .wd     (masked_oe_upper_data_wd),</pre>
<pre>    .d      (hw2reg.masked_oe_upper.data.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.masked_oe_upper.data.qe),</pre>
<pre>    .q      (reg2hw.masked_oe_upper.data.q ),</pre>
<pre>    .qs     (masked_oe_upper_data_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (16)</pre>
<pre style="background-color: #FF0000;">  ) u_masked_oe_upper_mask (</pre>
<pre>    .re     (masked_oe_upper_mask_re),</pre>
<pre>    .we     (masked_oe_upper_mask_we),</pre>
<pre>    .wd     (masked_oe_upper_mask_wd),</pre>
<pre>    .d      (hw2reg.masked_oe_upper.mask.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.masked_oe_upper.mask.qe),</pre>
<pre>    .q      (reg2hw.masked_oe_upper.mask.q ),</pre>
<pre>    .qs     (masked_oe_upper_mask_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_ctrl_en_rising (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_ctrl_en_rising_we),</pre>
<pre>    .wd     (intr_ctrl_en_rising_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_ctrl_en_rising.q ),</pre>
<pre>    .qs     (intr_ctrl_en_rising_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_ctrl_en_falling (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_ctrl_en_falling_we),</pre>
<pre>    .wd     (intr_ctrl_en_falling_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_ctrl_en_falling.q ),</pre>
<pre>    .qs     (intr_ctrl_en_falling_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_ctrl_en_lvlhigh (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_ctrl_en_lvlhigh_we),</pre>
<pre>    .wd     (intr_ctrl_en_lvlhigh_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_ctrl_en_lvlhigh.q ),</pre>
<pre>    .qs     (intr_ctrl_en_lvlhigh_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_ctrl_en_lvllow (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_ctrl_en_lvllow_we),</pre>
<pre>    .wd     (intr_ctrl_en_lvllow_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_ctrl_en_lvllow.q ),</pre>
<pre>    .qs     (intr_ctrl_en_lvllow_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (32),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (32'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_ctrl_en_input_filter (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (ctrl_en_input_filter_we),</pre>
<pre>    .wd     (ctrl_en_input_filter_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.ctrl_en_input_filter.q ),</pre>
<pre>    .qs     (ctrl_en_input_filter_qs)</pre>
<pre>  logic [14:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[ 0] = (reg_addr == GPIO_INTR_STATE_OFFSET);</pre>
<pre>    addr_hit[ 1] = (reg_addr == GPIO_INTR_ENABLE_OFFSET);</pre>
<pre>    addr_hit[ 2] = (reg_addr == GPIO_INTR_TEST_OFFSET);</pre>
<pre>    addr_hit[ 3] = (reg_addr == GPIO_DATA_IN_OFFSET);</pre>
<pre>    addr_hit[ 4] = (reg_addr == GPIO_DIRECT_OUT_OFFSET);</pre>
<pre>    addr_hit[ 5] = (reg_addr == GPIO_MASKED_OUT_LOWER_OFFSET);</pre>
<pre>    addr_hit[ 6] = (reg_addr == GPIO_MASKED_OUT_UPPER_OFFSET);</pre>
<pre>    addr_hit[ 7] = (reg_addr == GPIO_DIRECT_OE_OFFSET);</pre>
<pre>    addr_hit[ 8] = (reg_addr == GPIO_MASKED_OE_LOWER_OFFSET);</pre>
<pre>    addr_hit[ 9] = (reg_addr == GPIO_MASKED_OE_UPPER_OFFSET);</pre>
<pre>    addr_hit[10] = (reg_addr == GPIO_INTR_CTRL_EN_RISING_OFFSET);</pre>
<pre>    addr_hit[11] = (reg_addr == GPIO_INTR_CTRL_EN_FALLING_OFFSET);</pre>
<pre>    addr_hit[12] = (reg_addr == GPIO_INTR_CTRL_EN_LVLHIGH_OFFSET);</pre>
<pre>    addr_hit[13] = (reg_addr == GPIO_INTR_CTRL_EN_LVLLOW_OFFSET);</pre>
<pre>    addr_hit[14] = (reg_addr == GPIO_CTRL_EN_INPUT_FILTER_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[ 0] && reg_we && (GPIO_PERMIT[ 0] != (GPIO_PERMIT[ 0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 1] && reg_we && (GPIO_PERMIT[ 1] != (GPIO_PERMIT[ 1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 2] && reg_we && (GPIO_PERMIT[ 2] != (GPIO_PERMIT[ 2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 3] && reg_we && (GPIO_PERMIT[ 3] != (GPIO_PERMIT[ 3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 4] && reg_we && (GPIO_PERMIT[ 4] != (GPIO_PERMIT[ 4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 5] && reg_we && (GPIO_PERMIT[ 5] != (GPIO_PERMIT[ 5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 6] && reg_we && (GPIO_PERMIT[ 6] != (GPIO_PERMIT[ 6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 7] && reg_we && (GPIO_PERMIT[ 7] != (GPIO_PERMIT[ 7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 8] && reg_we && (GPIO_PERMIT[ 8] != (GPIO_PERMIT[ 8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 9] && reg_we && (GPIO_PERMIT[ 9] != (GPIO_PERMIT[ 9] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[10] && reg_we && (GPIO_PERMIT[10] != (GPIO_PERMIT[10] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[11] && reg_we && (GPIO_PERMIT[11] != (GPIO_PERMIT[11] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[12] && reg_we && (GPIO_PERMIT[12] != (GPIO_PERMIT[12] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[13] && reg_we && (GPIO_PERMIT[13] != (GPIO_PERMIT[13] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[14] && reg_we && (GPIO_PERMIT[14] != (GPIO_PERMIT[14] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign intr_state_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_wd = reg_wdata[31:0];</pre>
<pre>  assign intr_enable_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_wd = reg_wdata[31:0];</pre>
<pre>  assign intr_test_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_wd = reg_wdata[31:0];</pre>
<pre>  assign direct_out_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign direct_out_wd = reg_wdata[31:0];</pre>
<pre>  assign direct_out_re = addr_hit[4] && reg_re;</pre>
<pre>  assign masked_out_lower_data_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign masked_out_lower_data_wd = reg_wdata[15:0];</pre>
<pre>  assign masked_out_lower_data_re = addr_hit[5] && reg_re;</pre>
<pre>  assign masked_out_lower_mask_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign masked_out_lower_mask_wd = reg_wdata[31:16];</pre>
<pre>  assign masked_out_upper_data_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign masked_out_upper_data_wd = reg_wdata[15:0];</pre>
<pre>  assign masked_out_upper_data_re = addr_hit[6] && reg_re;</pre>
<pre>  assign masked_out_upper_mask_we = addr_hit[6] & reg_we & ~wr_err;</pre>
<pre>  assign masked_out_upper_mask_wd = reg_wdata[31:16];</pre>
<pre>  assign direct_oe_we = addr_hit[7] & reg_we & ~wr_err;</pre>
<pre>  assign direct_oe_wd = reg_wdata[31:0];</pre>
<pre>  assign direct_oe_re = addr_hit[7] && reg_re;</pre>
<pre>  assign masked_oe_lower_data_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign masked_oe_lower_data_wd = reg_wdata[15:0];</pre>
<pre>  assign masked_oe_lower_data_re = addr_hit[8] && reg_re;</pre>
<pre>  assign masked_oe_lower_mask_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign masked_oe_lower_mask_wd = reg_wdata[31:16];</pre>
<pre>  assign masked_oe_lower_mask_re = addr_hit[8] && reg_re;</pre>
<pre>  assign masked_oe_upper_data_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign masked_oe_upper_data_wd = reg_wdata[15:0];</pre>
<pre>  assign masked_oe_upper_data_re = addr_hit[9] && reg_re;</pre>
<pre>  assign masked_oe_upper_mask_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign masked_oe_upper_mask_wd = reg_wdata[31:16];</pre>
<pre>  assign masked_oe_upper_mask_re = addr_hit[9] && reg_re;</pre>
<pre>  assign intr_ctrl_en_rising_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign intr_ctrl_en_rising_wd = reg_wdata[31:0];</pre>
<pre>  assign intr_ctrl_en_falling_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign intr_ctrl_en_falling_wd = reg_wdata[31:0];</pre>
<pre>  assign intr_ctrl_en_lvlhigh_we = addr_hit[12] & reg_we & ~wr_err;</pre>
<pre>  assign intr_ctrl_en_lvlhigh_wd = reg_wdata[31:0];</pre>
<pre>  assign intr_ctrl_en_lvllow_we = addr_hit[13] & reg_we & ~wr_err;</pre>
<pre>  assign intr_ctrl_en_lvllow_wd = reg_wdata[31:0];</pre>
<pre>  assign ctrl_en_input_filter_we = addr_hit[14] & reg_we & ~wr_err;</pre>
<pre>  assign ctrl_en_input_filter_wd = reg_wdata[31:0];</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[31:0] = intr_state_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[31:0] = intr_enable_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[31:0] = '0;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[31:0] = data_in_qs;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[31:0] = direct_out_qs;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[15:0] = masked_out_lower_data_qs;</pre>
<pre>        reg_rdata_next[31:16] = '0;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[15:0] = masked_out_upper_data_qs;</pre>
<pre>        reg_rdata_next[31:16] = '0;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[31:0] = direct_oe_qs;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[15:0] = masked_oe_lower_data_qs;</pre>
<pre>        reg_rdata_next[31:16] = masked_oe_lower_mask_qs;</pre>
<pre>      addr_hit[9]: begin</pre>
<pre>        reg_rdata_next[15:0] = masked_oe_upper_data_qs;</pre>
<pre>        reg_rdata_next[31:16] = masked_oe_upper_mask_qs;</pre>
<pre>      addr_hit[10]: begin</pre>
<pre>        reg_rdata_next[31:0] = intr_ctrl_en_rising_qs;</pre>
<pre>      addr_hit[11]: begin</pre>
<pre>        reg_rdata_next[31:0] = intr_ctrl_en_falling_qs;</pre>
<pre>      addr_hit[12]: begin</pre>
<pre>        reg_rdata_next[31:0] = intr_ctrl_en_lvlhigh_qs;</pre>
<pre>      addr_hit[13]: begin</pre>
<pre>        reg_rdata_next[31:0] = intr_ctrl_en_lvllow_qs;</pre>
<pre>      addr_hit[14]: begin</pre>
<pre>        reg_rdata_next[31:0] = ctrl_en_input_filter_qs;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/ip/gpio/rtl/gpio_reg_pkg.sv</h3>
<pre>package gpio_reg_pkg;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_intr_enable_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_intr_test_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_direct_out_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>      logic        qe;</pre>
<pre>    } data;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>      logic        qe;</pre>
<pre>    } mask;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_masked_out_lower_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>      logic        qe;</pre>
<pre>    } data;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>      logic        qe;</pre>
<pre>    } mask;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_masked_out_upper_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre>    logic        qe;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_direct_oe_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>      logic        qe;</pre>
<pre>    } data;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>      logic        qe;</pre>
<pre>    } mask;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_masked_oe_lower_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>      logic        qe;</pre>
<pre>    } data;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>      logic        qe;</pre>
<pre>    } mask;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_masked_oe_upper_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_intr_ctrl_en_rising_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_intr_ctrl_en_falling_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_intr_ctrl_en_lvlhigh_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_intr_ctrl_en_lvllow_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] q;</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_ctrl_en_input_filter_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } gpio_hw2reg_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre>    logic        de;</pre>
<pre style="background-color: #FF0000;">  } gpio_hw2reg_data_in_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre style="background-color: #FF0000;">  } gpio_hw2reg_direct_out_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] d;</pre>
<pre>    } data;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] d;</pre>
<pre>    } mask;</pre>
<pre style="background-color: #FF0000;">  } gpio_hw2reg_masked_out_lower_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] d;</pre>
<pre>    } data;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] d;</pre>
<pre>    } mask;</pre>
<pre style="background-color: #FF0000;">  } gpio_hw2reg_masked_out_upper_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [31:0] d;</pre>
<pre style="background-color: #FF0000;">  } gpio_hw2reg_direct_oe_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] d;</pre>
<pre>    } data;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] d;</pre>
<pre>    } mask;</pre>
<pre style="background-color: #FF0000;">  } gpio_hw2reg_masked_oe_lower_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] d;</pre>
<pre>    } data;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] d;</pre>
<pre>    } mask;</pre>
<pre style="background-color: #FF0000;">  } gpio_hw2reg_masked_oe_upper_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    gpio_reg2hw_intr_state_reg_t intr_state; // [458:427]</pre>
<pre>    gpio_reg2hw_intr_enable_reg_t intr_enable; // [426:395]</pre>
<pre>    gpio_reg2hw_intr_test_reg_t intr_test; // [394:362]</pre>
<pre>    gpio_reg2hw_direct_out_reg_t direct_out; // [361:329]</pre>
<pre>    gpio_reg2hw_masked_out_lower_reg_t masked_out_lower; // [328:295]</pre>
<pre>    gpio_reg2hw_masked_out_upper_reg_t masked_out_upper; // [294:261]</pre>
<pre>    gpio_reg2hw_direct_oe_reg_t direct_oe; // [260:228]</pre>
<pre>    gpio_reg2hw_masked_oe_lower_reg_t masked_oe_lower; // [227:194]</pre>
<pre>    gpio_reg2hw_masked_oe_upper_reg_t masked_oe_upper; // [193:160]</pre>
<pre>    gpio_reg2hw_intr_ctrl_en_rising_reg_t intr_ctrl_en_rising; // [159:128]</pre>
<pre>    gpio_reg2hw_intr_ctrl_en_falling_reg_t intr_ctrl_en_falling; // [127:96]</pre>
<pre>    gpio_reg2hw_intr_ctrl_en_lvlhigh_reg_t intr_ctrl_en_lvlhigh; // [95:64]</pre>
<pre>    gpio_reg2hw_intr_ctrl_en_lvllow_reg_t intr_ctrl_en_lvllow; // [63:32]</pre>
<pre>    gpio_reg2hw_ctrl_en_input_filter_reg_t ctrl_en_input_filter; // [31:0]</pre>
<pre style="background-color: #FF0000;">  } gpio_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    gpio_hw2reg_intr_state_reg_t intr_state; // [257:226]</pre>
<pre>    gpio_hw2reg_data_in_reg_t data_in; // [225:226]</pre>
<pre>    gpio_hw2reg_direct_out_reg_t direct_out; // [225:193]</pre>
<pre>    gpio_hw2reg_masked_out_lower_reg_t masked_out_lower; // [192:159]</pre>
<pre>    gpio_hw2reg_masked_out_upper_reg_t masked_out_upper; // [158:125]</pre>
<pre>    gpio_hw2reg_direct_oe_reg_t direct_oe; // [124:92]</pre>
<pre>    gpio_hw2reg_masked_oe_lower_reg_t masked_oe_lower; // [91:58]</pre>
<pre>    gpio_hw2reg_masked_oe_upper_reg_t masked_oe_upper; // [57:24]</pre>
<pre style="background-color: #FF0000;">  } gpio_hw2reg_t;</pre>
<pre>  parameter logic [5:0] GPIO_INTR_STATE_OFFSET = 6'h 0;</pre>
<pre>  parameter logic [5:0] GPIO_INTR_ENABLE_OFFSET = 6'h 4;</pre>
<pre>  parameter logic [5:0] GPIO_INTR_TEST_OFFSET = 6'h 8;</pre>
<pre>  parameter logic [5:0] GPIO_DATA_IN_OFFSET = 6'h c;</pre>
<pre>  parameter logic [5:0] GPIO_DIRECT_OUT_OFFSET = 6'h 10;</pre>
<pre>  parameter logic [5:0] GPIO_MASKED_OUT_LOWER_OFFSET = 6'h 14;</pre>
<pre>  parameter logic [5:0] GPIO_MASKED_OUT_UPPER_OFFSET = 6'h 18;</pre>
<pre>  parameter logic [5:0] GPIO_DIRECT_OE_OFFSET = 6'h 1c;</pre>
<pre>  parameter logic [5:0] GPIO_MASKED_OE_LOWER_OFFSET = 6'h 20;</pre>
<pre>  parameter logic [5:0] GPIO_MASKED_OE_UPPER_OFFSET = 6'h 24;</pre>
<pre>  parameter logic [5:0] GPIO_INTR_CTRL_EN_RISING_OFFSET = 6'h 28;</pre>
<pre>  parameter logic [5:0] GPIO_INTR_CTRL_EN_FALLING_OFFSET = 6'h 2c;</pre>
<pre>  parameter logic [5:0] GPIO_INTR_CTRL_EN_LVLHIGH_OFFSET = 6'h 30;</pre>
<pre>  parameter logic [5:0] GPIO_INTR_CTRL_EN_LVLLOW_OFFSET = 6'h 34;</pre>
<pre>  parameter logic [5:0] GPIO_CTRL_EN_INPUT_FILTER_OFFSET = 6'h 38;</pre>
<pre>  typedef enum int {</pre>
<pre>    GPIO_INTR_STATE,</pre>
<pre>    GPIO_INTR_ENABLE,</pre>
<pre>    GPIO_INTR_TEST,</pre>
<pre>    GPIO_DATA_IN,</pre>
<pre>    GPIO_DIRECT_OUT,</pre>
<pre>    GPIO_MASKED_OUT_LOWER,</pre>
<pre>    GPIO_MASKED_OUT_UPPER,</pre>
<pre>    GPIO_DIRECT_OE,</pre>
<pre>    GPIO_MASKED_OE_LOWER,</pre>
<pre>    GPIO_MASKED_OE_UPPER,</pre>
<pre>    GPIO_INTR_CTRL_EN_RISING,</pre>
<pre>    GPIO_INTR_CTRL_EN_FALLING,</pre>
<pre>    GPIO_INTR_CTRL_EN_LVLHIGH,</pre>
<pre>    GPIO_INTR_CTRL_EN_LVLLOW,</pre>
<pre>    GPIO_CTRL_EN_INPUT_FILTER</pre>
<pre>  } gpio_id_e;</pre>
<pre>  parameter logic [3:0] GPIO_PERMIT [15] = '{</pre>
<pre>    4'b 1111, // index[ 0] GPIO_INTR_STATE</pre>
<pre>    4'b 1111, // index[ 1] GPIO_INTR_ENABLE</pre>
<pre>    4'b 1111, // index[ 2] GPIO_INTR_TEST</pre>
<pre>    4'b 1111, // index[ 3] GPIO_DATA_IN</pre>
<pre>    4'b 1111, // index[ 4] GPIO_DIRECT_OUT</pre>
<pre>    4'b 1111, // index[ 5] GPIO_MASKED_OUT_LOWER</pre>
<pre>    4'b 1111, // index[ 6] GPIO_MASKED_OUT_UPPER</pre>
<pre>    4'b 1111, // index[ 7] GPIO_DIRECT_OE</pre>
<pre>    4'b 1111, // index[ 8] GPIO_MASKED_OE_LOWER</pre>
<pre>    4'b 1111, // index[ 9] GPIO_MASKED_OE_UPPER</pre>
<pre>    4'b 1111, // index[10] GPIO_INTR_CTRL_EN_RISING</pre>
<pre>    4'b 1111, // index[11] GPIO_INTR_CTRL_EN_FALLING</pre>
<pre>    4'b 1111, // index[12] GPIO_INTR_CTRL_EN_LVLHIGH</pre>
<pre>    4'b 1111, // index[13] GPIO_INTR_CTRL_EN_LVLLOW</pre>
<pre>    4'b 1111  // index[14] GPIO_CTRL_EN_INPUT_FILTER</pre>
<h3>hw/ip/tlul/rtl/tlul_pkg.sv</h3>
<pre>package tlul_pkg;</pre>
<pre>  parameter ArbiterImpl = "BINTREE";</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    PutFullData    = 3'h 0,</pre>
<pre>    PutPartialData = 3'h 1,</pre>
<pre>    Get            = 3'h 4</pre>
<pre>  } tl_a_op_e;</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    AccessAck     = 3'h 0,</pre>
<pre>    AccessAckData = 3'h 1</pre>
<pre>  } tl_d_op_e;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic [6:0] rsvd1; // Reserved for future use</pre>
<pre>    logic       parity_en;</pre>
<pre>    logic [7:0] parity; // Use only lower TL_DBW bit</pre>
<pre style="background-color: #FF0000;">  } tl_a_user_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic                         a_valid;</pre>
<pre>    tl_a_op_e                     a_opcode;</pre>
<pre>    logic                  [2:0]  a_param;</pre>
<pre>    logic  [top_pkg::TL_SZW-1:0]  a_size;</pre>
<pre>    logic  [top_pkg::TL_AIW-1:0]  a_source;</pre>
<pre>    logic   [top_pkg::TL_AW-1:0]  a_address;</pre>
<pre>    logic  [top_pkg::TL_DBW-1:0]  a_mask;</pre>
<pre>    logic   [top_pkg::TL_DW-1:0]  a_data;</pre>
<pre>    tl_a_user_t                   a_user;</pre>
<pre>    logic                         d_ready;</pre>
<pre style="background-color: #FF0000;">  } tl_h2d_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    logic                         d_valid;</pre>
<pre>    tl_d_op_e                     d_opcode;</pre>
<pre>    logic                  [2:0]  d_param;</pre>
<pre>    logic  [top_pkg::TL_SZW-1:0]  d_size;   // Bouncing back a_size</pre>
<pre>    logic  [top_pkg::TL_AIW-1:0]  d_source;</pre>
<pre>    logic  [top_pkg::TL_DIW-1:0]  d_sink;</pre>
<pre>    logic   [top_pkg::TL_DW-1:0]  d_data;</pre>
<pre>    logic  [top_pkg::TL_DUW-1:0]  d_user;</pre>
<pre>    logic                         d_error;</pre>
<pre>    logic                         a_ready;</pre>
<pre style="background-color: #FF0000;">  } tl_d2h_t;</pre>
<h3>hw/ip/tlul/rtl/tlul_socket_m1.sv</h3>
<pre>module tlul_socket_m1 #(</pre>
<pre>  parameter int unsigned  M         = 4,</pre>
<pre>  parameter bit [M-1:0]   HReqPass  = {M{1'b1}},</pre>
<pre>  parameter bit [M-1:0]   HRspPass  = {M{1'b1}},</pre>
<pre>  parameter bit [M*4-1:0] HReqDepth = {M{4'h2}},</pre>
<pre>  parameter bit [M*4-1:0] HRspDepth = {M{4'h2}},</pre>
<pre>  parameter bit           DReqPass  = 1'b1,</pre>
<pre>  parameter bit           DRspPass  = 1'b1,</pre>
<pre>  parameter bit [3:0]     DReqDepth = 4'h2,</pre>
<pre>  parameter bit [3:0]     DRspDepth = 4'h2</pre>
<pre>  input                     clk_i,</pre>
<pre>  input                     rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_h_i [M],</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_h_o [M],</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_d_o,</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_d_i</pre>
<pre>  localparam int unsigned STIDW = $clog2(M);</pre>
<pre></pre>
<pre>  tlul_pkg::tl_d2h_t hrsp_fifo_i [M];</pre>
<pre></pre>
<pre>  logic [M-1:0] hgrant;</pre>
<pre></pre>
<pre>  tlul_pkg::tl_d2h_t drsp_fifo_o;</pre>
<pre></pre>
<pre>  logic arb_ready;</pre>
<pre>  tlul_pkg::tl_h2d_t arb_data;</pre>
<pre></pre>
<pre>    tlul_pkg::tl_h2d_t hreq_fifo_i;</pre>
<pre></pre>
<pre>    logic [IDW-1:0] shifted_id;</pre>
<pre>    assign reqid_sub = i;   // can cause conversion error?</pre>
<pre>    assign shifted_id = {</pre>
<pre>      tl_h_i[i].a_source[0+:(IDW-STIDW)],</pre>
<pre>      reqid_sub</pre>
<pre>    };</pre>
<pre>    assign unused_tl_h_source = tl_h_i[i].a_source[IDW-1 -: STIDW];</pre>
<pre></pre>
<pre>      a_valid:    tl_h_i[i].a_valid,</pre>
<pre>      a_opcode:   tl_h_i[i].a_opcode,</pre>
<pre>      a_param:    tl_h_i[i].a_param,</pre>
<pre>      a_size:     tl_h_i[i].a_size,</pre>
<pre>      a_source:   shifted_id,</pre>
<pre>      a_address:  tl_h_i[i].a_address,</pre>
<pre>      a_mask:     tl_h_i[i].a_mask,</pre>
<pre>      a_data:     tl_h_i[i].a_data,</pre>
<pre>      a_user:     tl_h_i[i].a_user,</pre>
<pre>      d_ready:    tl_h_i[i].d_ready</pre>
<pre>    };</pre>
<pre style="background-color: #FF0000;"></pre>
<pre>      .ReqPass    (HReqPass[i]),</pre>
<pre>      .RspPass    (HRspPass[i]),</pre>
<pre>      .ReqDepth   (HReqDepth[i*4+:4]),</pre>
<pre>      .RspDepth   (HRspDepth[i*4+:4]),</pre>
<pre>      .SpareReqW  (1)</pre>
<pre>    ) u_hostfifo (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .tl_h_i      (hreq_fifo_i),</pre>
<pre>      .tl_h_o      (tl_h_o[i]),</pre>
<pre>      .tl_d_o      (hreq_fifo_o[i]),</pre>
<pre>      .tl_d_i      (hrsp_fifo_i[i]),</pre>
<pre>      .spare_req_i (1'b0),</pre>
<pre>      .spare_req_o (),</pre>
<pre>      .spare_rsp_i (1'b0),</pre>
<pre>      .spare_rsp_o ()</pre>
<pre>    );</pre>
<pre>    .ReqPass    (DReqPass),</pre>
<pre>    .RspPass    (DRspPass),</pre>
<pre>    .ReqDepth   (DReqDepth),</pre>
<pre>    .RspDepth   (DRspDepth),</pre>
<pre>    .SpareReqW  (1)</pre>
<pre>  ) u_devicefifo (</pre>
<pre style="background-color: #FF0000;">    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_h_i      (dreq_fifo_i),</pre>
<pre>    .tl_h_o      (drsp_fifo_o),</pre>
<pre>    .tl_d_o      (tl_d_o),</pre>
<pre>    .tl_d_i      (tl_d_i),</pre>
<pre>    .spare_req_i (1'b0),</pre>
<pre>    .spare_req_o (),</pre>
<pre>    .spare_rsp_i (1'b0),</pre>
<pre>    .spare_rsp_o ()</pre>
<pre>  );</pre>
<pre>    assign hrequest[i] = hreq_fifo_o[i].a_valid;</pre>
<pre>  end</pre>
<pre></pre>
<pre style="background-color: #FF0000;">    prim_arbiter_ppc #(</pre>
<pre style="background-color: #FF0000;">      .N      (M),</pre>
<pre style="background-color: #FF0000;">      .DW     ($bits(tlul_pkg::tl_h2d_t))</pre>
<pre style="background-color: #FF0000;">    ) u_reqarb (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre style="background-color: #FF0000;">      .rst_ni,</pre>
<pre style="background-color: #FF0000;">      .req_i   ( hrequest    ),</pre>
<pre style="background-color: #FF0000;">      .data_i  ( hreq_fifo_o ),</pre>
<pre style="background-color: #FF0000;">      .gnt_o   ( hgrant      ),</pre>
<pre style="background-color: #FF0000;">      .idx_o   (             ),</pre>
<pre style="background-color: #FF0000;">      .valid_o ( arb_valid   ),</pre>
<pre style="background-color: #FF0000;">      .data_o  ( arb_data    ),</pre>
<pre style="background-color: #FF0000;">      .ready_i ( arb_ready   )</pre>
<pre style="background-color: #FF0000;">    );</pre>
<pre style="background-color: #FF0000;">    prim_arbiter_tree #(</pre>
<pre>      .N      (M),</pre>
<pre>      .DW     ($bits(tlul_pkg::tl_h2d_t))</pre>
<pre>    ) u_reqarb (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre>      .rst_ni,</pre>
<pre>      .req_i   ( hrequest    ),</pre>
<pre>      .data_i  ( hreq_fifo_o ),</pre>
<pre>      .gnt_o   ( hgrant      ),</pre>
<pre>      .idx_o   (             ),</pre>
<pre>      .valid_o ( arb_valid   ),</pre>
<pre>      .data_o  ( arb_data    ),</pre>
<pre>      .ready_i ( arb_ready   )</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">    `ASSERT_INIT(UnknownArbImpl_A, 0)</pre>
<pre>  logic [  M-1:0] dfifo_rspready;</pre>
<pre>  logic [IDW-1:0] hfifo_rspid;</pre>
<pre>  logic dfifo_rspready_merged;</pre>
<pre></pre>
<pre>  assign dreq_fifo_i = '{</pre>
<pre>    a_valid:   arb_valid,</pre>
<pre>    a_opcode:  arb_data.a_opcode,</pre>
<pre>    a_param:   arb_data.a_param,</pre>
<pre>    a_size:    arb_data.a_size,</pre>
<pre>    a_source:  arb_data.a_source,</pre>
<pre>    a_address: arb_data.a_address,</pre>
<pre>    a_mask:    arb_data.a_mask,</pre>
<pre>    a_data:    arb_data.a_data,</pre>
<pre>    a_user:    arb_data.a_user,</pre>
<pre></pre>
<pre>  };</pre>
<pre>    {STIDW{1'b0}},</pre>
<pre>    drsp_fifo_o.d_source[IDW-1:STIDW]</pre>
<pre>  };</pre>
<pre>    assign hfifo_rspvalid[i] = drsp_fifo_o.d_valid &</pre>
<pre>                               (drsp_fifo_o.d_source[0+:STIDW] == i);</pre>
<pre>    assign dfifo_rspready[i] = hreq_fifo_o[i].d_ready                &</pre>
<pre>                               (drsp_fifo_o.d_source[0+:STIDW] == i) &</pre>
<pre>                              drsp_fifo_o.d_valid;</pre>
<pre></pre>
<pre>      d_valid:  hfifo_rspvalid[i],</pre>
<pre>      d_opcode: drsp_fifo_o.d_opcode,</pre>
<pre>      d_param:  drsp_fifo_o.d_param,</pre>
<pre>      d_size:   drsp_fifo_o.d_size,</pre>
<pre>      d_source: hfifo_rspid,</pre>
<pre>      d_sink:   drsp_fifo_o.d_sink,</pre>
<pre>      d_data:   drsp_fifo_o.d_data,</pre>
<pre>      d_user:   drsp_fifo_o.d_user,</pre>
<pre>      d_error:  drsp_fifo_o.d_error,</pre>
<pre>      a_ready:  hgrant[i]</pre>
<pre>    };</pre>
<h3>hw/ip/prim_xilinx/rtl/prim_xilinx_pad_wrapper.sv</h3>
<pre>module prim_xilinx_pad_wrapper #(</pre>
<pre>  parameter int unsigned AttrDw = 2</pre>
<pre>  inout wire         inout_io, // bidirectional pad</pre>
<pre>  output logic       in_o,     // input data</pre>
<pre>  input              out_i,    // output data</pre>
<pre>  input              oe_i,     // output enable</pre>
<pre>  input [AttrDw-1:0] attr_i</pre>
<pre>  logic od, inv;</pre>
<pre>  assign {od, inv} = attr_i[1:0];</pre>
<pre>  assign in_o     = inv ^ inout_io;</pre>
<pre>  logic oe, out;</pre>
<pre>  assign out      = out_i ^ inv;</pre>
<pre>  assign oe       = oe_i & ((od & ~out) | ~od);</pre>
<pre>  assign inout_io = (oe) ? out : 1'bz;</pre>
<pre style="background-color: #FF0000;">endmodule : prim_xilinx_pad_wrapper</pre>
<h3>hw/ip/prim/abstract/prim_clock_gating.sv</h3>
<pre>  parameter prim_pkg::impl_e Impl = `PRIM_DEFAULT_IMPL</pre>
<pre>) (</pre>
<pre>  input        en_i,</pre>
<pre>  input        test_en_i,</pre>
<pre>  output logic clk_o</pre>
<pre>);</pre>
<pre>    prim_generic_clock_gating u_impl_generic (</pre>
<pre>      .clk_i,</pre>
<pre>      .en_i,</pre>
<pre>      .test_en_i,</pre>
<pre>      .clk_o</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">    prim_xilinx_clock_gating u_impl_xilinx (</pre>
<pre style="background-color: #FF0000;">      .clk_i,</pre>
<pre style="background-color: #FF0000;">      .en_i,</pre>
<pre style="background-color: #FF0000;">      .test_en_i,</pre>
<pre style="background-color: #FF0000;">      .clk_o</pre>
<pre style="background-color: #FF0000;">    );</pre>
<pre style="background-color: #FF0000;">    // TODO: Find code that works across tools and causes a compile failure</pre>
<h3>hw/ip/spi_device/rtl/spi_device_reg_top.sv</h3>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  output tlul_pkg::tl_h2d_t tl_win_o  [1],</pre>
<pre>  input  tlul_pkg::tl_d2h_t tl_win_i  [1],</pre>
<pre>  output spi_device_reg_pkg::spi_device_reg2hw_t reg2hw, // Write</pre>
<pre>  input  spi_device_reg_pkg::spi_device_hw2reg_t hw2reg, // Read</pre>
<pre>  input devmode_i // If 1, explicit error return for unmapped register access</pre>
<pre>  localparam int AW = 12;</pre>
<pre>  localparam int DW = 32;</pre>
<pre>  localparam int DBW = DW/8;                    // Byte Width</pre>
<pre>  logic           reg_we;</pre>
<pre>  logic           reg_re;</pre>
<pre>  logic [AW-1:0]  reg_addr;</pre>
<pre>  logic [DW-1:0]  reg_wdata;</pre>
<pre>  logic [DBW-1:0] reg_be;</pre>
<pre>  logic [DW-1:0]  reg_rdata;</pre>
<pre>  logic           reg_error;</pre>
<pre>  logic          addrmiss, wr_err;</pre>
<pre>  logic [DW-1:0] reg_rdata_next;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_reg_h2d;</pre>
<pre>  tlul_pkg::tl_d2h_t tl_reg_d2h;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_socket_h2d [2];</pre>
<pre>  tlul_pkg::tl_d2h_t tl_socket_d2h [2];</pre>
<pre>  logic [1:0] reg_steer;</pre>
<pre>  assign tl_reg_h2d = tl_socket_h2d[1];</pre>
<pre>  assign tl_socket_d2h[1] = tl_reg_d2h;</pre>
<pre>  assign tl_win_o[0] = tl_socket_h2d[0];</pre>
<pre>  assign tl_socket_d2h[0] = tl_win_i[0];</pre>
<pre>  tlul_socket_1n #(</pre>
<pre>    .N          (2),</pre>
<pre>    .HReqPass   (1'b1),</pre>
<pre>    .HRspPass   (1'b1),</pre>
<pre>    .DReqPass   ({2{1'b1}}),</pre>
<pre>    .DRspPass   ({2{1'b1}}),</pre>
<pre>    .HReqDepth  (4'h0),</pre>
<pre>    .HRspDepth  (4'h0),</pre>
<pre>    .DReqDepth  ({2{4'h0}}),</pre>
<pre>    .DRspDepth  ({2{4'h0}})</pre>
<pre style="background-color: #FF0000;">  ) u_socket (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_h_i (tl_i),</pre>
<pre>    .tl_h_o (tl_o),</pre>
<pre>    .tl_d_o (tl_socket_h2d),</pre>
<pre>    .tl_d_i (tl_socket_d2h),</pre>
<pre>    .dev_select (reg_steer)</pre>
<pre>  always_comb begin</pre>
<pre>    reg_steer = 1;       // Default set to register</pre>
<pre>    if (tl_i.a_address[AW-1:0] >= 2048) begin</pre>
<pre>      reg_steer = 0;</pre>
<pre>  tlul_adapter_reg #(</pre>
<pre>    .RegAw(AW),</pre>
<pre>    .RegDw(DW)</pre>
<pre style="background-color: #FF0000;">  ) u_reg_if (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_reg_h2d),</pre>
<pre>    .tl_o (tl_reg_d2h),</pre>
<pre>    .we_o    (reg_we),</pre>
<pre>    .re_o    (reg_re),</pre>
<pre>    .addr_o  (reg_addr),</pre>
<pre>    .wdata_o (reg_wdata),</pre>
<pre>    .be_o    (reg_be),</pre>
<pre>    .rdata_i (reg_rdata),</pre>
<pre>    .error_i (reg_error)</pre>
<pre>  assign reg_rdata = reg_rdata_next ;</pre>
<pre>  assign reg_error = (devmode_i & addrmiss) | wr_err ;</pre>
<pre>  logic intr_state_rxf_qs;</pre>
<pre>  logic intr_state_rxf_wd;</pre>
<pre>  logic intr_state_rxf_we;</pre>
<pre>  logic intr_state_rxlvl_qs;</pre>
<pre>  logic intr_state_rxlvl_wd;</pre>
<pre>  logic intr_state_rxlvl_we;</pre>
<pre>  logic intr_state_txlvl_qs;</pre>
<pre>  logic intr_state_txlvl_wd;</pre>
<pre>  logic intr_state_txlvl_we;</pre>
<pre>  logic intr_state_rxerr_qs;</pre>
<pre>  logic intr_state_rxerr_wd;</pre>
<pre>  logic intr_state_rxerr_we;</pre>
<pre>  logic intr_state_rxoverflow_qs;</pre>
<pre>  logic intr_state_rxoverflow_wd;</pre>
<pre>  logic intr_state_rxoverflow_we;</pre>
<pre>  logic intr_state_txunderflow_qs;</pre>
<pre>  logic intr_state_txunderflow_wd;</pre>
<pre>  logic intr_state_txunderflow_we;</pre>
<pre>  logic intr_enable_rxf_qs;</pre>
<pre>  logic intr_enable_rxf_wd;</pre>
<pre>  logic intr_enable_rxf_we;</pre>
<pre>  logic intr_enable_rxlvl_qs;</pre>
<pre>  logic intr_enable_rxlvl_wd;</pre>
<pre>  logic intr_enable_rxlvl_we;</pre>
<pre>  logic intr_enable_txlvl_qs;</pre>
<pre>  logic intr_enable_txlvl_wd;</pre>
<pre>  logic intr_enable_txlvl_we;</pre>
<pre>  logic intr_enable_rxerr_qs;</pre>
<pre>  logic intr_enable_rxerr_wd;</pre>
<pre>  logic intr_enable_rxerr_we;</pre>
<pre>  logic intr_enable_rxoverflow_qs;</pre>
<pre>  logic intr_enable_rxoverflow_wd;</pre>
<pre>  logic intr_enable_rxoverflow_we;</pre>
<pre>  logic intr_enable_txunderflow_qs;</pre>
<pre>  logic intr_enable_txunderflow_wd;</pre>
<pre>  logic intr_enable_txunderflow_we;</pre>
<pre>  logic intr_test_rxf_wd;</pre>
<pre>  logic intr_test_rxf_we;</pre>
<pre>  logic intr_test_rxlvl_wd;</pre>
<pre>  logic intr_test_rxlvl_we;</pre>
<pre>  logic intr_test_txlvl_wd;</pre>
<pre>  logic intr_test_txlvl_we;</pre>
<pre>  logic intr_test_rxerr_wd;</pre>
<pre>  logic intr_test_rxerr_we;</pre>
<pre>  logic intr_test_rxoverflow_wd;</pre>
<pre>  logic intr_test_rxoverflow_we;</pre>
<pre>  logic intr_test_txunderflow_wd;</pre>
<pre>  logic intr_test_txunderflow_we;</pre>
<pre>  logic control_abort_qs;</pre>
<pre>  logic control_abort_wd;</pre>
<pre>  logic control_abort_we;</pre>
<pre>  logic [1:0] control_mode_qs;</pre>
<pre>  logic [1:0] control_mode_wd;</pre>
<pre>  logic control_mode_we;</pre>
<pre>  logic control_rst_txfifo_qs;</pre>
<pre>  logic control_rst_txfifo_wd;</pre>
<pre>  logic control_rst_txfifo_we;</pre>
<pre>  logic control_rst_rxfifo_qs;</pre>
<pre>  logic control_rst_rxfifo_wd;</pre>
<pre>  logic control_rst_rxfifo_we;</pre>
<pre>  logic cfg_cpol_qs;</pre>
<pre>  logic cfg_cpol_wd;</pre>
<pre>  logic cfg_cpol_we;</pre>
<pre>  logic cfg_cpha_qs;</pre>
<pre>  logic cfg_cpha_wd;</pre>
<pre>  logic cfg_cpha_we;</pre>
<pre>  logic cfg_tx_order_qs;</pre>
<pre>  logic cfg_tx_order_wd;</pre>
<pre>  logic cfg_tx_order_we;</pre>
<pre>  logic cfg_rx_order_qs;</pre>
<pre>  logic cfg_rx_order_wd;</pre>
<pre>  logic cfg_rx_order_we;</pre>
<pre>  logic [7:0] cfg_timer_v_qs;</pre>
<pre>  logic [7:0] cfg_timer_v_wd;</pre>
<pre>  logic cfg_timer_v_we;</pre>
<pre>  logic [15:0] fifo_level_rxlvl_qs;</pre>
<pre>  logic [15:0] fifo_level_rxlvl_wd;</pre>
<pre>  logic fifo_level_rxlvl_we;</pre>
<pre>  logic [15:0] fifo_level_txlvl_qs;</pre>
<pre>  logic [15:0] fifo_level_txlvl_wd;</pre>
<pre>  logic fifo_level_txlvl_we;</pre>
<pre>  logic [7:0] async_fifo_level_rxlvl_qs;</pre>
<pre>  logic async_fifo_level_rxlvl_re;</pre>
<pre>  logic [7:0] async_fifo_level_txlvl_qs;</pre>
<pre>  logic async_fifo_level_txlvl_re;</pre>
<pre>  logic status_rxf_full_qs;</pre>
<pre>  logic status_rxf_full_re;</pre>
<pre>  logic status_rxf_empty_qs;</pre>
<pre>  logic status_rxf_empty_re;</pre>
<pre>  logic status_txf_full_qs;</pre>
<pre>  logic status_txf_full_re;</pre>
<pre>  logic status_txf_empty_qs;</pre>
<pre>  logic status_txf_empty_re;</pre>
<pre>  logic status_abort_done_qs;</pre>
<pre>  logic status_abort_done_re;</pre>
<pre>  logic status_csb_qs;</pre>
<pre>  logic status_csb_re;</pre>
<pre>  logic [15:0] rxf_ptr_rptr_qs;</pre>
<pre>  logic [15:0] rxf_ptr_rptr_wd;</pre>
<pre>  logic rxf_ptr_rptr_we;</pre>
<pre>  logic [15:0] rxf_ptr_wptr_qs;</pre>
<pre>  logic [15:0] txf_ptr_rptr_qs;</pre>
<pre>  logic [15:0] txf_ptr_wptr_qs;</pre>
<pre>  logic [15:0] txf_ptr_wptr_wd;</pre>
<pre>  logic txf_ptr_wptr_we;</pre>
<pre>  logic [15:0] rxf_addr_base_qs;</pre>
<pre>  logic [15:0] rxf_addr_base_wd;</pre>
<pre>  logic rxf_addr_base_we;</pre>
<pre>  logic [15:0] rxf_addr_limit_qs;</pre>
<pre>  logic [15:0] rxf_addr_limit_wd;</pre>
<pre>  logic rxf_addr_limit_we;</pre>
<pre>  logic [15:0] txf_addr_base_qs;</pre>
<pre>  logic [15:0] txf_addr_base_wd;</pre>
<pre>  logic txf_addr_base_we;</pre>
<pre>  logic [15:0] txf_addr_limit_qs;</pre>
<pre>  logic [15:0] txf_addr_limit_wd;</pre>
<pre>  logic txf_addr_limit_we;</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rxf (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rxf_we),</pre>
<pre>    .wd     (intr_state_rxf_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rxf.de),</pre>
<pre>    .d      (hw2reg.intr_state.rxf.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rxf.q ),</pre>
<pre>    .qs     (intr_state_rxf_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rxlvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rxlvl_we),</pre>
<pre>    .wd     (intr_state_rxlvl_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rxlvl.de),</pre>
<pre>    .d      (hw2reg.intr_state.rxlvl.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rxlvl.q ),</pre>
<pre>    .qs     (intr_state_rxlvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_txlvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_txlvl_we),</pre>
<pre>    .wd     (intr_state_txlvl_wd),</pre>
<pre>    .de     (hw2reg.intr_state.txlvl.de),</pre>
<pre>    .d      (hw2reg.intr_state.txlvl.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.txlvl.q ),</pre>
<pre>    .qs     (intr_state_txlvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rxerr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rxerr_we),</pre>
<pre>    .wd     (intr_state_rxerr_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rxerr.de),</pre>
<pre>    .d      (hw2reg.intr_state.rxerr.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rxerr.q ),</pre>
<pre>    .qs     (intr_state_rxerr_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_rxoverflow (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_rxoverflow_we),</pre>
<pre>    .wd     (intr_state_rxoverflow_wd),</pre>
<pre>    .de     (hw2reg.intr_state.rxoverflow.de),</pre>
<pre>    .d      (hw2reg.intr_state.rxoverflow.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.rxoverflow.q ),</pre>
<pre>    .qs     (intr_state_rxoverflow_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("W1C"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_state_txunderflow (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_state_txunderflow_we),</pre>
<pre>    .wd     (intr_state_txunderflow_wd),</pre>
<pre>    .de     (hw2reg.intr_state.txunderflow.de),</pre>
<pre>    .d      (hw2reg.intr_state.txunderflow.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_state.txunderflow.q ),</pre>
<pre>    .qs     (intr_state_txunderflow_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rxf (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rxf_we),</pre>
<pre>    .wd     (intr_enable_rxf_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rxf.q ),</pre>
<pre>    .qs     (intr_enable_rxf_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rxlvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rxlvl_we),</pre>
<pre>    .wd     (intr_enable_rxlvl_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rxlvl.q ),</pre>
<pre>    .qs     (intr_enable_rxlvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_txlvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_txlvl_we),</pre>
<pre>    .wd     (intr_enable_txlvl_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.txlvl.q ),</pre>
<pre>    .qs     (intr_enable_txlvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rxerr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rxerr_we),</pre>
<pre>    .wd     (intr_enable_rxerr_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rxerr.q ),</pre>
<pre>    .qs     (intr_enable_rxerr_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_rxoverflow (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_rxoverflow_we),</pre>
<pre>    .wd     (intr_enable_rxoverflow_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.rxoverflow.q ),</pre>
<pre>    .qs     (intr_enable_rxoverflow_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_enable_txunderflow (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (intr_enable_txunderflow_we),</pre>
<pre>    .wd     (intr_enable_txunderflow_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.intr_enable.txunderflow.q ),</pre>
<pre>    .qs     (intr_enable_txunderflow_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rxf (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rxf_we),</pre>
<pre>    .wd     (intr_test_rxf_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rxf.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rxf.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rxlvl (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rxlvl_we),</pre>
<pre>    .wd     (intr_test_rxlvl_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rxlvl.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rxlvl.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_txlvl (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_txlvl_we),</pre>
<pre>    .wd     (intr_test_txlvl_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.txlvl.qe),</pre>
<pre>    .q      (reg2hw.intr_test.txlvl.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rxerr (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rxerr_we),</pre>
<pre>    .wd     (intr_test_rxerr_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rxerr.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rxerr.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_rxoverflow (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_rxoverflow_we),</pre>
<pre>    .wd     (intr_test_rxoverflow_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.rxoverflow.qe),</pre>
<pre>    .q      (reg2hw.intr_test.rxoverflow.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_intr_test_txunderflow (</pre>
<pre>    .re     (1'b0),</pre>
<pre>    .we     (intr_test_txunderflow_we),</pre>
<pre>    .wd     (intr_test_txunderflow_wd),</pre>
<pre>    .d      ('0),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (reg2hw.intr_test.txunderflow.qe),</pre>
<pre>    .q      (reg2hw.intr_test.txunderflow.q ),</pre>
<pre>    .qs     ()</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_control_abort (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (control_abort_we),</pre>
<pre>    .wd     (control_abort_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.control.abort.q ),</pre>
<pre>    .qs     (control_abort_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (2),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (2'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_control_mode (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (control_mode_we),</pre>
<pre>    .wd     (control_mode_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.control.mode.q ),</pre>
<pre>    .qs     (control_mode_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_control_rst_txfifo (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (control_rst_txfifo_we),</pre>
<pre>    .wd     (control_rst_txfifo_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.control.rst_txfifo.q ),</pre>
<pre>    .qs     (control_rst_txfifo_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_control_rst_rxfifo (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (control_rst_rxfifo_we),</pre>
<pre>    .wd     (control_rst_rxfifo_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.control.rst_rxfifo.q ),</pre>
<pre>    .qs     (control_rst_rxfifo_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg_cpol (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (cfg_cpol_we),</pre>
<pre>    .wd     (cfg_cpol_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.cfg.cpol.q ),</pre>
<pre>    .qs     (cfg_cpol_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg_cpha (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (cfg_cpha_we),</pre>
<pre>    .wd     (cfg_cpha_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.cfg.cpha.q ),</pre>
<pre>    .qs     (cfg_cpha_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg_tx_order (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (cfg_tx_order_we),</pre>
<pre>    .wd     (cfg_tx_order_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.cfg.tx_order.q ),</pre>
<pre>    .qs     (cfg_tx_order_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (1),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (1'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg_rx_order (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (cfg_rx_order_we),</pre>
<pre>    .wd     (cfg_rx_order_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.cfg.rx_order.q ),</pre>
<pre>    .qs     (cfg_rx_order_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (8),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (8'h7f)</pre>
<pre style="background-color: #FF0000;">  ) u_cfg_timer_v (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (cfg_timer_v_we),</pre>
<pre>    .wd     (cfg_timer_v_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.cfg.timer_v.q ),</pre>
<pre>    .qs     (cfg_timer_v_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h80)</pre>
<pre style="background-color: #FF0000;">  ) u_fifo_level_rxlvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (fifo_level_rxlvl_we),</pre>
<pre>    .wd     (fifo_level_rxlvl_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.fifo_level.rxlvl.q ),</pre>
<pre>    .qs     (fifo_level_rxlvl_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_fifo_level_txlvl (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (fifo_level_txlvl_we),</pre>
<pre>    .wd     (fifo_level_txlvl_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.fifo_level.txlvl.q ),</pre>
<pre>    .qs     (fifo_level_txlvl_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (8)</pre>
<pre style="background-color: #FF0000;">  ) u_async_fifo_level_rxlvl (</pre>
<pre>    .re     (async_fifo_level_rxlvl_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.async_fifo_level.rxlvl.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (async_fifo_level_rxlvl_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (8)</pre>
<pre style="background-color: #FF0000;">  ) u_async_fifo_level_txlvl (</pre>
<pre>    .re     (async_fifo_level_txlvl_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.async_fifo_level.txlvl.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (async_fifo_level_txlvl_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_rxf_full (</pre>
<pre>    .re     (status_rxf_full_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.rxf_full.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_rxf_full_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_rxf_empty (</pre>
<pre>    .re     (status_rxf_empty_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.rxf_empty.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_rxf_empty_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_txf_full (</pre>
<pre>    .re     (status_txf_full_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.txf_full.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_txf_full_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_txf_empty (</pre>
<pre>    .re     (status_txf_empty_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.txf_empty.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_txf_empty_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_abort_done (</pre>
<pre>    .re     (status_abort_done_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.abort_done.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_abort_done_qs)</pre>
<pre>  prim_subreg_ext #(</pre>
<pre>    .DW    (1)</pre>
<pre style="background-color: #FF0000;">  ) u_status_csb (</pre>
<pre>    .re     (status_csb_re),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0),</pre>
<pre>    .d      (hw2reg.status.csb.d),</pre>
<pre>    .qre    (),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (status_csb_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxf_ptr_rptr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxf_ptr_rptr_we),</pre>
<pre>    .wd     (rxf_ptr_rptr_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxf_ptr.rptr.q ),</pre>
<pre>    .qs     (rxf_ptr_rptr_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxf_ptr_wptr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.rxf_ptr.wptr.de),</pre>
<pre>    .d      (hw2reg.rxf_ptr.wptr.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (rxf_ptr_wptr_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RO"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_txf_ptr_rptr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (1'b0),</pre>
<pre>    .wd     ('0  ),</pre>
<pre>    .de     (hw2reg.txf_ptr.rptr.de),</pre>
<pre>    .d      (hw2reg.txf_ptr.rptr.d ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (),</pre>
<pre>    .qs     (txf_ptr_rptr_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_txf_ptr_wptr (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (txf_ptr_wptr_we),</pre>
<pre>    .wd     (txf_ptr_wptr_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.txf_ptr.wptr.q ),</pre>
<pre>    .qs     (txf_ptr_wptr_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h0)</pre>
<pre style="background-color: #FF0000;">  ) u_rxf_addr_base (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxf_addr_base_we),</pre>
<pre>    .wd     (rxf_addr_base_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxf_addr.base.q ),</pre>
<pre>    .qs     (rxf_addr_base_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h1fc)</pre>
<pre style="background-color: #FF0000;">  ) u_rxf_addr_limit (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (rxf_addr_limit_we),</pre>
<pre>    .wd     (rxf_addr_limit_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.rxf_addr.limit.q ),</pre>
<pre>    .qs     (rxf_addr_limit_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h200)</pre>
<pre style="background-color: #FF0000;">  ) u_txf_addr_base (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (txf_addr_base_we),</pre>
<pre>    .wd     (txf_addr_base_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.txf_addr.base.q ),</pre>
<pre>    .qs     (txf_addr_base_qs)</pre>
<pre>  prim_subreg #(</pre>
<pre>    .DW      (16),</pre>
<pre>    .SWACCESS("RW"),</pre>
<pre>    .RESVAL  (16'h3fc)</pre>
<pre style="background-color: #FF0000;">  ) u_txf_addr_limit (</pre>
<pre>    .clk_i   (clk_i    ),</pre>
<pre>    .rst_ni  (rst_ni  ),</pre>
<pre>    .we     (txf_addr_limit_we),</pre>
<pre>    .wd     (txf_addr_limit_wd),</pre>
<pre>    .de     (1'b0),</pre>
<pre>    .d      ('0  ),</pre>
<pre>    .qe     (),</pre>
<pre>    .q      (reg2hw.txf_addr.limit.q ),</pre>
<pre>    .qs     (txf_addr_limit_qs)</pre>
<pre>  logic [11:0] addr_hit;</pre>
<pre>  always_comb begin</pre>
<pre>    addr_hit = '0;</pre>
<pre>    addr_hit[ 0] = (reg_addr == SPI_DEVICE_INTR_STATE_OFFSET);</pre>
<pre>    addr_hit[ 1] = (reg_addr == SPI_DEVICE_INTR_ENABLE_OFFSET);</pre>
<pre>    addr_hit[ 2] = (reg_addr == SPI_DEVICE_INTR_TEST_OFFSET);</pre>
<pre>    addr_hit[ 3] = (reg_addr == SPI_DEVICE_CONTROL_OFFSET);</pre>
<pre>    addr_hit[ 4] = (reg_addr == SPI_DEVICE_CFG_OFFSET);</pre>
<pre>    addr_hit[ 5] = (reg_addr == SPI_DEVICE_FIFO_LEVEL_OFFSET);</pre>
<pre>    addr_hit[ 6] = (reg_addr == SPI_DEVICE_ASYNC_FIFO_LEVEL_OFFSET);</pre>
<pre>    addr_hit[ 7] = (reg_addr == SPI_DEVICE_STATUS_OFFSET);</pre>
<pre>    addr_hit[ 8] = (reg_addr == SPI_DEVICE_RXF_PTR_OFFSET);</pre>
<pre>    addr_hit[ 9] = (reg_addr == SPI_DEVICE_TXF_PTR_OFFSET);</pre>
<pre>    addr_hit[10] = (reg_addr == SPI_DEVICE_RXF_ADDR_OFFSET);</pre>
<pre>    addr_hit[11] = (reg_addr == SPI_DEVICE_TXF_ADDR_OFFSET);</pre>
<pre>  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;</pre>
<pre>  always_comb begin</pre>
<pre>    wr_err = 1'b0;</pre>
<pre>    if (addr_hit[ 0] && reg_we && (SPI_DEVICE_PERMIT[ 0] != (SPI_DEVICE_PERMIT[ 0] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 1] && reg_we && (SPI_DEVICE_PERMIT[ 1] != (SPI_DEVICE_PERMIT[ 1] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 2] && reg_we && (SPI_DEVICE_PERMIT[ 2] != (SPI_DEVICE_PERMIT[ 2] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 3] && reg_we && (SPI_DEVICE_PERMIT[ 3] != (SPI_DEVICE_PERMIT[ 3] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 4] && reg_we && (SPI_DEVICE_PERMIT[ 4] != (SPI_DEVICE_PERMIT[ 4] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 5] && reg_we && (SPI_DEVICE_PERMIT[ 5] != (SPI_DEVICE_PERMIT[ 5] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 6] && reg_we && (SPI_DEVICE_PERMIT[ 6] != (SPI_DEVICE_PERMIT[ 6] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 7] && reg_we && (SPI_DEVICE_PERMIT[ 7] != (SPI_DEVICE_PERMIT[ 7] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 8] && reg_we && (SPI_DEVICE_PERMIT[ 8] != (SPI_DEVICE_PERMIT[ 8] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[ 9] && reg_we && (SPI_DEVICE_PERMIT[ 9] != (SPI_DEVICE_PERMIT[ 9] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[10] && reg_we && (SPI_DEVICE_PERMIT[10] != (SPI_DEVICE_PERMIT[10] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>    if (addr_hit[11] && reg_we && (SPI_DEVICE_PERMIT[11] != (SPI_DEVICE_PERMIT[11] & reg_be))) wr_err = 1'b1 ;</pre>
<pre>  assign intr_state_rxf_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rxf_wd = reg_wdata[0];</pre>
<pre>  assign intr_state_rxlvl_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rxlvl_wd = reg_wdata[1];</pre>
<pre>  assign intr_state_txlvl_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_txlvl_wd = reg_wdata[2];</pre>
<pre>  assign intr_state_rxerr_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rxerr_wd = reg_wdata[3];</pre>
<pre>  assign intr_state_rxoverflow_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_rxoverflow_wd = reg_wdata[4];</pre>
<pre>  assign intr_state_txunderflow_we = addr_hit[0] & reg_we & ~wr_err;</pre>
<pre>  assign intr_state_txunderflow_wd = reg_wdata[5];</pre>
<pre>  assign intr_enable_rxf_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rxf_wd = reg_wdata[0];</pre>
<pre>  assign intr_enable_rxlvl_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rxlvl_wd = reg_wdata[1];</pre>
<pre>  assign intr_enable_txlvl_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_txlvl_wd = reg_wdata[2];</pre>
<pre>  assign intr_enable_rxerr_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rxerr_wd = reg_wdata[3];</pre>
<pre>  assign intr_enable_rxoverflow_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_rxoverflow_wd = reg_wdata[4];</pre>
<pre>  assign intr_enable_txunderflow_we = addr_hit[1] & reg_we & ~wr_err;</pre>
<pre>  assign intr_enable_txunderflow_wd = reg_wdata[5];</pre>
<pre>  assign intr_test_rxf_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rxf_wd = reg_wdata[0];</pre>
<pre>  assign intr_test_rxlvl_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rxlvl_wd = reg_wdata[1];</pre>
<pre>  assign intr_test_txlvl_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_txlvl_wd = reg_wdata[2];</pre>
<pre>  assign intr_test_rxerr_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rxerr_wd = reg_wdata[3];</pre>
<pre>  assign intr_test_rxoverflow_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_rxoverflow_wd = reg_wdata[4];</pre>
<pre>  assign intr_test_txunderflow_we = addr_hit[2] & reg_we & ~wr_err;</pre>
<pre>  assign intr_test_txunderflow_wd = reg_wdata[5];</pre>
<pre>  assign control_abort_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign control_abort_wd = reg_wdata[0];</pre>
<pre>  assign control_mode_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign control_mode_wd = reg_wdata[5:4];</pre>
<pre>  assign control_rst_txfifo_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign control_rst_txfifo_wd = reg_wdata[16];</pre>
<pre>  assign control_rst_rxfifo_we = addr_hit[3] & reg_we & ~wr_err;</pre>
<pre>  assign control_rst_rxfifo_wd = reg_wdata[17];</pre>
<pre>  assign cfg_cpol_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign cfg_cpol_wd = reg_wdata[0];</pre>
<pre>  assign cfg_cpha_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign cfg_cpha_wd = reg_wdata[1];</pre>
<pre>  assign cfg_tx_order_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign cfg_tx_order_wd = reg_wdata[2];</pre>
<pre>  assign cfg_rx_order_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign cfg_rx_order_wd = reg_wdata[3];</pre>
<pre>  assign cfg_timer_v_we = addr_hit[4] & reg_we & ~wr_err;</pre>
<pre>  assign cfg_timer_v_wd = reg_wdata[15:8];</pre>
<pre>  assign fifo_level_rxlvl_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign fifo_level_rxlvl_wd = reg_wdata[15:0];</pre>
<pre>  assign fifo_level_txlvl_we = addr_hit[5] & reg_we & ~wr_err;</pre>
<pre>  assign fifo_level_txlvl_wd = reg_wdata[31:16];</pre>
<pre>  assign async_fifo_level_rxlvl_re = addr_hit[6] && reg_re;</pre>
<pre>  assign async_fifo_level_txlvl_re = addr_hit[6] && reg_re;</pre>
<pre>  assign status_rxf_full_re = addr_hit[7] && reg_re;</pre>
<pre>  assign status_rxf_empty_re = addr_hit[7] && reg_re;</pre>
<pre>  assign status_txf_full_re = addr_hit[7] && reg_re;</pre>
<pre>  assign status_txf_empty_re = addr_hit[7] && reg_re;</pre>
<pre>  assign status_abort_done_re = addr_hit[7] && reg_re;</pre>
<pre>  assign status_csb_re = addr_hit[7] && reg_re;</pre>
<pre>  assign rxf_ptr_rptr_we = addr_hit[8] & reg_we & ~wr_err;</pre>
<pre>  assign rxf_ptr_rptr_wd = reg_wdata[15:0];</pre>
<pre>  assign txf_ptr_wptr_we = addr_hit[9] & reg_we & ~wr_err;</pre>
<pre>  assign txf_ptr_wptr_wd = reg_wdata[31:16];</pre>
<pre>  assign rxf_addr_base_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign rxf_addr_base_wd = reg_wdata[15:0];</pre>
<pre>  assign rxf_addr_limit_we = addr_hit[10] & reg_we & ~wr_err;</pre>
<pre>  assign rxf_addr_limit_wd = reg_wdata[31:16];</pre>
<pre>  assign txf_addr_base_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign txf_addr_base_wd = reg_wdata[15:0];</pre>
<pre>  assign txf_addr_limit_we = addr_hit[11] & reg_we & ~wr_err;</pre>
<pre>  assign txf_addr_limit_wd = reg_wdata[31:16];</pre>
<pre>  always_comb begin</pre>
<pre>    reg_rdata_next = '0;</pre>
<pre>    unique case (1'b1)</pre>
<pre>      addr_hit[0]: begin</pre>
<pre>        reg_rdata_next[0] = intr_state_rxf_qs;</pre>
<pre>        reg_rdata_next[1] = intr_state_rxlvl_qs;</pre>
<pre>        reg_rdata_next[2] = intr_state_txlvl_qs;</pre>
<pre>        reg_rdata_next[3] = intr_state_rxerr_qs;</pre>
<pre>        reg_rdata_next[4] = intr_state_rxoverflow_qs;</pre>
<pre>        reg_rdata_next[5] = intr_state_txunderflow_qs;</pre>
<pre>      addr_hit[1]: begin</pre>
<pre>        reg_rdata_next[0] = intr_enable_rxf_qs;</pre>
<pre>        reg_rdata_next[1] = intr_enable_rxlvl_qs;</pre>
<pre>        reg_rdata_next[2] = intr_enable_txlvl_qs;</pre>
<pre>        reg_rdata_next[3] = intr_enable_rxerr_qs;</pre>
<pre>        reg_rdata_next[4] = intr_enable_rxoverflow_qs;</pre>
<pre>        reg_rdata_next[5] = intr_enable_txunderflow_qs;</pre>
<pre>      addr_hit[2]: begin</pre>
<pre>        reg_rdata_next[0] = '0;</pre>
<pre>        reg_rdata_next[1] = '0;</pre>
<pre>        reg_rdata_next[2] = '0;</pre>
<pre>        reg_rdata_next[3] = '0;</pre>
<pre>        reg_rdata_next[4] = '0;</pre>
<pre>        reg_rdata_next[5] = '0;</pre>
<pre>      addr_hit[3]: begin</pre>
<pre>        reg_rdata_next[0] = control_abort_qs;</pre>
<pre>        reg_rdata_next[5:4] = control_mode_qs;</pre>
<pre>        reg_rdata_next[16] = control_rst_txfifo_qs;</pre>
<pre>        reg_rdata_next[17] = control_rst_rxfifo_qs;</pre>
<pre>      addr_hit[4]: begin</pre>
<pre>        reg_rdata_next[0] = cfg_cpol_qs;</pre>
<pre>        reg_rdata_next[1] = cfg_cpha_qs;</pre>
<pre>        reg_rdata_next[2] = cfg_tx_order_qs;</pre>
<pre>        reg_rdata_next[3] = cfg_rx_order_qs;</pre>
<pre>        reg_rdata_next[15:8] = cfg_timer_v_qs;</pre>
<pre>      addr_hit[5]: begin</pre>
<pre>        reg_rdata_next[15:0] = fifo_level_rxlvl_qs;</pre>
<pre>        reg_rdata_next[31:16] = fifo_level_txlvl_qs;</pre>
<pre>      addr_hit[6]: begin</pre>
<pre>        reg_rdata_next[7:0] = async_fifo_level_rxlvl_qs;</pre>
<pre>        reg_rdata_next[23:16] = async_fifo_level_txlvl_qs;</pre>
<pre>      addr_hit[7]: begin</pre>
<pre>        reg_rdata_next[0] = status_rxf_full_qs;</pre>
<pre>        reg_rdata_next[1] = status_rxf_empty_qs;</pre>
<pre>        reg_rdata_next[2] = status_txf_full_qs;</pre>
<pre>        reg_rdata_next[3] = status_txf_empty_qs;</pre>
<pre>        reg_rdata_next[4] = status_abort_done_qs;</pre>
<pre>        reg_rdata_next[5] = status_csb_qs;</pre>
<pre>      addr_hit[8]: begin</pre>
<pre>        reg_rdata_next[15:0] = rxf_ptr_rptr_qs;</pre>
<pre>        reg_rdata_next[31:16] = rxf_ptr_wptr_qs;</pre>
<pre>      addr_hit[9]: begin</pre>
<pre>        reg_rdata_next[15:0] = txf_ptr_rptr_qs;</pre>
<pre>        reg_rdata_next[31:16] = txf_ptr_wptr_qs;</pre>
<pre>      addr_hit[10]: begin</pre>
<pre>        reg_rdata_next[15:0] = rxf_addr_base_qs;</pre>
<pre>        reg_rdata_next[31:16] = rxf_addr_limit_qs;</pre>
<pre>      addr_hit[11]: begin</pre>
<pre>        reg_rdata_next[15:0] = txf_addr_base_qs;</pre>
<pre>        reg_rdata_next[31:16] = txf_addr_limit_qs;</pre>
<pre>      default: begin</pre>
<pre>        reg_rdata_next = '1;</pre>
<h3>hw/ip/spi_device/rtl/spi_device_reg_pkg.sv</h3>
<pre>package spi_device_reg_pkg;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rxf;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rxlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } txlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rxerr;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rxoverflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } txunderflow;</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rxf;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rxlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } txlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rxerr;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rxoverflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } txunderflow;</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_intr_enable_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rxf;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rxlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } txlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rxerr;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } rxoverflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>      logic        qe;</pre>
<pre>    } txunderflow;</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_intr_test_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } abort;</pre>
<pre>    struct packed {</pre>
<pre>      logic [1:0]  q;</pre>
<pre>    } mode;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rst_txfifo;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rst_rxfifo;</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_control_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } cpol;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } cpha;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } tx_order;</pre>
<pre>    struct packed {</pre>
<pre>      logic        q;</pre>
<pre>    } rx_order;</pre>
<pre>    struct packed {</pre>
<pre>      logic [7:0]  q;</pre>
<pre>    } timer_v;</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_cfg_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>    } rxlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>    } txlvl;</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_fifo_level_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>    } rptr;</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_rxf_ptr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>    } wptr;</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_txf_ptr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>    } base;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>    } limit;</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_rxf_addr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>    } base;</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] q;</pre>
<pre>    } limit;</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_txf_addr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rxf;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rxlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } txlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rxerr;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } rxoverflow;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>      logic        de;</pre>
<pre>    } txunderflow;</pre>
<pre style="background-color: #FF0000;">  } spi_device_hw2reg_intr_state_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [7:0]  d;</pre>
<pre>    } rxlvl;</pre>
<pre>    struct packed {</pre>
<pre>      logic [7:0]  d;</pre>
<pre>    } txlvl;</pre>
<pre style="background-color: #FF0000;">  } spi_device_hw2reg_async_fifo_level_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } rxf_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } rxf_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } txf_full;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } txf_empty;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } abort_done;</pre>
<pre>    struct packed {</pre>
<pre>      logic        d;</pre>
<pre>    } csb;</pre>
<pre style="background-color: #FF0000;">  } spi_device_hw2reg_status_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] d;</pre>
<pre>      logic        de;</pre>
<pre>    } wptr;</pre>
<pre style="background-color: #FF0000;">  } spi_device_hw2reg_rxf_ptr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    struct packed {</pre>
<pre>      logic [15:0] d;</pre>
<pre>      logic        de;</pre>
<pre>    } rptr;</pre>
<pre style="background-color: #FF0000;">  } spi_device_hw2reg_txf_ptr_reg_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    spi_device_reg2hw_intr_state_reg_t intr_state; // [168:163]</pre>
<pre>    spi_device_reg2hw_intr_enable_reg_t intr_enable; // [162:157]</pre>
<pre>    spi_device_reg2hw_intr_test_reg_t intr_test; // [156:145]</pre>
<pre>    spi_device_reg2hw_control_reg_t control; // [144:140]</pre>
<pre>    spi_device_reg2hw_cfg_reg_t cfg; // [139:128]</pre>
<pre>    spi_device_reg2hw_fifo_level_reg_t fifo_level; // [127:96]</pre>
<pre>    spi_device_reg2hw_rxf_ptr_reg_t rxf_ptr; // [95:80]</pre>
<pre>    spi_device_reg2hw_txf_ptr_reg_t txf_ptr; // [79:64]</pre>
<pre>    spi_device_reg2hw_rxf_addr_reg_t rxf_addr; // [63:32]</pre>
<pre>    spi_device_reg2hw_txf_addr_reg_t txf_addr; // [31:0]</pre>
<pre style="background-color: #FF0000;">  } spi_device_reg2hw_t;</pre>
<pre>  typedef struct packed {</pre>
<pre>    spi_device_hw2reg_intr_state_reg_t intr_state; // [67:62]</pre>
<pre>    spi_device_hw2reg_async_fifo_level_reg_t async_fifo_level; // [61:62]</pre>
<pre>    spi_device_hw2reg_status_reg_t status; // [61:62]</pre>
<pre>    spi_device_hw2reg_rxf_ptr_reg_t rxf_ptr; // [61:46]</pre>
<pre>    spi_device_hw2reg_txf_ptr_reg_t txf_ptr; // [45:30]</pre>
<pre style="background-color: #FF0000;">  } spi_device_hw2reg_t;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_INTR_STATE_OFFSET = 12'h 0;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_INTR_ENABLE_OFFSET = 12'h 4;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_INTR_TEST_OFFSET = 12'h 8;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_CONTROL_OFFSET = 12'h c;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_CFG_OFFSET = 12'h 10;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_FIFO_LEVEL_OFFSET = 12'h 14;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_ASYNC_FIFO_LEVEL_OFFSET = 12'h 18;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_STATUS_OFFSET = 12'h 1c;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_RXF_PTR_OFFSET = 12'h 20;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_TXF_PTR_OFFSET = 12'h 24;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_RXF_ADDR_OFFSET = 12'h 28;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_TXF_ADDR_OFFSET = 12'h 2c;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_BUFFER_OFFSET = 12'h 800;</pre>
<pre>  parameter logic [11:0] SPI_DEVICE_BUFFER_SIZE   = 12'h 800;</pre>
<pre>  typedef enum int {</pre>
<pre>    SPI_DEVICE_INTR_STATE,</pre>
<pre>    SPI_DEVICE_INTR_ENABLE,</pre>
<pre>    SPI_DEVICE_INTR_TEST,</pre>
<pre>    SPI_DEVICE_CONTROL,</pre>
<pre>    SPI_DEVICE_CFG,</pre>
<pre>    SPI_DEVICE_FIFO_LEVEL,</pre>
<pre>    SPI_DEVICE_ASYNC_FIFO_LEVEL,</pre>
<pre>    SPI_DEVICE_STATUS,</pre>
<pre>    SPI_DEVICE_RXF_PTR,</pre>
<pre>    SPI_DEVICE_TXF_PTR,</pre>
<pre>    SPI_DEVICE_RXF_ADDR,</pre>
<pre>    SPI_DEVICE_TXF_ADDR</pre>
<pre>  } spi_device_id_e;</pre>
<pre>  parameter logic [3:0] SPI_DEVICE_PERMIT [12] = '{</pre>
<pre>    4'b 0001, // index[ 0] SPI_DEVICE_INTR_STATE</pre>
<pre>    4'b 0001, // index[ 1] SPI_DEVICE_INTR_ENABLE</pre>
<pre>    4'b 0001, // index[ 2] SPI_DEVICE_INTR_TEST</pre>
<pre>    4'b 0111, // index[ 3] SPI_DEVICE_CONTROL</pre>
<pre>    4'b 0011, // index[ 4] SPI_DEVICE_CFG</pre>
<pre>    4'b 1111, // index[ 5] SPI_DEVICE_FIFO_LEVEL</pre>
<pre>    4'b 0111, // index[ 6] SPI_DEVICE_ASYNC_FIFO_LEVEL</pre>
<pre>    4'b 0001, // index[ 7] SPI_DEVICE_STATUS</pre>
<pre>    4'b 1111, // index[ 8] SPI_DEVICE_RXF_PTR</pre>
<pre>    4'b 1111, // index[ 9] SPI_DEVICE_TXF_PTR</pre>
<pre>    4'b 1111, // index[10] SPI_DEVICE_RXF_ADDR</pre>
<pre>    4'b 1111  // index[11] SPI_DEVICE_TXF_ADDR</pre>
<h3>hw/ip/spi_device/rtl/spi_device_pkg.sv</h3>
<pre>package spi_device_pkg;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    FwMode      = 'h0,</pre>
<pre>    EepromRam   = 'h1,</pre>
<pre>    EepromFlash = 'h2,</pre>
<pre>    PassThrough = 'h3</pre>
<pre>  } spi_mode_e;</pre>
<pre>  typedef logic [2:0] spi_rdmode_t;</pre>
<pre>  typedef logic [7:0] spi_byte_t;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    Spi    = 2'h0,</pre>
<pre>    Espi   = 2'h1,</pre>
<pre>    Tpm    = 2'h2</pre>
<pre>  } spi_type_e;</pre>
<pre>  typedef enum logic [1:0] {</pre>
<pre>    AddrByte = 2'h0,  // 1 byte for address</pre>
<pre>    AddrWord = 2'h1,  // 2 bytes for address</pre>
<pre>    AddrFull = 2'h2   // 3 bytes for address</pre>
<pre>  } spi_addr_size_e;</pre>
<pre>  localparam int MEM_AW = 12; // Memory Address width (Byte based)</pre>
<pre>  typedef enum logic [7:0] {</pre>
<pre>    Nop    = 8'h00,</pre>
<pre>    WrSts  = 8'h01,   // Write STATUS1 followed by STATUS2 register</pre>
<pre>    Write  = 8'h02,   // Write Data</pre>
<pre>    Read   = 8'h03,   // Limit to a certain speed as read data starts right after addr</pre>
<pre>    WrDi   = 8'h04,   // Write Disable: Clear WEL to 0</pre>
<pre>    RdSts  = 8'h05,</pre>
<pre>    WrEn   = 8'h06,   // Write Enable: Set WEL to 1</pre>
<pre>    HsRd   = 8'h0B,   // 8 cycle gap between addr/ rdata</pre>
<pre>    RdSts2 = 8'h35,   // Read STATUS2 register</pre>
<pre>    DlRd   = 8'h3B,   // Dual Read</pre>
<pre>    QdRd   = 8'h6B    // Quad Read</pre>
<pre>  } spi_rom_cmd_e;</pre>
<pre style="background-color: #FF0000;">endpackage : spi_device_pkg</pre>
<h3>hw/ip/spi_device/rtl/spi_fwmode.sv</h3>
<pre>  input clk_in_i,</pre>
<pre>  input rst_in_ni,</pre>
<pre>  input clk_out_i,</pre>
<pre>  input rst_out_ni,</pre>
<pre>  input                             cpha_i,</pre>
<pre>  input                             cfg_rxorder_i, // 1: 0->7 , 0:7->0</pre>
<pre>  input                             cfg_txorder_i, // 1: 0->7 , 0:7->0</pre>
<pre>  input  spi_device_pkg::spi_mode_e mode_i, // Only works at mode_i == FwMode</pre>
<pre>  output logic                      rx_wvalid_o,</pre>
<pre>  input                             rx_wready_i,</pre>
<pre>  output spi_device_pkg::spi_byte_t rx_data_o,</pre>
<pre>  input                             tx_rvalid_i,</pre>
<pre>  output logic                      tx_rready_o,</pre>
<pre>  input  spi_device_pkg::spi_byte_t tx_data_i,</pre>
<pre>  output logic                      rx_overflow_o,</pre>
<pre>  output logic                      tx_underflow_o,</pre>
<pre>  input        csb_i,</pre>
<pre>  input        mosi,</pre>
<pre>  output logic miso,</pre>
<pre>  output logic miso_oe</pre>
<pre>  localparam int unsigned BITS     = $bits(spi_byte_t);</pre>
<pre>  localparam int unsigned BITWIDTH = $clog2(BITS);</pre>
<pre>  logic [BITWIDTH-1:0] rx_bitcount;</pre>
<pre>  typedef enum logic {</pre>
<pre>    TxIdle,</pre>
<pre>    TxActive</pre>
<pre>  } tx_state_e;</pre>
<pre>  tx_state_e tx_state;   // Only for handling CPHA</pre>
<pre>  spi_byte_t rx_data_d, rx_data_q;</pre>
<pre>  always_comb begin</pre>
<pre>    if (cfg_rxorder_i) begin</pre>
<pre>      rx_data_d = {mosi, rx_data_q[BITS-1:1]};</pre>
<pre>    end else begin</pre>
<pre>      rx_data_d = {rx_data_q[BITS-2:0], mosi};</pre>
<pre>  always_ff @(posedge clk_in_i) begin</pre>
<pre>    rx_data_q <= rx_data_d;</pre>
<pre>  assign rx_data_o = rx_data_d;</pre>
<pre>  always_ff @(posedge clk_in_i or negedge rst_in_ni) begin</pre>
<pre>    if (!rst_in_ni) begin</pre>
<pre>      rx_bitcount <= BITWIDTH'(BITS-1);</pre>
<pre>    end else begin</pre>
<pre>      if (rx_bitcount == '0) begin</pre>
<pre>        rx_bitcount <= BITWIDTH'(BITS-1);</pre>
<pre>      end else begin</pre>
<pre>        rx_bitcount <= rx_bitcount -1;</pre>
<pre>  assign rx_wvalid_o = (rx_bitcount == '0);</pre>
<pre>  logic [BITWIDTH-1:0] tx_bitcount;</pre>
<pre>  logic first_bit, last_bit;</pre>
<pre>  spi_byte_t miso_shift;</pre>
<pre>  assign first_bit = (tx_bitcount == BITWIDTH'(BITS-1)) ? 1'b1 : 1'b0;</pre>
<pre>  assign last_bit  = (tx_bitcount == '0) ? 1'b1 : 1'b0;</pre>
<pre>  assign tx_rready_o = (tx_bitcount == BITWIDTH'(1)); // Pop at second bit transfer</pre>
<pre>  always_ff @(posedge clk_out_i or negedge rst_out_ni) begin</pre>
<pre>    if (!rst_out_ni) begin</pre>
<pre>      tx_bitcount <= BITWIDTH'(BITS-1);</pre>
<pre>    end else begin</pre>
<pre>      if (last_bit) begin</pre>
<pre>        tx_bitcount <= BITWIDTH'(BITS-1);</pre>
<pre>      end else if (tx_state != TxIdle || cpha_i == 1'b0) begin</pre>
<pre>        tx_bitcount <= tx_bitcount - 1'b1;</pre>
<pre>  always_ff @(posedge clk_out_i or negedge rst_out_ni) begin</pre>
<pre>    if (!rst_out_ni) begin</pre>
<pre>      tx_state <= TxIdle;</pre>
<pre>    end else begin</pre>
<pre>      tx_state <= TxActive;</pre>
<pre>  assign miso = (cfg_txorder_i) ? ((~first_bit) ? miso_shift[0] : tx_data_i[0]) :</pre>
<pre>                (~first_bit) ? miso_shift[7] : tx_data_i[7] ;</pre>
<pre>  assign miso_oe = ~csb_i;</pre>
<pre>  always_ff @(posedge clk_out_i) begin</pre>
<pre>    if (cfg_txorder_i) begin</pre>
<pre>      if (first_bit) begin</pre>
<pre>        miso_shift <= {1'b0, tx_data_i[7:1]};</pre>
<pre>      end else begin</pre>
<pre>        miso_shift <= {1'b0, miso_shift[7:1]};</pre>
<pre>    end else begin</pre>
<pre>      if (first_bit) begin</pre>
<pre>        miso_shift <= {tx_data_i[6:0], 1'b0};</pre>
<pre>      end else begin</pre>
<pre>        miso_shift <= {miso_shift[6:0], 1'b0};</pre>
<pre>  assign rx_overflow_o  = rx_wvalid_o & ~rx_wready_i;</pre>
<pre>  assign tx_underflow_o = tx_rready_o & ~tx_rvalid_i;</pre>
<h3>hw/ip/spi_device/rtl/spi_device.sv</h3>
<pre>module spi_device #(</pre>
<pre>  parameter int SramAw = 9, // 2kB, SRAM Width is DW</pre>
<pre>  parameter int SramDw = 32</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input  tlul_pkg::tl_h2d_t tl_i,</pre>
<pre>  output tlul_pkg::tl_d2h_t tl_o,</pre>
<pre>  input              cio_sck_i,</pre>
<pre>  input              cio_csb_i,</pre>
<pre>  output logic       cio_miso_o,</pre>
<pre>  output logic       cio_miso_en_o,</pre>
<pre>  input              cio_mosi_i,</pre>
<pre>  output logic intr_rxf_o,         // RX FIFO Full</pre>
<pre>  output logic intr_rxlvl_o,       // RX FIFO above level</pre>
<pre>  output logic intr_txlvl_o,       // TX FIFO below level</pre>
<pre>  output logic intr_rxerr_o,       // RX Frame error</pre>
<pre>  output logic intr_rxoverflow_o,  // RX Async FIFO Overflow</pre>
<pre>  output logic intr_txunderflow_o, // TX Async FIFO Underflow</pre>
<pre>  input scanmode_i</pre>
<pre>  localparam int FifoWidth = $bits(spi_byte_t);</pre>
<pre>  localparam int FifoDepth = 8; // 2 DWords</pre>
<pre>  localparam int SDW = $clog2(SramDw/FifoWidth);</pre>
<pre>  localparam int PtrW = SramAw + 1 + SDW;</pre>
<pre>  localparam int AsFifoDepthW = $clog2(FifoDepth+1);</pre>
<pre>  logic clk_spi_in;   // clock for latch MOSI</pre>
<pre>  logic clk_spi_out;  // clock for driving MISO</pre>
<pre>  spi_device_reg2hw_t reg2hw;</pre>
<pre>  spi_device_hw2reg_t hw2reg;</pre>
<pre>  tlul_pkg::tl_h2d_t tl_sram_h2d [1];</pre>
<pre>  tlul_pkg::tl_d2h_t tl_sram_d2h [1];</pre>
<pre>  logic              mem_a_req;</pre>
<pre>  logic              mem_a_write;</pre>
<pre>  logic [SramAw-1:0] mem_a_addr;</pre>
<pre>  logic [SramDw-1:0] mem_a_wdata;</pre>
<pre>  logic              mem_a_rvalid;</pre>
<pre>  logic [SramDw-1:0] mem_a_rdata;</pre>
<pre>  logic [1:0]        mem_a_rerror;</pre>
<pre>  logic              mem_b_req;</pre>
<pre>  logic              mem_b_write;</pre>
<pre>  logic [SramAw-1:0] mem_b_addr;</pre>
<pre>  logic [SramDw-1:0] mem_b_wdata;</pre>
<pre>  logic              mem_b_rvalid;</pre>
<pre>  logic [SramDw-1:0] mem_b_rdata;</pre>
<pre>  logic [1:0]        mem_b_rerror;</pre>
<pre>  logic cpol; // Clock polarity</pre>
<pre>  logic cpha; // Phase : Not complete</pre>
<pre>  logic txorder; // TX bitstream order: 0(bit 7 to 0), 1(bit 0 to 7)</pre>
<pre>  logic rxorder; // RX bitstream order: 0(bit 7 to 0), 1(bit 0 to 7)</pre>
<pre>  logic abort;  // Abort current operations (txf only at this time)</pre>
<pre>  logic csb_syncd;</pre>
<pre>  logic rst_txfifo_n, rst_rxfifo_n;</pre>
<pre>  logic rst_txfifo_reg, rst_rxfifo_reg;</pre>
<pre>  spi_mode_e spi_mode;</pre>
<pre>  logic intr_sram_rxf_full, intr_fwm_rxerr;</pre>
<pre>  logic intr_fwm_rxlvl, rxlvl, rxlvl_d, intr_fwm_txlvl, txlvl, txlvl_d;</pre>
<pre>  logic intr_fwm_rxoverflow, intr_fwm_txunderflow;</pre>
<pre>  logic      rxf_wvalid, rxf_wready;</pre>
<pre>  spi_byte_t rxf_wdata;</pre>
<pre>  logic      rxf_overflow;</pre>
<pre>  logic      rxf_rvalid, rxf_rready;</pre>
<pre>  spi_byte_t rxf_rdata;</pre>
<pre>  logic      rxf_full_syncd;</pre>
<pre>  logic      txf_rvalid, txf_rready;</pre>
<pre>  spi_byte_t txf_rdata;</pre>
<pre>  logic      txf_underflow;</pre>
<pre>  logic      txf_wvalid, txf_wready;</pre>
<pre>  spi_byte_t txf_wdata;</pre>
<pre>  logic      txf_empty_syncd;</pre>
<pre>  typedef enum int {</pre>
<pre>    FwModeRxFifo = 0,</pre>
<pre>    FwModeTxFifo = 1</pre>
<pre>  } fwm_fifo_e;</pre>
<pre>  logic        [7:0] timer_v;   // Wait timer inside rxf control</pre>
<pre>  logic   [PtrW-1:0] sram_rxf_rptr, sram_rxf_wptr;</pre>
<pre>  logic   [PtrW-1:0] sram_txf_rptr, sram_txf_wptr;</pre>
<pre>  logic   [PtrW-1:0] sram_rxf_depth, sram_txf_depth;</pre>
<pre>  logic [SramAw-1:0] sram_rxf_bindex, sram_txf_bindex;</pre>
<pre>  logic [SramAw-1:0] sram_rxf_lindex, sram_txf_lindex;</pre>
<pre>  logic        [1:0] fwm_sram_req;</pre>
<pre>  logic [SramAw-1:0] fwm_sram_addr  [2];</pre>
<pre>  logic              fwm_sram_write [2];</pre>
<pre>  logic [SramDw-1:0] fwm_sram_wdata [2];</pre>
<pre>  logic        [1:0] fwm_sram_gnt;</pre>
<pre>  logic        [1:0] fwm_sram_rvalid;    // RXF doesn't use</pre>
<pre>  logic [SramDw-1:0] fwm_sram_rdata [2]; // RXF doesn't use</pre>
<pre>  logic        [1:0] fwm_sram_error [2];</pre>
<pre>  logic [AsFifoDepthW-1:0] as_txfifo_depth, as_rxfifo_depth;</pre>
<pre>  assign cpol = reg2hw.cfg.cpol.q;</pre>
<pre>  assign cpha = reg2hw.cfg.cpha.q;</pre>
<pre>  assign txorder = reg2hw.cfg.tx_order.q;</pre>
<pre>  assign rxorder = reg2hw.cfg.rx_order.q;</pre>
<pre>  assign rst_txfifo_reg = reg2hw.control.rst_txfifo.q;</pre>
<pre>  assign rst_rxfifo_reg = reg2hw.control.rst_rxfifo.q;</pre>
<pre>  assign timer_v = reg2hw.cfg.timer_v.q;</pre>
<pre>  assign sram_rxf_bindex = reg2hw.rxf_addr.base.q[SDW+:SramAw];</pre>
<pre>  assign sram_rxf_lindex = reg2hw.rxf_addr.limit.q[SDW+:SramAw];</pre>
<pre>  assign sram_txf_bindex = reg2hw.txf_addr.base.q[SDW+:SramAw];</pre>
<pre>  assign sram_txf_lindex = reg2hw.txf_addr.limit.q[SDW+:SramAw];</pre>
<pre>  assign sram_rxf_rptr = reg2hw.rxf_ptr.rptr.q[PtrW-1:0];</pre>
<pre>  assign hw2reg.rxf_ptr.wptr.d = {{(16-PtrW){1'b0}}, sram_rxf_wptr};</pre>
<pre>  assign hw2reg.rxf_ptr.wptr.de = 1'b1;</pre>
<pre>  assign sram_txf_wptr = reg2hw.txf_ptr.wptr.q[PtrW-1:0];</pre>
<pre>  assign hw2reg.txf_ptr.rptr.d = {{(16-PtrW){1'b0}}, sram_txf_rptr};</pre>
<pre>  assign hw2reg.txf_ptr.rptr.de = 1'b1;</pre>
<pre>  assign abort = reg2hw.control.abort.q;</pre>
<pre>  assign hw2reg.status.abort_done.d  = 1'b1;</pre>
<pre>  assign hw2reg.status.rxf_empty.d = ~rxf_rvalid;</pre>
<pre>  assign hw2reg.status.txf_full.d  = ~txf_wready;</pre>
<pre>  assign hw2reg.status.rxf_full.d = rxf_full_syncd;</pre>
<pre>  assign hw2reg.status.txf_empty.d = txf_empty_syncd;</pre>
<pre>  assign hw2reg.status.csb.d = csb_syncd;</pre>
<pre>  prim_flop_2sync #(.Width(1)) u_sync_csb (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .d(cio_csb_i),</pre>
<pre>    .q(csb_syncd)</pre>
<pre>  logic rxf_full_q, txf_empty_q;</pre>
<pre>  always_ff @(posedge clk_spi_in)  rxf_full_q  <= ~rxf_wready;</pre>
<pre>  always_ff @(posedge clk_spi_out) txf_empty_q <= ~txf_rvalid;</pre>
<pre>  prim_flop_2sync #(.Width(1)) u_sync_rxf (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .d(rxf_full_q),</pre>
<pre>    .q(rxf_full_syncd)</pre>
<pre>  prim_flop_2sync #(.Width(1), .ResetValue(1'b1)) u_sync_txe (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .d(txf_empty_q),</pre>
<pre>    .q(txf_empty_syncd)</pre>
<pre>  assign spi_mode = spi_mode_e'(reg2hw.control.mode.q);</pre>
<pre>  assign hw2reg.async_fifo_level.txlvl.d  = {{(8-AsFifoDepthW){1'b0}}, as_txfifo_depth};</pre>
<pre>  assign hw2reg.async_fifo_level.rxlvl.d  = {{(8-AsFifoDepthW){1'b0}}, as_rxfifo_depth};</pre>
<pre>  logic sram_rxf_full_q, fwm_rxerr_q;</pre>
<pre>  logic sram_rxf_full  , fwm_rxerr  ;</pre>
<pre>  assign fwm_rxerr = 1'b0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      sram_rxf_full_q <= 1'b0;</pre>
<pre>      fwm_rxerr_q     <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      sram_rxf_full_q <= sram_rxf_full;</pre>
<pre>      fwm_rxerr_q     <= fwm_rxerr;</pre>
<pre>  assign intr_sram_rxf_full = ~sram_rxf_full_q & sram_rxf_full;</pre>
<pre>  assign intr_fwm_rxerr     = ~fwm_rxerr_q & fwm_rxerr;</pre>
<pre>  assign rxlvl_d = (sram_rxf_depth >= reg2hw.fifo_level.rxlvl.q[PtrW-1:0]) ;</pre>
<pre>  assign txlvl_d = (sram_txf_depth <  reg2hw.fifo_level.txlvl.q[PtrW-1:0]) ;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rxlvl <= 1'b0;</pre>
<pre>      txlvl <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      rxlvl <= rxlvl_d;</pre>
<pre>      txlvl <= txlvl_d;</pre>
<pre>  assign intr_fwm_rxlvl = ~rxlvl && rxlvl_d;</pre>
<pre>  assign intr_fwm_txlvl = ~txlvl && txlvl_d;</pre>
<pre>  prim_pulse_sync u_rxf_overflow (</pre>
<pre>    .clk_src_i   (clk_spi_in         ),</pre>
<pre>    .rst_src_ni  (rst_ni             ),</pre>
<pre>    .src_pulse_i (rxf_overflow       ),</pre>
<pre>    .clk_dst_i   (clk_i              ),</pre>
<pre>    .rst_dst_ni  (rst_ni             ),</pre>
<pre>    .dst_pulse_o (intr_fwm_rxoverflow)</pre>
<pre>  prim_pulse_sync u_txf_underflow (</pre>
<pre>    .clk_src_i   (clk_spi_out         ),</pre>
<pre>    .rst_src_ni  (rst_ni              ),</pre>
<pre>    .src_pulse_i (txf_underflow       ),</pre>
<pre>    .clk_dst_i   (clk_i               ),</pre>
<pre>    .rst_dst_ni  (rst_ni              ),</pre>
<pre>    .dst_pulse_o (intr_fwm_txunderflow)</pre>
<pre>  assign intr_rxlvl_o       = reg2hw.intr_enable.rxlvl.q       & reg2hw.intr_state.rxlvl.q;</pre>
<pre>  assign intr_txlvl_o       = reg2hw.intr_enable.txlvl.q       & reg2hw.intr_state.txlvl.q;</pre>
<pre>  assign intr_rxf_o         = reg2hw.intr_enable.rxf.q         & reg2hw.intr_state.rxf.q;</pre>
<pre>  assign intr_rxerr_o       = reg2hw.intr_enable.rxerr.q       & reg2hw.intr_state.rxerr.q;</pre>
<pre>  assign intr_rxoverflow_o  = reg2hw.intr_enable.rxoverflow.q  & reg2hw.intr_state.rxoverflow.q;</pre>
<pre>  assign intr_txunderflow_o = reg2hw.intr_enable.txunderflow.q & reg2hw.intr_state.txunderflow.q;</pre>
<pre>  assign hw2reg.intr_state.rxf.d    = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.rxf.de   = intr_sram_rxf_full |</pre>
<pre>                                      (reg2hw.intr_test.rxf.qe   & reg2hw.intr_test.rxf.q);</pre>
<pre>  assign hw2reg.intr_state.rxerr.d  = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.rxerr.de = intr_fwm_rxerr |</pre>
<pre>                                      (reg2hw.intr_test.rxerr.qe & reg2hw.intr_test.rxerr.q);</pre>
<pre>  assign hw2reg.intr_state.rxlvl.d  = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.rxlvl.de = intr_fwm_rxlvl |</pre>
<pre>                                      (reg2hw.intr_test.rxlvl.qe & reg2hw.intr_test.rxlvl.q);</pre>
<pre>  assign hw2reg.intr_state.txlvl.d  = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.txlvl.de = intr_fwm_txlvl |</pre>
<pre>                                      (reg2hw.intr_test.txlvl.qe & reg2hw.intr_test.txlvl.q);</pre>
<pre>  assign hw2reg.intr_state.rxoverflow.d   = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.rxoverflow.de  = intr_fwm_rxoverflow |</pre>
<pre>      (reg2hw.intr_test.rxoverflow.qe  & reg2hw.intr_test.rxoverflow.q);</pre>
<pre>  assign hw2reg.intr_state.txunderflow.d  = 1'b1;</pre>
<pre>  assign hw2reg.intr_state.txunderflow.de = intr_fwm_txunderflow |</pre>
<pre>      (reg2hw.intr_test.txunderflow.qe & reg2hw.intr_test.txunderflow.q);</pre>
<pre>  logic sck_n;</pre>
<pre>  logic rst_spi_n;</pre>
<pre>  prim_clock_inverter u_clk_spi (.clk_i(cio_sck_i), .clk_no(sck_n), .scanmode_i);</pre>
<pre>  assign clk_spi_in  = (cpha ^ cpol) ? sck_n    : cio_sck_i   ;</pre>
<pre>  assign clk_spi_out = (cpha ^ cpol) ? cio_sck_i    : sck_n   ;</pre>
<pre>  assign rst_spi_n = (scanmode_i) ? rst_ni : rst_ni & ~cio_csb_i;</pre>
<pre>  assign rst_txfifo_n = (scanmode_i) ? rst_ni : rst_ni & ~rst_txfifo_reg;</pre>
<pre>  assign rst_rxfifo_n = (scanmode_i) ? rst_ni : rst_ni & ~rst_rxfifo_reg;</pre>
<pre>  spi_fwmode u_fwmode (</pre>
<pre>    .clk_in_i     (clk_spi_in),</pre>
<pre>    .rst_in_ni    (rst_spi_n),</pre>
<pre>    .clk_out_i    (clk_spi_out),</pre>
<pre>    .rst_out_ni   (rst_spi_n),</pre>
<pre>    .cpha_i        (cpha),</pre>
<pre>    .cfg_rxorder_i (rxorder),</pre>
<pre>    .cfg_txorder_i (txorder),</pre>
<pre>    .mode_i        (spi_mode),</pre>
<pre>    .rx_wvalid_o   (rxf_wvalid),</pre>
<pre>    .rx_wready_i   (rxf_wready),</pre>
<pre>    .rx_data_o     (rxf_wdata),</pre>
<pre>    .tx_rvalid_i   (txf_rvalid),</pre>
<pre>    .tx_rready_o   (txf_rready),</pre>
<pre>    .tx_data_i     (txf_rdata),</pre>
<pre>    .rx_overflow_o  (rxf_overflow),</pre>
<pre>    .tx_underflow_o (txf_underflow),</pre>
<pre>    .csb_i         (cio_csb_i),</pre>
<pre>    .mosi          (cio_mosi_i),</pre>
<pre>    .miso          (cio_miso_o),</pre>
<pre>    .miso_oe       (cio_miso_en_o)</pre>
<pre>  prim_fifo_async #(</pre>
<pre>    .Width (FifoWidth),</pre>
<pre>    .Depth (FifoDepth)</pre>
<pre style="background-color: #FF0000;">  ) u_rx_fifo (</pre>
<pre>    .clk_wr_i     (clk_spi_in),</pre>
<pre>    .rst_wr_ni    (rst_rxfifo_n),</pre>
<pre>    .clk_rd_i     (clk_i),</pre>
<pre>    .rst_rd_ni    (rst_rxfifo_n),</pre>
<pre>    .wvalid       (rxf_wvalid),</pre>
<pre>    .wready       (rxf_wready),</pre>
<pre>    .wdata        (rxf_wdata),</pre>
<pre>    .rvalid       (rxf_rvalid),</pre>
<pre>    .rready       (rxf_rready),</pre>
<pre>    .rdata        (rxf_rdata),</pre>
<pre>    .wdepth       (),</pre>
<pre>    .rdepth       (as_rxfifo_depth)</pre>
<pre>  prim_fifo_async #(</pre>
<pre>    .Width (FifoWidth),</pre>
<pre>    .Depth (FifoDepth)</pre>
<pre style="background-color: #FF0000;">  ) u_tx_fifo (</pre>
<pre>    .clk_wr_i     (clk_i),</pre>
<pre>    .rst_wr_ni    (rst_txfifo_n),</pre>
<pre>    .clk_rd_i     (clk_spi_out),</pre>
<pre>    .rst_rd_ni    (rst_txfifo_n),</pre>
<pre>    .wvalid       (txf_wvalid),</pre>
<pre>    .wready       (txf_wready),</pre>
<pre>    .wdata        (txf_wdata),</pre>
<pre>    .rvalid       (txf_rvalid),</pre>
<pre>    .rready       (txf_rready),</pre>
<pre>    .rdata        (txf_rdata),</pre>
<pre>    .wdepth       (as_txfifo_depth),</pre>
<pre>    .rdepth       ()</pre>
<pre>  spi_fwm_rxf_ctrl #(</pre>
<pre>    .FifoDw (FifoWidth),</pre>
<pre>    .SramAw (SramAw),</pre>
<pre>    .SramDw (SramDw)</pre>
<pre style="background-color: #FF0000;">  ) u_rxf_ctrl (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .base_index_i  (sram_rxf_bindex),</pre>
<pre>    .limit_index_i (sram_rxf_lindex),</pre>
<pre>    .timer_v      (timer_v),</pre>
<pre>    .rptr         (sram_rxf_rptr),  // Given by FW</pre>
<pre>    .wptr         (sram_rxf_wptr),  // to Register interface</pre>
<pre>    .depth        (sram_rxf_depth),</pre>
<pre>    .full         (sram_rxf_full),</pre>
<pre>    .fifo_valid  (rxf_rvalid),</pre>
<pre>    .fifo_ready  (rxf_rready),</pre>
<pre>    .fifo_rdata  (rxf_rdata),</pre>
<pre>    .sram_req    (fwm_sram_req   [FwModeRxFifo]),</pre>
<pre>    .sram_write  (fwm_sram_write [FwModeRxFifo]),</pre>
<pre>    .sram_addr   (fwm_sram_addr  [FwModeRxFifo]),</pre>
<pre>    .sram_wdata  (fwm_sram_wdata [FwModeRxFifo]),</pre>
<pre>    .sram_gnt    (fwm_sram_gnt   [FwModeRxFifo]),</pre>
<pre>    .sram_rvalid (fwm_sram_rvalid[FwModeRxFifo]),</pre>
<pre>    .sram_rdata  (fwm_sram_rdata [FwModeRxFifo]),</pre>
<pre>    .sram_error  (fwm_sram_error [FwModeRxFifo])</pre>
<pre>  spi_fwm_txf_ctrl #(</pre>
<pre>    .FifoDw (FifoWidth),</pre>
<pre>    .SramAw (SramAw),</pre>
<pre>    .SramDw (SramDw)</pre>
<pre style="background-color: #FF0000;">  ) u_txf_ctrl (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .base_index_i  (sram_txf_bindex),</pre>
<pre>    .limit_index_i (sram_txf_lindex),</pre>
<pre>    .abort        (abort),</pre>
<pre>    .rptr         (sram_txf_rptr),  // Given by FW</pre>
<pre>    .wptr         (sram_txf_wptr),  // to Register interface</pre>
<pre>    .depth        (sram_txf_depth),</pre>
<pre>    .fifo_valid  (txf_wvalid),</pre>
<pre>    .fifo_ready  (txf_wready),</pre>
<pre>    .fifo_wdata  (txf_wdata),</pre>
<pre>    .sram_req    (fwm_sram_req   [FwModeTxFifo]),</pre>
<pre>    .sram_write  (fwm_sram_write [FwModeTxFifo]),</pre>
<pre>    .sram_addr   (fwm_sram_addr  [FwModeTxFifo]),</pre>
<pre>    .sram_wdata  (fwm_sram_wdata [FwModeTxFifo]),</pre>
<pre>    .sram_gnt    (fwm_sram_gnt   [FwModeTxFifo]),</pre>
<pre>    .sram_rvalid (fwm_sram_rvalid[FwModeTxFifo]),</pre>
<pre>    .sram_rdata  (fwm_sram_rdata [FwModeTxFifo]),</pre>
<pre>    .sram_error  (fwm_sram_error [FwModeTxFifo])</pre>
<pre>  prim_sram_arbiter #(</pre>
<pre>    .N       (2),  // RXF, TXF</pre>
<pre>    .SramDw (SramDw),</pre>
<pre>    .SramAw (SramAw)   // 2kB</pre>
<pre style="background-color: #FF0000;">  ) u_fwmode_arb (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .req          (fwm_sram_req),</pre>
<pre>    .req_addr     (fwm_sram_addr),</pre>
<pre>    .req_write    (fwm_sram_write),</pre>
<pre>    .req_wdata    (fwm_sram_wdata),</pre>
<pre>    .gnt          (fwm_sram_gnt),</pre>
<pre>    .rsp_rvalid   (fwm_sram_rvalid),</pre>
<pre>    .rsp_rdata    (fwm_sram_rdata),</pre>
<pre>    .rsp_error    (fwm_sram_error),</pre>
<pre>    .sram_req     (mem_b_req),</pre>
<pre>    .sram_addr    (mem_b_addr),</pre>
<pre>    .sram_write   (mem_b_write),</pre>
<pre>    .sram_wdata   (mem_b_wdata),</pre>
<pre>    .sram_rvalid  (mem_b_rvalid),</pre>
<pre>    .sram_rdata   (mem_b_rdata),</pre>
<pre>    .sram_rerror  (mem_b_rerror)</pre>
<pre>  tlul_adapter_sram #(</pre>
<pre>    .SramAw      (SramAw),</pre>
<pre>    .SramDw      (SramDw),</pre>
<pre>    .Outstanding (1),</pre>
<pre>    .ByteAccess  (0)</pre>
<pre style="background-color: #FF0000;">  ) u_tlul2sram (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_sram_h2d [0]),</pre>
<pre>    .tl_o (tl_sram_d2h [0]),</pre>
<pre>    .req_o    (mem_a_req),</pre>
<pre>    .gnt_i    (mem_a_req),  //Always grant when request</pre>
<pre>    .we_o     (mem_a_write),</pre>
<pre>    .addr_o   (mem_a_addr),</pre>
<pre>    .wdata_o  (mem_a_wdata),</pre>
<pre>    .wmask_o  (),           // Not used</pre>
<pre>    .rdata_i  (mem_a_rdata),</pre>
<pre>    .rvalid_i (mem_a_rvalid),</pre>
<pre>    .rerror_i (mem_a_rerror)</pre>
<pre>  prim_ram_2p_adv #(</pre>
<pre>    .Depth (512),</pre>
<pre>    .Width (SramDw),    // 32 x 512 --> 2kB</pre>
<pre>    .CfgW  (8),</pre>
<pre>    .EnableECC           (1), // No Protection</pre>
<pre>    .EnableParity        (0),</pre>
<pre>    .EnableInputPipeline (0),</pre>
<pre>    .EnableOutputPipeline(0),</pre>
<pre>    .MemT ("SRAM")</pre>
<pre style="background-color: #FF0000;">  ) u_memory_2p (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .a_req_i    (mem_a_req),</pre>
<pre>    .a_write_i  (mem_a_write),</pre>
<pre>    .a_addr_i   (mem_a_addr),</pre>
<pre>    .a_wdata_i  (mem_a_wdata),</pre>
<pre>    .a_rvalid_o (mem_a_rvalid),</pre>
<pre>    .a_rdata_o  (mem_a_rdata),</pre>
<pre>    .a_rerror_o (mem_a_rerror),</pre>
<pre>    .b_req_i    (mem_b_req),</pre>
<pre>    .b_write_i  (mem_b_write),</pre>
<pre>    .b_addr_i   (mem_b_addr),</pre>
<pre>    .b_wdata_i  (mem_b_wdata),</pre>
<pre>    .b_rvalid_o (mem_b_rvalid),</pre>
<pre>    .b_rdata_o  (mem_b_rdata),</pre>
<pre>    .b_rerror_o (mem_b_rerror),</pre>
<pre>    .cfg_i      ('0)</pre>
<pre>  spi_device_reg_top u_reg (</pre>
<pre>    .clk_i,</pre>
<pre>    .rst_ni,</pre>
<pre>    .tl_i (tl_i),</pre>
<pre>    .tl_o (tl_o),</pre>
<pre>    .tl_win_o (tl_sram_h2d),</pre>
<pre>    .tl_win_i (tl_sram_d2h),</pre>
<pre>    .reg2hw,</pre>
<pre>    .hw2reg,</pre>
<pre>    .devmode_i  (1'b1)</pre>
<h3>hw/ip/spi_device/rtl/spi_fwm_txf_ctrl.sv</h3>
<pre>module spi_fwm_txf_ctrl #(</pre>
<pre>  parameter int FifoDw = 8,</pre>
<pre>  parameter int SramAw = 11,</pre>
<pre>  parameter int SramDw = 32,</pre>
<pre>  localparam int NumBytes = SramDw/FifoDw, // derived parameter</pre>
<pre>  localparam int SDW = $clog2(NumBytes),   // derived parameter</pre>
<pre>  localparam int PtrW = SramAw + SDW + 1   // derived parameter</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input [SramAw-1:0] base_index_i,</pre>
<pre>  input [SramAw-1:0] limit_index_i,</pre>
<pre>  input                   abort, // Abort State Machine if TX Async at stuck</pre>
<pre>  input        [PtrW-1:0] wptr,</pre>
<pre>  output logic [PtrW-1:0] rptr,</pre>
<pre>  output logic [PtrW-1:0] depth,</pre>
<pre>  output logic              fifo_valid,</pre>
<pre>  input                     fifo_ready,</pre>
<pre>  output logic [FifoDw-1:0] fifo_wdata,</pre>
<pre>  output logic              sram_req,</pre>
<pre>  output logic              sram_write,</pre>
<pre>  output logic [SramAw-1:0] sram_addr,</pre>
<pre>  output logic [SramDw-1:0] sram_wdata,</pre>
<pre>  input                     sram_gnt,</pre>
<pre>  input                     sram_rvalid,</pre>
<pre>  input        [SramDw-1:0] sram_rdata,</pre>
<pre>  input               [1:0] sram_error</pre>
<pre>  logic [SDW-1:0] pos;    // Current write position</pre>
<pre>  logic [SramAw-1:0] sramf_limit;</pre>
<pre>  logic [SramDw-1:0] sram_rdata_q;</pre>
<pre>  logic [SramDw-1:0] fifo_wdata_d;</pre>
<pre>  logic [PtrW-1:0] wptr_q;</pre>
<pre>  logic sramf_empty;</pre>
<pre>  logic cnt_eq_end; // pos goes 0 -> 1 -> 2 -> 3 -> then 0</pre>
<pre>  logic sram_req_d;</pre>
<pre>  logic update_rptr;</pre>
<pre>  logic latch_wptr;</pre>
<pre>  logic cnt_rst;  // Reset pos to rptr[SDW-1:0] or 0</pre>
<pre>  logic cnt_incr;</pre>
<pre>  logic txf_sel; // 0: sram_rdata, 1: sram_rdata_q</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    StIdle   = 'h0,</pre>
<pre>    StRead   = 'h1,</pre>
<pre>    StLatch  = 'h2,</pre>
<pre>    StPush   = 'h3,</pre>
<pre>    StUpdate = 'h4</pre>
<pre>  } state_e;</pre>
<pre>  state_e st_next, st;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) st <= StIdle;</pre>
<pre>    else         st <= st_next;</pre>
<pre>  assign sramf_empty = (rptr == wptr_q);</pre>
<pre>  assign sramf_limit = limit_index_i - base_index_i;</pre>
<pre>  always_comb begin</pre>
<pre>    sram_req_d  = 1'b0;</pre>
<pre>    update_rptr = 1'b0;</pre>
<pre>    latch_wptr  = 1'b0;</pre>
<pre>    fifo_valid  = 1'b0;</pre>
<pre>    txf_sel     = 1'b0; // 0: sram_rdata, 1:sram_rdata_q</pre>
<pre>    cnt_rst     = 1'b0; // reset pos to rptr</pre>
<pre>    cnt_incr    = 1'b0;</pre>
<pre>    unique case (st)</pre>
<pre>      StIdle: begin</pre>
<pre>        latch_wptr = 1'b1;</pre>
<pre>        if (!sramf_empty && fifo_ready) begin</pre>
<pre>          st_next = StRead;</pre>
<pre>          sram_req_d = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          st_next = StIdle;</pre>
<pre>      StRead: begin</pre>
<pre>        if (sram_gnt) begin</pre>
<pre>          st_next = StLatch;</pre>
<pre>          cnt_rst = 1'b1;</pre>
<pre>          sram_req_d = 1'b0;</pre>
<pre>        end else begin</pre>
<pre>          st_next = StRead;</pre>
<pre>          sram_req_d = 1'b1;</pre>
<pre>      StLatch: begin</pre>
<pre>        if (sram_rvalid) begin</pre>
<pre>          st_next = StPush;</pre>
<pre>          fifo_valid = 1'b1;</pre>
<pre>          txf_sel = 1'b0; // select current sram_rdata</pre>
<pre>          cnt_incr = 1'b1; // increase pos to next byte</pre>
<pre>        end else begin</pre>
<pre>          st_next = StLatch;</pre>
<pre>      StPush: begin</pre>
<pre>        if (abort) begin</pre>
<pre>          st_next = StUpdate;</pre>
<pre>        end else if (!fifo_ready) begin</pre>
<pre>          st_next = StPush;</pre>
<pre>        end else if (fifo_ready && !cnt_eq_end) begin</pre>
<pre>          st_next = StPush;</pre>
<pre>          fifo_valid = 1'b1;</pre>
<pre>          txf_sel = 1'b1; // select sram_rdata_q</pre>
<pre>          cnt_incr = 1'b1;</pre>
<pre>        end else if (fifo_ready && cnt_eq_end) begin</pre>
<pre>          st_next = StUpdate;</pre>
<pre>      StUpdate: begin</pre>
<pre>        st_next = StIdle;</pre>
<pre>        update_rptr = 1'b1;</pre>
<pre>      default: begin</pre>
<pre>        st_next = StIdle;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      pos <= '0;</pre>
<pre>    end else if (cnt_rst) begin</pre>
<pre>      pos <= rptr[SDW-1:0];</pre>
<pre>    end else if (cnt_incr) begin</pre>
<pre>      pos <= pos + 1'b1;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      wptr_q <= '0;</pre>
<pre>    end else if (latch_wptr) begin</pre>
<pre>      wptr_q <= wptr;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      rptr <= '0;</pre>
<pre>    end else if (update_rptr) begin</pre>
<pre>      if (pos == '0) begin</pre>
<pre>        if (rptr[PtrW-2:SDW] != sramf_limit) begin</pre>
<pre>          rptr[PtrW-1:SDW] <= rptr[PtrW-1:SDW] + 1'b1;</pre>
<pre>          rptr[SDW-1:0] <= '0;</pre>
<pre>        end else begin</pre>
<pre>          rptr[PtrW-1] <= ~rptr[PtrW-1];</pre>
<pre>          rptr[PtrW-2:SDW] <= '0;</pre>
<pre>          rptr[SDW-1:0]    <= '0;</pre>
<pre>      end else begin</pre>
<pre>        rptr[SDW-1:0] <= pos;</pre>
<pre>  always_comb begin</pre>
<pre>    if (wptr[PtrW-1] == rptr[PtrW-1]) begin</pre>
<pre>      depth = {1'b0, wptr[PtrW-2:0]} - {1'b0, rptr[PtrW-2:0]};</pre>
<pre>    end else begin</pre>
<pre>      depth = {1'b0, wptr[PtrW-2:0]}</pre>
<pre>            + ({1'b0, sramf_limit,{SDW{1'b1}}} - {1'b0, rptr[PtrW-2:0]} + 1'b1);</pre>
<pre>  assign cnt_eq_end = (wptr_q[PtrW-1:SDW] == rptr[PtrW-1:SDW]) ? wptr_q[SDW-1:0] == pos :</pre>
<pre>                      pos == '0;</pre>
<pre>  assign sram_addr = base_index_i + rptr[PtrW-2:SDW];</pre>
<pre>  assign sram_write = 1'b0;</pre>
<pre>  assign sram_wdata = '0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) sram_req <= 1'b0;</pre>
<pre>    else         sram_req <= sram_req_d;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) sram_rdata_q <= '0;</pre>
<pre>    else if (sram_rvalid) sram_rdata_q <= sram_rdata;</pre>
<pre>  assign fifo_wdata_d = (txf_sel) ? sram_rdata_q : sram_rdata ;</pre>
<pre>  always_comb begin</pre>
<pre>    fifo_wdata = '0;</pre>
<pre>    for (int i = 0 ; i < NumBytes ; i++) begin</pre>
<pre>      if (pos == i) fifo_wdata = fifo_wdata_d[8*i+:8];</pre>
<h3>hw/ip/spi_device/rtl/spi_fwm_rxf_ctrl.sv</h3>
<pre>module spi_fwm_rxf_ctrl #(</pre>
<pre>  parameter int unsigned FifoDw = 8,</pre>
<pre>  parameter int unsigned SramAw = 11,</pre>
<pre>  parameter int unsigned SramDw = 32,</pre>
<pre>  localparam int unsigned NumBytes = SramDw/FifoDw,    // derived parameter</pre>
<pre>  localparam int unsigned SDW      = $clog2(NumBytes), // derived parameter</pre>
<pre>  localparam int unsigned PtrW     = SramAw + SDW + 1  // derived parameter</pre>
<pre>  input clk_i,</pre>
<pre>  input rst_ni,</pre>
<pre>  input      [SramAw-1:0] base_index_i,</pre>
<pre>  input      [SramAw-1:0] limit_index_i,</pre>
<pre>  input             [7:0] timer_v,</pre>
<pre>  input        [PtrW-1:0] rptr,</pre>
<pre>  output logic [PtrW-1:0] wptr,</pre>
<pre>  output logic [PtrW-1:0] depth,</pre>
<pre>  output logic            full,</pre>
<pre>  input               fifo_valid,</pre>
<pre>  output logic        fifo_ready,</pre>
<pre>  input  [FifoDw-1:0] fifo_rdata,</pre>
<pre>  output logic              sram_req,</pre>
<pre>  output logic              sram_write,</pre>
<pre>  output logic [SramAw-1:0] sram_addr,</pre>
<pre>  output logic [SramDw-1:0] sram_wdata,</pre>
<pre>  input                     sram_gnt,</pre>
<pre>  input                     sram_rvalid,</pre>
<pre>  input        [SramDw-1:0] sram_rdata,</pre>
<pre>  input               [1:0] sram_error</pre>
<pre>  logic [NumBytes-1:0] byte_enable;</pre>
<pre>  logic [SDW-1:0]      pos;   // current byte position</pre>
<pre>  logic [7:0] cur_timer;</pre>
<pre>  logic [SramAw-1:0] sramf_limit;</pre>
<pre>  logic sramf_full;   // SRAM Fifo full</pre>
<pre>  logic full_sramwidth;   // Write data filled full SRAM</pre>
<pre>  logic timer_expired;</pre>
<pre>  logic update_wdata;</pre>
<pre>  logic clr_byte_enable;</pre>
<pre>  logic sram_req_d;</pre>
<pre>  logic sram_write_d;</pre>
<pre>  logic sram_wdata_sel;</pre>
<pre>  logic timer_rst;</pre>
<pre>  logic update_wptr;</pre>
<pre>  typedef enum logic [2:0] {</pre>
<pre>    StIdle   = 'h0,</pre>
<pre>    StPop    = 'h1,</pre>
<pre>    StWait   = 'h2,</pre>
<pre>    StRead   = 'h3,</pre>
<pre>    StModify = 'h4,</pre>
<pre>    StWrite  = 'h5,</pre>
<pre>    StUpdate = 'h6</pre>
<pre>  } state_e;</pre>
<pre>  state_e st_next, st;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) st <= StIdle;</pre>
<pre>    else         st <= st_next;</pre>
<pre>  logic [PtrW-1:0] ptr_cmp;</pre>
<pre>  assign ptr_cmp = rptr ^ wptr;</pre>
<pre>  assign sramf_full = (ptr_cmp[PtrW-1] == 1'b1) && (ptr_cmp[PtrW-2:SDW] == '0);</pre>
<pre>  assign full = sramf_full;</pre>
<pre>  assign sramf_limit = limit_index_i - base_index_i;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      wptr <= '0;</pre>
<pre>    end else if (update_wptr) begin</pre>
<pre>      if (byte_enable == '0) begin</pre>
<pre>        if (wptr[PtrW-2:SDW] == sramf_limit) begin</pre>
<pre>          wptr[PtrW-1] <= ~wptr[PtrW-1];</pre>
<pre>          wptr[PtrW-2:0] <= '0;</pre>
<pre>        end else begin</pre>
<pre>          wptr[PtrW-2:SDW] <= wptr[PtrW-2:SDW] + 1'b1;</pre>
<pre>          wptr[SDW-1:0] <= '0;</pre>
<pre>      end else begin</pre>
<pre>        wptr[SDW-1:0] <= pos;</pre>
<pre>  assign full_sramwidth = (1'b1 == &byte_enable);</pre>
<pre>  always_comb begin</pre>
<pre>    if (wptr[PtrW-1] == rptr[PtrW-1]) begin</pre>
<pre>      depth = {1'b0, wptr[PtrW-2:0]} - {1'b0, rptr[PtrW-2:0]};</pre>
<pre>    end else begin</pre>
<pre>      depth = {1'b0, wptr[PtrW-2:0]}</pre>
<pre>            + ({1'b0, sramf_limit,{SDW{1'b1}}} - {1'b0, rptr[PtrW-2:0]} + 1'b1);</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      cur_timer <= '1;</pre>
<pre>    end else if (timer_rst) begin</pre>
<pre>      cur_timer <= timer_v;</pre>
<pre>    end else if (st == StWait) begin</pre>
<pre>      if (cur_timer != '0) cur_timer <= cur_timer - 1'b1;</pre>
<pre>  assign timer_expired = (cur_timer == '0);</pre>
<pre>  assign sram_addr = base_index_i + wptr[PtrW-2:SDW];</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      byte_enable <= '0;</pre>
<pre>      pos <= '0;</pre>
<pre>    end else if (update_wdata) begin</pre>
<pre>      byte_enable[pos] <= 1'b1;</pre>
<pre>      if (pos == SDW'(NumBytes-1)) pos <= '0;</pre>
<pre>      else                         pos <= pos + 1'b1;</pre>
<pre>    end else if (clr_byte_enable) begin</pre>
<pre>      byte_enable <= '0;</pre>
<pre>      pos <= '0;</pre>
<pre>  always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      sram_wdata <= '0;</pre>
<pre>    end else if (update_wdata) begin</pre>
<pre>      sram_wdata[8*pos+:8] <= fifo_rdata;</pre>
<pre>    end else if (sram_wdata_sel == 1'b1) begin</pre>
<pre>      for (int i = 0 ; i < NumBytes ; i++) begin</pre>
<pre>        if (!byte_enable[i]) begin</pre>
<pre>          sram_wdata[8*i+:8] <= sram_rdata[8*i+:8];</pre>
<pre>    fifo_ready = 1'b0;</pre>
<pre>    update_wdata = 1'b0;</pre>
<pre>    clr_byte_enable = 1'b0;</pre>
<pre>    sram_req_d = 1'b0;</pre>
<pre>    sram_write_d = 1'b0;</pre>
<pre>    sram_wdata_sel = 1'b0;</pre>
<pre>    timer_rst = 1'b0;</pre>
<pre>    update_wptr = 1'b0;</pre>
<pre></pre>
<pre>      StIdle: begin</pre>
<pre>        // Out of reset state. If SRAM Fifo is not full and RX Fifo is not empty,</pre>
<pre>          st_next = StPop;</pre>
<pre>          fifo_ready = 1'b1;</pre>
<pre>          update_wdata = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          st_next = StIdle;</pre>
<pre>        end</pre>
<pre>        // Pop entries from FIFO. It moves to WAIT if Fifo is empty and still not</pre>
<pre>          st_next = StPop;</pre>
<pre>          fifo_ready = 1'b1;</pre>
<pre>          update_wdata = 1'b1;</pre>
<pre>        end else if (full_sramwidth) begin</pre>
<pre>          st_next = StWrite;</pre>
<pre>          clr_byte_enable = 1'b1;</pre>
<pre>          sram_req_d   = 1'b1;</pre>
<pre>          sram_write_d = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          st_next = StWait;</pre>
<pre>          timer_rst = 1'b1;</pre>
<pre>        end</pre>
<pre>        // Wait up to X clocks. This state is useful to reduce traffic to SRAM.</pre>
<pre>          st_next = StPop;</pre>
<pre>          fifo_ready = 1'b1;</pre>
<pre>          update_wdata = 1'b1;</pre>
<pre>        end else if (!fifo_valid && timer_expired) begin</pre>
<pre>          st_next = StRead;</pre>
<pre>          sram_req_d   = 1'b1;</pre>
<pre>          sram_write_d = 1'b0;</pre>
<pre>        end else begin</pre>
<pre>          st_next = StWait;</pre>
<pre>        end</pre>
<pre>        // As counter expires, RMW is only option. State machine reads from current</pre>
<pre>          st_next = StModify;</pre>
<pre>        end else begin</pre>
<pre>          st_next = StRead;</pre>
<pre>          sram_req_d   = 1'b1;</pre>
<pre>          sram_write_d = 1'b0;</pre>
<pre>        end</pre>
<pre>        // Waits until read data arrives.</pre>
<pre>          st_next = StWrite;</pre>
<pre>          sram_req_d   = 1'b1;</pre>
<pre>          sram_write_d = 1'b1;</pre>
<pre>          sram_wdata_sel = 1'b1;</pre>
<pre>        end else begin</pre>
<pre>          st_next = StModify;</pre>
<pre>        end</pre>
<pre>        // Regardless of RMW or just full Words write, statemachine writes data</pre>
<pre>          st_next = StUpdate;</pre>
<pre>        end else begin</pre>
<pre>          st_next = StWrite;</pre>
<pre>          sram_req_d   = 1'b1;</pre>
<pre>          sram_write_d = 1'b1;</pre>
<pre>        end</pre>
<pre>        // Now, update write pointer then goes back to StIdle.</pre>
<pre>        update_wptr = 1'b1;</pre>
<pre>      end</pre>
<pre>        st_next = StIdle;</pre>
<pre>      end</pre>
<pre>    if (!rst_ni) begin</pre>
<pre>      sram_req <= 1'b0;</pre>
<pre>      sram_write <= 1'b0;</pre>
<pre>    end else begin</pre>
<pre>      sram_req <= sram_req_d;</pre>
<pre>      sram_write <= sram_write_d;</pre>
<pre>    end</pre>
<h3>hw/ip/prim/abstract/prim_pad_wrapper.sv</h3>
<pre>  parameter prim_pkg::impl_e Impl = `PRIM_DEFAULT_IMPL,</pre>
<pre>  parameter int unsigned AttrDw = 6</pre>
<pre>) (</pre>
<pre>  output logic       in_o,     // input data</pre>
<pre>  input              out_i,    // output data</pre>
<pre>  input              oe_i,     // output enable</pre>
<pre>  // additional attributes</pre>
<pre>);</pre>
<pre>    prim_generic_pad_wrapper #(</pre>
<pre>      .AttrDw(AttrDw)</pre>
<pre>    ) i_pad_wrapper (</pre>
<pre style="background-color: #FF0000;">      .inout_io,</pre>
<pre>      .in_o,</pre>
<pre>      .out_i,</pre>
<pre>      .oe_i,</pre>
<pre>      .attr_i</pre>
<pre>    );</pre>
<pre style="background-color: #FF0000;">    prim_xilinx_pad_wrapper #(</pre>
<pre style="background-color: #FF0000;">      .AttrDw(AttrDw)</pre>
<pre style="background-color: #FF0000;">    ) i_pad_wrapper (</pre>
<pre style="background-color: #FF0000;">      .inout_io,</pre>
<pre style="background-color: #FF0000;">      .in_o,</pre>
<pre style="background-color: #FF0000;">      .out_i,</pre>
<pre style="background-color: #FF0000;">      .oe_i,</pre>
<pre style="background-color: #FF0000;">      .attr_i</pre>
<pre style="background-color: #FF0000;">    );</pre>
<pre style="background-color: #FF0000;">    // TODO: Find code that works across tools and causes a compile failure</pre>
<pre style="background-color: #FF0000;"></pre>
</body>
</html>

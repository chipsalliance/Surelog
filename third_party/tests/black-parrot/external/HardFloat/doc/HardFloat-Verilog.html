
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd">

<HTML>

<HEAD>
<TITLE>Berkeley HardFloat Verilog Modules</TITLE>
</HEAD>

<BODY>

<H1>Berkeley HardFloat Release 1: Verilog Modules</H1>

<P>
John R. Hauser<BR>
2019 July 29<BR>
</P>


<H2>Contents</H2>

<BLOCKQUOTE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
<COL WIDTH=25>
<COL WIDTH="*">
<TR><TD COLSPAN=2>1. Introduction</TD></TR>
<TR><TD COLSPAN=2>2. Limitations</TD></TR>
<TR><TD COLSPAN=2>3. Acknowledgments and License</TD></TR>
<TR><TD COLSPAN=2>4. HardFloat Package Directory Structure</TD></TR>
<TR><TD COLSPAN=2>5. Floating-Point Representations</TD></TR>
<TR><TD></TD><TD>5.1. Standard Formats</TD></TR>
<TR><TD></TD><TD>5.2. Recoded Formats</TD></TR>
<TR><TD></TD><TD>5.3. Raw Deconstructions</TD></TR>
<TR><TD COLSPAN=2>6. Common Control and Mode Inputs</TD></TR>
<TR><TD></TD><TD>6.1. Control Input</TD></TR>
<TR><TD></TD><TD>6.2. Rounding Mode</TD></TR>
<TR><TD COLSPAN=2>7. Exception Results</TD></TR>
<TR><TD COLSPAN=2>8. Specialization</TD></TR>
<TR><TD></TD><TD>8.1. Width and Default Value for the Control Input</TD></TR>
<TR><TD></TD><TD>8.2. Integer Results on Exceptions</TD></TR>
<TR><TD></TD><TD>8.3. NaN Results</TD></TR>
<TR><TD COLSPAN=2>9. Main Modules</TD></TR>
<TR>
  <TD></TD>
  <TD>9.1. Conversions Between Standard and Recoded Floating-Point
      (<CODE>fNToRecFN</CODE>, <CODE>recFNToFN</CODE>)</TD>
</TR>
<TR>
  <TD></TD>
  <TD>9.2. Conversions from Integer (<CODE>iNToRecFN</CODE>,
      &nbsp;<CODE>iNToRawFN</CODE>)</TD>
</TR>
<TR><TD></TD><TD>9.3. Conversions to Integer (<CODE>recFNToIN</CODE>)</TD></TR>
<TR>
  <TD></TD>
  <TD>9.4. Conversions Between Formats (<CODE>recFNToRecFN</CODE>)</TD>
</TR>
<TR>
  <TD></TD>
  <TD>9.5. Addition and Subtraction (<CODE>addRecFN</CODE>,
      &nbsp;<CODE>addRecFNToRaw</CODE>)</TD>
</TR>
<TR>
  <TD></TD>
  <TD>9.6. Multiplication (<CODE>mulRecFN</CODE>,
      &nbsp;<CODE>mulRecFNToRaw</CODE>,
      &nbsp;<CODE>mulRecFNToFullRaw</CODE>)</TD>
</TR>
<TR>
  <TD></TD>
  <TD>9.7. Fused Multiply-Add (<CODE>mulAddRecFN</CODE>,
      &nbsp;<CODE>mulAddRecFNToRaw</CODE>)</TD>
</TR>
<TR>
  <TD></TD>
  <TD>9.8. Division and Square Root (<CODE>divSqrtRecFN_small</CODE>,
       &nbsp;<CODE>divSqrtRecFNToRaw_small</CODE>)</TD>
</TR>
<TR><TD></TD><TD>9.9. Comparisons (<CODE>compareRecFN</CODE>)</TD></TR>
<TR><TD COLSPAN=2>10. Common Submodules</TD></TR>
<TR><TD></TD><TD>10.1. <CODE>isSigNaNRecFN</CODE></TD></TR>
<TR><TD></TD><TD>10.2. <CODE>recFNToRawFN</CODE></TD></TR>
<TR><TD></TD><TD>10.3. <CODE>roundAnyRawFNToRecFN</CODE></TD></TR>
<TR><TD></TD><TD>10.4. <CODE>roundRawFNToRecFN</CODE></TD></TR>
<TR><TD COLSPAN=2>11. Testing HardFloat</TD></TR>
<TR><TD COLSPAN=2>12. Contact Information</TD></TR>
</TABLE>
</BLOCKQUOTE>


<H2>1. Introduction</H2>

<P>
Berkeley HardFloat is a hardware implementation of binary floating-point that
conforms to the IEEE Standard for Floating-Point Arithmetic.
HardFloat supports a wide range of floating-point formats, using module
parameters to independently determine the widths of the exponent and
significand fields.
The set of possible formats includes the standard ones of <NOBR>16-bit</NOBR>
half-precision, <NOBR>32-bit</NOBR> single-precision, <NOBR>64-bit</NOBR>
double-precision, and <NOBR>128-bit</NOBR> quadruple-precision.
Some historical <EM>extended</EM> formats, such as Intel&rsquo;s old
<NOBR>80-bit</NOBR> double-extended-precision floating-point, are not directly
supported.
(But HardFloat could be used in the implementation of these and other
IEEE-based formats with the addition of modules to convert between encodings.)
</P>

<P>
For any supported format, the following arithmetic functions are available:
<UL>
<LI>
addition and subtraction,
<LI>
multiplication,
<LI>
fused multiply-add,
<LI>
division and square root (implemented iteratively),
<LI>
comparisons,
<LI>
conversions to/from other floating-point formats, and
<LI>
conversions to/from integers, signed and unsigned.
</UL>

<P>
This document covers the Verilog version of Berkeley HardFloat.
An understanding of both Verilog and the IEEE Floating-Point Standard is
required.
</P>

<P>
HardFloat is currently in its first documented release, called
<NOBR>Release 1</NOBR>.
</P>


<H2>2. Limitations</H2>

<P>
In its Verilog version, Berkeley HardFloat requires development tools that
conform at a minimum to the 2001 IEEE Standard for the Verilog language.
</P>

<P>
For a particular IEEE-conforming binary floating-point format, if <I>w</I> is
the width of the format&rsquo;s exponent field and <I>p</I> is the precision as
defined by the floating-point standard (that is,
<NOBR><I>p</I> = 1 + the</NOBR> width of the trailing significand field),
HardFloat requires that <NOBR><I>w</I> &ge; 3</NOBR> and
<NOBR><I>p</I> &ge; 3</NOBR>, and also that <I>w</I> and <I>p</I> satisfy this
relationship:
<BLOCKQUOTE>
<I>p</I> &nbsp;&le;&nbsp; 2<SUP>(<I>w</I> &minus; 2)</SUP> + 3
</BLOCKQUOTE>
<P>
Formats not satisfying these constraints will not always operate correctly.
</P>

<P>
Although HardFloat supports an infinite range of binary floating-point formats
within these constraints, <NOBR>Release 1</NOBR> has been tested only for the
common IEEE-defined formats of <NOBR>16-bit</NOBR> half-precision,
<NOBR>32-bit</NOBR> single-precision, <NOBR>64-bit</NOBR> double-precision, and
<NOBR>128-bit</NOBR> quadruple-precision.
<B>You should assume there is a greater risk of failure for any format that is
not one of the four that have been tested.</B>
</P>

<P>
While the range of HardFloat&rsquo;s parameters includes the
&ldquo;bfloat16&rdquo; format (<NOBR><I>w</I> = 8</NOBR>,
<NOBR><I>p</I> = 8</NOBR>) first defined by Google and subsequently adopted by
Intel and others, HardFloat&rsquo;s floating-point always includes support for
subnormals as dictated by the IEEE Standard, whereas at least some versions of
bfloat16 (as implemented by Intel, for example) officially exclude subnormals.
Getting HardFloat to implement bfloat16 without subnormals requires some
modifications, such as by adding wrappers around HardFloat&rsquo;s modules to
force subnormals to zeros.
</P>

<P>
HardFloat is designed to operate on IEEE floating-point values by converting
them into a <I>recoded format</I>, performing arithmetic in the recoded format,
and then eventually converting back to a standard IEEE-defined encoding.
HardFloat&rsquo;s recoded formats encode the exact same set of values as the
standard floating-point encodings, so recoding entails only a change of
<EM>representation</EM> as bits, not a change of value.
It is intended that this recoding be made invisible to other system components
by converting values back to a standard encoding whenever necessary.
Nevertheless, there may exist situations where use of the recoded formats
cannot be tolerated.
For more about the recoding, see <NOBR>section 5</NOBR>, <I>Floating-Point
Representations</I>.
</P>


<H2>3. Acknowledgments and License</H2>

<P>
The HardFloat package was written by me, <NOBR>John R.</NOBR> Hauser.
The project was done in the employ of the University of California, Berkeley,
within the Department of Electrical Engineering and Computer Sciences, first
for the Parallel Computing Laboratory (Par Lab), then for the ASPIRE Lab, and
lastly for the ADEPT Lab.
The work was officially overseen by Prof. Krste Asanovic, with funding provided
by these sources:
<BLOCKQUOTE>
<TABLE>
<COL>
<COL WIDTH=10>
<COL>
<TR>
<TD VALIGN=TOP><NOBR>Par Lab:</NOBR></TD>
<TD></TD>
<TD>
Microsoft (Award #024263), Intel (Award #024894), and U.C. Discovery
(Award #DIG07-10227), with additional support from Par Lab affiliates Nokia,
NVIDIA, Oracle, and Samsung.
</TD>
</TR>
<TR>
<TD VALIGN=TOP><NOBR>ASPIRE Lab:</NOBR></TD>
<TD></TD>
<TD>
DARPA PERFECT program (Award #HR0011-12-2-0016), with additional support from
ASPIRE industrial sponsor Intel and ASPIRE affiliates Google, Nokia, NVIDIA,
Oracle, and Samsung.
</TD>
</TR>
<TR>
<TD VALIGN=TOP><NOBR>ADEPT Lab:</NOBR></TD>
<TD></TD>
<TD>
ADEPT industrial sponsor Intel and ADEPT affiliates Google, Futurewei, Seagate,
Siemens, and SK Hynix.
</TD>
</TR>
</TABLE>
</BLOCKQUOTE>

<P>
The following applies to the whole of HardFloat <NOBR>Release 1</NOBR> as well
as to each source file individually.
</P>

<P>
Copyright 2019 The Regents of the University of California.
All rights reserved.
</P>

<P>
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
<OL>

<LI>
<P>
Redistributions of source code must retain the above copyright notice, this
list of conditions, and the following disclaimer.
</P>

<LI>
<P>
Redistributions in binary form must reproduce the above copyright notice, this
list of conditions, and the following disclaimer in the documentation and/or
other materials provided with the distribution.
</P>

<LI>
<P>
Neither the name of the University nor the names of its contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.
</P>

</OL>

<P>
THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS &ldquo;AS IS&rdquo;,
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
DISCLAIMED.
IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</P>


<H2>4. HardFloat Package Directory Structure</H2>

<P>
The directory structure for the Verilog version of HardFloat is as follows:
<BLOCKQUOTE>
<PRE>
doc
source
    8086-SSE
    ARM-VFPv2
    RISCV
test
    source
        Verilator
    build
        Verilator-GCC
        IcarusVerilog
</PRE>
</BLOCKQUOTE>
<P>
The source files that define the Verilog modules are all in the main
<CODE>source</CODE> directory.
The <CODE>test</CODE> directory has files used solely for testing.
</P>

<P>
Most of HardFloat&rsquo;s source files are regular Verilog
&lsquo;<CODE>.v</CODE>&rsquo; files containing module definitions.
There are also a few &lsquo;<CODE>.vi</CODE>&rsquo; files that define macros
and constant functions.
These latter types of files get textually included (using compiler directive
<CODE>`include</CODE>) in the other Verilog files.
</P>

<P>
Within the main <CODE>source</CODE> directory are subdirectories for files that
specialize the floating-point behavior to match particular processor families:
<BLOCKQUOTE>
<DL>
<DT><CODE>8086-SSE</CODE></DT>
<DD>
Intel&rsquo;s x86 processors with Streaming SIMD Extensions (SSE) and later
compatible extensions (but not including the older <NOBR>80-bit</NOBR>
double-extended-precision format)
</DD>
<DT><CODE>ARM-VFPv2</CODE></DT>
<DD>
Arm&rsquo;s VFPv2 or later floating-point
</DD>
<DT><CODE>RISCV</CODE></DT>
<DD>
<NOBR>RISC-V</NOBR> floating-point
</DD>
</DL>
</BLOCKQUOTE>
<P>
Each of these specialization subdirectories contains two files,
<CODE>HardFloat_specialize.vi</CODE> and <CODE>HardFloat_specialize.v</CODE>.
Specialization is covered in detail in <NOBR>section 8</NOBR>.
</P>


<H2>5. Floating-Point Representations</H2>

<P>
HardFloat has three main ways of representing binary floating-point values:
<BLOCKQUOTE>
<DL>

<DT>Standard IEEE formats (&lsquo;<CODE>fN</CODE>&rsquo;)</DT>
<DD>
A computation&rsquo;s original floating-point inputs and final results will
typically be represented in what the IEEE Standard calls <I>binary interchange
formats</I>, such as <I>binary32</I> for single-precision and <I>binary64</I>
for double-precision.
</DD>

<DT>Recoded formats (&lsquo;<CODE>recFN</CODE>&rsquo;)</DT>
<DD>
Rather than operate on the standard formats directly, HardFloat prefers to
translate IEEE-encoded values into equivalent <I>recoded formats</I> and
operate on those alternative representations instead.
The main purpose of the recoding is to make subnormals be normalized, aligned
with other floating-point values, thus reducing the complexity of
floating-point operations.
</DD>

<DT>Raw deconstructions (&lsquo;<CODE>rawFN</CODE>&rsquo;)</DT>
<DD>
During the computation of individual arithmetic operations, HardFloat often
represents floating-point values in a deconstructed &ldquo;raw&rdquo; form,
with separated sign, exponent, significand, etc.
Among other uses, this representation is employed for intermediate results
before rounding.
</DD>

</DL>
</BLOCKQUOTE>

<P>
Each of these representations is covered in a subsection below.
</P>

<H3>5.1. Standard Formats</H3>

<P>
HardFloat uses the term <I>standard format</I> to refer to an encoding of
floating-point in the style of a <I>binary interchange format</I> defined by
the IEEE Standard.
Although the standard officially limits binary interchange formats to certain
combinations of exponent width <I>w</I> and precision <I>p</I>, HardFloat
loosens those restrictions to allow any <I>w</I> and <I>p</I>, so long as each
parameter is no smaller than 3, and this relationship is also satisfied:
<BLOCKQUOTE>
<I>p</I> &nbsp;&le;&nbsp; 2<SUP>(<I>w</I> &minus; 2)</SUP> + 3
</BLOCKQUOTE>

<P>
In module names, HardFloat uses the abbreviation &lsquo;<CODE>fN</CODE>&rsquo;
(distinct from &lsquo;<CODE>recFN</CODE>&rsquo; or
&lsquo;<CODE>rawFN</CODE>&rsquo;) to refer to standard IEEE-style formats.
A particular format is indicated by parameters <CODE>expWidth</CODE>
(<NOBR>= <I>w</I></NOBR>) and <CODE>sigWidth</CODE> (<NOBR>= <I>p</I></NOBR>).
The size in bits of a complete floating-point value is <CODE>expWidth</CODE> +
<CODE>sigWidth</CODE>, which is subdivided as <NOBR>1 bit</NOBR> for the sign,
<CODE>expWidth</CODE> bits for the encoded exponent, and
<NOBR><CODE>sigWidth</CODE> &minus; 1</NOBR> bits for the trailing significand.
The parameters for the common (and tested) floating-point formats are
<BLOCKQUOTE>
<TABLE BORDER=0>
<TR>
 <TD></TD>
 <TD ROWSPAN=5> &nbsp; </TD>
 <TD><CODE>expWidth</CODE> (<I>w</I>)</TD>
 <TD ROWSPAN=5> &nbsp; </TD>
 <TD><CODE>sigWidth</CODE> (<I>p</I>)</TD>
</TR>
<TR>
 <TD>16-bit half-precision</TD>
 <TD ALIGN=CENTER>5</TD>
 <TD ALIGN=CENTER>11</TD>
</TR>
<TR>
 <TD>32-bit single-precision</TD>
 <TD ALIGN=CENTER>8</TD>
 <TD ALIGN=CENTER>24</TD>
</TR>
<TR>
 <TD>64-bit double-precision</TD>
 <TD ALIGN=CENTER>11</TD>
 <TD ALIGN=CENTER>53</TD>
</TR>
<TR>
 <TD>128-bit quadruple-precision</TD>
 <TD ALIGN=CENTER>15</TD>
 <TD ALIGN=CENTER>113</TD>
</TR>
</TABLE>
</BLOCKQUOTE>

<P>
As supplied, HardFloat distinguishes signaling NaNs from quiet NaNs in the way
the IEEE Standard prefers;
that is, if the most-significant bit of a NaN&rsquo;s trailing significand
<NOBR>is <CODE>0</CODE></NOBR>, the NaN is signaling;
if this bit <NOBR>is <CODE>1</CODE></NOBR>, the NaN is quiet.
When NaN payloads are propagated through operations, signaling NaNs are
ordinarily converted into quiet NaNs by flipping this bit from <CODE>0</CODE>
<NOBR>to <CODE>1</CODE></NOBR>.
</P>

<H3>5.2. Recoded Formats</H3>

<P>
For each standard format, HardFloat defines a corresponding
<I>recoded format</I> that encodes the same set of values in a slightly
different representation.
The recoded formats have sign, exponent, and significand fields just like the
standard formats, but with one extra bit for the exponent.
Hence, standard <NOBR>32-bit</NOBR> single-precision, for example, gets recoded
in <NOBR>33 bits</NOBR>:  one bit for the sign, 9 for the encoded exponent (one
more than usual), and 23 for the trailing significand.
The recoded formats simplify the implementation of floating-point arithmetic in
a few ways, the most important being to normalize subnormals so they can be
treated nearly the same as regular floating-point numbers.
</P>

<P>
The following table summarizes the recoding:
<BLOCKQUOTE>
<TABLE>
<TR>
<TD></TD>
<TD ROWSPAN=99 WIDTH=20></TD>
<TD COLSPAN=5>standard format</TD>
<TD ROWSPAN=99 WIDTH=25></TD>
<TD COLSPAN=4>HardFloat&rsquo;s recoded format</TD>
</TR>
<TR>
<TD></TD>
<TD>sign</TD>
<TD ROWSPAN=99> &nbsp; </TD>
<TD>exponent</TD>
<TD ROWSPAN=99> &nbsp; </TD>
<TD ALIGN=CENTER>significand</TD>
<TD>sign</TD>
<TD ROWSPAN=99> &nbsp; </TD>
<TD ALIGN=CENTER>exponent</TD>
<TD ALIGN=CENTER>significand</TD>
</TR>
<TR><TD></TD></TR>
<TR>
<TD>zeros</TD>
<TD ALIGN=CENTER><I>s</I></TD>
<TD ALIGN=CENTER>0</TD>
<TD ALIGN=CENTER>0</TD>
<TD ALIGN=CENTER><I>s</I></TD>
<TD ALIGN=CENTER><CODE>000</CODE><I>xx</I>...<I>xx</I></TD>
<TD ALIGN=CENTER>0</TD>
</TR>
<TR>
<TD>subnormal numbers</TD>
<TD ALIGN=CENTER><I>s</I></TD>
<TD ALIGN=CENTER>0</TD>
<TD ALIGN=CENTER><I>F</I></TD>
<TD ALIGN=CENTER><I>s</I></TD>
<TD ALIGN=CENTER>2<SUP><I>k</I></SUP> + 2 &minus; <I>n</I></TD>
<TD ALIGN=CENTER> &nbsp;&nbsp; normalized <I>F</I><CODE>&lt;&lt;</CODE><I>n</I></TD>
</TR>
<TR>
<TD>normal numbers</TD>
<TD ALIGN=CENTER><I>s</I></TD>
<TD ALIGN=CENTER><I>E</I></TD>
<TD ALIGN=CENTER><I>F</I></TD>
<TD ALIGN=CENTER><I>s</I></TD>
<TD ALIGN=CENTER><I>E</I> + 2<SUP><I>k</I></SUP> + 1</TD>
<TD ALIGN=CENTER><I>F</I></TD>
</TR>
<TR>
<TD>infinities</TD>
<TD ALIGN=CENTER><I>s</I></TD>
<TD ALIGN=CENTER><CODE>1111</CODE>...<CODE>11</CODE></TD>
<TD ALIGN=CENTER>0</TD>
<TD ALIGN=CENTER><I>s</I></TD>
<TD ALIGN=CENTER><CODE>110</CODE><I>xx</I>...<I>xx</I></TD>
<TD ALIGN=CENTER><I>xxxxxxx</I>...<I>xxxx</I></TD>
</TR>
<TR>
<TD>NaNs</TD>
<TD ALIGN=CENTER><I>s</I></TD>
<TD ALIGN=CENTER><CODE>1111</CODE>...<CODE>11</CODE></TD>
<TD ALIGN=CENTER><I>F</I></TD>
<TD ALIGN=CENTER><I>s</I></TD>
<TD ALIGN=CENTER><CODE>111</CODE><I>xx</I>...<I>xx</I></TD>
<TD ALIGN=CENTER><I>F</I></TD>
</TR>
</TABLE>
</BLOCKQUOTE>
<P>
The parameter <I>k</I> is <NOBR><CODE>expWidth</CODE> &minus; 1</NOBR>, where
<CODE>expWidth</CODE> is the <EM>standard width</EM> of the exponent field, not
the recoded width.
An <I>x</I> represents a &ldquo;don&rsquo;t care&rdquo; bit.
For the special values of zeros, infinities, and NaNs, only the three
most-significant bits are relevant in the recoded exponent field.
If those three bits are <CODE>000</CODE>, <CODE>110</CODE>, or
<CODE>111</CODE>, the floating-point value is a zero, infinity, or NaN,
respectively;
otherwise, the value is a normalized finite number.
In the latter case, if the recoded exponent field is
<NOBR>2<SUP><I>k</I></SUP> + 2</NOBR> or more, the value is a regular normal
number, and if it&rsquo;s less, the value is a normalized subnormal number.
(The notation &ldquo;normalized <I>F</I><CODE>&lt;&lt;</CODE><I>n</I>&rdquo;
means <I>F</I> normalized by shifting left by <NOBR><I>n</I> bits</NOBR> and
discarding the <NOBR>leading <CODE>1</CODE></NOBR>).
</P>

<P>
For most floating-point values (zeros, normal numbers, and NaNs) the only thing
different about the recoded formats is the encoding of the exponent;
the sign and significand fields are the same as the corresponding standard
format.
Infinities are special only in that the significand field is ignored in the
recoded formats and might not be zero.
Only for subnormals is there a significant transformation of both exponent and
significand fields, due to normalization.
</P>

<P>
A large number of possible bit patterns in the recoded formats don&rsquo;t
conform to entries in the table above, such as when the recoded
exponent&rsquo;s most-significant three bits are <CODE>000</CODE>, indicating a
zero, yet the significand field is not zero.
Such patterns are not valid.
If an invalid recoded input is given to a HardFloat module, all module outputs
are unspecified.
Invalid recoded results are never generated by HardFloat&rsquo;s modules, so
long as all module inputs are valid.
For normalized numbers (not zeros, infinities, or NaNs), a valid recoded
exponent field is always in the range
<NOBR>2<SUP><I>k</I></SUP> + 3 &minus; <CODE>sigWidth</CODE></NOBR> (for the
tiniest subnormal) to <NOBR>3&times;2<SUP><I>k</I></SUP> &minus; 1</NOBR> (for
the largest normal number).
</P>

<P>
In module names, a recoded format is abbreviated as
&lsquo;<CODE>recFN</CODE>&rsquo;.
Like the standard formats, a particular recoded format is specified by
parameters <CODE>expWidth</CODE> and <CODE>sigWidth</CODE>.
The parameters to give, however, are those of the <EM>corresponding standard
format</EM>, without adjustment for the wider recoded exponent field.
For example, the recoded format for common <NOBR>32-bit</NOBR> single-precision
is specified by <NOBR><CODE>expWidth</CODE> = 8</NOBR> and
<NOBR><CODE>sigWidth</CODE> = 24</NOBR>, the same as the standard format.
(Refer back to the previous subsection on the standard formats.)
Accordingly, the width of a recoded floating-point exponent field is really
<NOBR><CODE>expWidth</CODE> + 1</NOBR>, and the size in bits of the entire
recoded floating-point format is <CODE>expWidth</CODE> +
<NOBR><CODE>sigWidth</CODE> + 1</NOBR>.
</P>

<H3>5.3. Raw Deconstructions</H3>

<P>
Within the implementation of individual arithmetic operations (addition,
multiplication, etc.), HardFloat often represents floating-point values in a
deconstructed form, with six separate components:
<BLOCKQUOTE>
<DL>

<DT><CODE>isNaN</CODE></DT>
<DD>
A single bit indicating whether the floating-point value is a NaN.
If <CODE>isNaN</CODE> is <I>true</I> (<NOBR>= 1</NOBR>), the other components
are irrelevant except possibly for <CODE>sign</CODE> and <CODE>sig</CODE>.
Components <CODE>sign</CODE> and <CODE>sig</CODE> are relevant for a NaN only
if HardFloat is configured to propagate NaN payloads.
</DD>

<DT><CODE>isInf</CODE></DT>
<DD>
A single bit indicating whether the floating-point value is an infinity.
If <CODE>isNaN</CODE> is <I>false</I> and <CODE>isInf</CODE> is <I>true</I>,
the other components are irrelevant except for <CODE>sign</CODE>.
</DD>

<DT><CODE>isZero</CODE></DT>
<DD>
A single bit indicating whether the floating-point value is a zero.
If <CODE>isNaN</CODE> and <CODE>isInf</CODE> are both <I>false</I> and
<CODE>isZero</CODE> is <I>true</I>, the other components are irrelevant except
for <CODE>sign</CODE>.
</DD>

<DT><CODE>sign</CODE></DT>
<DD>
The floating-point sign bit.
Ignored only if <CODE>isNaN</CODE> is <I>true</I> and NaN payloads are not
propagated.
</DD>

<DT><CODE>sExp</CODE></DT>
<DD>
For a finite nonzero floating-point value, the biased floating-point exponent
as a signed integer.
For NaNs, infinities, and zeros, <CODE>sExp</CODE> is ignored.
As there are no special encodings of <CODE>sExp</CODE> to indicate special
values, <CODE>sExp</CODE> is always just a simple signed integer, with the same
bias as in the recoded formats.
For a specified <CODE>expWidth</CODE>, the actual width of <CODE>sExp</CODE> is
<NOBR><CODE>expWidth</CODE> + 2</NOBR>, giving it a range of
&minus;2<SUP><I>w</I>+1</SUP> to <NOBR>2<SUP><I>w</I>+1</SUP> &minus; 1</NOBR>,
where <NOBR><I>w</I> = <CODE>expWidth</CODE></NOBR> as usual.
</DD>

<DT><CODE>sig</CODE></DT>
<DD>
For a NaN, the NaN payload (sometimes ignored).
For a finite nonzero floating-point value, the complete significand, including
the usually implicit <NOBR><CODE>1</CODE> bit</NOBR>.
For a specified <CODE>sigWidth</CODE>, the width of <CODE>sig</CODE> is
<NOBR><CODE>sigWidth</CODE> + 1</NOBR>, with 2 extra bits at the
most-significant end when compared to the usual trailing significand of the
standard and recoded formats.
In some cases, these two bits are always binary <CODE>01</CODE>.
In other cases, the most-significant <CODE>1</CODE> bit of the significand can
be either of the two leading bits of <CODE>sig</CODE>, allowing for a
<NOBR>1-bit</NOBR> slack in the normalization of the significand.
A value of <CODE>sig</CODE> with the two most-significant bits both zeros
(<CODE>00</CODE>) is invalid (unless one of <CODE>isNaN</CODE>,
<CODE>isInf</CODE>, or <CODE>isZero</CODE> is <I>true</I>).
</DD>

</DL>
</BLOCKQUOTE>

<P>
Unlike the recoded formats, the deconstructed forms allow many valid encodings
that do not correspond directly to IEEE floating-point values.
These extra-precise and/or out-of-bounds values may be mapped to the set of
valid IEEE values by <EM>rounding</EM>, possibly resulting in underflow or
overflow.
</P>

<P>
In HardFloat&rsquo;s module names, the deconstructed forms are abbreviated as
&lsquo;<CODE>rawFN</CODE>&rsquo;.
They are typically used in two ways.
First, inputs to an operation get converted from recoded formats into
deconstructed forms using <CODE>recFNToRawFN</CODE> submodules.
An intermediate numeric result is then computed, also in raw form, and this
gets rounded to a valid IEEE value using module <CODE>roundRawFNToRecFN</CODE>
or <CODE>roundAnyRawFNToRecFN</CODE>.
These modules for handling <CODE>rawFN</CODE> are documented in more detail in
<NOBR>section 10</NOBR>, <I>Common Submodules</I>.
</P>


<H2>6. Common Control and Mode Inputs</H2>

<P>
HardFloat&rsquo;s floating-point arithmetic modules commonly take two inputs
that may adjust the behavior of the module:
<BLOCKQUOTE>
<CODE>control</CODE><BR>
<CODE>roundingMode</CODE><BR>
</BLOCKQUOTE>
<P>
These are covered in the following subsections.
</P>

<H3>6.1. Control Input</H3>

<P>
The <CODE>control</CODE> input is a vehicle for supplying to floating-point
operations any number of miscellaneous control parameters that are not expected
to change frequently.
The width of this input is specified by macro <CODE>floatControlWidth</CODE>,
which is defined by default in file <CODE>HardFloat_consts.vi</CODE>, although
it may be overridden in <CODE>HardFloat_specialize.vi</CODE>.
Currently, the default width for <CODE>control</CODE> is only
<NOBR>1 bit</NOBR>.
</P>

<P>
The default single bit of <CODE>control</CODE> determines detection of
<I>tininess</I> for underflow.
In the terminology of the IEEE Standard, HardFloat can detect tininess for
underflow either before or after rounding.
The following are the names of macros whose values can be bitwised
<NOBR>ORed</NOBR> into the <CODE>control</CODE> input:
<BLOCKQUOTE>
<PRE>
flControl_tininessBeforeRounding
flControl_tininessAfterRounding
</PRE>
</BLOCKQUOTE>
<P>
If the <CODE>control</CODE> bit specified by macro
<CODE>flControl_tininessAfterRounding</CODE> is <NOBR>set (= 1)</NOBR>, then
tininess is detected after rounding.
If this bit is not <NOBR>set (= 0)</NOBR>, tininess is detected before
rounding.
Detecting tininess after rounding is usually slightly better because it results
in fewer spurious underflow signals.
The option for detecting tininess before rounding is provided for compatibility
with some systems.
As required by the IEEE Standard since 2008, HardFloat always detects
<I>loss of accuracy</I> for underflow as an inexact result.
</P>

<H3>6.2. Rounding Mode</H3>

<P>
The <CODE>roundingMode</CODE> input to a module chooses the rounding mode for a
floating-point operation (obviously).
All five rounding modes defined by the 2008 IEEE Floating-Point Standard are
implemented for all operations that require rounding.
HardFloat adds support also for a sixth mode, <I>round to odd</I>.
The value of <CODE>roundingMode</CODE> may be that of any of these macros
defined in <CODE>HardFloat_consts.vi</CODE>:
<BLOCKQUOTE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR>
<TD><CODE>round_near_even</CODE></TD>
<TD>round to nearest, with ties to even</TD>
</TR>
<TR>
<TD><CODE>round_near_maxMag&nbsp;&nbsp;</CODE></TD>
<TD>round to nearest, with ties to maximum magnitude (away from zero)</TD>
</TR>
<TR>
<TD><CODE>round_minMag</CODE></TD>
<TD>round to minimum magnitude (toward zero)</TD>
</TR>
<TR>
<TD><CODE>round_min</CODE></TD>
<TD>round to minimum (down)</TD>
</TR>
<TR>
<TD><CODE>round_max</CODE></TD>
<TD>round to maximum (up)</TD>
</TR>
<TR>
<TD><CODE>round_odd</CODE></TD>
<TD>round to odd (jamming)</TD>
</TR>
</TABLE>
</BLOCKQUOTE>

<P>
Rounding mode <CODE>round_odd</CODE> operates as follows:
For a conversion to an integer, if the input is not already an integer value,
the rounded result is the closest <EM>odd</EM> integer.
For operations that return a floating-point value, the floating-point result is
first rounded to minimum magnitude, the same as <CODE>round_minMag</CODE>, and
then, if the result is inexact, the least-significant bit of the result is set
<NOBR>to <CODE>1</CODE></NOBR>.
Rounding to odd is also known as <EM>jamming</EM>.
</P>


<H2>7. Exception Results</H2>

<P>
HardFloat supports all five exception flags required by the IEEE Floating-Point
Standard.
Most modules for floating-point operations have an <CODE>exceptionFlags</CODE>
output with <NOBR>5 bits</NOBR> in this order:
<BLOCKQUOTE>
<CODE>{</CODE><I>invalid</I><CODE>, </CODE><I>infinite</I><CODE>,
    </CODE><I>overflow</I><CODE>, </CODE><I>underflow</I><CODE>,
    </CODE><I>inexact</I><CODE>}</CODE>
</BLOCKQUOTE>
<P>
The <I>infinite</I> exception is what the standard calls
&ldquo;divide by zero&rdquo;, meaning an infinite result generated from finite
operands.
</P>

<P>
The module that converts from floating-point to integer,
<CODE>recFNToIN</CODE>, drops the <I>infinite</I> and <I>underflow</I> bits,
because conversions to integer can never underflow or deliver an infinite
result.
This module has instead an <CODE>intExceptionFlags</CODE> output with
<NOBR>3 bits</NOBR> in this order:
<BLOCKQUOTE>
<CODE>{</CODE><I>invalid</I><CODE>, </CODE><I>overflow</I><CODE>,
    </CODE><I>inexact</I><CODE>}</CODE>
</BLOCKQUOTE>

<P>
Note that, although <CODE>recFNToIN</CODE> distinguishes <I>overflow</I> from
<I>invalid</I> exceptions in <CODE>intExceptionFlags</CODE> as shown, the IEEE
Standard does not permit conversions to integer to signal a
<I>floating-point overflow</I> exception.
Rather, if a system has no other way to indicate overflow from conversions to
integer, the standard requires that the floating-point <I>invalid</I> exception
be signaled, not floating-point <I>overflow</I>.
Hence, it will often be the case that the <I>invalid</I> and <I>overflow</I>
bits from the <CODE>intExceptionFlags</CODE> output must be <NOBR>ORed</NOBR>
together to signal the usual floating-point <I>invalid</I> exception.
</P>

<P>
Depending on how it is configured, HardFloat has the ability to create distinct
NaNs for different exceptions, and to propagate NaN payloads from operation
inputs to output.
These options for NaNs are determined by the specialization of HardFloat,
covered in the next section.
</P>


<H2>8. Specialization</H2>

<P>
The IEEE Floating-Point Standard allows for some variation among conforming
implementations, particularly concerning NaNs.
The HardFloat <CODE>source</CODE> directory is supplied with some
<I>specialization</I> subdirectories containing possible definitions for this
implementation-specific behavior.
For example, the <NOBR><CODE>8086-SSE</CODE></NOBR> subdirectory has source
files that specialize HardFloat to that of Intel&rsquo;s newer x86 processors.
The files in a specialization subdirectory determine:
<UL>
<LI>
the width of the <CODE>control</CODE> input, if it&rsquo;s not the default of
<NOBR>1 bit</NOBR>;
<LI>
an optional default value for the <CODE>control</CODE> input, including whether
tininess for underflow is detected before or after rounding by default;
<LI>
the integer results returned when conversions to integer type overflow or raise
the <I>invalid</I> exception;
<LI>
whether NaN payloads are propagated from function inputs to output;
and
<LI>
the specific NaN delivered for any operation that returns a NaN (either a
default NaN or the NaN with the desired propagated payload).
</UL>
<P>
A specialization subdirectory is expected to contain two files:  an
&ldquo;include&rdquo; file named <CODE>HardFloat_specialize.vi</CODE> and a
regular Verilog file named <CODE>HardFloat_specialize.v</CODE>.
</P>

<H3>8.1. Width and Default Value for the Control Input</H3>

<P>
If the specific implementation adds any bits to the <CODE>control</CODE> input,
its width must be defined in <CODE>HardFloat_specialize.vi</CODE> by undefining
(<CODE>`undef</CODE>) the existing macro <CODE>floatControlWidth</CODE> and
redefining it to the correct number of bits.
</P>

<P>
If needed, a default value for the <CODE>control</CODE> input can be specified
by defining macro <CODE>flControl_default</CODE> in
<CODE>HardFloat_specialize.vi</CODE>.
This macro should be defined to either
<CODE>`flControl_tininessBeforeRounding</CODE> or
<CODE>`flControl_tininessAfterRounding</CODE>, combined with defaults for any
added <CODE>control</CODE> bits.
</P>

<H3>8.2. Integer Results on Exceptions</H3>

<P>
To determine the result returned when a conversion to integer type overflows or
raises the <I>invalid</I> exception, file <CODE>HardFloat_specialize.v</CODE>
is expected to define a module with these parameters and ports:
<BLOCKQUOTE>
<PRE>
module
    iNFromException#(parameter width) (
        input signedOut,
        input isNaN,
        input sign,
        output [(width - 1):0] out
    );
</PRE>
</BLOCKQUOTE>
<P>
Input <CODE>signedOut</CODE> indicates whether the result integer type is
signed or unsigned, with 0 being <I>unsigned</I> and 1 being <I>signed</I>.
The other two inputs, <CODE>isNaN</CODE> and <CODE>sign</CODE>, provide
information about the original floating-point input that can affect the choice
of the integer result.
If <CODE>isNaN</CODE> is <I>true</I>, the floating-point input is a NaN;
else it is a number (possibly an infinity) outside the range of the integer
type.
The correct integer result is returned in <CODE>out</CODE>.
</P>

<H3>8.3. NaN Results</H3>

<P>
The specialization also determines the specific NaNs delivered when operations
return NaNs.
One must first choose whether NaN payloads will be propagated.
Defining macro <CODE>HardFloat_propagateNaNPayloads</CODE> in
<CODE>HardFloat_specialize.vi</CODE> enables NaN payload propagation.
(If defined, the content of this macro is ignored;
only its effect on <CODE>`ifdef</CODE> directives matters.)
The remaining specification of NaN results depends on whether macro
<CODE>HardFloat_propagateNaNPayloads</CODE> is defined.
</P>

<P><B>Without NaN payload propagation</B></P>

<P>
When NaN payloads are not propagated, a NaN result will usually be just the
<I>default NaN</I> for the result format, regardless of any input NaNs.
Default NaNs must be specified by two other macros defined in
<CODE>HardFloat_specialize.vi</CODE>.
First, a default NaN&rsquo;s sign bit is chosen by macro
<CODE>HardFloat_signDefaultNaN</CODE>, which can be defined as either
<CODE>0</CODE> <NOBR>or <CODE>1</CODE></NOBR>.
Second, the bulk of the default NaN payload (apart from the sign) is determined
by a function-like macro with one argument,
<CODE>HardFloat_fractDefaultNaN(<I>sigWidth</I>)</CODE>, which must evaluate to
an integer of <NOBR><CODE><I>sigWidth</I></CODE> &minus; 1</NOBR> bits.
</P>

<P><B>With NaN payload propagation</B></P>

<P>
If NaN propagation is enabled (macro
<CODE>HardFloat_propagateNaNPayloads</CODE> is defined), then NaN results are
determined in an entirely different way.
In this case, several modules must be supplied in
<CODE>HardFloat_specialize.v</CODE> to implement the desired propagation.
The names, parameters, and ports of these modules are as follows:
<BLOCKQUOTE>
<PRE>
module
    propagateFloatNaN_add#(parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input subOp,
        input isNaNA,
        input signA,
        input [(sigWidth - 2):0] fractA,
        input isNaNB,
        input signB,
        input [(sigWidth - 2):0] fractB,
        output signNaN,
        output [(sigWidth - 2):0] fractNaN
    );

module
    propagateFloatNaN_mul#(parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input isNaNA,
        input signA,
        input [(sigWidth - 2):0] fractA,
        input isNaNB,
        input signB,
        input [(sigWidth - 2):0] fractB,
        output signNaN,
        output [(sigWidth - 2):0] fractNaN
    );

module
    propagateFloatNaN_mulAdd#(parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input [1:0] op,
        input isNaNA,
        input signA,
        input [(sigWidth - 2):0] fractA,
        input isNaNB,
        input signB,
        input [(sigWidth - 2):0] fractB,
        input invalidProd,
        input isNaNC,
        input signC,
        input [(sigWidth - 2):0] fractC,
        output signNaN,
        output [(sigWidth - 2):0] fractNaN
    );

module
    propagateFloatNaN_divSqrt#(parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input sqrtOp,
        input isNaNA,
        input signA,
        input [(sigWidth - 2):0] fractA,
        input isNaNB,
        input signB,
        input [(sigWidth - 2):0] fractB,
        output signNaN,
        output [(sigWidth - 2):0] fractNaN
    );
</PRE>
</BLOCKQUOTE>
<P>
A different NaN-propagation module is needed for each of addition/subtraction,
multiplication, fused multiply-add, and division/square-root.
In all cases:
<UL>
<LI>
The <CODE>control</CODE> input comes directly from the inputs of the original
floating-point operation.
<LI>
Inputs <CODE>isNaNA</CODE>, <CODE>signA</CODE>, and <CODE>fractA</CODE>
provide information about the first floating-point operand.
(<CODE>signA</CODE> and <CODE>fractA</CODE> are expected to be useful only when
<CODE>isNaNA</CODE> is <I>true</I>.)
<LI>
Inputs <CODE>isNaNB</CODE>, <CODE>signB</CODE>, and <CODE>fractB</CODE> inform
about the second floating-point operand.
<LI>
The proper NaN result is indicated by outputs <CODE>signNaN</CODE> and
<CODE>fractNaN</CODE>.
</UL>

<P>
Module <CODE>propagateFloatNaN_add</CODE> has an extra input,
<CODE>subOp</CODE>, indicating whether the operation is addition
(<NOBR>= 0</NOBR>) or subtraction (<NOBR>= 1</NOBR>).
Similarly, <CODE>propagateFloatNaN_divSqrt</CODE> has an extra input,
<CODE>sqrtOp</CODE>, indicating whether the operation is division
(<NOBR>= 0</NOBR>) or square root (<NOBR>= 1</NOBR>).
For square roots, the <CODE><I>b</I></CODE> operand (<CODE>isNaNB</CODE>,
<CODE>signB</CODE>, <CODE>fractB</CODE>) should be ignored.
Module <CODE>propagateFloatNaN_mulAdd</CODE> has these extra inputs:
<UL>
<LI>
Input <CODE>op</CODE> duplicates the same input to the <CODE>mulAdd</CODE>
module.
<LI>
Input <CODE>invalidProd</CODE> indicates whether the product of floating-point
operands <CODE><I>a</I></CODE> and <CODE><I>b</I></CODE> is invalid (because
one operand is a zero and the other is an infinity).
<LI>
Inputs <CODE>isNaNC</CODE>, <CODE>signC</CODE>, and <CODE>fractC</CODE> inform
about the third floating-point operand, which is the other addend besides the
product <NOBR><CODE><I>a</I></CODE> &times; <CODE><I>b</I></CODE></NOBR>.
</UL>

<P>
If no floating-point operand is a NaN (all <CODE>isNaN</CODE> inputs are
<I>false</I>), the modules must return the correct default NaN for an invalid
operation of the given kind.
</P>

<P>
It may be that correct NaN results depend in part on whether floating-point
operands are signaling NaNs.
If so, inputs <CODE>isNaNA</CODE> and <CODE>fractA</CODE> contain enough
information for a module to determine whether operand <CODE><I>a</I></CODE> is
a signaling NaN, and likewise for operands <CODE><I>b</I></CODE>
<NOBR>and <CODE><I>c</I></CODE></NOBR>.
</P>


<H2>9. Main Modules</H2>

<P>
HardFloat defines modules for the following floating-point conversions and
operations:
<UL>
<LI>
conversions between standard IEEE floating-point formats and HardFloat&rsquo;s
recoded format;
<LI>
conversions between integers (signed or unsigned) and floating-point;
<LI>
conversions between floating-point formats having different range or precision;
<LI>
floating-point addition and subtraction;
<LI>
floating-point multiplication;
<LI>
the fused multiply-add function defined by the IEEE Standard;
<LI>
floating-point division and square root; and
<LI>
floating-point equality and inequality comparisons.
</UL>

<P>
Only for the first bullet item above do HardFloat&rsquo;s modules directly
touch floating-point encoded in a standard IEEE format.
Otherwise, floating-point inputs are always in HardFloat&rsquo;s recoded
format, and floating-point outputs are either in a recoded format or in a
&ldquo;raw&rdquo; deconstructed form.
When an output is in deconstructed form, the output value is before rounding,
and it must still be processed through <CODE>roundRawFNToRecFN</CODE> or
<CODE>roundAnyRawFNToRecFN</CODE> to obtain a correctly rounded result in
conformance with IEEE rules.
Modules <CODE>roundRawFNToRecFN</CODE> and <CODE>roundAnyRawFNToRecFN</CODE>
are documented later, in <NOBR>section 10</NOBR>, <I>Common Submodules</I>.
</P>

<P>
Many HardFloat modules take inputs named <CODE>control</CODE> and
<CODE>roundingMode</CODE>.
These are always as documented in <NOBR>section 6</NOBR>, <I>Common Control and
Mode Inputs</I>.
Likewise, an output named <CODE>exceptionFlags</CODE> is always the five
exception flags reported in <NOBR>section 7</NOBR>, <I>Exception Results</I>.
</P>

<P>
Naturally, if recoded floating-point inputs to a module are not valid according
to <NOBR>section 5.2</NOBR>, <I>Recoded Formats</I>, then module outputs become
unspecified.
</P>

<H3>9.1. Conversions Between Standard and Recoded Floating-Point
  (<CODE>fNToRecFN</CODE>, <CODE>recFNToFN</CODE>)</H3>

<P>
HardFloat has only two modules that input or output floating-point encoded in a
standard IEEE format.
One module, <CODE>fNToRecFN</CODE>, converts from a standard format into
HardFloat&rsquo;s equivalent recoded format, and the other,
<CODE>recFNToFN</CODE>, converts back from a recoded format to standard format.
For all other functions, HardFloat requires the use of either its recoded
format or a &ldquo;raw&rdquo; deconstructed form.
The two conversion modules are complementary, with these parameters and ports:
<BLOCKQUOTE>
<PRE>
module
    fNToRecFN#(parameter expWidth, parameter sigWidth) (
        input [(expWidth + sigWidth - 1):0] in,
        output [(expWidth + sigWidth):0] out
    );

module
    recFNToFN#(parameter expWidth, parameter sigWidth) (
        input [(expWidth + sigWidth):0] in,
        output [(expWidth + sigWidth - 1):0] out
    );
</PRE>
</BLOCKQUOTE>

<P>
Because the set of values encoded in the recoded format is identical to the
corresponding standard format, there are no possible exceptions from converting
in either direction.
</P>

<H3>9.2. Conversions from Integer (<CODE>iNToRecFN</CODE>,
  &nbsp;<CODE>iNToRawFN</CODE>)</H3>

<P>
Module <CODE>iNToRecFN</CODE> converts from an integer type to floating-point
in recoded form.
Its parameters and ports are:
<BLOCKQUOTE>
<PRE>
module
    iNToRecFN#(parameter intWidth, parameter expWidth, parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input signedIn,
        input [(intWidth - 1):0] in,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );
</PRE>
</BLOCKQUOTE>
<P>
The input named <CODE>in</CODE> is interpreted as an unsigned integer if
<CODE>signedIn</CODE> is <I>false</I>, or as a signed integer if
<CODE>signedIn</CODE> is <I>true</I>.
</P>

<P>
Module <CODE>iNToRawFN</CODE> performs a similar function, but returns a
floating-point value in deconstructed form:
<BLOCKQUOTE>
<PRE>
module
    iNToRawFN#(parameter intWidth) (
        input signedIn,
        input [(intWidth - 1):0] in,
        output isZero,
        output sign,
        output signed [(<I>clog2</I>(intWidth) + 2):0] sExp,
        output [intWidth:0] sig
    );
</PRE>
</BLOCKQUOTE>

<P>
This module lacks parameters <CODE>expWidth</CODE> and <CODE>sigWidth</CODE>.
Instead, the output format is determined from the width of the input integer as
follows:
<BLOCKQUOTE>
<CODE>expWidth</CODE> = <CODE><I>clog2</I></CODE>(<CODE>intWidth</CODE>) + 1<BR>
<CODE>sigWidth</CODE> = <CODE>intWidth</CODE>
</BLOCKQUOTE>
<P>
Function <CODE><I>clog2</I></CODE>(<I>x</I>) is the smallest integer at least
as large as the <NOBR>base-2</NOBR> logarithm <NOBR>of <I>x</I></NOBR>.
For example, if <CODE>intWidth</CODE> is 17, the <NOBR>base-2</NOBR> logarithm
of <CODE>intWidth</CODE> is approximately 4.087, so
<CODE><I>clog2</I></CODE>(<CODE>intWidth</CODE>) <NOBR>is 5</NOBR>, and port
<CODE>sExp</CODE> is thus <NOBR>8 bits</NOBR> wide.
</P>

<P>
The deconstructed output from <CODE>iNToRawFN</CODE> omits <CODE>isNaN</CODE>
and <CODE>isInf</CODE>, because these are known always to be <I>false</I> for
an integer.
</P>

<P>
The widths chosen for the output exponent and significand allow the
floating-point result from <CODE>iNToRawFN</CODE> to be always exactly equal in
value to the integer input (much like <CODE>recFNToRawFN</CODE>,
<NOBR>section 10.2</NOBR>).
Furthermore, <CODE>iNToRawFN</CODE> guarantees the following for its outputs:
<UL>

<LI>
The encoded exponent <CODE>sExp</CODE> is never negative.

<LI>
For a nonzero integer input (<CODE>isZero</CODE> is <I>false</I>), the two
most-significant bits of <CODE>sig</CODE> are binary <CODE>01</CODE>.

<LI>
For a zero integer input (<CODE>isZero</CODE> is <I>true</I>),
<CODE>sign</CODE> and <CODE>sig</CODE> are zeros.
</UL>

<H3>9.3. Conversions to Integer (<CODE>recFNToIN</CODE>)</H3>

<P>
Module <CODE>recFNToIN</CODE> converts from a floating-point value in recoded
form to an integer type.
Its parameters and ports are:
<BLOCKQUOTE>
<PRE>
module
    recFNToIN#(parameter expWidth, parameter sigWidth, parameter intWidth) (
        input [(`floatControlWidth - 1):0] control,
        input [(expWidth + sigWidth):0] in,
        input [2:0] roundingMode,
        input signedOut,
        output [(intWidth - 1):0] out,
        output [2:0] intExceptionFlags
    );
</PRE>
</BLOCKQUOTE>
<P>
The output named <CODE>out</CODE> is an unsigned integer if input
<CODE>signedOut</CODE> is <I>false</I>, or is a signed integer if
<CODE>signedOut</CODE> is <I>true</I>.
</P>

<P>
As explained earlier in <NOBR>section 7</NOBR>, <I>Exception Results</I>, the
<NOBR>3-bit</NOBR> output named <CODE>intExceptionFlags</CODE> reports
exceptions <I>invalid</I>, <I>overflow</I>, and <I>inexact</I>.
Although <CODE>intExceptionFlags</CODE> distinguishes integer <I>overflow</I>
separately from <I>invalid</I> exceptions, the IEEE Standard does not permit
conversions to integer to raise a <I>floating-point overflow</I> exception.
Instead, if a system has no other way to indicate that a conversion to integer
overflowed, the standard requires that the <I>floating-point invalid</I>
exception be raised, not <I>floating-point overflow</I>.
Hence, the <I>invalid</I> and <I>overflow</I> bits from
<CODE>intExceptionFlags</CODE> will typically be <NOBR>ORed</NOBR> together to
contribute to the usual floating-point <I>invalid</I> exception.
</P>

<H3>9.4. Conversions Between Formats (<CODE>recFNToRecFN</CODE>)</H3>

<P>
Module <CODE>recFNToRecFN</CODE> converts a recoded floating-point value to a
different recoded format (such as from single-precision to double-precision, or
vice versa):
<BLOCKQUOTE>
<PRE>
module
    recFNToRecFN#(
        parameter inExpWidth,
        parameter inSigWidth,
        parameter outExpWidth,
        parameter outSigWidth
    ) (
        input [(`floatControlWidth - 1):0] control,
        input [(inExpWidth + inSigWidth):0] in,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );
</PRE>
</BLOCKQUOTE>
<P>
This module requires no special explanation.
</P>

<H3>9.5. Addition and Subtraction (<CODE>addRecFN</CODE>,
  &nbsp;<CODE>addRecFNToRaw</CODE>)</H3>

<P>
Module <CODE>addRecFN</CODE> adds or subtracts two recoded floating-point
values, returning a result in the same format.
Its parameters and ports are:
<BLOCKQUOTE>
<PRE>
module
    addRecFN#(parameter expWidth, parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input subOp,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );
</PRE>
</BLOCKQUOTE>
<P>
When input <CODE>subOp</CODE> <NOBR>is 0</NOBR>, the operation is addition
(<NOBR><CODE><I>a</I></CODE> + <CODE><I>b</I></CODE></NOBR>), and when it
<NOBR>is 1</NOBR>, the operation is subtraction
(<NOBR><CODE><I>a</I></CODE> &minus; <CODE><I>b</I></CODE></NOBR>).
</P>

<P>
A variant module, <CODE>addRecFNToRaw</CODE>, returns the intermediate result
of addition or subtraction <EM>before rounding</EM>, as a &ldquo;raw&rdquo;
deconstructed floating-point value with two extra bits of significand:
<BLOCKQUOTE>
<PRE>
module
    addRecFNToRaw#(parameter expWidth, parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input subOp,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output invalidExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth + 2):0] out_sig
    );
</PRE>
</BLOCKQUOTE>
<P>
Boolean output <CODE>invalidExc</CODE> is <I>true</I> if the operation should
raise an <I>invalid</I> exception.
Module <CODE>roundRawFNToRecFN</CODE> can be used to round the intermediate
result in conformance with the IEEE Standard.
</P>

<H3>9.6. Multiplication (<CODE>mulRecFN</CODE>,
  &nbsp;<CODE>mulRecFNToRaw</CODE>, &nbsp;<CODE>mulRecFNToFullRaw</CODE>)</H3>

<P>
Module <CODE>mulRecFN</CODE> multiplies two recoded floating-point values,
returning a result in the same format:
<BLOCKQUOTE>
<PRE>
module
    mulRecFN#(parameter expWidth, parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );
</PRE>
</BLOCKQUOTE>

<P>
A variant module, <CODE>mulRecFNToRaw</CODE>, returns the intermediate result
of multiplication <EM>before rounding</EM>, as a &ldquo;raw&rdquo;
deconstructed floating-point value with two extra bits of significand:
<BLOCKQUOTE>
<PRE>
module
    mulRecFNToRaw#(parameter expWidth, parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        output invalidExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth + 2):0] out_sig
    );
</PRE>
</BLOCKQUOTE>
<P>
Boolean output <CODE>invalidExc</CODE> is <I>true</I> if the operation should
raise an <I>invalid</I> exception.
Module <CODE>roundRawFNToRecFN</CODE> can be used to round the intermediate
result in conformance with the IEEE Standard.
</P>

<P>
Module <CODE>mulRecFNToFullRaw</CODE> is a different variant, acting like
<CODE>mulRecFNToRaw</CODE> except returning the complete double-width product
significand:
<BLOCKQUOTE>
<PRE>
module
    mulRecFNToFullRaw#(parameter expWidth, parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        output invalidExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth*2 - 1):0] out_sig
    );
</PRE>
</BLOCKQUOTE>
<P>
Unlike <CODE>mulRecFNToRaw</CODE>, the result from
<CODE>mulRecFNToFullRaw</CODE> is the exact product of the operands, without
any rounding approximation.
This full-size deconstructed floating-point result can be correctly rounded to
any recoded format using <CODE>roundAnyRawFNToRecFN</CODE>.
</P>

<H3>9.7. Fused Multiply-Add (<CODE>mulAddRecFN</CODE>,
  &nbsp;<CODE>mulAddRecFNToRaw</CODE>)</H3>

<P>
Module <CODE>mulAddRecFN</CODE> implements fused multiply-add as defined by the
IEEE Floating-Point Standard:
<BLOCKQUOTE>
<PRE>
module
    mulAddRecFN#(parameter expWidth, parameter sigWidth, parameter imulEn = 1) (
        input [(`floatControlWidth - 1):0] control,
        input [2:0] op,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [(expWidth + sigWidth):0] c,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags,
        output [expWidth + sigWidth-1:0] out_imul
    );
</PRE>
</BLOCKQUOTE>
<P>
When <NOBR><CODE>op</CODE> = 0</NOBR>, the module computes
<NOBR>(<CODE><I>a</I></CODE> &times; <CODE><I>b</I></CODE>) +
<CODE><I>c</I></CODE></NOBR> with a single rounding.
If one of the multiplication operands <CODE><I>a</I></CODE> and
<CODE><I>b</I></CODE> is infinite and the other is zero, the <I>invalid</I>
exception is indicated even if operand <CODE><I>c</I></CODE> is a quiet NaN.
</P>

<P>
The bits of input <CODE>op[1:0]</CODE> affect the signs of the addends, making it
possible to turn addition into subtraction (much like the <CODE>subOp</CODE>
input to <CODE>addRecFN</CODE>).
The exact effects of <CODE>op</CODE> are summarized in this table:
<BLOCKQUOTE>
<TABLE BORDER=0>
<TR>
 <TD ALIGN=CENTER><CODE>op[1]</CODE></TD>
 <TD ROWSPAN=5> &nbsp; </TD>
 <TD ALIGN=CENTER><CODE>op[0]</CODE></TD>
 <TD ROWSPAN=5> &nbsp; </TD>
 <TD ALIGN=CENTER>Function</TD>
</TR>
<TR>
 <TD ALIGN=CENTER>0</TD>
 <TD ALIGN=CENTER>0</TD>
 <TD ALIGN=CENTER>(<CODE><I>a</I></CODE> &times; <CODE><I>b</I></CODE>) + <CODE><I>c</I></CODE></TD>
</TR>
<TR>
 <TD ALIGN=CENTER>0</TD>
 <TD ALIGN=CENTER>1</TD>
 <TD ALIGN=CENTER>(<CODE><I>a</I></CODE> &times; <CODE><I>b</I></CODE>) &minus; <CODE><I>c</I></CODE></TD>
</TR>
<TR>
 <TD ALIGN=CENTER>1</TD>
 <TD ALIGN=CENTER>0</TD>
 <TD ALIGN=CENTER><CODE><I>c</I></CODE> &minus; (<CODE><I>a</I></CODE> &times; <CODE><I>b</I></CODE>)</TD>
</TR>
<TR>
 <TD ALIGN=CENTER>1</TD>
 <TD ALIGN=CENTER>1</TD>
 <TD ALIGN=CENTER>&minus;(<CODE><I>a</I></CODE> &times; <CODE><I>b</I></CODE>) &minus; <CODE><I>c</I></CODE></TD>
</TR>
</TABLE>
</BLOCKQUOTE>
<P>
In all cases, the function is computed with only a single rounding, of course.
</P>

Also, Fused Multiply-Add can perform integer multiplication <i>a</i> * <i>b</i> when parameter <i>imulEn</i> is set to 1. If so, <code>op[2]</code> is the valid signal for enabling this mode. We use occasions <code>sigWidth = 24</code> and <code>expWidth = 8</code> as an example to illustrate the process. Clearly, there is a 24bit multiplier and 48bit adder in the module such configured. The figure below shows the regular way we perform 32bit multiplication: (Thanks for Professor Michael B. Taylor to provide this figure.)
<br>
<img src="fma.svg">
<br>
The red part is done with 24bit multiplier. To generate blue part, we need two 8bit multiplies and their sum. In fact, we don't need the full result of 8bit multiplies because only products on the right side of the purple line will be useful finally. At last, we use 48bit adder to combine them together. This method can be easily extended to any <code>expWidth</code> and <code>sigWidth</code> as long as they met the requirement of HardFloat. Figure on the right shows how we use the same approach on FP64 to finish a 64bit MUL.

<P>
A variant module, <CODE>mulAddRecFNToRaw</CODE>, returns the intermediate
result of the fused multiply-add <EM>before rounding</EM>, as a
&ldquo;raw&rdquo; deconstructed floating-point value with two extra bits of
significand:
<BLOCKQUOTE>
<PRE>
module
    mulAddRecFNToRaw#(parameter expWidth, parameter sigWidth) (
        input [(`floatControlWidth - 1):0] control,
        input [2:0] op,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [(expWidth + sigWidth):0] c,
        input [2:0] roundingMode,
        output invalidExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth + 2):0] out_sig,
        output [expWidth + sigWidth-1:0] out_imul
    );
</PRE>
</BLOCKQUOTE>
<P>
Boolean output <CODE>invalidExc</CODE> is <I>true</I> if the operation should
raise an <I>invalid</I> exception.
Module <CODE>roundRawFNToRecFN</CODE> can be used to round the intermediate
result in conformance with the IEEE Standard.
</P>

<H3>9.8. Division and Square Root (<CODE>divSqrtRecFN_small</CODE>,
  &nbsp;<CODE>divSqrtRecFNToRaw_small</CODE>)</H3>

<P>
Besides basic addition and multiplication, HardFloat has modules for computing
either division or square root, where the choice of function is controlled by a
module input.
Implementing as they do the most complex operations that HardFloat supports,
these combined division/square-root modules are unique within HardFloat for
being <EM>sequential</EM>, meaning they take a clock input and execute over
more than one clock cycle.
The division/square-root modules in HardFloat use classic one-bit-per-cycle
techniques that are simple and inexpensive but also slower than other known
algorithms for computing division and square root.
This character is reflected in the suffix &lsquo;<CODE>_small</CODE>&rsquo; in
the modules&rsquo; names.
</P>

<P>
HardFloat&rsquo;s principal division/square-root module is
<CODE>divSqrtRecFN_small</CODE>, with these parameters and ports:
<BLOCKQUOTE>
<PRE>
module
    divSqrtRecFN_small#(
        parameter expWidth,
        parameter sigWidth,
        parameter options = 0
    ) (
        input nReset,
        input clock,
        input [(`floatControlWidth - 1):0] control,
        output inReady,
        input inValid,
        input sqrtOp,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output outValid,
        output sqrtOpOut,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );
</PRE>
</BLOCKQUOTE>

<P>
Currently, the only valid value for the <CODE>options</CODE> parameter is zero.
</P>

<P>
The reset input, <CODE>nReset</CODE>, is active-negative and operates
asynchronously within the module.
(By applying reset asynchronously, the module should accept any valid form of
reset, assuming proper care is taken elsewhere to synchronize the release of
reset with the clock.)
No clock cycles are needed during reset.
Apart from reset, state changes within the module occur only on the rising
edges of <CODE>clock</CODE>.
</P>

<P>
The module asserts <CODE>inReady</CODE> <I>true</I> (<NOBR>= 1</NOBR>) in any
clock cycle when it is ready to start a new division or square root operation.
Whenever <CODE>inReady</CODE> and <CODE>inValid</CODE> are both <I>true</I> at
a rising edge of <CODE>clock</CODE>, a new operation is begun, and inputs
<CODE>control</CODE>, <CODE>sqrtOp</CODE>, <CODE>a</CODE>, <CODE>b</CODE>, and
<CODE>roundingMode</CODE> must also be valid.
The computation of <CODE>inValid</CODE> (or any other module input) should not
depend on <CODE>inReady</CODE> within the same clock cycle.
</P>

<P>
If <CODE>sqrtOp</CODE> <NOBR>is 0</NOBR> when a new operation is started, the
operation is division
(<NOBR><CODE><I>a</I></CODE> &divide; <CODE><I>b</I></CODE></NOBR>).
If <CODE>sqrtOp</CODE> <NOBR>is 1</NOBR>, the operation is the square root
<NOBR>of <CODE><I>a</I></CODE></NOBR>, and operand <CODE><I>b</I></CODE> is
ignored.
</P>

<P>
After some number of clock cycles, <CODE>outValid</CODE> is asserted
<I>true</I> for exactly one clock cycle, at which time outputs
<CODE>sqrtOpOut</CODE>, <CODE>out</CODE>, and <CODE>exceptionFlags</CODE> are
all valid.
These outputs become invalid again in the very next clock cycle if another
division or square root operation gets initiated before or during the cycle
that <CODE>outValid</CODE> is <I>true</I>.
There is no mechanism within the module to retain a result for more than one
cycle once another division or square root has begun.
</P>

<P>
On the other hand, if no subsequent operation has yet been started when
<CODE>outValid</CODE> is asserted, then <CODE>divSqrtRecFN_small</CODE> will
hold its result outputs constant until a new operation is begun (by asserting
<CODE>inValid</CODE> while <CODE>inReady</CODE> is <I>true</I>).
Even so, <CODE>outValid</CODE> is never asserted for more than one clock cycle
per result, indicating the first cycle when the result is valid.
</P>

<P>
Output <CODE>sqrtOpOut</CODE> is merely a copy of the original
<CODE>sqrtOp</CODE> for the operation.
It is expected that clients will rarely have a need for this output.
</P>

<P>
The number of clock cycles to complete an operation is not guaranteed to be
constant, but may in fact depend on all inputs to the operation, including
<CODE>a</CODE>, <CODE>b</CODE>, and <CODE>roundingMode</CODE>.
Because the module employs algorithms that compute one result bit per cycle,
the number of cycles is typically
<NOBR><CODE>sigWidth</CODE> + <I>n</I></NOBR>, for some
<NOBR>small <I>n</I></NOBR>.
However, for exceptional cases (zero divided by infinity, for example), a
result may be delivered much sooner.
</P>

<P>
A variant module, <CODE>divSqrtRecFNToRaw_small</CODE>, returns the
intermediate result of a division or square root operation
<EM>before rounding</EM>, as a &ldquo;raw&rdquo; deconstructed floating-point
value with two extra bits of significand:
<BLOCKQUOTE>
<PRE>
module
    divSqrtRecFNToRaw_small#(
        parameter expWidth,
        parameter sigWidth,
        parameter options = 0
    ) (
        input nReset,
        input clock,
        input [(`floatControlWidth - 1):0] control,
        output inReady,
        input inValid,
        input sqrtOp,
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input [2:0] roundingMode,
        output outValid,
        output sqrtOpOut,
        output [2:0] roundingModeOut,
        output invalidExc,
        output infiniteExc,
        output out_isNaN,
        output out_isInf,
        output out_isZero,
        output out_sign,
        output signed [(expWidth + 1):0] out_sExp,
        output [(sigWidth + 2):0] out_sig
    );
</PRE>
</BLOCKQUOTE>
<P>
Functionally, the only difference between this module and
<CODE>divSqrtRecFN_small</CODE> is the form of the outputs.
Like <CODE>sqrtOpOut</CODE>, output <CODE>roundingModeOut</CODE> is simply a
copy of the original <CODE>roundingMode</CODE> for the operation.
Boolean output <CODE>invalidExc</CODE> is <I>true</I> if the operation should
raise an <I>invalid</I> exception, while <CODE>infiniteExc</CODE> is
<I>true</I> if the operation should raise an <I>infinite</I> exception
(&ldquo;divide by zero&rdquo;).
Module <CODE>roundRawFNToRecFN</CODE> can be used to round the intermediate
result in conformance with the IEEE Standard.
</P>

<H3>9.9. Comparisons (<CODE>compareRecFN</CODE>)</H3>

<P>
Module <CODE>compareRecFN</CODE> compares two recoded floating-point values for
equality or inequality, according to the IEEE Standard.
Its parameters and ports are as follows:
<BLOCKQUOTE>
<PRE>
module
    compareRecFN#(parameter expWidth, parameter sigWidth) (
        input [(expWidth + sigWidth):0] a,
        input [(expWidth + sigWidth):0] b,
        input signaling,
        output lt,
        output eq,
        output gt,
        output unordered,
        output [4:0] exceptionFlags
    );
</PRE>
</BLOCKQUOTE>

<P>
If Boolean input <CODE>signaling</CODE> is <I>true</I>, a <I>signaling</I>
comparison is done, meaning that an <I>invalid</I> exception is raised if
either operand is any kind of NaN.
If <CODE>signaling</CODE> is <I>false</I>, a <I>quiet</I> comparison is done,
meaning that quiet NaNs do not cause an <I>invalid</I> exception.
The IEEE Standard mandates that equality comparisons (<NOBR>=, &ne;</NOBR>)
ordinarily are <I>quiet</I>, while inequality comparisons
(<NOBR>&lt;, &le;</NOBR>, <NOBR>&ge;, &gt;</NOBR>) ordinarily are
<I>signaling</I>.
</P>

<P>
Boolean outputs <CODE>lt</CODE>, <CODE>eq</CODE>, and <CODE>gt</CODE> indicate
whether <NOBR><CODE><I>a</I></CODE> &lt; <CODE><I>b</I></CODE></NOBR>,
<NOBR><CODE><I>a</I></CODE> = <CODE><I>b</I></CODE></NOBR>, or
<NOBR><CODE><I>a</I></CODE> &gt; <CODE><I>b</I></CODE></NOBR>, respectively.
Output <CODE>unordered</CODE> is <I>true</I> if either operand is a NaN.
Exactly one of <CODE>lt</CODE>, <CODE>eq</CODE>, <CODE>gt</CODE>, and
<CODE>unordered</CODE> will be <I>true</I> for any pair of operands,
<CODE><I>a</I></CODE> <NOBR>and <CODE><I>b</I></CODE></NOBR>.
</P>


<H2>10. Common Submodules</H2>

<P>
A few HardFloat modules are components that are shared by multiple
floating-point operations.
One such module tests whether a floating-point value is a signaling NaN.
Other modules convert into and out of the deconstructed &ldquo;raw&rdquo; forms
documented earler in <NOBR>section 5.3</NOBR>, <I>Raw Deconstructions</I>.
These component modules are found in files <CODE>isSigNaNRecFN.v</CODE> and
<CODE>HardFloat_rawFN.v</CODE>.
</P>

<P>
These modules are documented here for those who may need to use them directly.
Otherwise, this section can be skipped.
</P>

<H3>10.1. <CODE>isSigNaNRecFN</CODE></H3>

<P>
Module <CODE>isSigNaNRecFN</CODE> tells whether a floating-point value is a
signaling NaN.
It has these parameters and ports:
<BLOCKQUOTE>
<PRE>
module
    isSigNaNRecFN#(parameter expWidth, parameter sigWidth) (
        input [(expWidth + sigWidth):0] in,
        output isSigNaN
    );
</PRE>
</BLOCKQUOTE>
<P>
As indicated by the module&rsquo;s name, the input floating-point value is in
HardFloat&rsquo;s recoded format.
The output <CODE>isSigNaN</CODE> is <I>true</I> if the input is a signaling
NaN.
</P>

<H3>10.2. <CODE>recFNToRawFN</CODE></H3>

<P>
Module <CODE>recFNToRawFN</CODE> converts a floating-point value from
HardFloat&rsquo;s recoded format into the &ldquo;raw&rdquo; deconstructed form.
Its parameters and ports are as follows:
<BLOCKQUOTE>
<PRE>
module
    recFNToRawFN#(parameter expWidth, parameter sigWidth) (
        input [(expWidth + sigWidth):0] in,
        output isNaN,
        output isInf,
        output isZero,
        output sign,
        output signed [(expWidth + 1):0] sExp,
        output [sigWidth:0] sig
    );
</PRE>
</BLOCKQUOTE>

<P>
For general information about the deconstructed form, see
<NOBR>section 5.3</NOBR>, <I>Raw Deconstructions</I>.
Besides the usual rules for the deconstructed form, this module guarantees the
following for its outputs:
<UL>

<LI>
All three of <CODE>isNaN</CODE>, <CODE>isInf</CODE>, and <CODE>isZero</CODE>
are always valid, so at most one is <I>true</I>.
(Ordinarily, when <CODE>isNaN</CODE> is <I>true</I>, the value of
<CODE>isInf</CODE> is irrelevant, and when <CODE>isNaN</CODE> or
<CODE>isInf</CODE> is <I>true</I>, <CODE>isZero</CODE> is irrelevant.)

<LI>
The encoded exponent <CODE>sExp</CODE> is never negative.

<LI>
For a finite nonzero number (with <CODE>isNaN</CODE>, <CODE>isInf</CODE>, and
<CODE>isZero</CODE> all being <I>false</I>):
<UL>
<LI>
<CODE>sExp</CODE> is in the recoded format&rsquo;s range of
<NOBR>2<SUP><I>k</I></SUP> + 3 &minus; <CODE>sigWidth</CODE></NOBR> (smallest)
to <NOBR>3&times;2<SUP><I>k</I></SUP> &minus; 1</NOBR> (largest),
where again <NOBR><I>k</I> = <CODE>expWidth</CODE> &minus; 1</NOBR>.
<LI>
The two most-significant bits of <CODE>sig</CODE> are binary <CODE>01</CODE>.
</UL>

<LI>
For a zero (<CODE>isZero</CODE> is <I>true</I>):
<UL>
<LI>
<CODE>sExp</CODE> is less than the value it has for any finite nonzero number
in the same format (i.e., less than
<NOBR>2<SUP><I>k</I></SUP> + 3 &minus; <CODE>sigWidth</CODE></NOBR>).
<LI>
<CODE>sig</CODE> is zero.
</UL>

</UL>

<H3>10.3. <CODE>roundAnyRawFNToRecFN</CODE></H3>

<P>
Module <CODE>roundAnyRawFNToRecFN</CODE> takes an intermediate floating-point
value in deconstructed form and rounds it to a valid IEEE-conformant value in a
recoded format, applying the requested rounding mode and taking account of any
exceptional conditions such as underflow or overflow.
This module is declared with these parameters and ports:
<BLOCKQUOTE>
<PRE>
module
    roundAnyRawFNToRecFN#(
        parameter inExpWidth,
        parameter inSigWidth,
        parameter outExpWidth,
        parameter outSigWidth,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,
        input infiniteExc,
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(inExpWidth + 1):0] in_sExp,
        input [inSigWidth:0] in_sig,
        input [2:0] roundingMode,
        output [(outExpWidth + outSigWidth):0] out,
        output [4:0] exceptionFlags
    );
</PRE>
</BLOCKQUOTE>

<P>
Parameters <CODE>inExpWidth</CODE> and <CODE>inSigWidth</CODE> characterize the
floating-point input to be rounded, while <CODE>outExpWidth</CODE> and
<CODE>outSigWidth</CODE> control the result format.
The <CODE>options</CODE> parameter is explained later below.
</P>

<P>
Inputs <CODE>control</CODE> and <CODE>roundingMode</CODE> are as documented in
<NOBR>section 6</NOBR>, <I>Common Control and Mode Inputs</I>.
The <CODE>in_*</CODE> inputs obviously supply the incoming floating-point value
in deconstructed form.
Output <CODE>out</CODE> is the rounded IEEE floating-point value, in recoded
format, while <CODE>exceptionFlags</CODE> delivers the five floating-point
exception flags as documented in <NOBR>section 7</NOBR>,
<I>Exception Results</I>.
</P>

<P>
That leaves only inputs <CODE>invalidExc</CODE> and <CODE>infiniteExc</CODE>,
both Booleans.
If <CODE>invalidExc</CODE> is <I>true</I>, it forces an <I>invalid</I>
exception to be asserted, independent of the other inputs, so the
floating-point result delivered by <CODE>out</CODE> will be a NaN, and an
<I>invalid</I> exception will be indicated in <CODE>exceptionFlags</CODE>.
Similarly, <CODE>infiniteExc</CODE> asserts an <I>infinite</I> exception
(&ldquo;divide by zero&rdquo;) independent of most other inputs.
If <CODE>invalidExc</CODE> is <I>false</I> and <CODE>infiniteExc</CODE> is
<I>true</I>, the floating-point output will be an infinity with sign
<CODE>in_sign</CODE>, and an <I>infinite</I> exception will be indicated in
<CODE>exceptionFlags</CODE>.
</P>

<P>
When the floating-point input to <CODE>roundAnyRawFNToRecFN</CODE> is the
intermediate result of an operation, its precision typically needs to be at
least two bits greater than the output precision to avoid corrupting the result
value, i.e.,
<CODE>inSigWidth</CODE> &ge; <NOBR><CODE>outSigWidth</CODE> + 2</NOBR>.
In this case, the least-significant bit of the input is typically called the
<I>sticky</I> bit of the computation.
On the other hand, if the floating-point input is always an <EM>exact</EM>
value (such as from <CODE>iNToRawFN</CODE> or <CODE>recFNToRawFN</CODE>), then
no relationship between input and output formats is necessary.
</P>

<P>
Source file <CODE>HardFloat_consts.vi</CODE> defines several
&lsquo;<CODE>flRoundOpt_</CODE>&rsquo; macros to be used for the
<CODE>options</CODE> parameter, with the following meanings:
<BLOCKQUOTE>
<DL>

<DT><CODE>flRoundOpt_sigMSBitAlwaysZero</CODE></DT>
<DD>
For finite nonzero values, the two most-significant bits of <CODE>in_sig</CODE>
are always binary <CODE>01</CODE>.
</DD>

<DT><CODE>flRoundOpt_subnormsAlwaysExact</CODE></DT>
<DD>
Whenever the floating-point result is a subnormal, the result is always exact,
requiring no real rounding.
The <I>inexact</I> exception is therefore never indicated for subnormal
results.
(This case commonly arises with floating-point addition and subtraction.)
</DD>

<DT><CODE>flRoundOpt_neverUnderflows</CODE></DT>
<DD>
Underflow never occurs, because, for finite nonzero values, the floating-point
exponent is never below the normal range.
</DD>

<DT><CODE>flRoundOpt_neverOverflows</CODE></DT>
<DD>
Overflow never occurs, because, for finite nonzero values, the floating-point
exponent is never above the normal range.
</DD>

</DL>
</BLOCKQUOTE>
<P>
The <CODE>options</CODE> parameter can be set to the bitwise OR of any
combination of these macro values, or to 0, if none is applicable.
By setting <CODE>options</CODE> to the maximal set of conditions that apply,
the efficiency of the module may be improved.
</P>

<P>
If the floating-point output is a NaN (because either <CODE>invalidExc</CODE>
is <I>true</I>, or <CODE>invalidExc</CODE> and <CODE>infiniteExc</CODE> are
<I>false</I> and <CODE>in_isNaN</CODE> is <I>true</I>), and if macro
<CODE>HardFloat_propagateNaNPayloads</CODE> is defined (refer back to
<NOBR>section 8.3</NOBR>, <I>NaN Results</I>), then the NaN&rsquo;s payload is
specified by inputs <CODE>in_sign</CODE> and <CODE>in_sig</CODE>.
This is true even when the NaN result should be the default NaN.
The client is responsible for controlling when a NaN result will be the default
NaN, by setting <CODE>in_sign</CODE> and <CODE>in_sig</CODE> appropriately.
On the other hand, if macro <CODE>HardFloat_propagateNaNPayloads</CODE> is not
defined, any NaN outputs from <CODE>roundAnyRawFNToRecFN</CODE> are always the
default NaN, and inputs <CODE>in_sign</CODE> and <CODE>in_sig</CODE> are
ignored for NaNs.
</P>

<H3>10.4. <CODE>roundRawFNToRecFN</CODE></H3>

<P>
Module <CODE>roundRawFNToRecFN</CODE> is a variation on
<CODE>roundAnyRawFNToRecFN</CODE>, with the same set of ports but fewer
parameters:
<BLOCKQUOTE>
<PRE>
module
    roundRawFNToRecFN#(
        parameter expWidth,
        parameter sigWidth,
        parameter options = 0
    ) (
        input [(`floatControlWidth - 1):0] control,
        input invalidExc,
        input infiniteExc,
        input in_isNaN,
        input in_isInf,
        input in_isZero,
        input in_sign,
        input signed [(expWidth + 1):0] in_sExp,
        input [(sigWidth + 2):0] in_sig,
        input [2:0] roundingMode,
        output [(expWidth + sigWidth):0] out,
        output [4:0] exceptionFlags
    );
</PRE>
</BLOCKQUOTE>

<P>
<CODE>roundRawFNToRecFN</CODE> is identical to
<CODE>roundAnyRawFNToRecFN</CODE> with this assignment of parameters:
<BLOCKQUOTE>
<CODE>inExpWidth</CODE> = <CODE>expWidth</CODE><BR>
<CODE>inSigWidth</CODE> = <CODE>sigWidth</CODE> + 2<BR>
<CODE>outExpWidth</CODE> = <CODE>expWidth</CODE><BR>
<CODE>outSigWidth</CODE> = <CODE>sigWidth</CODE>
</BLOCKQUOTE>
<P>
Note that the deconstructed input has implicitly two more bits of precision
than the specified <CODE>sigWidth</CODE> would normally indicate.
</P>


<H2>11. Testing HardFloat</H2>

<P>
The HardFloat package includes a subdirectory named <CODE>test</CODE>
containing source code and example <CODE>Makefile</CODE>s for testing
HardFloat&rsquo;s Verilog modules.
To execute the tests, either a Verilog simulator or Verilator is required.
(Verilator is a free tool for converting a subset of synthesizable Verilog or
SystemVerilog into C++ code.
When compiled into an executable program, the code generated by Verilator has
been found to run much faster than some Verilog simulators.)
</P>

<P>
HardFloat&rsquo;s test infrastructure also depends on Berkeley TestFloat, which
must be obtained and compiled separately.
And building TestFloat furthermore requires Berkeley SoftFloat, thus completing
the three-part set of Berkeley HardFloat, SoftFloat, and TestFloat.
Information about TestFloat and SoftFloat can be found at their respective Web
pages:
<BLOCKQUOTE>
<TABLE>
<TR>
<TD><A HREF="http://www.jhauser.us/arithmetic/TestFloat.html"><NOBR><CODE>http://www.jhauser.us/arithmetic/TestFloat.html</CODE></NOBR></A></TD>
</TR>
<TR>
<TD><A HREF="http://www.jhauser.us/arithmetic/SoftFloat.html"><NOBR><CODE>http://www.jhauser.us/arithmetic/SoftFloat.html</CODE></NOBR></A></TD>
</TR>
</TABLE>
</BLOCKQUOTE>

<P>
Separate documentation is supplied according to whether one is using a Verilog
simulator or Verilator for testing:
<BLOCKQUOTE>
<TABLE>
<TR>
<TD><A HREF="HardFloat-test-Verilog.html"><NOBR><CODE>HardFloat-test-Verilog.html</CODE></NOBR></A></TD>
<TD>
Documentation for testing HardFloat using Verilog simulation.
</TD>
</TR>
<TR>
<TD><A HREF="HardFloat-test-Verilator.html"><NOBR><CODE>HardFloat-test-Verilator.html</CODE></NOBR></A><CODE>&nbsp;&nbsp;&nbsp;</CODE></TD>
<TD>
Documentation for testing HardFloat using Verilator.
</TD>
</TR>
</TABLE>
</BLOCKQUOTE>


<H2>12. Contact Information</H2>

<P>
At the time of this writing, the most up-to-date information about HardFloat
and the latest release can be found at the Web page
<A HREF="http://www.jhauser.us/arithmetic/HardFloat.html"><NOBR><CODE>http://www.jhauser.us/arithmetic/HardFloat.html</CODE></NOBR></A>.
</P>


</BODY>

</HTML>

